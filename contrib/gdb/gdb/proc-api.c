begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for SVR4 /proc (process file system) for GDB.     Copyright 1999, 2000, 2001, 2003 Free Software Foundation, Inc.     Written by Michael Snyder at Cygnus Solutions.    Based on work by Fred Fish, Stu Grossman, Geoff Noer, and others.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation,  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Pretty-print trace of api calls to the /proc api  * (ioctl or read/write calls).  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_PROC_API
argument_list|)
end_if

begin_define
define|#
directive|define
name|_STRUCTURED_PROC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROC_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for struct proc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_USER_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* for struct user */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* for O_RDWR etc. */
end_comment

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"proc-utils.h"
end_include

begin_comment
comment|/*  Much of the information used in the /proc interface, particularly for     printing status information, is kept as tables of structures of the     following form.  These tables can be used to map numeric values to     their symbolic names and to a string that describes their specific use. */
end_comment

begin_struct
struct|struct
name|trans
block|{
name|long
name|value
decl_stmt|;
comment|/* The numeric value */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* Short description of value */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|procfs_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|procfs_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|procfs_filename
init|=
literal|"procfs_trace"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|prepare_to_trace
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|procfs_trace
condition|)
comment|/* if procfs tracing turned on */
if|if
condition|(
name|procfs_file
operator|==
name|NULL
condition|)
comment|/* if output file not yet open */
if|if
condition|(
name|procfs_filename
operator|!=
name|NULL
condition|)
comment|/* if output filename known */
name|procfs_file
operator|=
name|fopen
argument_list|(
name|procfs_filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|/* open output file */
block|}
end_function

begin_function
specifier|static
name|void
name|set_procfs_trace_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* not sure what I might actually need to do here, if anything */
block|if (procfs_file)     fflush (procfs_file);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|set_procfs_file_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
comment|/* Just changed the filename for procfs tracing.      If a file was already open, close it.  */
if|if
condition|(
name|procfs_file
condition|)
name|fclose
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
name|procfs_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NEW_PROC_API
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|trans
name|ioctl_table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PIOCACINFO
comment|/* irix */
block|{
name|PIOCACINFO
block|,
literal|"PIOCACINFO"
block|,
literal|"get process account info"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCACTION
block|,
literal|"PIOCACTION"
block|,
literal|"get signal action structs"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCARGUMENTS
comment|/* osf */
block|{
name|PIOCARGUMENTS
block|,
literal|"PIOCARGUMENTS"
block|,
literal|"command line args"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIOCAUXV
comment|/* solaris aux vectors */
block|{
name|PIOCAUXV
block|,
literal|"PIOCAUXV"
block|,
literal|"get aux vector"
block|}
block|,
block|{
name|PIOCNAUXV
block|,
literal|"PIOCNAUXV"
block|,
literal|"get number of aux vector entries"
block|}
block|,
endif|#
directive|endif
comment|/* AUXV */
block|{
name|PIOCCFAULT
block|,
literal|"PIOCCFAULT"
block|,
literal|"clear current fault"
block|}
block|,
block|{
name|PIOCCRED
block|,
literal|"PIOCCRED"
block|,
literal|"get process credentials"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCENEVCTRS
comment|/* irix event counters */
block|{
name|PIOCENEVCTRS
block|,
literal|"PIOCENEVCTRS"
block|,
literal|"acquire and start event counters"
block|}
block|,
block|{
name|PIOCGETEVCTRL
block|,
literal|"PIOCGETEVCTRL"
block|,
literal|"get control info of event counters"
block|}
block|,
block|{
name|PIOCGETEVCTRS
block|,
literal|"PIOCGETEVCTRS"
block|,
literal|"dump event counters"
block|}
block|,
block|{
name|PIOCGETPREVCTRS
block|,
literal|"PIOCGETPREVCTRS"
block|,
literal|"dump event counters& prusage info"
block|}
block|,
block|{
name|PIOCRELEVCTRS
block|,
literal|"PIOCRELEVCTRS"
block|,
literal|"release/stop event counters"
block|}
block|,
block|{
name|PIOCSETEVCTRL
block|,
literal|"PIOCSETEVCTRL"
block|,
literal|"set control info of event counters"
block|}
block|,
block|{
name|PIOCGETPTIMER
block|,
literal|"PIOCGETPTIMER"
block|,
literal|"get process timers"
block|}
block|,
endif|#
directive|endif
comment|/* irix event counters */
block|{
name|PIOCGENTRY
block|,
literal|"PIOCGENTRY"
block|,
literal|"get traced syscall entry set"
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|PIOCGETPR
argument_list|)
block|{
name|PIOCGETPR
block|,
literal|"PIOCGETPR"
block|,
literal|"read struct proc"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PIOCGETU
argument_list|)
block|{
name|PIOCGETU
block|,
literal|"PIOCGETU"
block|,
literal|"read user area"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PIOCGETUTK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|SHOW_UTT
argument_list|)
operator|)
comment|/* osf */
block|{
name|PIOCGETUTK
block|,
literal|"PIOCGETUTK"
block|,
literal|"get the utask struct"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCGEXIT
block|,
literal|"PIOCGEXIT"
block|,
literal|"get traced syscall exit  set"
block|}
block|,
block|{
name|PIOCGFAULT
block|,
literal|"PIOCGFAULT"
block|,
literal|"get traced fault set"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCGFPCR
comment|/* osf */
block|{
name|PIOCGFPCR
block|,
literal|"PIOCGFPCR"
block|,
literal|"get FP control register"
block|}
block|,
block|{
name|PIOCSFPCR
block|,
literal|"PIOCSFPCR"
block|,
literal|"set FP conrtol register"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCGFPREG
block|,
literal|"PIOCGFPREG"
block|,
literal|"get floating point registers"
block|}
block|,
block|{
name|PIOCGHOLD
block|,
literal|"PIOCGHOLD"
block|,
literal|"get held signal set"
block|}
block|,
block|{
name|PIOCGREG
block|,
literal|"PIOCGREG"
block|,
literal|"get general registers"
block|}
block|,
block|{
name|PIOCGROUPS
block|,
literal|"PIOCGROUPS"
block|,
literal|"get supplementary groups"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCGSPCACT
comment|/* osf */
block|{
name|PIOCGSPCACT
block|,
literal|"PIOCGSPCACT"
block|,
literal|"get special action"
block|}
block|,
block|{
name|PIOCSSPCACT
block|,
literal|"PIOCSSPCACT"
block|,
literal|"set special action"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCGTRACE
block|,
literal|"PIOCGTRACE"
block|,
literal|"get traced signal set"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCGWATCH
comment|/* irix watchpoints */
block|{
name|PIOCGWATCH
block|,
literal|"PIOCGWATCH"
block|,
literal|"get watchpoint"
block|}
block|,
block|{
name|PIOCSWATCH
block|,
literal|"PIOCSWATCH"
block|,
literal|"set watchpoint"
block|}
block|,
block|{
name|PIOCNWATCH
block|,
literal|"PIOCNWATCH"
block|,
literal|"get number of watchpoints"
block|}
block|,
endif|#
directive|endif
comment|/* irix watchpoints */
ifdef|#
directive|ifdef
name|PIOCGWIN
comment|/* solaris sparc */
block|{
name|PIOCGWIN
block|,
literal|"PIOCGWIN"
block|,
literal|"get gwindows_t"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIOCGXREG
comment|/* solaris sparc extra regs */
block|{
name|PIOCGXREGSIZE
block|,
literal|"PIOCXREGSIZE"
block|,
literal|"get extra register state size"
block|}
block|,
block|{
name|PIOCGXREG
block|,
literal|"PIOCGXREG"
block|,
literal|"get extra register state"
block|}
block|,
block|{
name|PIOCSXREG
block|,
literal|"PIOCSXREG"
block|,
literal|"set extra register state"
block|}
block|,
endif|#
directive|endif
comment|/* XREG */
block|{
name|PIOCKILL
block|,
literal|"PIOCKILL"
block|,
literal|"send signal"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCLDT
comment|/* solaris i386 */
block|{
name|PIOCLDT
block|,
literal|"PIOCLDT"
block|,
literal|"get LDT"
block|}
block|,
block|{
name|PIOCNLDT
block|,
literal|"PIOCNLDT"
block|,
literal|"get number of LDT entries"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIOCLSTATUS
comment|/* solaris and unixware */
block|{
name|PIOCLSTATUS
block|,
literal|"PIOCLSTATUS"
block|,
literal|"get status of all lwps"
block|}
block|,
block|{
name|PIOCLUSAGE
block|,
literal|"PIOCLUSAGE"
block|,
literal|"get resource usage of all lwps"
block|}
block|,
block|{
name|PIOCOPENLWP
block|,
literal|"PIOCOPENLWP"
block|,
literal|"get lwp file descriptor"
block|}
block|,
block|{
name|PIOCLWPIDS
block|,
literal|"PIOCLWPIDS"
block|,
literal|"get lwp identifiers"
block|}
block|,
endif|#
directive|endif
comment|/* LWP */
block|{
name|PIOCMAP
block|,
literal|"PIOCMAP"
block|,
literal|"get memory map information"
block|}
block|,
block|{
name|PIOCMAXSIG
block|,
literal|"PIOCMAXSIG"
block|,
literal|"get max signal number"
block|}
block|,
block|{
name|PIOCNICE
block|,
literal|"PIOCNICE"
block|,
literal|"set nice priority"
block|}
block|,
block|{
name|PIOCNMAP
block|,
literal|"PIOCNMAP"
block|,
literal|"get number of memory mappings"
block|}
block|,
block|{
name|PIOCOPENM
block|,
literal|"PIOCOPENM"
block|,
literal|"open mapped object for reading"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCOPENMOBS
comment|/* osf */
block|{
name|PIOCOPENMOBS
block|,
literal|"PIOCOPENMOBS"
block|,
literal|"open mapped object"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIOCOPENPD
comment|/* solaris */
block|{
name|PIOCOPENPD
block|,
literal|"PIOCOPENPD"
block|,
literal|"get page data file descriptor"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCPSINFO
block|,
literal|"PIOCPSINFO"
block|,
literal|"get ps(1) information"
block|}
block|,
block|{
name|PIOCRESET
block|,
literal|"PIOCRESET"
block|,
literal|"reset process flags"
block|}
block|,
block|{
name|PIOCRFORK
block|,
literal|"PIOCRFORK"
block|,
literal|"reset inherit-on-fork flag"
block|}
block|,
block|{
name|PIOCRRLC
block|,
literal|"PIOCRRLC"
block|,
literal|"reset run-on-last-close flag"
block|}
block|,
block|{
name|PIOCRUN
block|,
literal|"PIOCRUN"
block|,
literal|"make process runnable"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCSAVECCNTRS
comment|/* irix */
block|{
name|PIOCSAVECCNTRS
block|,
literal|"PIOCSAVECCNTRS"
block|,
literal|"parent gets child cntrs"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCSENTRY
block|,
literal|"PIOCSENTRY"
block|,
literal|"set traced syscall entry set"
block|}
block|,
block|{
name|PIOCSET
block|,
literal|"PIOCSET"
block|,
literal|"set process flags"
block|}
block|,
block|{
name|PIOCSEXIT
block|,
literal|"PIOCSEXIT"
block|,
literal|"set traced syscall exit  set"
block|}
block|,
block|{
name|PIOCSFAULT
block|,
literal|"PIOCSFAULT"
block|,
literal|"set traced fault set"
block|}
block|,
block|{
name|PIOCSFORK
block|,
literal|"PIOCSFORK"
block|,
literal|"set inherit-on-fork flag"
block|}
block|,
block|{
name|PIOCSFPREG
block|,
literal|"PIOCSFPREG"
block|,
literal|"set floating point registers"
block|}
block|,
block|{
name|PIOCSHOLD
block|,
literal|"PIOCSHOLD"
block|,
literal|"set held signal set"
block|}
block|,
block|{
name|PIOCSREG
block|,
literal|"PIOCSREG"
block|,
literal|"set general registers"
block|}
block|,
block|{
name|PIOCSRLC
block|,
literal|"PIOCSRLC"
block|,
literal|"set run-on-last-close flag"
block|}
block|,
block|{
name|PIOCSSIG
block|,
literal|"PIOCSSIG"
block|,
literal|"set current signal"
block|}
block|,
block|{
name|PIOCSTATUS
block|,
literal|"PIOCSTATUS"
block|,
literal|"get process status"
block|}
block|,
block|{
name|PIOCSTOP
block|,
literal|"PIOCSTOP"
block|,
literal|"post stop request"
block|}
block|,
block|{
name|PIOCSTRACE
block|,
literal|"PIOCSTRACE"
block|,
literal|"set traced signal set"
block|}
block|,
block|{
name|PIOCUNKILL
block|,
literal|"PIOCUNKILL"
block|,
literal|"delete a signal"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCUSAGE
comment|/* solaris */
block|{
name|PIOCUSAGE
block|,
literal|"PIOCUSAGE"
block|,
literal|"get resource usage"
block|}
block|,
endif|#
directive|endif
block|{
name|PIOCWSTOP
block|,
literal|"PIOCWSTOP"
block|,
literal|"wait for process to stop"
block|}
block|,
ifdef|#
directive|ifdef
name|PIOCNTHR
comment|/* osf threads */
block|{
name|PIOCNTHR
block|,
literal|"PIOCNTHR"
block|,
literal|"get thread count"
block|}
block|,
block|{
name|PIOCRTINH
block|,
literal|"PIOCRTINH"
block|,
literal|"reset inherit-on-thread-creation"
block|}
block|,
block|{
name|PIOCSTINH
block|,
literal|"PIOCSTINH"
block|,
literal|"set   inherit-on-thread-creation"
block|}
block|,
block|{
name|PIOCTLIST
block|,
literal|"PIOCTLIST"
block|,
literal|"get thread ids"
block|}
block|,
block|{
name|PIOCXPTH
block|,
literal|"PIOCXPTH"
block|,
literal|"translate port to thread handle"
block|}
block|,
block|{
name|PIOCTRUN
block|,
literal|"PIOCTRUN"
block|,
literal|"make thread runnable"
block|}
block|,
block|{
name|PIOCTSTATUS
block|,
literal|"PIOCTSTATUS"
block|,
literal|"get thread status"
block|}
block|,
block|{
name|PIOCTSTOP
block|,
literal|"PIOCTSTOP"
block|,
literal|"stop a thread"
block|}
block|,
comment|/* ... TGTRACE TSTRACE TSSIG TKILL TUNKILL TCFAULT TGFAULT TSFAULT      TGFPREG TSFPREG TGREG TSREG TACTION TTERM TABRUN TGENTRY TSENTRY      TGEXIT TSEXIT TSHOLD ... thread functions */
endif|#
directive|endif
comment|/* osf threads */
block|{
operator|-
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ioctl_with_trace
parameter_list|(
name|int
name|fd
parameter_list|,
name|long
name|opcode
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|arg1
decl_stmt|;
name|prepare_to_trace
argument_list|()
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ioctl_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ioctl_table
index|[
name|i
index|]
operator|.
name|value
operator|==
name|opcode
condition|)
break|break;
if|if
condition|(
name|info_verbose
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s:%d -- "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|PIOCSET
case|:
name|arg1
operator|=
name|ptr
condition|?
operator|*
operator|(
name|long
operator|*
operator|)
name|ptr
else|:
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCSET,   %s) %s\n"
argument_list|,
name|arg1
operator|==
name|PR_FORK
condition|?
literal|"PR_FORK"
else|:
name|arg1
operator|==
name|PR_RLC
condition|?
literal|"PR_RLC"
else|:
ifdef|#
directive|ifdef
name|PR_ASYNC
name|arg1
operator|==
name|PR_ASYNC
condition|?
literal|"PR_ASYNC"
else|:
endif|#
directive|endif
literal|"<unknown flag>"
argument_list|,
name|info_verbose
condition|?
name|ioctl_table
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCRESET
case|:
name|arg1
operator|=
name|ptr
condition|?
operator|*
operator|(
name|long
operator|*
operator|)
name|ptr
else|:
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCRESET, %s) %s\n"
argument_list|,
name|arg1
operator|==
name|PR_FORK
condition|?
literal|"PR_FORK"
else|:
name|arg1
operator|==
name|PR_RLC
condition|?
literal|"PR_RLC"
else|:
ifdef|#
directive|ifdef
name|PR_ASYNC
name|arg1
operator|==
name|PR_ASYNC
condition|?
literal|"PR_ASYNC"
else|:
endif|#
directive|endif
literal|"<unknown flag>"
argument_list|,
name|info_verbose
condition|?
name|ioctl_table
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSTRACE
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCSTRACE) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signalset
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSFAULT
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (%s) "
argument_list|,
name|opcode
operator|==
name|PIOCSFAULT
condition|?
literal|"PIOCSFAULT"
else|:
literal|"PIOCGFAULT"
argument_list|)
expr_stmt|;
name|proc_prettyfprint_faultset
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|fltset_t
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSENTRY
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (%s) "
argument_list|,
name|opcode
operator|==
name|PIOCSENTRY
condition|?
literal|"PIOCSENTRY"
else|:
literal|"PIOCGENTRY"
argument_list|)
expr_stmt|;
name|proc_prettyfprint_syscalls
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sysset_t
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSEXIT
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (%s) "
argument_list|,
name|opcode
operator|==
name|PIOCSEXIT
condition|?
literal|"PIOCSEXIT"
else|:
literal|"PIOCGEXIT"
argument_list|)
expr_stmt|;
name|proc_prettyfprint_syscalls
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sysset_t
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSHOLD
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (%s) "
argument_list|,
name|opcode
operator|==
name|PIOCSHOLD
condition|?
literal|"PIOCSHOLD"
else|:
literal|"PIOCGHOLD"
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signalset
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSSIG
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCSSIG) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signal
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
name|ptr
condition|?
operator|(
operator|(
name|siginfo_t
operator|*
operator|)
name|ptr
operator|)
operator|->
name|si_signo
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCRUN
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCRUN) "
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|ptr
condition|?
operator|*
operator|(
name|long
operator|*
operator|)
name|ptr
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRCSIG
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"clearSig "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRCFAULT
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"clearFlt "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSTRACE
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"setTrace "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSHOLD
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"setHold "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSFAULT
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"setFlt "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSVADDR
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"setVaddr "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSTEP
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"step "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSABORT
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"syscallAbort "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRSTOP
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopReq "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCKILL
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCKILL) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signal
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
name|ptr
condition|?
operator|*
operator|(
name|long
operator|*
operator|)
name|ptr
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PIOCSSPCACT
case|case
name|PIOCSSPCACT
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (PIOCSSPCACT) "
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|ptr
condition|?
operator|*
operator|(
name|long
operator|*
operator|)
name|ptr
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRFS_STOPFORK
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopFork "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRFS_STOPEXEC
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopExec "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRFS_STOPTERM
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopTerm "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRFS_STOPTCR
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopThreadCreate "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRFS_STOPTTERM
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopThreadTerm "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
name|PRFS_KOLC
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"killOnLastClose "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PIOCSSPCACT */
default|default:
if|if
condition|(
name|ioctl_table
index|[
name|i
index|]
operator|.
name|name
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (%s) %s\n"
argument_list|,
name|ioctl_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|info_verbose
condition|?
name|ioctl_table
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"ioctl (<unknown %ld (0x%lx)) \n"
argument_list|,
name|opcode
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|opcode
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_trace
operator|&&
name|ret
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"[ioctl (%s) FAILED! (%s)]\n"
argument_list|,
name|ioctl_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|?
name|ioctl_table
index|[
name|i
index|]
operator|.
name|name
else|:
literal|"<unknown>"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NEW_PROC_API */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|rw_table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PCAGENT
comment|/* solaris */
block|{
name|PCAGENT
block|,
literal|"PCAGENT"
block|,
literal|"create agent lwp with regs from argument"
block|}
block|,
endif|#
directive|endif
block|{
name|PCCFAULT
block|,
literal|"PCCFAULT"
block|,
literal|"clear current fault"
block|}
block|,
ifdef|#
directive|ifdef
name|PCCSIG
comment|/* solaris */
block|{
name|PCCSIG
block|,
literal|"PCCSIG"
block|,
literal|"clear current signal"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCDSTOP
comment|/* solaris */
block|{
name|PCDSTOP
block|,
literal|"PCDSTOP"
block|,
literal|"post stop request"
block|}
block|,
endif|#
directive|endif
block|{
name|PCKILL
block|,
literal|"PCKILL"
block|,
literal|"post a signal"
block|}
block|,
ifdef|#
directive|ifdef
name|PCNICE
comment|/* solaris */
block|{
name|PCNICE
block|,
literal|"PCNICE"
block|,
literal|"set nice priority"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCREAD
comment|/* solaris */
block|{
name|PCREAD
block|,
literal|"PCREAD"
block|,
literal|"read from the address space"
block|}
block|,
block|{
name|PCWRITE
block|,
literal|"PCWRITE"
block|,
literal|"write to the address space"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCRESET
comment|/* unixware */
block|{
name|PCRESET
block|,
literal|"PCRESET"
block|,
literal|"unset modes"
block|}
block|,
endif|#
directive|endif
block|{
name|PCRUN
block|,
literal|"PCRUN"
block|,
literal|"make process/lwp runnable"
block|}
block|,
ifdef|#
directive|ifdef
name|PCSASRS
comment|/* solaris 2.7 only */
block|{
name|PCSASRS
block|,
literal|"PCSASRS"
block|,
literal|"set ancillary state registers"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCSCRED
comment|/* solaris */
block|{
name|PCSCRED
block|,
literal|"PCSCRED"
block|,
literal|"set process credentials"
block|}
block|,
endif|#
directive|endif
block|{
name|PCSENTRY
block|,
literal|"PCSENTRY"
block|,
literal|"set traced syscall entry set"
block|}
block|,
block|{
name|PCSET
block|,
literal|"PCSET"
block|,
literal|"set modes"
block|}
block|,
block|{
name|PCSEXIT
block|,
literal|"PCSEXIT"
block|,
literal|"set traced syscall exit  set"
block|}
block|,
block|{
name|PCSFAULT
block|,
literal|"PCSFAULT"
block|,
literal|"set traced fault set"
block|}
block|,
block|{
name|PCSFPREG
block|,
literal|"PCSFPREG"
block|,
literal|"set floating point registers"
block|}
block|,
ifdef|#
directive|ifdef
name|PCSHOLD
comment|/* solaris */
block|{
name|PCSHOLD
block|,
literal|"PCSHOLD"
block|,
literal|"set signal mask"
block|}
block|,
endif|#
directive|endif
block|{
name|PCSREG
block|,
literal|"PCSREG"
block|,
literal|"set general registers"
block|}
block|,
block|{
name|PCSSIG
block|,
literal|"PCSSIG"
block|,
literal|"set current signal"
block|}
block|,
block|{
name|PCSTOP
block|,
literal|"PCSTOP"
block|,
literal|"post stop request and wait"
block|}
block|,
block|{
name|PCSTRACE
block|,
literal|"PCSTRACE"
block|,
literal|"set traced signal set"
block|}
block|,
ifdef|#
directive|ifdef
name|PCSVADDR
comment|/* solaris */
block|{
name|PCSVADDR
block|,
literal|"PCSVADDR"
block|,
literal|"set pc virtual address"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCSXREG
comment|/* solaris sparc only */
block|{
name|PCSXREG
block|,
literal|"PCSXREG"
block|,
literal|"set extra registers"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCTWSTOP
comment|/* solaris */
block|{
name|PCTWSTOP
block|,
literal|"PCTWSTOP"
block|,
literal|"wait for stop, with timeout arg"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCUNKILL
comment|/* solaris */
block|{
name|PCUNKILL
block|,
literal|"PCUNKILL"
block|,
literal|"delete a pending signal"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCUNSET
comment|/* solaris */
block|{
name|PCUNSET
block|,
literal|"PCUNSET"
block|,
literal|"unset modes"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCWATCH
comment|/* solaris */
block|{
name|PCWATCH
block|,
literal|"PCWATCH"
block|,
literal|"set/unset watched memory area"
block|}
block|,
endif|#
directive|endif
block|{
name|PCWSTOP
block|,
literal|"PCWSTOP"
block|,
literal|"wait for process/lwp to stop, no timeout"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|off_t
name|lseek_offset
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|write_with_trace
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|varg
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|i
init|=
name|ARRAY_SIZE
argument_list|(
name|rw_table
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|procfs_ctl_t
modifier|*
name|arg
init|=
operator|(
name|procfs_ctl_t
operator|*
operator|)
name|varg
decl_stmt|;
name|prepare_to_trace
argument_list|()
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
name|procfs_ctl_t
name|opcode
init|=
name|arg
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rw_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rw_table
index|[
name|i
index|]
operator|.
name|value
operator|==
name|opcode
condition|)
break|break;
if|if
condition|(
name|info_verbose
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s:%d -- "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|PCSET
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSET,   %s) %s\n"
argument_list|,
name|arg
index|[
literal|1
index|]
operator|==
name|PR_FORK
condition|?
literal|"PR_FORK"
else|:
name|arg
index|[
literal|1
index|]
operator|==
name|PR_RLC
condition|?
literal|"PR_RLC"
else|:
ifdef|#
directive|ifdef
name|PR_ASYNC
name|arg
index|[
literal|1
index|]
operator|==
name|PR_ASYNC
condition|?
literal|"PR_ASYNC"
else|:
endif|#
directive|endif
literal|"<unknown flag>"
argument_list|,
name|info_verbose
condition|?
name|rw_table
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PCUNSET
case|case
name|PCUNSET
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCRESET
if|#
directive|if
name|PCRESET
operator|!=
name|PCUNSET
case|case
name|PCRESET
case|:
endif|#
directive|endif
endif|#
directive|endif
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCRESET, %s) %s\n"
argument_list|,
name|arg
index|[
literal|1
index|]
operator|==
name|PR_FORK
condition|?
literal|"PR_FORK"
else|:
name|arg
index|[
literal|1
index|]
operator|==
name|PR_RLC
condition|?
literal|"PR_RLC"
else|:
ifdef|#
directive|ifdef
name|PR_ASYNC
name|arg
index|[
literal|1
index|]
operator|==
name|PR_ASYNC
condition|?
literal|"PR_ASYNC"
else|:
endif|#
directive|endif
literal|"<unknown flag>"
argument_list|,
name|info_verbose
condition|?
name|rw_table
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCSTRACE
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSTRACE) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signalset
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|arg
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCSFAULT
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSFAULT) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_faultset
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|fltset_t
operator|*
operator|)
operator|&
name|arg
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCSENTRY
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSENTRY) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_syscalls
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sysset_t
operator|*
operator|)
operator|&
name|arg
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCSEXIT
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSEXIT) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_syscalls
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sysset_t
operator|*
operator|)
operator|&
name|arg
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PCSHOLD
case|case
name|PCSHOLD
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSHOLD) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signalset
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|arg
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PCSSIG
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCSSIG) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signal
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
name|arg
index|[
literal|1
index|]
condition|?
operator|(
operator|(
name|siginfo_t
operator|*
operator|)
operator|&
name|arg
index|[
literal|1
index|]
operator|)
operator|->
name|si_signo
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCRUN
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCRUN) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|&
name|PRCSIG
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"clearSig "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|&
name|PRCFAULT
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"clearFlt "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|&
name|PRSTEP
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"step "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRSABORT
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|&
name|PRSABORT
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"syscallAbort "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRSTOP
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|&
name|PRSTOP
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"stopReq "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCKILL
case|:
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (PCKILL) "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_signal
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
if|if
condition|(
name|rw_table
index|[
name|i
index|]
operator|.
name|name
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (%s) %s\n"
argument_list|,
name|rw_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|info_verbose
condition|?
name|rw_table
index|[
name|i
index|]
operator|.
name|desc
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lseek_offset
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (<unknown>, %lud bytes at 0x%08lx) \n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lseek_offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"write (<unknown>, %lud bytes) \n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_trace
operator|&&
name|ret
operator|!=
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"[write (%s) FAILED! (%s)]\n"
argument_list|,
name|rw_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|?
name|rw_table
index|[
name|i
index|]
operator|.
name|name
else|:
literal|"<unknown>"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
name|lseek_offset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|off_t
name|lseek_with_trace
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|off_t
name|ret
decl_stmt|;
name|prepare_to_trace
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
expr_stmt|;
name|lseek_offset
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|procfs_trace
operator|&&
operator|(
name|ret
operator|==
operator|-
literal|1
operator|||
name|errno
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"[lseek (0x%08lx) FAILED! (%s)]\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_PROC_API */
end_comment

begin_function
name|int
name|open_with_trace
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|mode
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|prepare_to_trace
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s:%d -- "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"[open FAILED! (%s) line %d]\\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%d = open (%s, "
argument_list|,
name|ret
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|O_RDONLY
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"O_RDONLY) %d\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|O_WRONLY
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"O_WRONLY) %d\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|O_RDWR
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"O_RDWR)   %d\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|close_with_trace
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|prepare_to_trace
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s:%d -- "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"[close FAILED! (%s)]\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%d = close (%d)\n"
argument_list|,
name|ret
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|pid_t
name|wait_with_trace
parameter_list|(
name|int
modifier|*
name|wstat
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|lstat
init|=
literal|0
decl_stmt|;
name|prepare_to_trace
argument_list|()
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s:%d -- "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"wait (line %d) "
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|wait
argument_list|(
operator|&
name|lstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
if|if
condition|(
name|errno
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"[wait FAILED! (%s)]\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"returned pid %d, status 0x%x\n"
argument_list|,
name|ret
argument_list|,
name|lstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wstat
condition|)
operator|*
name|wstat
operator|=
name|lstat
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|procfs_note
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|prepare_to_trace
argument_list|()
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s:%d -- "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|proc_prettyfprint_status
parameter_list|(
name|long
name|flags
parameter_list|,
name|int
name|why
parameter_list|,
name|int
name|what
parameter_list|,
name|int
name|thread
parameter_list|)
block|{
name|prepare_to_trace
argument_list|()
expr_stmt|;
if|if
condition|(
name|procfs_trace
condition|)
block|{
if|if
condition|(
name|thread
condition|)
name|fprintf
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
literal|"Thread %d: "
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|proc_prettyfprint_flags
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
name|proc_prettyfprint_why
argument_list|(
name|procfs_file
condition|?
name|procfs_file
else|:
name|stdout
argument_list|,
name|why
argument_list|,
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|procfs_file
condition|)
name|fflush
argument_list|(
name|procfs_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_initialize_proc_api
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"procfs-trace"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|procfs_trace
argument_list|,
literal|"Set tracing for /proc api calls.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_procfs_trace_cmd
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"procfs-file"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|procfs_filename
argument_list|,
literal|"Set filename for /proc tracefile.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_procfs_file_cmd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

