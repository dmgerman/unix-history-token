begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-vector operations for controlling Unix child processes, for GDB.    Copyright 1990-1996, 1998, 1999 Free Software Foundation, Inc.    Contributed by Cygnus Support.  ## Contains temporary hacks..  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* "wait.h" fills in the gaps left by<wait.h> */
end_comment

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|symtab_and_line
modifier|*
name|child_enable_exception_callback
name|PARAMS
argument_list|(
operator|(
expr|enum
name|exception_event_kind
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|exception_event_record
modifier|*
name|child_get_current_exception_event
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_initialize_inftarg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_WAIT
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|child_wait
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|target_waitstatus
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHILD_WAIT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_WAIT
argument_list|)
end_if

begin_decl_stmt
name|void
name|child_post_wait
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|child_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_detach_from_process
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_attach_to_process
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_ATTACH
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|void
name|child_post_attach
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|child_require_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_require_detach
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ptrace_me
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ptrace_him
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|child_can_run
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|child_stop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_THREAD_ALIVE
end_ifndef

begin_decl_stmt
name|int
name|child_thread_alive
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|init_child_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|child_suppress_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inftarg should pretend not to 				   be a runnable target.  Used by targets 				   that can sit atop inftarg, such as HPUX 				   thread support.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_WAIT
end_ifndef

begin_comment
comment|/*##*/
end_comment

begin_comment
comment|/* Enable HACK for ttrace work.  In  * infttrace.c/require_notification_of_events,  * this is set to 0 so that the loop in child_wait  * won't loop.  */
end_comment

begin_decl_stmt
name|int
name|not_same_real_pid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*##*/
end_comment

begin_comment
comment|/* Wait for child to do something.  Return pid of child, or -1 in case    of error; store status through argument pointer OURSTATUS.  */
end_comment

begin_function
specifier|static
name|int
name|child_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|int
name|save_errno
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|execd_pathname
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
name|int
name|related_pid
decl_stmt|;
name|int
name|syscall_id
decl_stmt|;
name|enum
name|target_waitkind
name|kind
decl_stmt|;
do|do
block|{
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 			   attached process. */
name|set_sigio_trap
argument_list|()
expr_stmt|;
name|pid
operator|=
name|ptrace_wait
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|clear_sigio_trap
argument_list|()
expr_stmt|;
name|clear_sigint_trap
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|save_errno
operator|==
name|EINTR
condition|)
continue|continue;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Child process unexpectedly missing: %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Claim it exited with unknown signal.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Did it exit?      */
if|if
condition|(
name|target_has_exited
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
operator|&
name|exit_status
argument_list|)
condition|)
block|{
comment|/* ??rehrauer: For now, ignore this. */
continue|continue;
block|}
if|if
condition|(
operator|!
name|target_thread_alive
argument_list|(
name|pid
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|pid
return|;
block|}
if|if
condition|(
name|target_has_forked
argument_list|(
name|pid
argument_list|,
operator|&
name|related_pid
argument_list|)
operator|&&
operator|(
operator|(
name|pid
operator|==
name|inferior_pid
operator|)
operator|||
operator|(
name|related_pid
operator|==
name|inferior_pid
operator|)
operator|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_FORKED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|related_pid
operator|=
name|related_pid
expr_stmt|;
return|return
name|pid
return|;
block|}
if|if
condition|(
name|target_has_vforked
argument_list|(
name|pid
argument_list|,
operator|&
name|related_pid
argument_list|)
operator|&&
operator|(
operator|(
name|pid
operator|==
name|inferior_pid
operator|)
operator|||
operator|(
name|related_pid
operator|==
name|inferior_pid
operator|)
operator|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_VFORKED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|related_pid
operator|=
name|related_pid
expr_stmt|;
return|return
name|pid
return|;
block|}
if|if
condition|(
name|target_has_execd
argument_list|(
name|pid
argument_list|,
operator|&
name|execd_pathname
argument_list|)
condition|)
block|{
comment|/* Are we ignoring initial exec events?  (This is likely because            we're in the process of starting up the inferior, and another            (older) mechanism handles those.)  If so, we'll report this            as a regular stop, not an exec.            */
if|if
condition|(
name|inferior_ignoring_startup_exec_events
condition|)
block|{
name|inferior_ignoring_startup_exec_events
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXECD
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|execd_pathname
operator|=
name|execd_pathname
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
comment|/* All we must do with these is communicate their occurrence        to wait_for_inferior...        */
if|if
condition|(
name|target_has_syscall_event
argument_list|(
name|pid
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|syscall_id
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|syscall_id
operator|=
name|syscall_id
expr_stmt|;
return|return
name|pid
return|;
block|}
comment|/*##  } while (pid != inferior_pid); ##*/
comment|/* Some other child died or stopped */
comment|/* hack for thread testing */
block|}
do|while
condition|(
operator|(
name|pid
operator|!=
name|inferior_pid
operator|)
operator|&&
name|not_same_real_pid
condition|)
do|;
comment|/*##*/
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHILD_WAIT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_WAIT
argument_list|)
end_if

begin_function
name|void
name|child_post_wait
parameter_list|(
name|pid
parameter_list|,
name|wait_status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
block|{
comment|/* This version of Unix doesn't require a meaningful "post wait"      operation.      */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_THREAD_ALIVE
end_ifndef

begin_comment
comment|/* Check to see if the given thread is alive.     FIXME: Is kill() ever the right way to do this?  I doubt it, but    for now we're going to try and be compatable with the old thread    code.  */
end_comment

begin_function
name|int
name|child_thread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
return|return
operator|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|child_attach_to_process
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|after_fork
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|int
name|after_fork
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ATTACH_DETACH
name|error
argument_list|(
literal|"Can't attach to a process on this machine."
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|dummy
decl_stmt|;
name|dummy
operator|=
name|args
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
operator|&
name|dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Some targets don't set errno on errors, grrr! */
if|if
condition|(
operator|(
name|pid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|args
operator|==
name|dummy
operator|)
condition|)
name|error
argument_list|(
literal|"Illegal process-id: %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_fork
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching after fork to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program: %s, %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|after_fork
condition|)
name|attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
else|else
name|REQUIRE_ATTACH
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATTACH_DETACH */
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it.  */
end_comment

begin_function
specifier|static
name|void
name|child_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_attach_to_process
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_ATTACH
argument_list|)
end_if

begin_function
name|void
name|child_post_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't require a meaningful "post attach"      operation by a debugger.  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|child_require_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_attach_to_process
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_detach_from_process
parameter_list|(
name|pid
parameter_list|,
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|after_fork
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|int
name|after_fork
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ATTACH_DETACH
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|after_fork
condition|)
name|printf_unfiltered
argument_list|(
literal|"Detaching after fork from %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s, %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|after_fork
condition|)
name|detach
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
else|else
name|REQUIRE_DETACH
argument_list|(
name|pid
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|error
argument_list|(
literal|"This version of Unix does not support detaching a process."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|child_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_detach_from_process
argument_list|(
name|inferior_pid
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_require_detach
parameter_list|(
name|pid
parameter_list|,
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_detach_from_process
argument_list|(
name|pid
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|child_prepare_to_store
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|child_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|child_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub function which causes the inferior that runs it, to be ptrace-able    by its parent process.  */
end_comment

begin_function
specifier|static
name|void
name|ptrace_me
parameter_list|()
block|{
comment|/* "Trace me, Dr. Memory!" */
name|call_ptrace
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub function which causes the GDB that runs it, to start ptrace-ing    the child process.  */
end_comment

begin_function
specifier|static
name|void
name|ptrace_him
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
comment|/* On some targets, there must be some explicit synchronization      between the parent and child processes after the debugger      forks, and before the child execs the debuggee program.  This      call basically gives permission for the child to exec.      */
name|target_acknowledge_created_inferior
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* START_INFERIOR_TRAPS_EXPECTED is defined in inferior.h,    * and will be 1 or 2 depending on whether we're starting    * without or with a shell.    */
name|startup_inferior
argument_list|(
name|START_INFERIOR_TRAPS_EXPECTED
argument_list|)
expr_stmt|;
comment|/* On some targets, there must be some explicit actions taken after      the inferior has been started up.      */
name|target_post_startup_inferior
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior Unix child process and sets inferior_pid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().  */
end_comment

begin_function
specifier|static
name|void
name|child_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HPUXHPPA
name|char
modifier|*
name|tryname
decl_stmt|;
name|char
modifier|*
name|shell_file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
comment|/* On HP-UX, we have a possible bad interaction between    * the start-up-with-shell code and our catch-fork/catch-exec    * logic. To avoid the bad interaction, we start up with the    * C shell ("csh") and pass it the "-f" flag (fast start-up,    * don't run .cshrc code).    * See further comments in inferior.h toward the bottom    * (STARTUP_WITH_SHELL flag) and in fork-child.c    */
comment|/* Rather than passing in a hard-wired path like "/bin/csh",    * we look down the PATH to find csh. I took this code from    * procfs.c, which is the file in the Sun-specific part of GDB    * analogous to inftarg.c. See procfs.c for more detailed     * comments. - RT    */
name|shell_file
operator|=
literal|"csh"
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
literal|"/bin:/usr/bin"
expr_stmt|;
name|tryname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|shell_file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p1
condition|?
name|p1
operator|+
literal|1
else|:
name|NULL
control|)
block|{
name|p1
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
name|len
operator|=
name|p1
operator|-
name|p
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tryname
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tryname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|tryname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tryname
argument_list|,
name|shell_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|tryname
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|tryname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* We certainly need to reject directories.  I'm not quite          as sure about FIFOs, sockets, etc., but I kind of doubt          that people want to exec() these things.  */
continue|continue;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Not found. I replaced the error() which existed in procfs.c      * with simply passing in NULL and hoping fork_inferior()       * can deal with it. - RT      */
comment|/* error ("Can't find shell %s in PATH", shell_file); */
name|shell_file
operator|=
name|NULL
expr_stmt|;
else|else
name|shell_file
operator|=
name|tryname
expr_stmt|;
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|ptrace_me
argument_list|,
name|ptrace_him
argument_list|,
name|pre_fork_inferior
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|ptrace_me
argument_list|,
name|ptrace_him
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_STARTUP_INFERIOR
argument_list|)
end_if

begin_function
name|void
name|child_post_startup_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't require a meaningful "post startup inferior"      operation by a debugger.      */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_ACKNOWLEDGE_CREATED_INFERIOR
argument_list|)
end_if

begin_function
name|void
name|child_acknowledge_created_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't require a meaningful "acknowledge created inferior"      operation by a debugger.      */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|child_clone_and_follow_inferior
parameter_list|(
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|child_pid
decl_stmt|;
name|int
modifier|*
name|followed_child
decl_stmt|;
block|{
name|clone_and_follow_inferior
argument_list|(
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
comment|/* Don't resume CHILD_PID; it's stopped where it ought to be, until      the decision gets made elsewhere how to continue it.      */
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_FOLLOW_INFERIOR_BY_CLONE
argument_list|)
end_if

begin_function
name|void
name|child_post_follow_inferior_by_clone
parameter_list|()
block|{
comment|/* This version of Unix doesn't require a meaningful "post follow inferior"      operation by a clone debugger.      */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_INSERT_FORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_fork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of fork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REMOVE_FORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_fork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of fork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_INSERT_VFORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_vfork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of vfork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REMOVE_VFORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_vfork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of vfork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_HAS_FORKED
argument_list|)
end_if

begin_function
name|int
name|child_has_forked
parameter_list|(
name|pid
parameter_list|,
name|child_pid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|child_pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of fork events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_HAS_VFORKED
argument_list|)
end_if

begin_function
name|int
name|child_has_vforked
parameter_list|(
name|pid
parameter_list|,
name|child_pid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|child_pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of vfork events.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC
argument_list|)
end_if

begin_function
name|int
name|child_can_follow_vfork_prior_to_exec
parameter_list|()
block|{
comment|/* This version of Unix doesn't support notification of vfork events.      However, if it did, it probably wouldn't allow vforks to be followed      before the following exec.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_POST_FOLLOW_VFORK
argument_list|)
end_if

begin_function
name|void
name|child_post_follow_vfork
parameter_list|(
name|parent_pid
parameter_list|,
name|followed_parent
parameter_list|,
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|parent_pid
decl_stmt|;
name|int
name|followed_parent
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
name|int
name|followed_child
decl_stmt|;
block|{
comment|/* This version of Unix doesn't require a meaningful "post follow vfork"      operation by a clone debugger.      */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_INSERT_EXEC_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_exec_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of exec events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REMOVE_EXEC_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_exec_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of exec events.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_HAS_EXECD
argument_list|)
end_if

begin_function
name|int
name|child_has_execd
parameter_list|(
name|pid
parameter_list|,
name|execd_pathname
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
modifier|*
name|execd_pathname
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of exec events.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_REPORTED_EXEC_EVENTS_PER_EXEC_CALL
argument_list|)
end_if

begin_function
name|int
name|child_reported_exec_events_per_exec_call
parameter_list|()
block|{
comment|/* This version of Unix doesn't support notification of exec events.      */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_HAS_SYSCALL_EVENT
argument_list|)
end_if

begin_function
name|int
name|child_has_syscall_event
parameter_list|(
name|pid
parameter_list|,
name|kind
parameter_list|,
name|syscall_id
parameter_list|)
name|int
name|pid
decl_stmt|;
name|enum
name|target_waitkind
modifier|*
name|kind
decl_stmt|;
name|int
modifier|*
name|syscall_id
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support notification of syscall events.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_HAS_EXITED
argument_list|)
end_if

begin_function
name|int
name|child_has_exited
parameter_list|(
name|pid
parameter_list|,
name|wait_status
parameter_list|,
name|exit_status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
name|int
modifier|*
name|exit_status
decl_stmt|;
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
operator|*
name|exit_status
operator|=
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
operator|*
name|exit_status
operator|=
literal|0
expr_stmt|;
comment|/* ?? Don't know what else to say here. */
return|return
literal|1
return|;
block|}
comment|/* ?? Do we really need to consult the event state, too?  Assume the    wait_state alone suffices.    */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|child_mourn_inferior
parameter_list|()
block|{
comment|/* FIXME: Should be in a header file */
specifier|extern
name|void
name|proc_remove_foreign
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
name|proc_remove_foreign
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|child_can_run
parameter_list|()
block|{
comment|/* This variable is controlled by modules that sit atop inftarg that may layer      their own process structure atop that provided here.  hpux-thread.c does      this because of the Hpux user-mode level thread model.  */
return|return
operator|!
name|child_suppress_run
return|;
block|}
end_function

begin_comment
comment|/* Send a SIGINT to the process group.  This acts just like the user typed a    ^C on the controlling terminal.     XXX - This may not be correct for all systems.  Some may want to use    killpg() instead of kill (-pgrp). */
end_comment

begin_function
specifier|static
name|void
name|child_stop
parameter_list|()
block|{
specifier|extern
name|pid_t
name|inferior_process_group
decl_stmt|;
name|kill
argument_list|(
operator|-
name|inferior_process_group
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_ENABLE_EXCEPTION_CALLBACK
argument_list|)
end_if

begin_function
name|struct
name|symtab_and_line
modifier|*
name|child_enable_exception_callback
parameter_list|(
name|kind
parameter_list|,
name|enable
parameter_list|)
name|enum
name|exception_event_kind
name|kind
decl_stmt|;
name|int
name|enable
decl_stmt|;
block|{
return|return
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_GET_CURRENT_EXCEPTION_EVENT
argument_list|)
end_if

begin_function
name|struct
name|exception_event_record
modifier|*
name|child_get_current_exception_event
parameter_list|()
block|{
return|return
operator|(
expr|struct
name|exception_event_record
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_PID_TO_EXEC_FILE
argument_list|)
end_if

begin_function
name|char
modifier|*
name|child_pid_to_exec_file
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This version of Unix doesn't support translation of a process ID      to the filename of the executable file.      */
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|child_core_file_to_sym_file
parameter_list|(
name|core
parameter_list|)
name|char
modifier|*
name|core
decl_stmt|;
block|{
comment|/* The target stratum for a running executable need not support      this operation.      */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|init_child_ops
parameter_list|()
block|{
name|child_ops
operator|.
name|to_shortname
operator|=
literal|"child"
expr_stmt|;
name|child_ops
operator|.
name|to_longname
operator|=
literal|"Unix child process"
expr_stmt|;
name|child_ops
operator|.
name|to_doc
operator|=
literal|"Unix child process (started by the \"run\" command)."
expr_stmt|;
name|child_ops
operator|.
name|to_open
operator|=
name|child_open
expr_stmt|;
name|child_ops
operator|.
name|to_attach
operator|=
name|child_attach
expr_stmt|;
name|child_ops
operator|.
name|to_post_attach
operator|=
name|child_post_attach
expr_stmt|;
name|child_ops
operator|.
name|to_require_attach
operator|=
name|child_require_attach
expr_stmt|;
name|child_ops
operator|.
name|to_detach
operator|=
name|child_detach
expr_stmt|;
name|child_ops
operator|.
name|to_require_detach
operator|=
name|child_require_detach
expr_stmt|;
name|child_ops
operator|.
name|to_resume
operator|=
name|child_resume
expr_stmt|;
name|child_ops
operator|.
name|to_wait
operator|=
name|child_wait
expr_stmt|;
name|child_ops
operator|.
name|to_post_wait
operator|=
name|child_post_wait
expr_stmt|;
name|child_ops
operator|.
name|to_fetch_registers
operator|=
name|fetch_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_store_registers
operator|=
name|store_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_prepare_to_store
operator|=
name|child_prepare_to_store
expr_stmt|;
name|child_ops
operator|.
name|to_xfer_memory
operator|=
name|child_xfer_memory
expr_stmt|;
name|child_ops
operator|.
name|to_files_info
operator|=
name|child_files_info
expr_stmt|;
name|child_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|child_ops
operator|.
name|to_kill
operator|=
name|kill_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_create_inferior
operator|=
name|child_create_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_post_startup_inferior
operator|=
name|child_post_startup_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|child_acknowledge_created_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|child_clone_and_follow_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|child_post_follow_inferior_by_clone
expr_stmt|;
name|child_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|child_insert_fork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|child_remove_fork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|child_insert_vfork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|child_remove_vfork_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_has_forked
operator|=
name|child_has_forked
expr_stmt|;
name|child_ops
operator|.
name|to_has_vforked
operator|=
name|child_has_vforked
expr_stmt|;
name|child_ops
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|child_can_follow_vfork_prior_to_exec
expr_stmt|;
name|child_ops
operator|.
name|to_post_follow_vfork
operator|=
name|child_post_follow_vfork
expr_stmt|;
name|child_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|child_insert_exec_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|child_remove_exec_catchpoint
expr_stmt|;
name|child_ops
operator|.
name|to_has_execd
operator|=
name|child_has_execd
expr_stmt|;
name|child_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|child_reported_exec_events_per_exec_call
expr_stmt|;
name|child_ops
operator|.
name|to_has_syscall_event
operator|=
name|child_has_syscall_event
expr_stmt|;
name|child_ops
operator|.
name|to_has_exited
operator|=
name|child_has_exited
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
operator|=
name|child_mourn_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_can_run
operator|=
name|child_can_run
expr_stmt|;
name|child_ops
operator|.
name|to_thread_alive
operator|=
name|child_thread_alive
expr_stmt|;
name|child_ops
operator|.
name|to_stop
operator|=
name|child_stop
expr_stmt|;
name|child_ops
operator|.
name|to_enable_exception_callback
operator|=
name|child_enable_exception_callback
expr_stmt|;
name|child_ops
operator|.
name|to_get_current_exception_event
operator|=
name|child_get_current_exception_event
expr_stmt|;
name|child_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|child_pid_to_exec_file
expr_stmt|;
name|child_ops
operator|.
name|to_core_file_to_sym_file
operator|=
name|child_core_file_to_sym_file
expr_stmt|;
name|child_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|child_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_inftarg
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_OPTIONAL_PROC_FS
name|char
name|procname
index|[
literal|32
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* If we have an optional /proc filesystem (e.g. under OSF/1),      don't add ptrace support if we can access the running GDB via /proc.  */
ifndef|#
directive|ifndef
name|PROC_NAME_FMT
define|#
directive|define
name|PROC_NAME_FMT
value|"/proc/%05d"
endif|#
directive|endif
name|sprintf
argument_list|(
name|procname
argument_list|,
name|PROC_NAME_FMT
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|procname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|init_child_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

