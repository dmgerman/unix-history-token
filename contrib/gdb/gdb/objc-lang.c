begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Objective-C language support routines for GDB, the GNU debugger.     Copyright 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Apple Computer, Inc.    Written by Michael Snyder.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"objc-lang.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* for strchr */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* for target_has_execution */
end_comment

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"infcall.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_struct
struct|struct
name|objc_object
block|{
name|CORE_ADDR
name|isa
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|objc_class
block|{
name|CORE_ADDR
name|isa
decl_stmt|;
name|CORE_ADDR
name|super_class
decl_stmt|;
name|CORE_ADDR
name|name
decl_stmt|;
name|long
name|version
decl_stmt|;
name|long
name|info
decl_stmt|;
name|long
name|instance_size
decl_stmt|;
name|CORE_ADDR
name|ivars
decl_stmt|;
name|CORE_ADDR
name|methods
decl_stmt|;
name|CORE_ADDR
name|cache
decl_stmt|;
name|CORE_ADDR
name|protocols
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|objc_super
block|{
name|CORE_ADDR
name|receiver
decl_stmt|;
name|CORE_ADDR
name|class
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|objc_method
block|{
name|CORE_ADDR
name|name
decl_stmt|;
name|CORE_ADDR
name|types
decl_stmt|;
name|CORE_ADDR
name|imp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Lookup a structure type named "struct NAME", visible in lexical    block BLOCK.  If NOERR is nonzero, return zero if NAME is not    suitably defined.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_struct_typedef
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|int
name|noerr
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noerr
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|"No struct type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
block|{
if|if
condition|(
name|noerr
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|"This context has class, union or enum %s, not a struct."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|lookup_objc_class
parameter_list|(
name|char
modifier|*
name|classname
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|function
decl_stmt|,
modifier|*
name|classval
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
comment|/* Can't call into inferior to lookup class.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"objc_lookUpClass"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"objc_lookUpClass"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"objc_lookup_class"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"objc_lookup_class"
argument_list|)
expr_stmt|;
else|else
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"no way to lookup Objective-C classes"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|classval
operator|=
name|value_string
argument_list|(
name|classname
argument_list|,
name|strlen
argument_list|(
name|classname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|classval
operator|=
name|value_coerce_array
argument_list|(
name|classval
argument_list|)
expr_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|call_function_by_hand
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
operator|&
name|classval
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|lookup_child_selector
parameter_list|(
name|char
modifier|*
name|selname
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|function
decl_stmt|,
modifier|*
name|selstring
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
comment|/* Can't call into inferior to lookup selector.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"sel_getUid"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"sel_getUid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"sel_get_any_uid"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"sel_get_any_uid"
argument_list|)
expr_stmt|;
else|else
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"no way to lookup Objective-C selectors"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|selstring
operator|=
name|value_coerce_array
argument_list|(
name|value_string
argument_list|(
name|selname
argument_list|,
name|strlen
argument_list|(
name|selname
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_as_long
argument_list|(
name|call_function_by_hand
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
operator|&
name|selstring
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|value_nsstring
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|stringValue
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|value
modifier|*
name|function
decl_stmt|,
modifier|*
name|nsstringValue
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
return|return
literal|0
return|;
comment|/* Can't call into inferior to create NSString.  */
name|sym
operator|=
name|lookup_struct_typedef
argument_list|(
literal|"NSString"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|sym
operator|=
name|lookup_struct_typedef
argument_list|(
literal|"NXString"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|stringValue
index|[
literal|2
index|]
operator|=
name|value_string
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stringValue
index|[
literal|2
index|]
operator|=
name|value_coerce_array
argument_list|(
name|stringValue
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* _NSNewStringFromCString replaces "istr" after Lantern2A.  */
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"_NSNewStringFromCString"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"_NSNewStringFromCString"
argument_list|)
expr_stmt|;
name|nsstringValue
operator|=
name|call_function_by_hand
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
operator|&
name|stringValue
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"istr"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"istr"
argument_list|)
expr_stmt|;
name|nsstringValue
operator|=
name|call_function_by_hand
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
operator|&
name|stringValue
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"+[NSString stringWithCString:]"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"+[NSString stringWithCString:]"
argument_list|)
expr_stmt|;
name|stringValue
index|[
literal|0
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|lookup_objc_class
argument_list|(
literal|"NSString"
argument_list|)
argument_list|)
expr_stmt|;
name|stringValue
index|[
literal|1
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|lookup_child_selector
argument_list|(
literal|"stringWithCString:"
argument_list|)
argument_list|)
expr_stmt|;
name|nsstringValue
operator|=
name|call_function_by_hand
argument_list|(
name|function
argument_list|,
literal|3
argument_list|,
operator|&
name|stringValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"NSString: internal error -- no way to create new NSString"
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|nsstringValue
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|nsstringValue
return|;
block|}
end_function

begin_comment
comment|/* Objective-C name demangling.  */
end_comment

begin_function
name|char
modifier|*
name|objc_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|char
modifier|*
name|demangled
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|mangled
index|[
literal|1
index|]
operator|==
literal|'i'
operator|||
name|mangled
index|[
literal|1
index|]
operator|==
literal|'c'
operator|)
operator|&&
name|mangled
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|cp
operator|=
name|demangled
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|mangled
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mangled
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
comment|/* for instance method */
else|else
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
comment|/* for class    method */
operator|*
name|cp
operator|++
operator|=
literal|'['
expr_stmt|;
comment|/* opening left brace  */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|mangled
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* tack on the rest of the mangled name */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
literal|'_'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* skip any initial underbars in class name */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
comment|/* find first non-initial underbar */
block|{
name|xfree
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
comment|/* not mangled name */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
comment|/* easy case: no category name     */
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* replace two '_' with one ' '    */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|mangled
operator|+
operator|(
name|cp
operator|-
name|demangled
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
literal|'('
expr_stmt|;
comment|/* less easy case: category name */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|xfree
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
comment|/* not mangled name */
return|return
name|NULL
return|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|')'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* overwriting 1st char of method name...  */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|mangled
operator|+
operator|(
name|cp
operator|-
name|demangled
operator|)
argument_list|)
expr_stmt|;
comment|/* get it back */
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
literal|'_'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* skip any initial underbars in method name */
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'_'
condition|)
operator|*
name|cp
operator|=
literal|':'
expr_stmt|;
comment|/* replace remaining '_' with ':' */
operator|*
name|cp
operator|++
operator|=
literal|']'
expr_stmt|;
comment|/* closing right brace */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* string terminator */
return|return
name|demangled
return|;
block|}
else|else
return|return
name|NULL
return|;
comment|/* Not an objc mangled name.  */
block|}
end_function

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a    literal string whose delimiter is QUOTER.  Note that that format    for printing characters and strings is language specific.  */
end_comment

begin_function
specifier|static
name|void
name|objc_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies.  */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|objc_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|objc_emit_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH    characters.  Printing stops early if the number hits print_max;    repeat counts are printed as appropriate.  Print ellipses at the    end if we had to stop before printing LENGTH characters, or if    FORCE_ELLIPSES.  */
end_comment

begin_function
specifier|static
name|void
name|objc_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
comment|/* If the string was not truncated due to `set print elements', and      the last byte of it is a null, we don't print that, in      traditional C style.  */
if|if
condition|(
operator|(
operator|!
name|force_ellipses
operator|)
operator|&&
name|length
operator|>
literal|0
operator|&&
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|length
operator|--
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining to see whether it 	 is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|objc_printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|objc_emit_char
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fundamental C type using default reasonable for the    current target.     Some object/debugging file formats (DWARF version 1, COFF, etc) do    not define fundamental types such as "int" or "double".  Others    (stabs or DWARF version 2, etc) do define fundamental types.  For    the formats which don't provide fundamental types, gdb can create    such types using this function.     FIXME: Some compilers distinguish explicitly signed integral types    (signed short, signed int, signed long) from "regular" integral    types (short, int, long) in the debugging information.  There is    some disagreement as to how useful this feature is.  In particular,    gcc does not support this.  Also, only some debugging formats allow    the distinction to be passed on to a debugger.  For now, we always    just use "short", "int", or "long" as the type name, for both the    implicit and explicitly signed types.  This also makes life easier    for the gdb test suite since we don't have to account for the    differences in output depending upon what the compiler and    debugging format support.  We will probably have to re-examine the    issue when gdb starts taking it's fundamental type information    directly from the debugging information supplied by the compiler.    fnf@cygnus.com */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|objc_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME: For now, if we are asked to produce a type not in 	   this language, create the equivalent of a C integer type 	   with the name "<?type?>".  When all the dust settles from 	   the type reconstruction work, this should probably become 	   an error.  */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no C/C++ fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if we are currently in the Objective-C dispatch function.    If so, get the address of the method function that the dispatcher    would call and use that as the function to step into instead. Also    skip over the trampoline for the function (if any).  This is better    for the user since they are only interested in stepping into the    method function anyway.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|objc_skip_trampoline
parameter_list|(
name|CORE_ADDR
name|stop_pc
parameter_list|)
block|{
name|CORE_ADDR
name|real_stop_pc
decl_stmt|;
name|CORE_ADDR
name|method_stop_pc
decl_stmt|;
name|real_stop_pc
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_stop_pc
operator|!=
literal|0
condition|)
name|find_objc_msgcall
argument_list|(
name|real_stop_pc
argument_list|,
operator|&
name|method_stop_pc
argument_list|)
expr_stmt|;
else|else
name|find_objc_msgcall
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|method_stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_stop_pc
condition|)
block|{
name|real_stop_pc
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|method_stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_stop_pc
operator|==
literal|0
condition|)
name|real_stop_pc
operator|=
name|method_stop_pc
expr_stmt|;
block|}
return|return
name|real_stop_pc
return|;
block|}
end_function

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|objc_op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"||"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"&&"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"|"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"=="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"!="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"%"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"!"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"~"
block|,
name|UNOP_COMPLEMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|UNOP_ADDR
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof "
block|,
name|UNOP_SIZEOF
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"++"
block|,
name|UNOP_PREINCREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
name|UNOP_PREDECREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|OP_NULL
block|,
name|PREC_NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|objc_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_long_long
block|,
operator|&
name|builtin_type_signed_char
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_long_long
block|,
operator|&
name|builtin_type_long_double
block|,
operator|&
name|builtin_type_complex
block|,
operator|&
name|builtin_type_double_complex
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|objc_language_defn
init|=
block|{
literal|"objective-c"
block|,
comment|/* Language name */
name|language_objc
block|,
name|objc_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|objc_parse
block|,
name|objc_error
block|,
name|objc_printchar
block|,
comment|/* Print a character constant */
name|objc_printstr
block|,
comment|/* Function to print string constant */
name|objc_emit_char
block|,
name|objc_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
name|objc_skip_trampoline
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|objc_demangle
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|objc_op_print_tab
block|,
comment|/* Expression operators for printing */
literal|1
block|,
comment|/* C-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ObjC:  * Following functions help construct Objective-C message calls   */
end_comment

begin_struct
struct|struct
name|selname
comment|/* For parsing Objective-C.  */
block|{
name|struct
name|selname
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|msglist_sel
decl_stmt|;
name|int
name|msglist_len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|msglist_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|selname
modifier|*
name|selname_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|msglist_sel
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|start_msglist
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|selname
modifier|*
name|new
init|=
operator|(
expr|struct
name|selname
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|selname
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|selname_chain
expr_stmt|;
name|new
operator|->
name|msglist_len
operator|=
name|msglist_len
expr_stmt|;
name|new
operator|->
name|msglist_sel
operator|=
name|msglist_sel
expr_stmt|;
name|msglist_len
operator|=
literal|0
expr_stmt|;
name|msglist_sel
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|msglist_sel
operator|=
literal|0
expr_stmt|;
name|selname_chain
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_msglist
parameter_list|(
name|struct
name|stoken
modifier|*
name|str
parameter_list|,
name|int
name|addcolon
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|plen
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
block|{
comment|/* Unnamed arg, or...  */
if|if
condition|(
name|addcolon
operator|==
literal|0
condition|)
block|{
comment|/* variable number of args.  */
name|msglist_len
operator|++
expr_stmt|;
return|return;
block|}
name|p
operator|=
literal|""
expr_stmt|;
name|plen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|str
operator|->
name|ptr
expr_stmt|;
name|plen
operator|=
name|str
operator|->
name|length
expr_stmt|;
block|}
name|len
operator|=
name|plen
operator|+
name|strlen
argument_list|(
name|msglist_sel
argument_list|)
operator|+
literal|2
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|msglist_sel
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|msglist_sel
argument_list|)
expr_stmt|;
name|msglist_sel
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|addcolon
condition|)
block|{
name|s
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msglist_len
operator|++
expr_stmt|;
block|}
else|else
name|s
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|int
name|end_msglist
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|val
init|=
name|msglist_len
decl_stmt|;
name|struct
name|selname
modifier|*
name|sel
init|=
name|selname_chain
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|msglist_sel
decl_stmt|;
name|CORE_ADDR
name|selid
decl_stmt|;
name|selname_chain
operator|=
name|sel
operator|->
name|next
expr_stmt|;
name|msglist_len
operator|=
name|sel
operator|->
name|msglist_len
expr_stmt|;
name|msglist_sel
operator|=
name|sel
operator|->
name|msglist_sel
expr_stmt|;
name|selid
operator|=
name|lookup_child_selector
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|selid
condition|)
name|error
argument_list|(
literal|"Can't find selector \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|selid
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Number of args */
name|xfree
argument_list|(
name|sel
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Function: specialcmp (char *a, char *b)  *  * Special strcmp: treats ']' and ' ' as end-of-string.  * Used for qsorting lists of objc methods (either by class or selector).  */
end_comment

begin_function
specifier|static
name|int
name|specialcmp
parameter_list|(
name|char
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|b
parameter_list|)
block|{
while|while
condition|(
operator|*
name|a
operator|&&
operator|*
name|a
operator|!=
literal|' '
operator|&&
operator|*
name|a
operator|!=
literal|']'
operator|&&
operator|*
name|b
operator|&&
operator|*
name|b
operator|!=
literal|' '
operator|&&
operator|*
name|b
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
condition|)
return|return
operator|*
name|a
operator|-
operator|*
name|b
return|;
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|a
operator|&&
operator|*
name|a
operator|!=
literal|' '
operator|&&
operator|*
name|a
operator|!=
literal|']'
condition|)
return|return
literal|1
return|;
comment|/* a is longer therefore greater */
if|if
condition|(
operator|*
name|b
operator|&&
operator|*
name|b
operator|!=
literal|' '
operator|&&
operator|*
name|b
operator|!=
literal|']'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* a is shorter therefore lesser */
return|return
literal|0
return|;
comment|/* a and b are identical */
block|}
end_function

begin_comment
comment|/*  * Function: compare_selectors (const void *, const void *)  *  * Comparison function for use with qsort.  Arguments are symbols or  * msymbols Compares selector part of objc method name alphabetically.  */
end_comment

begin_function
specifier|static
name|int
name|compare_selectors
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|char
modifier|*
name|aname
decl_stmt|,
modifier|*
name|bname
decl_stmt|;
name|aname
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|bname
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aname
operator|==
name|NULL
operator|||
name|bname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"internal: compare_selectors(1)"
argument_list|)
expr_stmt|;
name|aname
operator|=
name|strchr
argument_list|(
name|aname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|bname
operator|=
name|strchr
argument_list|(
name|bname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|aname
operator|==
name|NULL
operator|||
name|bname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"internal: compare_selectors(2)"
argument_list|)
expr_stmt|;
return|return
name|specialcmp
argument_list|(
name|aname
operator|+
literal|1
argument_list|,
name|bname
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: selectors_info (regexp, from_tty)  *  * Implements the "Info selectors" command.  Takes an optional regexp  * arg.  Lists all objective c selectors that match the regexp.  Works  * by grepping thru all symbols for objective c methods.  Output list  * is sorted and uniqued.   */
end_comment

begin_function
specifier|static
name|void
name|selectors_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|int
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|char
name|myregexp
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|asel
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|int
name|plusminus
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|myregexp
argument_list|,
literal|".*]"
argument_list|)
expr_stmt|;
comment|/* Null input, match all objc methods.  */
else|else
block|{
if|if
condition|(
operator|*
name|regexp
operator|==
literal|'+'
operator|||
operator|*
name|regexp
operator|==
literal|'-'
condition|)
block|{
comment|/* User wants only class methods or only instance methods.  */
name|plusminus
operator|=
operator|*
name|regexp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|regexp
operator|==
literal|' '
operator|||
operator|*
name|regexp
operator|==
literal|'\t'
condition|)
name|regexp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|regexp
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|myregexp
argument_list|,
literal|".*]"
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|myregexp
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|myregexp
index|[
name|strlen
argument_list|(
name|myregexp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
condition|)
comment|/* end of selector */
name|myregexp
index|[
name|strlen
argument_list|(
name|myregexp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
comment|/* end of method name */
else|else
name|strcat
argument_list|(
name|myregexp
argument_list|,
literal|".*]"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regexp
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|re_comp
argument_list|(
name|myregexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* First time thru is JUST to get max length and count.  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|name
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
comment|/* Got a method name.  */
block|{
comment|/* Filter for class/instance methods.  */
if|if
condition|(
name|plusminus
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
name|plusminus
condition|)
continue|continue;
comment|/* Find selector part.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
operator|+
literal|2
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
operator|++
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|mystart
init|=
name|name
decl_stmt|;
name|char
modifier|*
name|myend
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|mystart
argument_list|,
literal|']'
argument_list|)
decl_stmt|;
if|if
condition|(
name|myend
operator|&&
operator|(
name|myend
operator|-
name|mystart
operator|>
name|maxlen
operator|)
condition|)
name|maxlen
operator|=
name|myend
operator|-
name|mystart
expr_stmt|;
comment|/* Get longest selector.  */
name|matches
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|matches
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Selectors matching \"%s\":\n\n"
argument_list|,
name|regexp
condition|?
name|regexp
else|:
literal|"*"
argument_list|)
expr_stmt|;
name|sym_arr
operator|=
name|alloca
argument_list|(
name|matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|name
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
comment|/* Got a method name.  */
block|{
comment|/* Filter for class/instance methods.  */
if|if
condition|(
name|plusminus
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
name|plusminus
condition|)
continue|continue;
comment|/* Find selector part.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
operator|+
literal|2
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
operator|++
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|sym_arr
index|[
name|matches
operator|++
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|msymbol
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|sym_arr
argument_list|,
name|matches
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
operator|*
argument_list|)
argument_list|,
name|compare_selectors
argument_list|)
expr_stmt|;
comment|/* Prevent compare on first iteration.  */
name|asel
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|matches
condition|;
name|ix
operator|++
control|)
comment|/* Now do the output.  */
block|{
name|char
modifier|*
name|p
init|=
name|asel
decl_stmt|;
name|QUIT
expr_stmt|;
name|name
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym_arr
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|name
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|&&
name|specialcmp
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Seen this one already (not unique).  */
comment|/* Copy selector part.  */
while|while
condition|(
operator|*
name|name
operator|&&
operator|*
name|name
operator|!=
literal|']'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Print in columns.  */
name|puts_filtered_tabular
argument_list|(
name|asel
argument_list|,
name|maxlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|begin_line
argument_list|()
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"No selectors matching \"%s\"\n"
argument_list|,
name|regexp
condition|?
name|regexp
else|:
literal|"*"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: compare_classes (const void *, const void *)  *  * Comparison function for use with qsort.  Arguments are symbols or  * msymbols Compares class part of objc method name alphabetically.   */
end_comment

begin_function
specifier|static
name|int
name|compare_classes
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|char
modifier|*
name|aname
decl_stmt|,
modifier|*
name|bname
decl_stmt|;
name|aname
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|bname
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aname
operator|==
name|NULL
operator|||
name|bname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"internal: compare_classes(1)"
argument_list|)
expr_stmt|;
return|return
name|specialcmp
argument_list|(
name|aname
operator|+
literal|1
argument_list|,
name|bname
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: classes_info(regexp, from_tty)  *  * Implements the "info classes" command for objective c classes.  * Lists all objective c classes that match the optional regexp.  * Works by grepping thru the list of objective c methods.  List will  * be sorted and uniqued (since one class may have many methods).  * BUGS: will not list a class that has no methods.   */
end_comment

begin_function
specifier|static
name|void
name|classes_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|int
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|char
name|myregexp
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|aclass
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|myregexp
argument_list|,
literal|".* "
argument_list|)
expr_stmt|;
comment|/* Null input: match all objc classes.  */
else|else
block|{
name|strcpy
argument_list|(
name|myregexp
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|myregexp
index|[
name|strlen
argument_list|(
name|myregexp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
condition|)
comment|/* In the method name, the end of the class name is marked by ' '.  */
name|myregexp
index|[
name|strlen
argument_list|(
name|myregexp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
else|else
name|strcat
argument_list|(
name|myregexp
argument_list|,
literal|".* "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regexp
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|re_comp
argument_list|(
name|myregexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* First time thru is JUST to get max length and count.  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|name
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
comment|/* Got a method name.  */
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
name|name
operator|+
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Compute length of classname part.  */
name|char
modifier|*
name|mystart
init|=
name|name
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|myend
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|mystart
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|myend
operator|&&
operator|(
name|myend
operator|-
name|mystart
operator|>
name|maxlen
operator|)
condition|)
name|maxlen
operator|=
name|myend
operator|-
name|mystart
expr_stmt|;
name|matches
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matches
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Classes matching \"%s\":\n\n"
argument_list|,
name|regexp
condition|?
name|regexp
else|:
literal|"*"
argument_list|)
expr_stmt|;
name|sym_arr
operator|=
name|alloca
argument_list|(
name|matches
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|name
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
comment|/* Got a method name.  */
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
name|name
operator|+
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|sym_arr
index|[
name|matches
operator|++
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|msymbol
expr_stmt|;
block|}
name|qsort
argument_list|(
name|sym_arr
argument_list|,
name|matches
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
operator|*
argument_list|)
argument_list|,
name|compare_classes
argument_list|)
expr_stmt|;
comment|/* Prevent compare on first iteration.  */
name|aclass
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|matches
condition|;
name|ix
operator|++
control|)
comment|/* Now do the output.  */
block|{
name|char
modifier|*
name|p
init|=
name|aclass
decl_stmt|;
name|QUIT
expr_stmt|;
name|name
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym_arr
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|name
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|&&
name|specialcmp
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Seen this one already (not unique).  */
comment|/* Copy class part of method name.  */
while|while
condition|(
operator|*
name|name
operator|&&
operator|*
name|name
operator|!=
literal|' '
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Print in columns.  */
name|puts_filtered_tabular
argument_list|(
name|aclass
argument_list|,
name|maxlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|begin_line
argument_list|()
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"No classes matching \"%s\"\n"
argument_list|,
name|regexp
condition|?
name|regexp
else|:
literal|"*"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Function: find_imps (char *selector, struct symbol **sym_arr)  *  * Input:  a string representing a selector  *         a pointer to an array of symbol pointers  *         possibly a pointer to a symbol found by the caller.  *  * Output: number of methods that implement that selector.  Side  * effects: The array of symbol pointers is filled with matching syms.  *  * By analogy with function "find_methods" (symtab.c), builds a list  * of symbols matching the ambiguous input, so that "decode_line_2"  * (symtab.c) can list them and ask the user to choose one or more.  * In this case the matches are objective c methods  * ("implementations") matching an objective c selector.  *  * Note that it is possible for a normal (c-style) function to have  * the same name as an objective c selector.  To prevent the selector  * from eclipsing the function, we allow the caller (decode_line_1) to  * search for such a function first, and if it finds one, pass it in  * to us.  We will then integrate it into the list.  We also search  * for one here, among the minsyms.  *  * NOTE: if NUM_DEBUGGABLE is non-zero, the sym_arr will be divided  *       into two parts: debuggable (struct symbol) syms, and  *       non_debuggable (struct minimal_symbol) syms.  The debuggable  *       ones will come first, before NUM_DEBUGGABLE (which will thus  *       be the index of the first non-debuggable one).   */
end_comment

begin_comment
comment|/*  * Function: total_number_of_imps (char *selector);  *  * Input:  a string representing a selector   * Output: number of methods that implement that selector.  *  * By analogy with function "total_number_of_methods", this allows  * decode_line_1 (symtab.c) to detect if there are objective c methods  * matching the input, and to allocate an array of pointers to them  * which can be manipulated by "decode_line_2" (also in symtab.c).  */
end_comment

begin_function
name|char
modifier|*
name|parse_selector
parameter_list|(
name|char
modifier|*
name|method
parameter_list|,
name|char
modifier|*
modifier|*
name|selector
parameter_list|)
block|{
name|char
modifier|*
name|s1
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
name|int
name|found_quote
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|nselector
init|=
name|NULL
decl_stmt|;
name|gdb_assert
argument_list|(
name|selector
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s1
operator|=
name|method
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\''
condition|)
block|{
name|found_quote
operator|=
literal|1
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|s1
operator|++
expr_stmt|;
name|nselector
operator|=
name|s1
expr_stmt|;
name|s2
operator|=
name|s1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|s2
argument_list|)
operator|||
operator|(
operator|*
name|s2
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|*
name|s2
operator|==
literal|':'
operator|)
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
expr_stmt|;
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|s2
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|s2
operator|==
literal|'\''
operator|)
condition|)
break|break;
else|else
return|return
name|NULL
return|;
name|s2
operator|++
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|s2
operator|++
expr_stmt|;
if|if
condition|(
name|found_quote
condition|)
block|{
if|if
condition|(
operator|*
name|s2
operator|==
literal|'\''
condition|)
name|s2
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|selector
operator|!=
name|NULL
condition|)
operator|*
name|selector
operator|=
name|nselector
expr_stmt|;
return|return
name|s2
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|parse_method
parameter_list|(
name|char
modifier|*
name|method
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|char
modifier|*
modifier|*
name|class
parameter_list|,
name|char
modifier|*
modifier|*
name|category
parameter_list|,
name|char
modifier|*
modifier|*
name|selector
parameter_list|)
block|{
name|char
modifier|*
name|s1
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
name|int
name|found_quote
init|=
literal|0
decl_stmt|;
name|char
name|ntype
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|nclass
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ncategory
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|nselector
init|=
name|NULL
decl_stmt|;
name|gdb_assert
argument_list|(
name|type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|class
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|category
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|selector
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s1
operator|=
name|method
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\''
condition|)
block|{
name|found_quote
operator|=
literal|1
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|s1
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|s1
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|ntype
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
literal|'['
condition|)
return|return
name|NULL
return|;
name|s1
operator|++
expr_stmt|;
name|nclass
operator|=
name|s1
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|s1
argument_list|)
operator|||
operator|(
operator|*
name|s1
operator|==
literal|'_'
operator|)
condition|)
name|s1
operator|++
expr_stmt|;
name|s2
operator|=
name|s1
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|s2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s2
operator|==
literal|'('
condition|)
block|{
name|s2
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|s2
operator|++
expr_stmt|;
name|ncategory
operator|=
name|s2
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|s2
argument_list|)
operator|||
operator|(
operator|*
name|s2
operator|==
literal|'_'
operator|)
condition|)
name|s2
operator|++
expr_stmt|;
operator|*
name|s2
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Truncate the class name now that we're not using the open paren.  */
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|nselector
operator|=
name|s2
expr_stmt|;
name|s1
operator|=
name|s2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|s2
argument_list|)
operator|||
operator|(
operator|*
name|s2
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|*
name|s2
operator|==
literal|':'
operator|)
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
expr_stmt|;
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s2
operator|==
literal|']'
condition|)
break|break;
else|else
return|return
name|NULL
return|;
name|s2
operator|++
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|s2
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|s2
operator|++
expr_stmt|;
if|if
condition|(
name|found_quote
condition|)
block|{
if|if
condition|(
operator|*
name|s2
operator|!=
literal|'\''
condition|)
return|return
name|NULL
return|;
name|s2
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
operator|*
name|type
operator|=
name|ntype
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|NULL
condition|)
operator|*
name|class
operator|=
name|nclass
expr_stmt|;
if|if
condition|(
name|category
operator|!=
name|NULL
condition|)
operator|*
name|category
operator|=
name|ncategory
expr_stmt|;
if|if
condition|(
name|selector
operator|!=
name|NULL
condition|)
operator|*
name|selector
operator|=
name|nselector
expr_stmt|;
return|return
name|s2
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_methods
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|char
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|category
parameter_list|,
specifier|const
name|char
modifier|*
name|selector
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|syms
parameter_list|,
name|unsigned
name|int
modifier|*
name|nsym
parameter_list|,
name|unsigned
name|int
modifier|*
name|ndebug
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|NULL
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
name|NULL
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|char
name|ntype
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|nclass
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ncategory
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|nselector
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|csym
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|cdebug
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|int
name|tmplen
init|=
literal|0
decl_stmt|;
name|gdb_assert
argument_list|(
name|nsym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|ndebug
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
condition|)
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|->
name|type
operator|!=
name|mst_text
operator|)
operator|&&
operator|(
name|msymbol
operator|->
name|type
operator|!=
name|mst_file_text
operator|)
condition|)
comment|/* Not a function or method.  */
continue|continue;
if|if
condition|(
name|symtab
condition|)
if|if
condition|(
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|)
operator|||
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|>=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|)
condition|)
comment|/* Not in the specified symtab.  */
continue|continue;
name|symname
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|symname
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
name|symname
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|)
operator|||
operator|(
name|symname
index|[
literal|1
index|]
operator|!=
literal|'['
operator|)
condition|)
comment|/* Not a method name.  */
continue|continue;
while|while
condition|(
operator|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|1
operator|)
operator|>=
name|tmplen
condition|)
block|{
name|tmplen
operator|=
operator|(
name|tmplen
operator|==
literal|0
operator|)
condition|?
literal|1024
else|:
name|tmplen
operator|*
literal|2
expr_stmt|;
name|tmp
operator|=
name|xrealloc
argument_list|(
name|tmp
argument_list|,
name|tmplen
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|symname
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_method
argument_list|(
name|tmp
argument_list|,
operator|&
name|ntype
argument_list|,
operator|&
name|nclass
argument_list|,
operator|&
name|ncategory
argument_list|,
operator|&
name|nselector
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|type
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|ntype
operator|!=
name|type
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|class
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|nclass
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|class
argument_list|,
name|nclass
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|category
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ncategory
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|category
argument_list|,
name|ncategory
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|selector
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|nselector
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|selector
argument_list|,
name|nselector
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
continue|continue;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|newsymname
init|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|symname
argument_list|,
name|newsymname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found a high-level method sym: swap it into the                  lower part of sym_arr (below num_debuggable).  */
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
block|{
name|syms
index|[
name|csym
index|]
operator|=
name|syms
index|[
name|cdebug
index|]
expr_stmt|;
name|syms
index|[
name|cdebug
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|csym
operator|++
expr_stmt|;
name|cdebug
operator|++
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"debugging symbol \"%s\" does not match minimal symbol (\"%s\"); ignoring"
argument_list|,
name|newsymname
argument_list|,
name|symname
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
name|syms
index|[
name|csym
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|msymbol
expr_stmt|;
name|csym
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Found a non-debuggable method symbol.  */
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
name|syms
index|[
name|csym
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|msymbol
expr_stmt|;
name|csym
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsym
operator|!=
name|NULL
condition|)
operator|*
name|nsym
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|ndebug
operator|!=
name|NULL
condition|)
operator|*
name|ndebug
operator|=
name|cdebug
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|find_imps
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|char
modifier|*
name|method
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|syms
parameter_list|,
name|unsigned
name|int
modifier|*
name|nsym
parameter_list|,
name|unsigned
name|int
modifier|*
name|ndebug
parameter_list|)
block|{
name|char
name|type
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|class
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|category
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|selector
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|csym
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|cdebug
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ncsym
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ncdebug
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|gdb_assert
argument_list|(
name|nsym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|ndebug
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsym
operator|!=
name|NULL
condition|)
operator|*
name|nsym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ndebug
operator|!=
name|NULL
condition|)
operator|*
name|ndebug
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|method
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|parse_method
argument_list|(
name|buf
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|category
argument_list|,
operator|&
name|selector
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
init|=
name|NULL
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|parse_selector
argument_list|(
name|buf
argument_list|,
operator|&
name|selector
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|selector
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|syms
condition|)
name|syms
index|[
name|csym
index|]
operator|=
name|sym
expr_stmt|;
name|csym
operator|++
expr_stmt|;
name|cdebug
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|selector
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|syms
condition|)
name|syms
index|[
name|csym
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|msym
expr_stmt|;
name|csym
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
name|find_methods
argument_list|(
name|symtab
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|category
argument_list|,
name|selector
argument_list|,
name|syms
operator|+
name|csym
argument_list|,
operator|&
name|ncsym
argument_list|,
operator|&
name|ncdebug
argument_list|)
expr_stmt|;
else|else
name|find_methods
argument_list|(
name|symtab
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|category
argument_list|,
name|selector
argument_list|,
name|NULL
argument_list|,
operator|&
name|ncsym
argument_list|,
operator|&
name|ncdebug
argument_list|)
expr_stmt|;
comment|/* If we didn't find any methods, just return.  */
if|if
condition|(
name|ncsym
operator|==
literal|0
operator|&&
name|ncdebug
operator|==
literal|0
condition|)
return|return
name|method
return|;
comment|/* Take debug symbols from the second batch of symbols and swap them    * with debug symbols from the first batch.  Repeat until either the    * second section is out of debug symbols or the first section is    * full of debug symbols.  Either way we have all debug symbols    * packed to the beginning of the buffer.      */
if|if
condition|(
name|syms
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|cdebug
operator|<
name|csym
operator|)
operator|&&
operator|(
name|ncdebug
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
comment|/* First non-debugging symbol.  */
name|unsigned
name|int
name|i
init|=
name|cdebug
decl_stmt|;
comment|/* Last of second batch of debug symbols.  */
name|unsigned
name|int
name|j
init|=
name|csym
operator|+
name|ncdebug
operator|-
literal|1
decl_stmt|;
name|s
operator|=
name|syms
index|[
name|j
index|]
expr_stmt|;
name|syms
index|[
name|j
index|]
operator|=
name|syms
index|[
name|i
index|]
expr_stmt|;
name|syms
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
comment|/* We've moved a symbol from the second debug section to the              first one.  */
name|cdebug
operator|++
expr_stmt|;
name|ncdebug
operator|--
expr_stmt|;
block|}
block|}
name|csym
operator|+=
name|ncsym
expr_stmt|;
name|cdebug
operator|+=
name|ncdebug
expr_stmt|;
if|if
condition|(
name|nsym
operator|!=
name|NULL
condition|)
operator|*
name|nsym
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|ndebug
operator|!=
name|NULL
condition|)
operator|*
name|ndebug
operator|=
name|cdebug
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
return|return
name|method
operator|+
operator|(
name|tmp
operator|-
name|buf
operator|)
return|;
if|if
condition|(
name|csym
operator|>
literal|1
condition|)
block|{
comment|/* Sort debuggable symbols.  */
if|if
condition|(
name|cdebug
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|syms
argument_list|,
name|cdebug
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
operator|*
argument_list|)
argument_list|,
name|compare_classes
argument_list|)
expr_stmt|;
comment|/* Sort minimal_symbols.  */
if|if
condition|(
operator|(
name|csym
operator|-
name|cdebug
operator|)
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|&
name|syms
index|[
name|cdebug
index|]
argument_list|,
name|csym
operator|-
name|cdebug
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
operator|*
argument_list|)
argument_list|,
name|compare_classes
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the sym_arr list.  */
name|syms
index|[
name|csym
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|method
operator|+
operator|(
name|tmp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_object_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|object
decl_stmt|,
modifier|*
name|function
decl_stmt|,
modifier|*
name|description
decl_stmt|;
name|CORE_ADDR
name|string_addr
decl_stmt|,
name|object_addr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|args
operator|||
operator|!
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"The 'print-object' command requires an argument (an Objective-C object)"
argument_list|)
expr_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|int
name|pc
init|=
literal|0
decl_stmt|;
name|object
operator|=
name|expr
operator|->
name|language_defn
operator|->
name|la_exp_desc
operator|->
name|evaluate_exp
argument_list|(
name|builtin_type_void_data_ptr
argument_list|,
name|expr
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_NORMAL
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
comment|/* Validate the address for sanity.  */
name|object_addr
operator|=
name|value_as_long
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|object_addr
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function
operator|=
name|find_function_in_inferior
argument_list|(
literal|"_NSPrintForDebugger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Unable to locate _NSPrintForDebugger in child process"
argument_list|)
expr_stmt|;
name|description
operator|=
name|call_function_by_hand
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
name|string_addr
operator|=
name|value_as_long
argument_list|(
name|description
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_addr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"object returns null description"
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|string_addr
operator|+
name|i
operator|++
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
do|do
block|{
comment|/* Read and print characters up to EOS.  */
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|string_addr
operator|+
name|i
operator|++
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
else|else
name|printf_filtered
argument_list|(
literal|"<object returns empty description>"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The data structure 'methcalls' is used to detect method calls (thru  * ObjC runtime lib functions objc_msgSend, objc_msgSendSuper, etc.),  * and ultimately find the method being called.   */
end_comment

begin_struct
struct|struct
name|objc_methcall
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Return instance method to be called.  */
name|int
function_decl|(
modifier|*
name|stop_at
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
comment|/* Start of pc range corresponding to method invocation.  */
name|CORE_ADDR
name|begin
decl_stmt|;
comment|/* End of pc range corresponding to method invocation.  */
name|CORE_ADDR
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|resolve_msgsend
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resolve_msgsend_stret
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resolve_msgsend_super
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resolve_msgsend_super_stret
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|objc_methcall
name|methcalls
index|[]
init|=
block|{
block|{
literal|"_objc_msgSend"
block|,
name|resolve_msgsend
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"_objc_msgSend_stret"
block|,
name|resolve_msgsend_stret
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"_objc_msgSendSuper"
block|,
name|resolve_msgsend_super
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"_objc_msgSendSuper_stret"
block|,
name|resolve_msgsend_super_stret
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"_objc_getClass"
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"_objc_getMetaClass"
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|nmethcalls
value|(sizeof (methcalls) / sizeof (methcalls[0]))
end_define

begin_comment
comment|/* The following function, "find_objc_msgsend", fills in the data  * structure "objc_msgs" by finding the addresses of each of the  * (currently four) functions that it holds (of which objc_msgSend is  * the first).  This must be called each time symbols are loaded, in  * case the functions have moved for some reason.    */
end_comment

begin_function
specifier|static
name|void
name|find_objc_msgsend
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmethcalls
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|func
decl_stmt|;
comment|/* Try both with and without underscore.  */
name|func
operator|=
name|lookup_minimal_symbol
argument_list|(
name|methcalls
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|func
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|methcalls
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
name|func
operator|=
name|lookup_minimal_symbol
argument_list|(
name|methcalls
index|[
name|i
index|]
operator|.
name|name
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|methcalls
index|[
name|i
index|]
operator|.
name|begin
operator|=
literal|0
expr_stmt|;
name|methcalls
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|methcalls
index|[
name|i
index|]
operator|.
name|begin
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|func
argument_list|)
expr_stmt|;
do|do
block|{
name|methcalls
index|[
name|i
index|]
operator|.
name|end
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|++
name|func
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|methcalls
index|[
name|i
index|]
operator|.
name|begin
operator|==
name|methcalls
index|[
name|i
index|]
operator|.
name|end
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* find_objc_msgcall (replaces pc_off_limits)  *  * ALL that this function now does is to determine whether the input  * address ("pc") is the address of one of the Objective-C message  * dispatch functions (mainly objc_msgSend or objc_msgSendSuper), and  * if so, it returns the address of the method that will be called.  *  * The old function "pc_off_limits" used to do a lot of other things  * in addition, such as detecting shared library jump stubs and  * returning the address of the shlib function that would be called.  * That functionality has been moved into the SKIP_TRAMPOLINE_CODE and  * IN_SOLIB_TRAMPOLINE macros, which are resolved in the target-  * dependent modules.    */
end_comment

begin_struct
struct|struct
name|objc_submethod_helper_data
block|{
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|new_pc
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|find_objc_msgcall_submethod_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|objc_submethod_helper_data
modifier|*
name|s
init|=
operator|(
expr|struct
name|objc_submethod_helper_data
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|f
argument_list|(
name|s
operator|->
name|pc
argument_list|,
name|s
operator|->
name|new_pc
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_objc_msgcall_submethod
parameter_list|(
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
block|{
name|struct
name|objc_submethod_helper_data
name|s
decl_stmt|;
name|s
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|s
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|s
operator|.
name|new_pc
operator|=
name|new_pc
expr_stmt|;
if|if
condition|(
name|catch_errors
argument_list|(
name|find_objc_msgcall_submethod_helper
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|,
literal|"Unable to determine target of Objective-C method call (ignoring):\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|find_objc_msgcall
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|find_objc_msgsend
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_pc
operator|!=
name|NULL
condition|)
block|{
operator|*
name|new_pc
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmethcalls
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pc
operator|>=
name|methcalls
index|[
name|i
index|]
operator|.
name|begin
operator|)
operator|&&
operator|(
name|pc
operator|<
name|methcalls
index|[
name|i
index|]
operator|.
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|methcalls
index|[
name|i
index|]
operator|.
name|stop_at
operator|!=
name|NULL
condition|)
return|return
name|find_objc_msgcall_submethod
argument_list|(
name|methcalls
index|[
name|i
index|]
operator|.
name|stop_at
argument_list|,
name|pc
argument_list|,
name|new_pc
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_objc_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_objc_language
parameter_list|(
name|void
parameter_list|)
block|{
name|add_language
argument_list|(
operator|&
name|objc_language_defn
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"selectors"
argument_list|,
name|selectors_info
argument_list|,
comment|/* INFO SELECTORS command.  */
literal|"All Objective-C selectors, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"classes"
argument_list|,
name|classes_info
argument_list|,
comment|/* INFO CLASSES   command.  */
literal|"All Objective-C classes, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"print-object"
argument_list|,
name|class_vars
argument_list|,
name|print_object_command
argument_list|,
literal|"Ask an Objective-C object to print itself."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"po"
argument_list|,
literal|"print-object"
argument_list|,
name|class_vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_objc_method
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|objc_method
modifier|*
name|method
parameter_list|)
block|{
name|method
operator|->
name|name
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|method
operator|->
name|types
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|method
operator|->
name|imp
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|read_objc_methlist_nmethods
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_objc_methlist_method
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|unsigned
name|long
name|num
parameter_list|,
name|struct
name|objc_method
modifier|*
name|method
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|num
operator|<
name|read_objc_methlist_nmethods
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|read_objc_method
argument_list|(
name|addr
operator|+
literal|8
operator|+
operator|(
literal|12
operator|*
name|num
operator|)
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_objc_object
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|objc_object
modifier|*
name|object
parameter_list|)
block|{
name|object
operator|->
name|isa
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_objc_super
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|objc_super
modifier|*
name|super
parameter_list|)
block|{
name|super
operator|->
name|receiver
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|super
operator|->
name|class
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|read_objc_class
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|objc_class
modifier|*
name|class
parameter_list|)
block|{
name|class
operator|->
name|isa
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|super_class
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|name
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|version
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|12
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|info
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|16
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|instance_size
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|18
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|ivars
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|24
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|methods
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|28
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|cache
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|class
operator|->
name|protocols
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|find_implementation_from_class
parameter_list|(
name|CORE_ADDR
name|class
parameter_list|,
name|CORE_ADDR
name|sel
parameter_list|)
block|{
name|CORE_ADDR
name|subclass
init|=
name|class
decl_stmt|;
while|while
condition|(
name|subclass
operator|!=
literal|0
condition|)
block|{
name|struct
name|objc_class
name|class_str
decl_stmt|;
name|unsigned
name|mlistnum
init|=
literal|0
decl_stmt|;
name|read_objc_class
argument_list|(
name|subclass
argument_list|,
operator|&
name|class_str
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CORE_ADDR
name|mlist
decl_stmt|;
name|unsigned
name|long
name|nmethods
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|mlist
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|class_str
operator|.
name|methods
operator|+
operator|(
literal|4
operator|*
name|mlistnum
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlist
operator|==
literal|0
condition|)
break|break;
name|nmethods
operator|=
name|read_objc_methlist_nmethods
argument_list|(
name|mlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmethods
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|objc_method
name|meth_str
decl_stmt|;
name|read_objc_methlist_method
argument_list|(
name|mlist
argument_list|,
name|i
argument_list|,
operator|&
name|meth_str
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr,  		       "checking method 0x%lx against selector 0x%lx\n",  		       meth_str.name, sel);
endif|#
directive|endif
if|if
condition|(
name|meth_str
operator|.
name|name
operator|==
name|sel
condition|)
comment|/* FIXME: hppa arch was doing a pointer dereference 		   here. There needs to be a better way to do that.  */
return|return
name|meth_str
operator|.
name|imp
return|;
block|}
name|mlistnum
operator|++
expr_stmt|;
block|}
name|subclass
operator|=
name|class_str
operator|.
name|super_class
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|find_implementation
parameter_list|(
name|CORE_ADDR
name|object
parameter_list|,
name|CORE_ADDR
name|sel
parameter_list|)
block|{
name|struct
name|objc_object
name|ostr
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|read_objc_object
argument_list|(
name|object
argument_list|,
operator|&
name|ostr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostr
operator|.
name|isa
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|find_implementation_from_class
argument_list|(
name|ostr
operator|.
name|isa
argument_list|,
name|sel
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OBJC_FETCH_POINTER_ARGUMENT
parameter_list|(
name|argi
parameter_list|)
define|\
value|FETCH_POINTER_ARGUMENT (get_current_frame (), argi, builtin_type_void_func_ptr)
end_define

begin_function
specifier|static
name|int
name|resolve_msgsend
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
block|{
name|CORE_ADDR
name|object
decl_stmt|;
name|CORE_ADDR
name|sel
decl_stmt|;
name|CORE_ADDR
name|res
decl_stmt|;
name|object
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sel
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|find_implementation
argument_list|(
name|object
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pc
operator|!=
literal|0
condition|)
operator|*
name|new_pc
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resolve_msgsend_stret
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
block|{
name|CORE_ADDR
name|object
decl_stmt|;
name|CORE_ADDR
name|sel
decl_stmt|;
name|CORE_ADDR
name|res
decl_stmt|;
name|object
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sel
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|res
operator|=
name|find_implementation
argument_list|(
name|object
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pc
operator|!=
literal|0
condition|)
operator|*
name|new_pc
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resolve_msgsend_super
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
block|{
name|struct
name|objc_super
name|sstr
decl_stmt|;
name|CORE_ADDR
name|super
decl_stmt|;
name|CORE_ADDR
name|sel
decl_stmt|;
name|CORE_ADDR
name|res
decl_stmt|;
name|super
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sel
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|read_objc_super
argument_list|(
name|super
argument_list|,
operator|&
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstr
operator|.
name|class
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|res
operator|=
name|find_implementation_from_class
argument_list|(
name|sstr
operator|.
name|class
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pc
operator|!=
literal|0
condition|)
operator|*
name|new_pc
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resolve_msgsend_super_stret
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|new_pc
parameter_list|)
block|{
name|struct
name|objc_super
name|sstr
decl_stmt|;
name|CORE_ADDR
name|super
decl_stmt|;
name|CORE_ADDR
name|sel
decl_stmt|;
name|CORE_ADDR
name|res
decl_stmt|;
name|super
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sel
operator|=
name|OBJC_FETCH_POINTER_ARGUMENT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|read_objc_super
argument_list|(
name|super
argument_list|,
operator|&
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstr
operator|.
name|class
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|res
operator|=
name|find_implementation_from_class
argument_list|(
name|sstr
operator|.
name|class
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pc
operator|!=
literal|0
condition|)
operator|*
name|new_pc
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

