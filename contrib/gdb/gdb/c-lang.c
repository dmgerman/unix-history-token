begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C language support routines for GDB, the GNU debugger.    Copyright 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|c_emit_char
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
name|stream
operator|,
name|int
name|quoter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific. */
end_comment

begin_function
specifier|static
name|void
name|c_emit_char
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|c_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputc_filtered
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_EMIT_CHAR
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fputc_filtered
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    LENGTH is -1 if the string is nul terminated.  Each character is WIDTH bytes    long.  Printing stops early if the number hits print_max; repeat counts are    printed as appropriate.  Print ellipses at the end if we had to stop before    printing LENGTH characters, or if FORCE_ELLIPSES.  */
end_comment

begin_function
name|void
name|c_printstr
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|width
parameter_list|,
name|force_ellipses
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|inspect_it
decl_stmt|;
specifier|extern
name|int
name|repeat_count_threshold
decl_stmt|;
specifier|extern
name|int
name|print_max
decl_stmt|;
comment|/* If the string was not truncated due to `set print elements', and      the last byte of it is a null, we don't print that, in traditional C      style.  */
if|if
condition|(
operator|!
name|force_ellipses
operator|&&
name|length
operator|>
literal|0
operator|&&
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
name|width
argument_list|,
name|width
argument_list|)
operator|==
literal|'\0'
condition|)
name|length
operator|--
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|unsigned
name|long
name|current_char
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|current_char
operator|=
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
name|i
operator|*
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
name|rep1
operator|*
name|width
argument_list|,
name|width
argument_list|)
operator|==
name|current_char
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|LA_PRINT_CHAR
argument_list|(
name|current_char
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|LA_EMIT_CHAR
argument_list|(
name|current_char
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fundamental C type using default reasonable for the current    target machine.     Some object/debugging file formats (DWARF version 1, COFF, etc) do not    define fundamental types such as "int" or "double".  Others (stabs or    DWARF version 2, etc) do define fundamental types.  For the formats which    don't provide fundamental types, gdb can create such types using this    function.     FIXME:  Some compilers distinguish explicitly signed integral types    (signed short, signed int, signed long) from "regular" integral types    (short, int, long) in the debugging information.  There is some dis-    agreement as to how useful this feature is.  In particular, gcc does    not support this.  Also, only some debugging formats allow the    distinction to be passed on to a debugger.  For now, we always just    use "short", "int", or "long" as the type name, for both the implicit    and explicitly signed types.  This also makes life easier for the    gdb test suite since we don't have to account for the differences    in output depending upon what the compiler and debugging format    support.  We will probably have to re-examine the issue when gdb    starts taking it's fundamental type information directly from the    debugging information supplied by the compiler.  fnf@cygnus.com */
end_comment

begin_function
name|struct
name|type
modifier|*
name|c_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this 	   language, create the equivalent of a C integer type with the 	   name "<?type?>".  When all the dust settles from the type 	   reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no C/C++ fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"bool"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_NOSIGN
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_TEMPLATE_ARG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_TEMPLATE_ARG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<template arg>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|op_print
name|c_op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"||"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"&&"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"|"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"=="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"!="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"%"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"!"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"~"
block|,
name|UNOP_COMPLEMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|UNOP_ADDR
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof "
block|,
name|UNOP_SIZEOF
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"++"
block|,
name|UNOP_PREINCREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
name|UNOP_PREDECREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
comment|/* C++  */
block|{
literal|"::"
block|,
name|BINOP_SCOPE
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
name|CONST_PTR
parameter_list|(
name|c_builtin_types
index|[]
parameter_list|)
init|=
block|{
operator|&
name|builtin_type_int
operator|,
function_decl|&builtin_type_long
operator|,
function_decl|&builtin_type_short
operator|,
function_decl|&builtin_type_char
operator|,
function_decl|&builtin_type_float
operator|,
function_decl|&builtin_type_double
operator|,
function_decl|&builtin_type_void
operator|,
function_decl|&builtin_type_long_long
operator|,
function_decl|&builtin_type_signed_char
operator|,
function_decl|&builtin_type_unsigned_char
operator|,
function_decl|&builtin_type_unsigned_short
operator|,
function_decl|&builtin_type_unsigned_int
operator|,
function_decl|&builtin_type_unsigned_long
operator|,
function_decl|&builtin_type_unsigned_long_long
operator|,
function_decl|&builtin_type_long_double
operator|,
function_decl|&builtin_type_complex
operator|,
function_decl|&builtin_type_double_complex
operator|,
function_decl|0
end_function_decl

begin_decl_stmt
unit|};
specifier|const
name|struct
name|language_defn
name|c_language_defn
init|=
block|{
literal|"c"
block|,
comment|/* Language name */
name|language_c
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|c_parse
block|,
name|c_error
block|,
name|evaluate_subexp_standard
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|cplus_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_long_long
block|,
operator|&
name|builtin_type_signed_char
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_long_long
block|,
operator|&
name|builtin_type_long_double
block|,
operator|&
name|builtin_type_complex
block|,
operator|&
name|builtin_type_double_complex
block|,
operator|&
name|builtin_type_bool
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|cplus_language_defn
init|=
block|{
literal|"c++"
block|,
comment|/* Language name */
name|language_cplus
block|,
name|cplus_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|c_parse
block|,
name|c_error
block|,
name|evaluate_subexp_standard
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|asm_language_defn
init|=
block|{
literal|"asm"
block|,
comment|/* Language name */
name|language_asm
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|c_parse
block|,
name|c_error
block|,
name|evaluate_subexp_standard
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_c_language
parameter_list|()
block|{
name|add_language
argument_list|(
operator|&
name|c_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|cplus_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|asm_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

