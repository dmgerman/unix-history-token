begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C language support routines for GDB, the GNU debugger.    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"macroscope.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"charset.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_c_language
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific. */
end_comment

begin_function
specifier|static
name|void
name|c_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|escape
decl_stmt|;
name|int
name|host_char
decl_stmt|;
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
name|escape
operator|=
name|c_target_char_has_backslash_escape
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape
condition|)
block|{
if|if
condition|(
name|quoter
operator|==
literal|'"'
operator|&&
name|strcmp
argument_list|(
name|escape
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
comment|/* Print nulls embedded in double quoted strings as \000 to 	   prevent ambiguity.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\000"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%s"
argument_list|,
name|escape
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_char_to_host
argument_list|(
name|c
argument_list|,
operator|&
name|host_char
argument_list|)
operator|&&
name|host_char_print_literally
argument_list|(
name|host_char
argument_list|)
condition|)
block|{
if|if
condition|(
name|host_char
operator|==
literal|'\\'
operator|||
name|host_char
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|host_char
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputc_filtered
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_EMIT_CHAR
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fputc_filtered
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    LENGTH is -1 if the string is nul terminated.  Each character is WIDTH bytes    long.  Printing stops early if the number hits print_max; repeat counts are    printed as appropriate.  Print ellipses at the end if we had to stop before    printing LENGTH characters, or if FORCE_ELLIPSES.  */
end_comment

begin_function
name|void
name|c_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
comment|/* If the string was not truncated due to `set print elements', and      the last byte of it is a null, we don't print that, in traditional C      style.  */
if|if
condition|(
operator|!
name|force_ellipses
operator|&&
name|length
operator|>
literal|0
operator|&&
operator|(
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
name|width
argument_list|,
name|width
argument_list|)
operator|==
literal|'\0'
operator|)
condition|)
name|length
operator|--
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining          to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|unsigned
name|long
name|current_char
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|current_char
operator|=
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
name|i
operator|*
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
name|rep1
operator|*
name|width
argument_list|,
name|width
argument_list|)
operator|==
name|current_char
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|LA_PRINT_CHAR
argument_list|(
name|current_char
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|LA_EMIT_CHAR
argument_list|(
name|current_char
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fundamental C type using default reasonable for the current    target machine.     Some object/debugging file formats (DWARF version 1, COFF, etc) do not    define fundamental types such as "int" or "double".  Others (stabs or    DWARF version 2, etc) do define fundamental types.  For the formats which    don't provide fundamental types, gdb can create such types using this    function.     FIXME:  Some compilers distinguish explicitly signed integral types    (signed short, signed int, signed long) from "regular" integral types    (short, int, long) in the debugging information.  There is some dis-    agreement as to how useful this feature is.  In particular, gcc does    not support this.  Also, only some debugging formats allow the    distinction to be passed on to a debugger.  For now, we always just    use "short", "int", or "long" as the type name, for both the implicit    and explicitly signed types.  This also makes life easier for the    gdb test suite since we don't have to account for the differences    in output depending upon what the compiler and debugging format    support.  We will probably have to re-examine the issue when gdb    starts taking it's fundamental type information directly from the    debugging information supplied by the compiler.  fnf@cygnus.com */
end_comment

begin_function
name|struct
name|type
modifier|*
name|c_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this          language, create the equivalent of a C integer type with the          name "<?type?>".  When all the dust settles from the type          reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no C/C++ fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"bool"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_NOSIGN
argument_list|,
literal|"char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex long double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_TEMPLATE_ARG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_TEMPLATE_ARG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<template arg>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Preprocessing and parsing C and C++ expressions.  */
end_comment

begin_comment
comment|/* When we find that lexptr (the global var defined in parse.c) is    pointing at a macro invocation, we expand the invocation, and call    scan_macro_expansion to save the old lexptr here and point lexptr    into the expanded text.  When we reach the end of that, we call    end_macro_expansion to pop back to the value we saved here.  The    macro expansion code promises to return only fully-expanded text,    so we don't need to "push" more than one level.     This is disgusting, of course.  It would be cleaner to do all macro    expansion beforehand, and then hand that to lexptr.  But we don't    really know where the expression ends.  Remember, in a command like       (gdb) break *ADDRESS if CONDITION     we evaluate ADDRESS in the scope of the current frame, but we    evaluate CONDITION in the scope of the breakpoint's location.  So    it's simply wrong to try to macro-expand the whole thing at once.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|macro_original_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|macro_expanded_text
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|scan_macro_expansion
parameter_list|(
name|char
modifier|*
name|expansion
parameter_list|)
block|{
comment|/* We'd better not be trying to push the stack twice.  */
name|gdb_assert
argument_list|(
operator|!
name|macro_original_text
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|macro_expanded_text
argument_list|)
expr_stmt|;
comment|/* Save the old lexptr value, so we can return to it when we're done      parsing the expanded text.  */
name|macro_original_text
operator|=
name|lexptr
expr_stmt|;
name|lexptr
operator|=
name|expansion
expr_stmt|;
comment|/* Save the expanded text, so we can free it when we're finished.  */
name|macro_expanded_text
operator|=
name|expansion
expr_stmt|;
block|}
end_function

begin_function
name|int
name|scanning_macro_expansion
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|macro_original_text
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|void
name|finished_macro_expansion
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There'd better be something to pop back to, and we better have      saved a pointer to the start of the expanded text.  */
name|gdb_assert
argument_list|(
name|macro_original_text
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|macro_expanded_text
argument_list|)
expr_stmt|;
comment|/* Pop back to the original text.  */
name|lexptr
operator|=
name|macro_original_text
expr_stmt|;
name|macro_original_text
operator|=
literal|0
expr_stmt|;
comment|/* Free the expanded text.  */
name|xfree
argument_list|(
name|macro_expanded_text
argument_list|)
expr_stmt|;
name|macro_expanded_text
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_macro_cleanup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|macro_original_text
condition|)
name|finished_macro_expansion
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We set these global variables before calling c_parse, to tell it    how it to find macro definitions for the expression at hand.  */
end_comment

begin_decl_stmt
name|macro_lookup_ftype
modifier|*
name|expression_macro_lookup_func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|expression_macro_lookup_baton
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|macro_definition
modifier|*
name|null_macro_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|c_preprocess_and_parse
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set up a lookup function for the macro expander.  */
name|struct
name|macro_scope
modifier|*
name|scope
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|expression_context_block
condition|)
name|scope
operator|=
name|sal_macro_scope
argument_list|(
name|find_pc_line
argument_list|(
name|expression_context_pc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|scope
operator|=
name|default_macro_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|scope
condition|)
block|{
name|expression_macro_lookup_func
operator|=
name|standard_macro_lookup
expr_stmt|;
name|expression_macro_lookup_baton
operator|=
operator|(
name|void
operator|*
operator|)
name|scope
expr_stmt|;
block|}
else|else
block|{
name|expression_macro_lookup_func
operator|=
name|null_macro_lookup
expr_stmt|;
name|expression_macro_lookup_baton
operator|=
literal|0
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
operator|!
name|macro_original_text
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|scan_macro_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|int
name|result
init|=
name|c_parse
argument_list|()
decl_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|op_print
name|c_op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"||"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"&&"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"|"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"=="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"!="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"%"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"!"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"~"
block|,
name|UNOP_COMPLEMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|UNOP_ADDR
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof "
block|,
name|UNOP_SIZEOF
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"++"
block|,
name|UNOP_PREINCREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
name|UNOP_PREDECREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|c_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_long_long
block|,
operator|&
name|builtin_type_signed_char
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_long_long
block|,
operator|&
name|builtin_type_long_double
block|,
operator|&
name|builtin_type_complex
block|,
operator|&
name|builtin_type_double_complex
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|c_language_defn
init|=
block|{
literal|"c"
block|,
comment|/* Language name */
name|language_c
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|c_preprocess_and_parse
block|,
name|c_error
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|NULL
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|NULL
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|cplus_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_long_long
block|,
operator|&
name|builtin_type_signed_char
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_long_long
block|,
operator|&
name|builtin_type_long_double
block|,
operator|&
name|builtin_type_complex
block|,
operator|&
name|builtin_type_double_complex
block|,
operator|&
name|builtin_type_bool
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|cplus_language_defn
init|=
block|{
literal|"c++"
block|,
comment|/* Language name */
name|language_cplus
block|,
name|cplus_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|c_preprocess_and_parse
block|,
name|c_error
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|cp_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|cp_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|cplus_demangle
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|asm_language_defn
init|=
block|{
literal|"asm"
block|,
comment|/* Language name */
name|language_asm
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|c_preprocess_and_parse
block|,
name|c_error
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|NULL
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|NULL
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following language_defn does not represent a real language.    It just provides a minimal support a-la-C that should allow users    to do some simple operations when debugging applications that use    a language currently not supported by GDB.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|minimal_language_defn
init|=
block|{
literal|"minimal"
block|,
comment|/* Language name */
name|language_minimal
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|c_preprocess_and_parse
block|,
name|c_error
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|c_emit_char
block|,
comment|/* Print a single char */
name|c_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|c_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|c_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|NULL
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|NULL
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|c_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_c_language
parameter_list|(
name|void
parameter_list|)
block|{
name|add_language
argument_list|(
operator|&
name|c_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|cplus_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|asm_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|minimal_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

