begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target glue for the SPARC Sparclet ROM monitor.     Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free    Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"srec.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for generic_load */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function_decl
specifier|extern
name|void
name|report_transfer_performance
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|time_t
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|sparclet_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sparclet_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This array of registers need to match the indexes used by GDB.    This exists because the various ROM monitors use different strings    than does GDB, and don't necessarily support all the registers    either. So, typing "info reg sp" becomes a "r30".  */
end_comment

begin_comment
comment|/*PSR 0x00000080  impl ver icc AW LE EE EC EF PIL S PS ET CWP  WIM    0x0  0x0 0x0  0  0  0  0  0 0x0 1  0  0 0x00 0x2    0000010    INS        LOCALS       OUTS      GLOBALS    0  0x00000000  0x00000000  0x00000000  0x00000000    1  0x00000000  0x00000000  0x00000000  0x00000000    2  0x00000000  0x00000000  0x00000000  0x00000000    3  0x00000000  0x00000000  0x00000000  0x00000000    4  0x00000000  0x00000000  0x00000000  0x00000000    5  0x00000000  0x00001000  0x00000000  0x00000000    6  0x00000000  0x00000000  0x123f0000  0x00000000    7  0x00000000  0x00000000  0x00000000  0x00000000    pc:  0x12010000 0x00000000    unimp    npc: 0x12010004 0x00001000    unimp     0x1000    tbr: 0x00000000    y:   0x00000000  */
end_comment

begin_comment
comment|/* these correspond to the offsets from tm-* files from config directories */
end_comment

begin_comment
comment|/* is wim part of psr?? */
end_comment

begin_comment
comment|/* monitor wants lower case */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sparclet_regnames
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"o6"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"i6"
block|,
literal|"i7"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* no FPU regs */
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* no CPSR, FPSR */
literal|"y"
block|,
literal|"psr"
block|,
literal|"wim"
block|,
literal|"tbr"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|""
block|,
literal|""
block|,
literal|"ccsr"
block|,
literal|"ccpr"
block|,
literal|"cccrcr"
block|,
literal|"ccor"
block|,
literal|"ccobr"
block|,
literal|"ccibr"
block|,
literal|"ccir"
block|,
literal|""
block|,
comment|/*       ASR15                 ASR19 (don't display them) */
literal|"asr1"
block|,
literal|""
block|,
literal|"asr17"
block|,
literal|"asr18"
block|,
literal|""
block|,
literal|"asr20"
block|,
literal|"asr21"
block|,
literal|"asr22"
block|,
comment|/*   "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",     "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15",    "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23",    "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31",    "apsr",  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: sparclet_supply_register    Just returns with no action.    This function is required, because parse_register_dump (monitor.c)    expects to be able to call it.  If we don't supply something, it will    call a null pointer and core-dump.  Since this function does not     actually do anything, GDB will request the registers individually.  */
end_comment

begin_function
specifier|static
name|void
name|sparclet_supply_register
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|,
name|int
name|regnamelen
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|vallen
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sparclet_load
parameter_list|(
name|struct
name|serial
modifier|*
name|desc
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|hashmark
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|load_offset
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
name|unsigned
name|long
name|data_count
init|=
literal|0
decl_stmt|;
comment|/* enable user to specify address for downloading as 2nd arg to load */
name|i
operator|=
name|sscanf
argument_list|(
name|file
argument_list|,
literal|"%*s 0x%lx"
argument_list|,
operator|&
name|load_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|file
init|;
operator|*
name|p
operator|!=
literal|'\000'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
name|load_offset
operator|=
literal|0
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|section_size
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
operator|+
name|load_offset
expr_stmt|;
name|section_size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|data_count
operator|+=
name|section_size
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4x .. 0x%4x  "
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
argument_list|,
name|vma
argument_list|,
name|vma
operator|+
name|section_size
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"load c r %x %x\r"
argument_list|,
name|vma
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
literal|"load: loading "
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
literal|"\r"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|section_size
condition|;
name|i
operator|+=
literal|2048
control|)
block|{
name|int
name|numbytes
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|numbytes
operator|=
name|min
argument_list|(
sizeof|sizeof
name|buf
argument_list|,
name|section_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buf
argument_list|,
name|i
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmark
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Per-packet (or S-record) loop */
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Loadable sections */
name|monitor_printf
argument_list|(
literal|"reg pc %x\r"
argument_list|,
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"reg npc %x\r"
argument_list|,
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"run\r"
argument_list|)
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmark
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
name|push_remote_target
argument_list|(
name|monitor_get_dev_name
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the monitor command strings. Since these are passed directly    through to a printf style function, we may include formatting    strings. We also need a CR or LF on the end.  */
end_comment

begin_comment
comment|/* need to pause the monitor for timing reasons, so slow it down */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sparclet_inits
index|[]
init|=
block|{
literal|"\n\r\r\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
name|sparclet_cmds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_sparclet_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|sparclet_cmds
operator|.
name|flags
operator|=
name|MO_CLR_BREAK_USES_ADDR
operator||
name|MO_HEX_PREFIX
operator||
name|MO_NO_ECHO_ON_OPEN
operator||
name|MO_NO_ECHO_ON_SETMEM
operator||
name|MO_RUN_FIRST_TIME
operator||
name|MO_GETMEM_READ_SINGLE
expr_stmt|;
comment|/* flags */
name|sparclet_cmds
operator|.
name|init
operator|=
name|sparclet_inits
expr_stmt|;
comment|/* Init strings */
name|sparclet_cmds
operator|.
name|cont
operator|=
literal|"cont\r"
expr_stmt|;
comment|/* continue command */
name|sparclet_cmds
operator|.
name|step
operator|=
literal|"step\r"
expr_stmt|;
comment|/* single step */
name|sparclet_cmds
operator|.
name|stop
operator|=
literal|"\r"
expr_stmt|;
comment|/* break interrupts the program */
name|sparclet_cmds
operator|.
name|set_break
operator|=
literal|"+bp %x\r"
expr_stmt|;
comment|/* set a breakpoint */
name|sparclet_cmds
operator|.
name|clr_break
operator|=
literal|"-bp %x\r"
expr_stmt|;
comment|/* can't use "br" because only 2 hw bps are supported */
name|sparclet_cmds
operator|.
name|clr_all_break
operator|=
literal|"-bp %x\r"
expr_stmt|;
comment|/* clear a breakpoint */
literal|"-bp\r"
expr_stmt|;
comment|/* clear all breakpoints */
name|sparclet_cmds
operator|.
name|fill
operator|=
literal|"fill %x -n %x -v %x -b\r"
expr_stmt|;
comment|/* fill (start length val) */
comment|/* can't use "fi" because it takes words, not bytes */
comment|/* ex [addr] [-n count] [-b|-s|-l]          default: ex cur -n 1 -b */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|cmdb
operator|=
literal|"ex %x -b\r%x\rq\r"
expr_stmt|;
comment|/* setmem.cmdb (addr, value) */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|cmdw
operator|=
literal|"ex %x -s\r%x\rq\r"
expr_stmt|;
comment|/* setmem.cmdw (addr, value) */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|cmdl
operator|=
literal|"ex %x -l\r%x\rq\r"
expr_stmt|;
comment|/* setmem.cmdl (addr, value) */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.cmdll (addr, value) */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/*": " */
comment|/* setmem.resp_delim */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/*"? " */
comment|/* setmem.term */
name|sparclet_cmds
operator|.
name|setmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/*"q\r" */
comment|/* setmem.term_cmd */
comment|/* since the parsing of multiple bytes is difficult due to      interspersed addresses, we'll only read 1 value at a time,      even tho these can handle a count */
comment|/* we can use -n to set count to read, but may have to parse? */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|cmdb
operator|=
literal|"ex %x -n 1 -b\r"
expr_stmt|;
comment|/* getmem.cmdb (addr, #bytes) */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|cmdw
operator|=
literal|"ex %x -n 1 -s\r"
expr_stmt|;
comment|/* getmem.cmdw (addr, #swords) */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|cmdl
operator|=
literal|"ex %x -n 1 -l\r"
expr_stmt|;
comment|/* getmem.cmdl (addr, #words) */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdll (addr, #dwords) */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|resp_delim
operator|=
literal|": "
expr_stmt|;
comment|/* getmem.resp_delim */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.term */
name|sparclet_cmds
operator|.
name|getmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.term_cmd */
name|sparclet_cmds
operator|.
name|setreg
operator|.
name|cmd
operator|=
literal|"reg %s 0x%x\r"
expr_stmt|;
comment|/* setreg.cmd (name, value) */
name|sparclet_cmds
operator|.
name|setreg
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.resp_delim */
name|sparclet_cmds
operator|.
name|setreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.term */
name|sparclet_cmds
operator|.
name|setreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.term_cmd */
name|sparclet_cmds
operator|.
name|getreg
operator|.
name|cmd
operator|=
literal|"reg %s\r"
expr_stmt|;
comment|/* getreg.cmd (name) */
name|sparclet_cmds
operator|.
name|getreg
operator|.
name|resp_delim
operator|=
literal|" "
expr_stmt|;
comment|/* getreg.resp_delim */
name|sparclet_cmds
operator|.
name|getreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.term */
name|sparclet_cmds
operator|.
name|getreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.term_cmd */
name|sparclet_cmds
operator|.
name|dump_registers
operator|=
literal|"reg\r"
expr_stmt|;
comment|/* dump_registers */
name|sparclet_cmds
operator|.
name|register_pattern
operator|=
literal|"\\(\\w+\\)=\\([0-9a-fA-F]+\\)"
expr_stmt|;
comment|/* register_pattern */
name|sparclet_cmds
operator|.
name|supply_register
operator|=
name|sparclet_supply_register
expr_stmt|;
comment|/* supply_register */
name|sparclet_cmds
operator|.
name|load_routine
operator|=
name|sparclet_load
expr_stmt|;
comment|/* load_routine */
name|sparclet_cmds
operator|.
name|load
operator|=
name|NULL
expr_stmt|;
comment|/* download command (srecs on console) */
name|sparclet_cmds
operator|.
name|loadresp
operator|=
name|NULL
expr_stmt|;
comment|/* load response */
name|sparclet_cmds
operator|.
name|prompt
operator|=
literal|"monitor>"
expr_stmt|;
comment|/* monitor command prompt */
comment|/* yikes!  gdb core dumps without this delimitor!! */
name|sparclet_cmds
operator|.
name|line_term
operator|=
literal|"\r"
expr_stmt|;
comment|/* end-of-command delimitor */
name|sparclet_cmds
operator|.
name|cmd_end
operator|=
name|NULL
expr_stmt|;
comment|/* optional command terminator */
name|sparclet_cmds
operator|.
name|target
operator|=
operator|&
name|sparclet_ops
expr_stmt|;
comment|/* target operations */
name|sparclet_cmds
operator|.
name|stopbits
operator|=
name|SERIAL_1_STOPBITS
expr_stmt|;
comment|/* number of stop bits */
name|sparclet_cmds
operator|.
name|regnames
operator|=
name|sparclet_regnames
expr_stmt|;
comment|/* registers names */
name|sparclet_cmds
operator|.
name|magic
operator|=
name|MONITOR_OPS_MAGIC
expr_stmt|;
comment|/* magic */
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|sparclet_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|monitor_open
argument_list|(
name|args
argument_list|,
operator|&
name|sparclet_cmds
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_sparclet
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|init_sparclet_cmds
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sparclet_regnames
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|sparclet_regnames
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
name|sparclet_regnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mon can't report c* or a* regs */
name|sparclet_regnames
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mon won't report %G0 */
name|init_monitor_ops
argument_list|(
operator|&
name|sparclet_ops
argument_list|)
expr_stmt|;
name|sparclet_ops
operator|.
name|to_shortname
operator|=
literal|"sparclet"
expr_stmt|;
comment|/* for the target command */
name|sparclet_ops
operator|.
name|to_longname
operator|=
literal|"SPARC Sparclet monitor"
expr_stmt|;
comment|/* use SW breaks; target only supports 2 HW breakpoints */
name|sparclet_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|sparclet_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|sparclet_ops
operator|.
name|to_doc
operator|=
literal|"Use a board running the Sparclet debug monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|sparclet_ops
operator|.
name|to_open
operator|=
name|sparclet_open
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|sparclet_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

