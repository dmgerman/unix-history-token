begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for DINK32 (PowerPC) ROM monitor for    GDB, the GNU debugger.    Copyright 1997 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|dink32_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dink32_supply_register
parameter_list|(
name|regname
parameter_list|,
name|regnamelen
parameter_list|,
name|val
parameter_list|,
name|vallen
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
name|int
name|regnamelen
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|vallen
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|,
name|base
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regnamelen
operator|<
literal|2
operator|||
name|regnamelen
operator|>
literal|4
condition|)
return|return;
switch|switch
condition|(
name|regname
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'R'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|regname
index|[
literal|1
index|]
operator|>
literal|'9'
condition|)
return|return;
if|if
condition|(
name|regnamelen
operator|==
literal|2
condition|)
name|regno
operator|=
name|regname
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|regnamelen
operator|==
literal|3
operator|&&
name|regname
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|regname
index|[
literal|2
index|]
operator|<=
literal|'9'
condition|)
name|regno
operator|=
operator|(
name|regname
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|regname
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
return|return;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|!=
literal|'R'
operator|||
name|regname
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|regname
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return;
if|if
condition|(
name|regnamelen
operator|==
literal|3
condition|)
name|regno
operator|=
literal|32
operator|+
name|regname
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|regnamelen
operator|==
literal|4
operator|&&
name|regname
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|regname
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
name|regno
operator|=
literal|32
operator|+
operator|(
name|regname
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|regname
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
return|return;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|regnamelen
operator|!=
literal|2
operator|||
name|regname
index|[
literal|1
index|]
operator|!=
literal|'P'
condition|)
return|return;
name|regno
operator|=
literal|64
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|regnamelen
operator|!=
literal|3
operator|||
name|regname
index|[
literal|1
index|]
operator|!=
literal|'S'
operator|||
name|regname
index|[
literal|2
index|]
operator|!=
literal|'R'
condition|)
return|return;
name|regno
operator|=
literal|65
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|regnamelen
operator|!=
literal|2
operator|||
name|regname
index|[
literal|1
index|]
operator|!=
literal|'R'
condition|)
return|return;
name|regno
operator|=
literal|66
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|regnamelen
operator|!=
literal|4
operator|||
name|regname
index|[
literal|1
index|]
operator|!=
literal|'P'
operator|||
name|regname
index|[
literal|2
index|]
operator|!=
literal|'R'
condition|)
return|return;
elseif|else
if|if
condition|(
name|regname
index|[
literal|3
index|]
operator|==
literal|'8'
condition|)
name|regno
operator|=
literal|67
expr_stmt|;
elseif|else
if|if
condition|(
name|regname
index|[
literal|3
index|]
operator|==
literal|'9'
condition|)
name|regno
operator|=
literal|68
expr_stmt|;
elseif|else
if|if
condition|(
name|regname
index|[
literal|3
index|]
operator|==
literal|'1'
condition|)
name|regno
operator|=
literal|69
expr_stmt|;
elseif|else
if|if
condition|(
name|regname
index|[
literal|3
index|]
operator|==
literal|'0'
condition|)
name|regno
operator|=
literal|70
expr_stmt|;
else|else
return|return;
break|break;
default|default:
return|return;
block|}
name|monitor_supply_register
argument_list|(
name|regno
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dink32_load
parameter_list|(
name|monops
parameter_list|,
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|struct
name|monitor_ops
modifier|*
name|monops
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|generic_load
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No process now */
block|}
end_function

begin_comment
comment|/* This array of registers needs to match the indexes used by GDB. The    whole reason this exists is because the various ROM monitors use    different names than GDB does, and don't support all the registers    either.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dink32_regnames
index|[
name|NUM_REGS
index|]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"srr0"
block|,
literal|"msr"
block|,
literal|"cr"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"xer"
block|,
literal|"xer"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|dink32_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dink32_inits
index|[]
init|=
block|{
literal|"\r"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
name|dink32_cmds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dink32_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|monitor_open
argument_list|(
name|args
argument_list|,
operator|&
name|dink32_cmds
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_dink32_rom
parameter_list|()
block|{
name|dink32_cmds
operator|.
name|flags
operator|=
name|MO_HEX_PREFIX
operator||
name|MO_GETMEM_NEEDS_RANGE
operator||
name|MO_FILL_USES_ADDR
operator||
name|MO_HANDLE_NL
operator||
name|MO_32_REGS_PAIRED
operator||
name|MO_SETREG_INTERACTIVE
operator||
name|MO_SETMEM_INTERACTIVE
operator||
name|MO_GETMEM_16_BOUNDARY
operator||
name|MO_CLR_BREAK_1_BASED
operator||
name|MO_SREC_ACK
operator||
name|MO_SREC_ACK_ROTATE
expr_stmt|;
name|dink32_cmds
operator|.
name|init
operator|=
name|dink32_inits
expr_stmt|;
name|dink32_cmds
operator|.
name|cont
operator|=
literal|"go +\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|step
operator|=
literal|"tr +\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|set_break
operator|=
literal|"bp 0x%x\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|clr_break
operator|=
literal|"bp %d\r"
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Would need to follow strict alignment rules.. */
block|dink32_cmds.fill = "mf %x %x %x\r";
endif|#
directive|endif
name|dink32_cmds
operator|.
name|setmem
operator|.
name|cmdb
operator|=
literal|"mm -b %x\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|setmem
operator|.
name|cmdw
operator|=
literal|"mm -w %x\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|setmem
operator|.
name|cmdl
operator|=
literal|"mm %x\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|setmem
operator|.
name|term
operator|=
literal|" ?  "
expr_stmt|;
name|dink32_cmds
operator|.
name|getmem
operator|.
name|cmdb
operator|=
literal|"md %x\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|getmem
operator|.
name|resp_delim
operator|=
literal|"        "
expr_stmt|;
name|dink32_cmds
operator|.
name|setreg
operator|.
name|cmd
operator|=
literal|"rm %s\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|setreg
operator|.
name|term
operator|=
literal|" ?  "
expr_stmt|;
name|dink32_cmds
operator|.
name|getreg
operator|.
name|cmd
operator|=
literal|"rd %s\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|getreg
operator|.
name|resp_delim
operator|=
literal|": "
expr_stmt|;
name|dink32_cmds
operator|.
name|dump_registers
operator|=
literal|"rd r\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|register_pattern
operator|=
literal|"\\(\\w+\\) +=\\([0-9a-fA-F]+\\b\\)"
expr_stmt|;
name|dink32_cmds
operator|.
name|supply_register
operator|=
name|dink32_supply_register
expr_stmt|;
comment|/* S-record download, via "keyboard port".  */
name|dink32_cmds
operator|.
name|load
operator|=
literal|"dl -k\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|loadresp
operator|=
literal|"Set Input Port : set to Keyboard Port\r"
expr_stmt|;
if|#
directive|if
literal|0
comment|/* slow load routine not needed if S-records work... */
block|dink32_cmds.load_routine = dink32_load;
endif|#
directive|endif
name|dink32_cmds
operator|.
name|prompt
operator|=
literal|"DINK32_603>>"
expr_stmt|;
name|dink32_cmds
operator|.
name|line_term
operator|=
literal|"\r"
expr_stmt|;
name|dink32_cmds
operator|.
name|target
operator|=
operator|&
name|dink32_ops
expr_stmt|;
name|dink32_cmds
operator|.
name|stopbits
operator|=
name|SERIAL_1_STOPBITS
expr_stmt|;
name|dink32_cmds
operator|.
name|regnames
operator|=
name|dink32_regnames
expr_stmt|;
name|dink32_cmds
operator|.
name|magic
operator|=
name|MONITOR_OPS_MAGIC
expr_stmt|;
name|init_monitor_ops
argument_list|(
operator|&
name|dink32_ops
argument_list|)
expr_stmt|;
name|dink32_ops
operator|.
name|to_shortname
operator|=
literal|"dink32"
expr_stmt|;
name|dink32_ops
operator|.
name|to_longname
operator|=
literal|"DINK32 monitor"
expr_stmt|;
name|dink32_ops
operator|.
name|to_doc
operator|=
literal|"Debug using the DINK32 monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|dink32_ops
operator|.
name|to_open
operator|=
name|dink32_open
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|dink32_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

