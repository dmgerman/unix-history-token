begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Shared library support for RS/6000 (xcoff) object files, for GDB.    Copyright 1991, 1992 Free Software Foundation.    Contributed by IBM Corporation.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"xcoffsolib.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_SYMBOLS_MANUAL
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|symtab
modifier|*
name|current_source_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_source_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The real work of adding a shared library file to the symtab and    the section list.  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
init|=
name|vmap
decl_stmt|;
name|struct
name|objfile
modifier|*
name|obj
decl_stmt|;
name|struct
name|symtab
modifier|*
name|saved_symtab
decl_stmt|;
name|int
name|saved_line
decl_stmt|;
name|int
name|loaded
init|=
literal|0
decl_stmt|;
comment|/* true if any shared obj loaded */
name|int
name|matched
init|=
literal|0
decl_stmt|;
comment|/* true if any shared obj matched */
if|if
condition|(
name|arg_string
operator|==
literal|0
condition|)
name|re_comp
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|arg_string
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vp
operator|||
operator|!
name|vp
operator|->
name|nxt
condition|)
return|return;
comment|/* save current symbol table and line number, in case they get changed      in symbol loading process. */
name|saved_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|saved_line
operator|=
name|current_source_line
expr_stmt|;
comment|/* skip over the first vmap, it is the main program, always loaded. */
name|vp
operator|=
name|vp
operator|->
name|nxt
expr_stmt|;
for|for
control|(
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
block|{
if|if
condition|(
name|re_exec
argument_list|(
name|vp
operator|->
name|name
argument_list|)
operator|||
operator|(
operator|*
name|vp
operator|->
name|member
operator|&&
name|re_exec
argument_list|(
name|vp
operator|->
name|member
argument_list|)
operator|)
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* if already loaded, continue with the next one. */
if|if
condition|(
name|vp
operator|->
name|loaded
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%s%s%s%s: already loaded.\n"
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|"("
else|:
literal|""
argument_list|,
name|vp
operator|->
name|member
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|") "
else|:
literal|""
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf_unfiltered
argument_list|(
literal|"Loading  %s%s%s%s..."
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|"("
else|:
literal|""
argument_list|,
name|vp
operator|->
name|member
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|") "
else|:
literal|""
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* This is gross and doesn't work.  If this code is re-enabled, 	 just stick a objfile member into the struct vmap; that's the 	 way solib.c (for SunOS/SVR4) does it.  */
name|obj
operator|=
name|lookup_objfile_bfd
argument_list|(
name|vp
operator|->
name|bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|warning
argument_list|(
literal|"\nObj structure for the shared object not found. Loading failed."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|syms_from_objfile
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_symfile_objfile
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmap_symtab
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|loaded
operator|=
name|vp
operator|->
name|loaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* if any shared object is loaded, then misc_func_vector needs sorting. */
if|if
condition|(
name|loaded
condition|)
block|{
if|#
directive|if
literal|0
block|sort_misc_function_vector ();
endif|#
directive|endif
name|current_source_symtab
operator|=
name|saved_symtab
expr_stmt|;
name|current_source_line
operator|=
name|saved_line
expr_stmt|;
comment|/* Getting new symbols might change our opinion about what is frameless.        Is this correct?? FIXME. */
comment|/*    reinit_frame_cache(); */
block|}
elseif|else
if|if
condition|(
operator|!
name|matched
condition|)
name|printf_unfiltered
argument_list|(
literal|"No matching shared object found.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_SYMBOLS_MANUAL */
end_comment

begin_comment
comment|/* Return the module name of a given text address. Note that returned buffer    is not persistent. */
end_comment

begin_function
name|char
modifier|*
name|pc_load_segment_name
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
init|=
name|vmap
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
if|if
condition|(
name|vp
operator|->
name|tstart
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|vp
operator|->
name|tend
condition|)
block|{
if|if
condition|(
operator|*
name|vp
operator|->
name|member
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|strcat
argument_list|(
operator|&
name|buffer
index|[
literal|1
index|]
argument_list|,
name|vp
operator|->
name|member
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buffer
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
return|return
literal|"(unknown load module)"
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|solib_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|solib_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|vmap
modifier|*
name|vp
init|=
name|vmap
decl_stmt|;
comment|/* Check for new shared libraries loaded with load ().  */
name|xcoff_relocate_symtab
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|nxt
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip over the first vmap, it is the main program, always loaded.  */
name|vp
operator|=
name|vp
operator|->
name|nxt
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\ Text Range		Data Range		Syms	Shared Object Library\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|vp
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
block|{
name|printf_unfiltered
argument_list|(
literal|"0x%08x-0x%08x	0x%08x-0x%08x	%s	%s%s%s%s\n"
argument_list|,
name|vp
operator|->
name|tstart
argument_list|,
name|vp
operator|->
name|tend
argument_list|,
name|vp
operator|->
name|dstart
argument_list|,
name|vp
operator|->
name|dend
argument_list|,
name|vp
operator|->
name|loaded
condition|?
literal|"Yes"
else|:
literal|"No "
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|"("
else|:
literal|""
argument_list|,
name|vp
operator|->
name|member
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|") "
else|:
literal|""
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Check for new shared libraries loaded with load ().  */
name|xcoff_relocate_symtab
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_SYMBOLS_MANUAL
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SOLIB_SYMBOLS_MANUAL */
block|}
end_function

begin_function
name|void
name|_initialize_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|solib_info
argument_list|,
literal|"Status of loaded shared object libraries"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

