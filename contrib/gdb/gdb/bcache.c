begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implement a cached obstack.    Written by Fred Fish<fnf@cygnus.com>    Rewritten by Jim Blandy<jimb@cygnus.com>     Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"bcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* For memcpy declaration */
end_comment

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* The type used to hold a single bcache string.  The user data is    stored in d.data.  Since it can be any type, it needs to have the    same alignment as the most strict alignment of any type on the host    machine.  I don't know of any really correct way to do this in    stock ANSI C, so just do it the same way obstack.h does.  */
end_comment

begin_struct
struct|struct
name|bstring
block|{
comment|/* Hash chain.  */
name|struct
name|bstring
modifier|*
name|next
decl_stmt|;
comment|/* Assume the data length is no more than 64k.  */
name|unsigned
name|short
name|length
decl_stmt|;
comment|/* The half hash hack.  This contains the upper 16 bits of the hash      value and is used as a pre-check when comparing two strings and      avoids the need to do length or memcmp calls.  It proves to be      roughly 100% effective.  */
name|unsigned
name|short
name|half_hash
decl_stmt|;
union|union
block|{
name|char
name|data
index|[
literal|1
index|]
decl_stmt|;
name|double
name|dummy
decl_stmt|;
block|}
name|d
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The structure for a bcache itself.  The bcache is initialized, in    bcache_xmalloc(), by filling it with zeros and then setting the    corresponding obstack's malloc() and free() methods.  */
end_comment

begin_struct
struct|struct
name|bcache
block|{
comment|/* All the bstrings are allocated here.  */
name|struct
name|obstack
name|cache
decl_stmt|;
comment|/* How many hash buckets we're using.  */
name|unsigned
name|int
name|num_buckets
decl_stmt|;
comment|/* Hash buckets.  This table is allocated using malloc, so when we      grow the table we can return the old table to the system.  */
name|struct
name|bstring
modifier|*
modifier|*
name|bucket
decl_stmt|;
comment|/* Statistics.  */
name|unsigned
name|long
name|unique_count
decl_stmt|;
comment|/* number of unique strings */
name|long
name|total_count
decl_stmt|;
comment|/* total number of strings cached, including dups */
name|long
name|unique_size
decl_stmt|;
comment|/* size of unique strings, in bytes */
name|long
name|total_size
decl_stmt|;
comment|/* total number of bytes cached, including dups */
name|long
name|structure_size
decl_stmt|;
comment|/* total size of bcache, including infrastructure */
comment|/* Number of times that the hash table is expanded and hence      re-built, and the corresponding number of times that a string is      [re]hashed as part of entering it into the expanded table.  The      total number of hashes can be computed by adding TOTAL_COUNT to      expand_hash_count.  */
name|unsigned
name|long
name|expand_count
decl_stmt|;
name|unsigned
name|long
name|expand_hash_count
decl_stmt|;
comment|/* Number of times that the half-hash compare hit (compare the upper      16 bits of hash values) hit, but the corresponding combined      length/data compare missed.  */
name|unsigned
name|long
name|half_hash_miss_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The old hash function was stolen from SDBM. This is what DB 3.0 uses now,  * and is better than the old one.   */
end_comment

begin_escape
end_escape

begin_function
name|unsigned
name|long
name|hash
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|k
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|unsigned
name|long
name|h
decl_stmt|;
name|k
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|e
operator|=
name|k
operator|+
name|length
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|k
operator|<
name|e
condition|;
operator|++
name|k
control|)
block|{
name|h
operator|*=
literal|16777619
expr_stmt|;
name|h
operator|^=
operator|*
name|k
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Growing the bcache's hash table.  */
end_comment

begin_comment
comment|/* If the average chain length grows beyond this, then we want to    resize our hash table.  */
end_comment

begin_define
define|#
directive|define
name|CHAIN_LENGTH_THRESHOLD
value|(5)
end_define

begin_function
specifier|static
name|void
name|expand_hash_table
parameter_list|(
name|struct
name|bcache
modifier|*
name|bcache
parameter_list|)
block|{
comment|/* A table of good hash table sizes.  Whenever we grow, we pick the      next larger size from this table.  sizes[i] is close to 1<< (i+10),      so we roughly double the table size each time.  After we fall off       the end of this table, we just double.  Don't laugh --- there have      been executables sighted with a gigabyte of debug info.  */
specifier|static
name|unsigned
name|long
name|sizes
index|[]
init|=
block|{
literal|1021
block|,
literal|2053
block|,
literal|4099
block|,
literal|8191
block|,
literal|16381
block|,
literal|32771
block|,
literal|65537
block|,
literal|131071
block|,
literal|262144
block|,
literal|524287
block|,
literal|1048573
block|,
literal|2097143
block|,
literal|4194301
block|,
literal|8388617
block|,
literal|16777213
block|,
literal|33554467
block|,
literal|67108859
block|,
literal|134217757
block|,
literal|268435459
block|,
literal|536870923
block|,
literal|1073741827
block|,
literal|2147483659UL
block|}
decl_stmt|;
name|unsigned
name|int
name|new_num_buckets
decl_stmt|;
name|struct
name|bstring
modifier|*
modifier|*
name|new_buckets
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Count the stats.  Every unique item needs to be re-hashed and      re-entered.  */
name|bcache
operator|->
name|expand_count
operator|++
expr_stmt|;
name|bcache
operator|->
name|expand_hash_count
operator|+=
name|bcache
operator|->
name|unique_count
expr_stmt|;
comment|/* Find the next size.  */
name|new_num_buckets
operator|=
name|bcache
operator|->
name|num_buckets
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sizes
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sizes
index|[
name|i
index|]
operator|>
name|bcache
operator|->
name|num_buckets
condition|)
block|{
name|new_num_buckets
operator|=
name|sizes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
comment|/* Allocate the new table.  */
block|{
name|size_t
name|new_size
init|=
name|new_num_buckets
operator|*
sizeof|sizeof
argument_list|(
name|new_buckets
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|new_buckets
operator|=
operator|(
expr|struct
name|bstring
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_buckets
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|bcache
operator|->
name|structure_size
operator|-=
operator|(
name|bcache
operator|->
name|num_buckets
operator|*
sizeof|sizeof
argument_list|(
name|bcache
operator|->
name|bucket
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
name|bcache
operator|->
name|structure_size
operator|+=
name|new_size
expr_stmt|;
block|}
comment|/* Rehash all existing strings.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bcache
operator|->
name|num_buckets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bstring
modifier|*
name|s
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|s
operator|=
name|bcache
operator|->
name|bucket
index|[
name|i
index|]
init|;
name|s
condition|;
name|s
operator|=
name|next
control|)
block|{
name|struct
name|bstring
modifier|*
modifier|*
name|new_bucket
decl_stmt|;
name|next
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|new_bucket
operator|=
operator|&
name|new_buckets
index|[
operator|(
name|hash
argument_list|(
operator|&
name|s
operator|->
name|d
operator|.
name|data
argument_list|,
name|s
operator|->
name|length
argument_list|)
operator|%
name|new_num_buckets
operator|)
index|]
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|*
name|new_bucket
expr_stmt|;
operator|*
name|new_bucket
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/* Plug in the new table.  */
if|if
condition|(
name|bcache
operator|->
name|bucket
condition|)
name|xfree
argument_list|(
name|bcache
operator|->
name|bucket
argument_list|)
expr_stmt|;
name|bcache
operator|->
name|bucket
operator|=
name|new_buckets
expr_stmt|;
name|bcache
operator|->
name|num_buckets
operator|=
name|new_num_buckets
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Looking up things in the bcache.  */
end_comment

begin_comment
comment|/* The number of bytes needed to allocate a struct bstring whose data    is N bytes long.  */
end_comment

begin_define
define|#
directive|define
name|BSTRING_SIZE
parameter_list|(
name|n
parameter_list|)
value|(offsetof (struct bstring, d.data) + (n))
end_define

begin_comment
comment|/* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has    never seen those bytes before, add a copy of them to BCACHE.  In    either case, return a pointer to BCACHE's copy of that string.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|bcache_data
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|bcache
modifier|*
name|bcache
parameter_list|)
block|{
name|unsigned
name|long
name|full_hash
decl_stmt|;
name|unsigned
name|short
name|half_hash
decl_stmt|;
name|int
name|hash_index
decl_stmt|;
name|struct
name|bstring
modifier|*
name|s
decl_stmt|;
comment|/* If our average chain length is too high, expand the hash table.  */
if|if
condition|(
name|bcache
operator|->
name|unique_count
operator|>=
name|bcache
operator|->
name|num_buckets
operator|*
name|CHAIN_LENGTH_THRESHOLD
condition|)
name|expand_hash_table
argument_list|(
name|bcache
argument_list|)
expr_stmt|;
name|bcache
operator|->
name|total_count
operator|++
expr_stmt|;
name|bcache
operator|->
name|total_size
operator|+=
name|length
expr_stmt|;
name|full_hash
operator|=
name|hash
argument_list|(
name|addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|half_hash
operator|=
operator|(
name|full_hash
operator|>>
literal|16
operator|)
expr_stmt|;
name|hash_index
operator|=
name|full_hash
operator|%
name|bcache
operator|->
name|num_buckets
expr_stmt|;
comment|/* Search the hash bucket for a string identical to the caller's.      As a short-circuit first compare the upper part of each hash      values.  */
for|for
control|(
name|s
operator|=
name|bcache
operator|->
name|bucket
index|[
name|hash_index
index|]
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|half_hash
operator|==
name|half_hash
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|length
operator|==
name|length
operator|&&
operator|!
name|memcmp
argument_list|(
operator|&
name|s
operator|->
name|d
operator|.
name|data
argument_list|,
name|addr
argument_list|,
name|length
argument_list|)
condition|)
return|return
operator|&
name|s
operator|->
name|d
operator|.
name|data
return|;
else|else
name|bcache
operator|->
name|half_hash_miss_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* The user's string isn't in the list.  Insert it after *ps.  */
block|{
name|struct
name|bstring
modifier|*
name|new
init|=
name|obstack_alloc
argument_list|(
operator|&
name|bcache
operator|->
name|cache
argument_list|,
name|BSTRING_SIZE
argument_list|(
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|new
operator|->
name|d
operator|.
name|data
argument_list|,
name|addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|new
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|bcache
operator|->
name|bucket
index|[
name|hash_index
index|]
expr_stmt|;
name|new
operator|->
name|half_hash
operator|=
name|half_hash
expr_stmt|;
name|bcache
operator|->
name|bucket
index|[
name|hash_index
index|]
operator|=
name|new
expr_stmt|;
name|bcache
operator|->
name|unique_count
operator|++
expr_stmt|;
name|bcache
operator|->
name|unique_size
operator|+=
name|length
expr_stmt|;
name|bcache
operator|->
name|structure_size
operator|+=
name|BSTRING_SIZE
argument_list|(
name|length
argument_list|)
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|d
operator|.
name|data
return|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|deprecated_bcache
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|bcache
modifier|*
name|bcache
parameter_list|)
block|{
return|return
name|bcache_data
argument_list|(
name|addr
argument_list|,
name|length
argument_list|,
name|bcache
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|void
modifier|*
name|bcache
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|bcache
modifier|*
name|bcache
parameter_list|)
block|{
return|return
name|bcache_data
argument_list|(
name|addr
argument_list|,
name|length
argument_list|,
name|bcache
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocating and freeing bcaches.  */
end_comment

begin_function
name|struct
name|bcache
modifier|*
name|bcache_xmalloc
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Allocate the bcache pre-zeroed.  */
name|struct
name|bcache
modifier|*
name|b
init|=
name|XCALLOC
argument_list|(
literal|1
argument_list|,
expr|struct
name|bcache
argument_list|)
decl_stmt|;
comment|/* We could use obstack_specify_allocation here instead, but      gdb_obstack.h specifies the allocation/deallocation      functions.  */
name|obstack_init
argument_list|(
operator|&
name|b
operator|->
name|cache
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Free all the storage associated with BCACHE.  */
end_comment

begin_function
name|void
name|bcache_xfree
parameter_list|(
name|struct
name|bcache
modifier|*
name|bcache
parameter_list|)
block|{
if|if
condition|(
name|bcache
operator|==
name|NULL
condition|)
return|return;
name|obstack_free
argument_list|(
operator|&
name|bcache
operator|->
name|cache
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|bcache
operator|->
name|bucket
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|bcache
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Printing statistics.  */
end_comment

begin_function
specifier|static
name|int
name|compare_ints
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
comment|/* Because we know we're comparing two ints which are positive,      there's no danger of overflow here.  */
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|ap
operator|-
operator|*
operator|(
name|int
operator|*
operator|)
name|bp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_percentage
parameter_list|(
name|int
name|portion
parameter_list|,
name|int
name|total
parameter_list|)
block|{
if|if
condition|(
name|total
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"(not applicable)\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%3d%%\n"
argument_list|,
name|portion
operator|*
literal|100
operator|/
name|total
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print statistics on BCACHE's memory usage and efficacity at    eliminating duplication.  NAME should describe the kind of data    BCACHE holds.  Statistics are printed using `printf_filtered' and    its ilk.  */
end_comment

begin_function
name|void
name|print_bcache_statistics
parameter_list|(
name|struct
name|bcache
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|occupied_buckets
decl_stmt|;
name|int
name|max_chain_length
decl_stmt|;
name|int
name|median_chain_length
decl_stmt|;
name|int
name|max_entry_size
decl_stmt|;
name|int
name|median_entry_size
decl_stmt|;
comment|/* Count the number of occupied buckets, tally the various string      lengths, and measure chain lengths.  */
block|{
name|unsigned
name|int
name|b
decl_stmt|;
name|int
modifier|*
name|chain_length
init|=
name|XCALLOC
argument_list|(
name|c
operator|->
name|num_buckets
operator|+
literal|1
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|int
modifier|*
name|entry_size
init|=
name|XCALLOC
argument_list|(
name|c
operator|->
name|unique_count
operator|+
literal|1
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|int
name|stringi
init|=
literal|0
decl_stmt|;
name|occupied_buckets
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|c
operator|->
name|num_buckets
condition|;
name|b
operator|++
control|)
block|{
name|struct
name|bstring
modifier|*
name|s
init|=
name|c
operator|->
name|bucket
index|[
name|b
index|]
decl_stmt|;
name|chain_length
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|occupied_buckets
operator|++
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|gdb_assert
argument_list|(
name|b
operator|<
name|c
operator|->
name|num_buckets
argument_list|)
expr_stmt|;
name|chain_length
index|[
name|b
index|]
operator|++
expr_stmt|;
name|gdb_assert
argument_list|(
name|stringi
operator|<
name|c
operator|->
name|unique_count
argument_list|)
expr_stmt|;
name|entry_size
index|[
name|stringi
operator|++
index|]
operator|=
name|s
operator|->
name|length
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
comment|/* To compute the median, we need the set of chain lengths sorted.  */
name|qsort
argument_list|(
name|chain_length
argument_list|,
name|c
operator|->
name|num_buckets
argument_list|,
sizeof|sizeof
argument_list|(
name|chain_length
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_ints
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|entry_size
argument_list|,
name|c
operator|->
name|unique_count
argument_list|,
sizeof|sizeof
argument_list|(
name|entry_size
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|num_buckets
operator|>
literal|0
condition|)
block|{
name|max_chain_length
operator|=
name|chain_length
index|[
name|c
operator|->
name|num_buckets
operator|-
literal|1
index|]
expr_stmt|;
name|median_chain_length
operator|=
name|chain_length
index|[
name|c
operator|->
name|num_buckets
operator|/
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|max_chain_length
operator|=
literal|0
expr_stmt|;
name|median_chain_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|unique_count
operator|>
literal|0
condition|)
block|{
name|max_entry_size
operator|=
name|entry_size
index|[
name|c
operator|->
name|unique_count
operator|-
literal|1
index|]
expr_stmt|;
name|median_entry_size
operator|=
name|entry_size
index|[
name|c
operator|->
name|unique_count
operator|/
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|max_entry_size
operator|=
literal|0
expr_stmt|;
name|median_entry_size
operator|=
literal|0
expr_stmt|;
block|}
name|xfree
argument_list|(
name|chain_length
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|entry_size
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"  Cached '%s' statistics:\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Total object count:  %ld\n"
argument_list|,
name|c
operator|->
name|total_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Unique object count: %lu\n"
argument_list|,
name|c
operator|->
name|unique_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Percentage of duplicates, by count: "
argument_list|)
expr_stmt|;
name|print_percentage
argument_list|(
name|c
operator|->
name|total_count
operator|-
name|c
operator|->
name|unique_count
argument_list|,
name|c
operator|->
name|total_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Total object size:   %ld\n"
argument_list|,
name|c
operator|->
name|total_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Unique object size:  %ld\n"
argument_list|,
name|c
operator|->
name|unique_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Percentage of duplicates, by size:  "
argument_list|)
expr_stmt|;
name|print_percentage
argument_list|(
name|c
operator|->
name|total_size
operator|-
name|c
operator|->
name|unique_size
argument_list|,
name|c
operator|->
name|total_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Max entry size:     %d\n"
argument_list|,
name|max_entry_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Average entry size: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|unique_count
operator|>
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%ld\n"
argument_list|,
name|c
operator|->
name|unique_size
operator|/
name|c
operator|->
name|unique_count
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"(not applicable)\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Median entry size:  %d\n"
argument_list|,
name|median_entry_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Total memory used by bcache, including overhead: %ld\n"
argument_list|,
name|c
operator|->
name|structure_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Percentage memory overhead: "
argument_list|)
expr_stmt|;
name|print_percentage
argument_list|(
name|c
operator|->
name|structure_size
operator|-
name|c
operator|->
name|unique_size
argument_list|,
name|c
operator|->
name|unique_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Net memory savings:         "
argument_list|)
expr_stmt|;
name|print_percentage
argument_list|(
name|c
operator|->
name|total_size
operator|-
name|c
operator|->
name|structure_size
argument_list|,
name|c
operator|->
name|total_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Hash table size:           %3d\n"
argument_list|,
name|c
operator|->
name|num_buckets
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Hash table expands:        %lu\n"
argument_list|,
name|c
operator|->
name|expand_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Hash table hashes:         %lu\n"
argument_list|,
name|c
operator|->
name|total_count
operator|+
name|c
operator|->
name|expand_hash_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Half hash misses:          %lu\n"
argument_list|,
name|c
operator|->
name|half_hash_miss_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Hash table population:     "
argument_list|)
expr_stmt|;
name|print_percentage
argument_list|(
name|occupied_buckets
argument_list|,
name|c
operator|->
name|num_buckets
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Median hash chain length:  %3d\n"
argument_list|,
name|median_chain_length
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Average hash chain length: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|num_buckets
operator|>
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%3lu\n"
argument_list|,
name|c
operator|->
name|unique_count
operator|/
name|c
operator|->
name|num_buckets
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"(not applicable)\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    Maximum hash chain length: %3d\n"
argument_list|,
name|max_chain_length
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bcache_memory_used
parameter_list|(
name|struct
name|bcache
modifier|*
name|bcache
parameter_list|)
block|{
return|return
name|obstack_memory_used
argument_list|(
operator|&
name|bcache
operator|->
name|cache
argument_list|)
return|;
block|}
end_function

end_unit

