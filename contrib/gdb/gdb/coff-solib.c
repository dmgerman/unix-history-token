begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle COFF SVR3 shared libraries for GDB, the GNU Debugger.    Copyright 1993 Free Software Foundation, Inc.     This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_comment
comment|/*  GLOBAL FUNCTION  	coff_solib_add -- add a shared library files to the symtab list.  We 	examine the `.lib' section of the exec file and determine the names of 	the shared libraries.  	This function is responsible for discovering those names and 	addresses, and saving sufficient information about them to allow 	their symbols to be read at a later time.  SYNOPSIS  	void coff_solib_add (char *arg_string, int from_tty, 			     struct target_ops *target)  DESCRIPTION  */
end_comment

begin_function
name|void
name|coff_solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|asection
modifier|*
name|libsect
decl_stmt|;
name|libsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".lib"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libsect
condition|)
block|{
name|int
name|libsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lib
decl_stmt|;
struct|struct
name|libent
block|{
name|bfd_byte
name|len
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|nameoffset
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
name|libsize
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|libsect
argument_list|)
expr_stmt|;
name|lib
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|libsize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|exec_bfd
argument_list|,
name|libsect
argument_list|,
name|lib
argument_list|,
literal|0
argument_list|,
name|libsize
argument_list|)
expr_stmt|;
while|while
condition|(
name|libsize
operator|>
literal|0
condition|)
block|{
name|struct
name|libent
modifier|*
name|ent
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nameoffset
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|ent
operator|=
operator|(
expr|struct
name|libent
operator|*
operator|)
name|lib
expr_stmt|;
name|len
operator|=
name|bfd_get_32
argument_list|(
name|exec_bfd
argument_list|,
name|ent
operator|->
name|len
argument_list|)
expr_stmt|;
name|nameoffset
operator|=
name|bfd_get_32
argument_list|(
name|exec_bfd
argument_list|,
name|ent
operator|->
name|nameoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|ent
operator|+
name|nameoffset
operator|*
literal|4
expr_stmt|;
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|,
comment|/* addr */
literal|0
argument_list|,
comment|/* not mainline */
literal|0
argument_list|,
comment|/* not mapped */
literal|0
argument_list|)
expr_stmt|;
comment|/* Not readnow */
name|libsize
operator|-=
name|len
operator|*
literal|4
expr_stmt|;
name|lib
operator|+=
name|len
operator|*
literal|4
expr_stmt|;
block|}
comment|/* Getting new symbols may change our opinion about what is 	 frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    GLOBAL FUNCTION    	coff_solib_create_inferior_hook -- shared library startup support    SYNOPSIS    	void coff_solib_create_inferior_hook()    DESCRIPTION    	When gdb starts up the inferior, the kernel maps in the shared 	libraries.  We get here with the target stopped at it's first 	instruction, and the libraries already mapped.  At this	point, this 	function gets called via expansion of the macro 	SOLIB_CREATE_INFERIOR_HOOK.   */
end_comment

begin_function
name|void
name|coff_solib_create_inferior_hook
parameter_list|()
block|{
name|coff_solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

