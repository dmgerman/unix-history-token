begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU/Linux on ARM native support.    Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"arm-tdep.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|arm_apcs_32
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|typeNone
value|0x00
end_define

begin_define
define|#
directive|define
name|typeSingle
value|0x01
end_define

begin_define
define|#
directive|define
name|typeDouble
value|0x02
end_define

begin_define
define|#
directive|define
name|typeExtended
value|0x03
end_define

begin_define
define|#
directive|define
name|FPWORDS
value|28
end_define

begin_define
define|#
directive|define
name|ARM_CPSR_REGNUM
value|16
end_define

begin_typedef
typedef|typedef
union|union
name|tagFPREG
block|{
name|unsigned
name|int
name|fSingle
decl_stmt|;
name|unsigned
name|int
name|fDouble
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|fExtended
index|[
literal|3
index|]
decl_stmt|;
block|}
name|FPREG
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tagFPA11
block|{
name|FPREG
name|fpreg
index|[
literal|8
index|]
decl_stmt|;
comment|/* 8 floating point registers */
name|unsigned
name|int
name|fpsr
decl_stmt|;
comment|/* floating point status register */
name|unsigned
name|int
name|fpcr
decl_stmt|;
comment|/* floating point control register */
name|unsigned
name|char
name|fType
index|[
literal|8
index|]
decl_stmt|;
comment|/* type of floating point value held in 				   floating point registers.  */
name|int
name|initflag
decl_stmt|;
comment|/* NWFPE initialization flag.  */
block|}
name|FPA11
typedef|;
end_typedef

begin_comment
comment|/* The following variables are used to determine the version of the    underlying GNU/Linux operating system.  Examples:     GNU/Linux 2.0.35             GNU/Linux 2.2.12    os_version = 0x00020023      os_version = 0x0002020c    os_major = 2                 os_major = 2    os_minor = 0                 os_minor = 2    os_release = 35              os_release = 12     Note: os_version = (os_major<< 16) | (os_minor<< 8) | os_release     These are initialized using get_linux_version() from    _initialize_arm_linux_nat().  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|os_version
decl_stmt|,
name|os_major
decl_stmt|,
name|os_minor
decl_stmt|,
name|os_release
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On GNU/Linux, threads are implemented as pseudo-processes, in which    case we may be tracing more than one process at a time.  In that    case, inferior_ptid will contain the main process ID and the    individual thread (process) ID.  get_thread_id () is used to get    the thread id if it's available, and the process id otherwise.  */
end_comment

begin_function
name|int
name|get_thread_id
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|tid
init|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|tid
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
return|return
name|tid
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GET_THREAD_ID
parameter_list|(
name|PTID
parameter_list|)
value|get_thread_id ((PTID));
end_define

begin_function
specifier|static
name|void
name|fetch_nwfpe_single
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
decl_stmt|;
name|mem
index|[
literal|0
index|]
operator|=
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fSingle
expr_stmt|;
name|mem
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|supply_register
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_nwfpe_double
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
decl_stmt|;
name|mem
index|[
literal|0
index|]
operator|=
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fDouble
index|[
literal|1
index|]
expr_stmt|;
name|mem
index|[
literal|1
index|]
operator|=
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fDouble
index|[
literal|0
index|]
expr_stmt|;
name|mem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|supply_register
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_nwfpe_none
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|supply_register
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_nwfpe_extended
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
decl_stmt|;
name|mem
index|[
literal|0
index|]
operator|=
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fExtended
index|[
literal|0
index|]
expr_stmt|;
comment|/* sign& exponent */
name|mem
index|[
literal|1
index|]
operator|=
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fExtended
index|[
literal|2
index|]
expr_stmt|;
comment|/* ls bits */
name|mem
index|[
literal|2
index|]
operator|=
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fExtended
index|[
literal|1
index|]
expr_stmt|;
comment|/* ms bits */
name|supply_register
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_nwfpe_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|int
name|fn
init|=
name|regno
operator|-
name|ARM_F0_REGNUM
decl_stmt|;
switch|switch
condition|(
name|fpa11
operator|->
name|fType
index|[
name|fn
index|]
condition|)
block|{
case|case
name|typeSingle
case|:
name|fetch_nwfpe_single
argument_list|(
name|fn
argument_list|,
name|fpa11
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeDouble
case|:
name|fetch_nwfpe_double
argument_list|(
name|fn
argument_list|,
name|fpa11
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeExtended
case|:
name|fetch_nwfpe_extended
argument_list|(
name|fn
argument_list|,
name|fpa11
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fetch_nwfpe_none
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_nwfpe_single
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
decl_stmt|;
name|regcache_collect
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fSingle
operator|=
name|mem
index|[
literal|0
index|]
expr_stmt|;
name|fpa11
operator|->
name|fType
index|[
name|fn
index|]
operator|=
name|typeSingle
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|store_nwfpe_double
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
decl_stmt|;
name|regcache_collect
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fDouble
index|[
literal|1
index|]
operator|=
name|mem
index|[
literal|0
index|]
expr_stmt|;
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fDouble
index|[
literal|0
index|]
operator|=
name|mem
index|[
literal|1
index|]
expr_stmt|;
name|fpa11
operator|->
name|fType
index|[
name|fn
index|]
operator|=
name|typeDouble
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_nwfpe_extended
parameter_list|(
name|unsigned
name|int
name|fn
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
name|unsigned
name|int
name|mem
index|[
literal|3
index|]
decl_stmt|;
name|regcache_collect
argument_list|(
name|ARM_F0_REGNUM
operator|+
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fExtended
index|[
literal|0
index|]
operator|=
name|mem
index|[
literal|0
index|]
expr_stmt|;
comment|/* sign& exponent */
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fExtended
index|[
literal|2
index|]
operator|=
name|mem
index|[
literal|1
index|]
expr_stmt|;
comment|/* ls bits */
name|fpa11
operator|->
name|fpreg
index|[
name|fn
index|]
operator|.
name|fExtended
index|[
literal|1
index|]
operator|=
name|mem
index|[
literal|2
index|]
expr_stmt|;
comment|/* ms bits */
name|fpa11
operator|->
name|fType
index|[
name|fn
index|]
operator|=
name|typeDouble
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_nwfpe_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|FPA11
modifier|*
name|fpa11
parameter_list|)
block|{
if|if
condition|(
name|register_cached
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|fn
init|=
name|regno
operator|-
name|ARM_F0_REGNUM
decl_stmt|;
switch|switch
condition|(
name|fpa11
operator|->
name|fType
index|[
name|fn
index|]
condition|)
block|{
case|case
name|typeSingle
case|:
name|store_nwfpe_single
argument_list|(
name|fn
argument_list|,
name|fpa11
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeDouble
case|:
name|store_nwfpe_double
argument_list|(
name|fn
argument_list|,
name|fpa11
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeExtended
case|:
name|store_nwfpe_extended
argument_list|(
name|fn
argument_list|,
name|fpa11
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get the value of a particular register from the floating point    state of the process and store it into regcache.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_fpregister
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|tid
decl_stmt|;
name|FPA11
name|fp
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Read the floating point state.  */
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch floating point register."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fetch fpsr.  */
if|if
condition|(
name|ARM_FPS_REGNUM
operator|==
name|regno
condition|)
name|supply_register
argument_list|(
name|ARM_FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|.
name|fpsr
argument_list|)
expr_stmt|;
comment|/* Fetch the floating point register.  */
if|if
condition|(
name|regno
operator|>=
name|ARM_F0_REGNUM
operator|&&
name|regno
operator|<=
name|ARM_F7_REGNUM
condition|)
block|{
name|int
name|fn
init|=
name|regno
operator|-
name|ARM_F0_REGNUM
decl_stmt|;
switch|switch
condition|(
name|fp
operator|.
name|fType
index|[
name|fn
index|]
condition|)
block|{
case|case
name|typeSingle
case|:
name|fetch_nwfpe_single
argument_list|(
name|fn
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeDouble
case|:
name|fetch_nwfpe_double
argument_list|(
name|fn
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeExtended
case|:
name|fetch_nwfpe_extended
argument_list|(
name|fn
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fetch_nwfpe_none
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get the whole floating point state of the process and store it    into regcache.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|regno
decl_stmt|,
name|tid
decl_stmt|;
name|FPA11
name|fp
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Read the floating point state.  */
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch the floating point registers."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fetch fpsr.  */
name|supply_register
argument_list|(
name|ARM_FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|.
name|fpsr
argument_list|)
expr_stmt|;
comment|/* Fetch the floating point registers.  */
for|for
control|(
name|regno
operator|=
name|ARM_F0_REGNUM
init|;
name|regno
operator|<=
name|ARM_F7_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|fn
init|=
name|regno
operator|-
name|ARM_F0_REGNUM
decl_stmt|;
switch|switch
condition|(
name|fp
operator|.
name|fType
index|[
name|fn
index|]
condition|)
block|{
case|case
name|typeSingle
case|:
name|fetch_nwfpe_single
argument_list|(
name|fn
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeDouble
case|:
name|fetch_nwfpe_double
argument_list|(
name|fn
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|typeExtended
case|:
name|fetch_nwfpe_extended
argument_list|(
name|fn
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fetch_nwfpe_none
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Save a particular register into the floating point state of the    process using the contents from regcache.  */
end_comment

begin_function
specifier|static
name|void
name|store_fpregister
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|tid
decl_stmt|;
name|FPA11
name|fp
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Read the floating point state.  */
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch the floating point registers."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Store fpsr.  */
if|if
condition|(
name|ARM_FPS_REGNUM
operator|==
name|regno
operator|&&
name|register_cached
argument_list|(
name|ARM_FPS_REGNUM
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|ARM_FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|.
name|fpsr
argument_list|)
expr_stmt|;
comment|/* Store the floating point register.  */
if|if
condition|(
name|regno
operator|>=
name|ARM_F0_REGNUM
operator|&&
name|regno
operator|<=
name|ARM_F7_REGNUM
condition|)
block|{
name|store_nwfpe_register
argument_list|(
name|regno
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to store floating point register."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Save the whole floating point state of the process using    the contents from regcache.  */
end_comment

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|regno
decl_stmt|,
name|tid
decl_stmt|;
name|FPA11
name|fp
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Read the floating point state.  */
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch the floating point registers."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Store fpsr.  */
if|if
condition|(
name|register_cached
argument_list|(
name|ARM_FPS_REGNUM
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|ARM_FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|.
name|fpsr
argument_list|)
expr_stmt|;
comment|/* Store the floating point registers.  */
for|for
control|(
name|regno
operator|=
name|ARM_F0_REGNUM
init|;
name|regno
operator|<=
name|ARM_F7_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
name|fetch_nwfpe_register
argument_list|(
name|regno
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to store floating point registers."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Fetch a general register of the process and store into    regcache.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|tid
decl_stmt|;
name|elf_gregset_t
name|regs
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch general register."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|>=
name|ARM_A1_REGNUM
operator|&&
name|regno
operator|<
name|ARM_PC_REGNUM
condition|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARM_PS_REGNUM
operator|==
name|regno
condition|)
block|{
if|if
condition|(
name|arm_apcs_32
condition|)
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|ARM_CPSR_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ARM_PC_REGNUM
operator|==
name|regno
condition|)
block|{
name|regs
index|[
name|ARM_PC_REGNUM
index|]
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch all general registers of the process and store into    regcache.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|regno
decl_stmt|,
name|tid
decl_stmt|;
name|elf_gregset_t
name|regs
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch general registers."
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
name|ARM_A1_REGNUM
init|;
name|regno
operator|<
name|ARM_PC_REGNUM
condition|;
name|regno
operator|++
control|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_apcs_32
condition|)
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|ARM_CPSR_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|ARM_PC_REGNUM
index|]
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all general registers of the process from the values in    regcache.  */
end_comment

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|tid
decl_stmt|;
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
operator|!
name|register_cached
argument_list|(
name|regno
argument_list|)
condition|)
return|return;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Get the general registers from the process.  */
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch general registers."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|>=
name|ARM_A1_REGNUM
operator|&&
name|regno
operator|<=
name|ARM_PC_REGNUM
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to store general register."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|regno
decl_stmt|,
name|tid
decl_stmt|;
name|elf_gregset_t
name|regs
decl_stmt|;
comment|/* Get the thread id for the ptrace call.  */
name|tid
operator|=
name|GET_THREAD_ID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Fetch the general registers.  */
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to fetch general registers."
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
name|ARM_A1_REGNUM
init|;
name|regno
operator|<=
name|ARM_PC_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|register_cached
argument_list|(
name|regno
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to store general registers."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Fetch registers from the child process.  Fetch all registers if    regno == -1, otherwise fetch all general registers or all floating    point registers depending upon the value of regno.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|regno
condition|)
block|{
name|fetch_regs
argument_list|()
expr_stmt|;
name|fetch_fpregs
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
name|ARM_F0_REGNUM
operator|||
name|regno
operator|>
name|ARM_FPS_REGNUM
condition|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|ARM_F0_REGNUM
operator|&&
name|regno
operator|<=
name|ARM_FPS_REGNUM
condition|)
name|fetch_fpregister
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store registers back into the inferior.  Store all registers if    regno == -1, otherwise store all general registers or all floating    point registers depending upon the value of regno.  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|regno
condition|)
block|{
name|store_regs
argument_list|()
expr_stmt|;
name|store_fpregs
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|regno
operator|<
name|ARM_F0_REGNUM
operator|)
operator|||
operator|(
name|regno
operator|>
name|ARM_FPS_REGNUM
operator|)
condition|)
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
name|ARM_F0_REGNUM
operator|)
operator|&&
operator|(
name|regno
operator|<=
name|ARM_FPS_REGNUM
operator|)
condition|)
name|store_fpregister
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill register regno (if it is a general-purpose register) in    *gregsetp with the appropriate value from GDB's register array.    If regno is -1, do this for all registers.  */
end_comment

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|regno
condition|)
block|{
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
name|ARM_A1_REGNUM
init|;
name|regnum
operator|<=
name|ARM_PC_REGNUM
condition|;
name|regnum
operator|++
control|)
name|regcache_collect
argument_list|(
name|regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|>=
name|ARM_A1_REGNUM
operator|&&
name|regno
operator|<=
name|ARM_PC_REGNUM
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARM_PS_REGNUM
operator|==
name|regno
operator|||
operator|-
literal|1
operator|==
name|regno
condition|)
block|{
if|if
condition|(
name|arm_apcs_32
condition|)
name|regcache_collect
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|ARM_CPSR_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|regcache_collect
argument_list|(
name|ARM_PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill GDB's register array with the general-purpose register values    in *gregsetp.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|reg_pc
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|ARM_A1_REGNUM
init|;
name|regno
operator|<
name|ARM_PC_REGNUM
condition|;
name|regno
operator|++
control|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_apcs_32
condition|)
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|ARM_CPSR_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|reg_pc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|*
name|gregsetp
argument_list|)
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reg_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register regno (if it is a floating-point register) in    *fpregsetp with the appropriate value from GDB's register array.    If regno is -1, do this for all registers.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|FPA11
modifier|*
name|fp
init|=
operator|(
name|FPA11
operator|*
operator|)
name|fpregsetp
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|regno
condition|)
block|{
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
name|ARM_F0_REGNUM
init|;
name|regnum
operator|<=
name|ARM_F7_REGNUM
condition|;
name|regnum
operator|++
control|)
name|store_nwfpe_register
argument_list|(
name|regnum
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|>=
name|ARM_F0_REGNUM
operator|&&
name|regno
operator|<=
name|ARM_F7_REGNUM
condition|)
block|{
name|store_nwfpe_register
argument_list|(
name|regno
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Store fpsr.  */
if|if
condition|(
name|ARM_FPS_REGNUM
operator|==
name|regno
operator|||
operator|-
literal|1
operator|==
name|regno
condition|)
name|regcache_collect
argument_list|(
name|ARM_FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|->
name|fpsr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill GDB's register array with the floating-point register values    in *fpregsetp.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|FPA11
modifier|*
name|fp
init|=
operator|(
name|FPA11
operator|*
operator|)
name|fpregsetp
decl_stmt|;
comment|/* Fetch fpsr.  */
name|supply_register
argument_list|(
name|ARM_FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|->
name|fpsr
argument_list|)
expr_stmt|;
comment|/* Fetch the floating point registers.  */
for|for
control|(
name|regno
operator|=
name|ARM_F0_REGNUM
init|;
name|regno
operator|<=
name|ARM_F7_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
name|fetch_nwfpe_register
argument_list|(
name|regno
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|arm_linux_kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|get_linux_version
parameter_list|(
name|unsigned
name|int
modifier|*
name|vmajor
parameter_list|,
name|unsigned
name|int
modifier|*
name|vminor
parameter_list|,
name|unsigned
name|int
modifier|*
name|vrelease
parameter_list|)
block|{
name|struct
name|utsname
name|info
decl_stmt|;
name|char
modifier|*
name|pmajor
decl_stmt|,
modifier|*
name|pminor
decl_stmt|,
modifier|*
name|prelease
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|uname
argument_list|(
operator|&
name|info
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to determine GNU/Linux version."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pmajor
operator|=
name|strtok
argument_list|(
name|info
operator|.
name|release
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|pminor
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|prelease
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|*
name|vmajor
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtoul
argument_list|(
name|pmajor
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|vminor
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtoul
argument_list|(
name|pminor
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|vrelease
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtoul
argument_list|(
name|prelease
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|vmajor
operator|<<
literal|16
operator|)
operator||
operator|(
operator|*
name|vminor
operator|<<
literal|8
operator|)
operator||
operator|*
name|vrelease
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_initialize_arm_linux_nat
parameter_list|(
name|void
parameter_list|)
block|{
name|os_version
operator|=
name|get_linux_version
argument_list|(
operator|&
name|os_major
argument_list|,
operator|&
name|os_minor
argument_list|,
operator|&
name|os_release
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

