begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for SPARC.     Copyright 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MACHINE_REG_H
end_ifdef

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sparc-tdep.h"
end_include

begin_include
include|#
directive|include
file|"sparc-nat.h"
end_include

begin_comment
comment|/* With some trickery we can use the code in this file for most (if    not all) ptrace(2) based SPARC systems, which includes SunOS 4,    GNU/Linux and the various SPARC BSD's.     First, we need a data structure for use with ptrace(2).  SunOS has    `struct regs' and `struct fp_status' in<machine/reg.h>.  BSD's    have `struct reg' and `struct fpreg' in<machine/reg.h>.  GNU/Linux    has the same structures as SunOS 4, but they're in<asm/reg.h>,    which is a kernel header.  As a general rule we avoid including    GNU/Linux kernel headers.  Fortunately GNU/Linux has a `gregset_t'    and a `fpregset_t' that are equivalent to `struct regs' and `struct    fp_status' in<sys/ucontext.h>, which is automatically included by<signal.h>.  Settling on using the `gregset_t' and `fpregset_t'    typedefs, providing them for the other systems, therefore solves    the puzzle.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MACHINE_REG_H
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRUCT_REG
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|reg
name|gregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fpreg
name|fpregset_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|regs
name|gregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fp_status
name|fpregset_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Second, we need to remap the BSD ptrace(2) requests to their SunOS    equivalents.  GNU/Linux already follows SunOS here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_GETREGS
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_GETREGS
value|PT_GETREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_SETREGS
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_SETREGS
value|PT_SETREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_GETFPREGS
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_GETFPREGS
value|PT_GETFPREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_SETFPREGS
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_SETFPREGS
value|PT_SETFPREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register set description.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|sparc_gregset
modifier|*
name|sparc_gregset
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|sparc_supply_gregset
function_decl|)
parameter_list|(
specifier|const
name|struct
name|sparc_gregset
modifier|*
parameter_list|,
name|struct
name|regcache
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|sparc_collect_gregset
function_decl|)
parameter_list|(
specifier|const
name|struct
name|sparc_gregset
modifier|*
parameter_list|,
specifier|const
name|struct
name|regcache
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|sparc_supply_fpregset
function_decl|)
parameter_list|(
name|struct
name|regcache
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|sparc_collect_fpregset
function_decl|)
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|sparc_gregset_supplies_p
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|sparc_fpregset_supplies_p
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Determine whether `gregset_t' contains register REGNUM.  */
end_comment

begin_function
name|int
name|sparc32_gregset_supplies_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* Integer registers.  */
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_G1_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_G7_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|SPARC_O0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_L7_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|SPARC_I0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Control registers.  */
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
operator|||
name|regnum
operator|==
name|SPARC32_PSR_REGNUM
operator|||
name|regnum
operator|==
name|SPARC32_Y_REGNUM
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine whether `fpregset_t' contains register REGNUM.  */
end_comment

begin_function
name|int
name|sparc32_fpregset_supplies_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* Floating-point registers.  */
if|if
condition|(
name|regnum
operator|>=
name|SPARC_F0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_F31_REGNUM
condition|)
return|return
literal|1
return|;
comment|/* Control registers.  */
if|if
condition|(
name|regnum
operator|==
name|SPARC32_FSR_REGNUM
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this    for all registers (including the floating-point registers).  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|regcache
init|=
name|current_regcache
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* NOTE: cagney/2002-12-03: This code assumes that the currently      selected light weight processes' registers can be written      directly into the selected thread's register cache.  This works      fine when given an 1:1 LWP:thread model (such as found on      GNU/Linux) but will, likely, have problems when used on an N:1      (userland threads) or N:M (userland multiple LWP) model.  In the      case of the latter two, the LWP's registers do not necessarily      belong to the selected thread (the LWP could be in the middle of      executing the thread switch code).       These functions should instead be paramaterized with an explicit      object (struct regcache, struct thread_info?) into which the LWPs      registers can be written.  */
name|pid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC_G0_REGNUM
condition|)
block|{
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC_G0_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|sparc_gregset_supplies_p
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|sparc_supply_gregset
argument_list|(
name|sparc_gregset
argument_list|,
name|regcache
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|sparc_fpregset_supplies_p
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|sparc_supply_fpregset
argument_list|(
name|regcache
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fpregs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|regcache
init|=
name|current_regcache
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* NOTE: cagney/2002-12-02: See comment in fetch_inferior_registers      about threaded assumptions.  */
name|pid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|sparc_gregset_supplies_p
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|sparc_collect_gregset
argument_list|(
name|sparc_gregset
argument_list|,
name|regcache
argument_list|,
name|regnum
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write registers"
argument_list|)
expr_stmt|;
comment|/* Deal with the stack regs.  */
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|SPARC_SP_REGNUM
operator|||
operator|(
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
operator|)
condition|)
block|{
name|ULONGEST
name|sp
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_SP_REGNUM
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
name|sparc_collect_rwindow
argument_list|(
name|regcache
argument_list|,
name|sp
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|sparc_fpregset_supplies_p
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|fpregset_t
name|fpregs
decl_stmt|,
name|saved_fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating-point registers"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|saved_fpregs
argument_list|,
operator|&
name|fpregs
argument_list|,
sizeof|sizeof
argument_list|(
name|fpregs
argument_list|)
argument_list|)
expr_stmt|;
name|sparc_collect_fpregset
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
operator|&
name|fpregs
argument_list|)
expr_stmt|;
comment|/* Writing the floating-point registers will fail on NetBSD with 	 EINVAL if the inferior process doesn't have an FPU state 	 (i.e. if it didn't use the FPU yet).  Therefore we don't try 	 to write the registers if nothing changed.  */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|saved_fpregs
argument_list|,
operator|&
name|fpregs
argument_list|,
sizeof|sizeof
argument_list|(
name|fpregs
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write floating-point registers"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fetch StackGhost Per-Process XOR cookie.  */
end_comment

begin_function
name|LONGEST
name|sparc_xfer_wcookie
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|wcookie
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|wcookie
decl_stmt|;
name|gdb_assert
argument_list|(
name|object
operator|==
name|TARGET_OBJECT_WCOOKIE
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|readbuf
operator|&&
name|writebuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|PT_WCOOKIE
comment|/* If PT_WCOOKIE is defined (by<sys/ptrace.h>), assume we're      running on an OpenBSD release that uses StackGhost (3.1 or      later).  As of release 3.4, OpenBSD doesn't use a randomized      cookie yet, but a future release probably will.  */
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Sanity check.  The proper type for a cookie is register_t, but        we can't assume that this type exists on all systems supported        by the code in this file.  */
name|gdb_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|wcookie
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the cookie.  */
if|if
condition|(
name|ptrace
argument_list|(
name|PT_WCOOKIE
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|wcookie
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get StackGhost cookie"
argument_list|)
expr_stmt|;
comment|/* Although PT_WCOOKIE is defined on OpenBSD 3.1 and later, 	   the request wasn't implemented until after OpenBSD 3.4.  If 	   the kernel doesn't support the PT_WCOOKIE request, assume 	   we're running on a kernel that uses non-randomized cookies.  */
name|wcookie
operator|=
literal|0x3
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PT_WCOOKIE */
if|if
condition|(
name|len
operator|>
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|-
name|offset
condition|)
name|len
operator|=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|-
name|offset
expr_stmt|;
name|memcpy
argument_list|(
name|readbuf
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide a prototype to silence -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_sparc_nat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_sparc_nat
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Deafult to using SunOS 4 register sets.  */
if|if
condition|(
name|sparc_gregset
operator|==
name|NULL
condition|)
name|sparc_gregset
operator|=
operator|&
name|sparc32_sunos4_gregset
expr_stmt|;
if|if
condition|(
name|sparc_supply_gregset
operator|==
name|NULL
condition|)
name|sparc_supply_gregset
operator|=
name|sparc32_supply_gregset
expr_stmt|;
if|if
condition|(
name|sparc_collect_gregset
operator|==
name|NULL
condition|)
name|sparc_collect_gregset
operator|=
name|sparc32_collect_gregset
expr_stmt|;
if|if
condition|(
name|sparc_supply_fpregset
operator|==
name|NULL
condition|)
name|sparc_supply_fpregset
operator|=
name|sparc32_supply_fpregset
expr_stmt|;
if|if
condition|(
name|sparc_collect_fpregset
operator|==
name|NULL
condition|)
name|sparc_collect_fpregset
operator|=
name|sparc32_collect_fpregset
expr_stmt|;
if|if
condition|(
name|sparc_gregset_supplies_p
operator|==
name|NULL
condition|)
name|sparc_gregset_supplies_p
operator|=
name|sparc32_gregset_supplies_p
expr_stmt|;
if|if
condition|(
name|sparc_fpregset_supplies_p
operator|==
name|NULL
condition|)
name|sparc_fpregset_supplies_p
operator|=
name|sparc32_fpregset_supplies_p
expr_stmt|;
block|}
end_function

end_unit

