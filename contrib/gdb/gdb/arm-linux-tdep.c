begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU/Linux on ARM target support.    Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"arm-tdep.h"
end_include

begin_comment
comment|/* For shared library handling.  */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Under ARM GNU/Linux the traditional way of performing a breakpoint    is to execute a particular software interrupt, rather than use a    particular undefined instruction to provoke a trap.  Upon exection    of the software interrupt the kernel stops the inferior with a    SIGTRAP, and wakes the debugger.  Since ARM GNU/Linux is little    endian, and doesn't support Thumb at the moment we only override    the ARM little-endian breakpoint.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_linux_arm_le_breakpoint
index|[]
init|=
block|{
literal|0x01
block|,
literal|0x00
block|,
literal|0x9f
block|,
literal|0xef
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CALL_DUMMY_WORDS:    This sequence of words is the instructions     mov  lr, pc    mov  pc, r4    swi	bkpt_swi     Note this is 12 bytes.  */
end_comment

begin_decl_stmt
name|LONGEST
name|arm_linux_call_dummy_words
index|[]
init|=
block|{
literal|0xe1a0e00f
block|,
literal|0xe1a0f004
block|,
literal|0xef9f001
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description of the longjmp buffer.  */
end_comment

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|INT_REGISTER_RAW_SIZE
end_define

begin_define
define|#
directive|define
name|JB_PC
value|21
end_define

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state    a function return value of type TYPE, and copy that, in virtual format,    into VALBUF.  */
end_comment

begin_comment
comment|/* FIXME rearnsha/2002-02-23: This function shouldn't be necessary.    The ARM generic one should be able to handle the model used by    linux and the low-level formatting of the registers should be    hidden behind the regcache abstraction.  */
end_comment

begin_function
specifier|static
name|void
name|arm_linux_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
comment|/* ScottB: This needs to be looked at to handle the different      floating point emulators on ARM GNU/Linux.  Right now the code      assumes that fetch inferior registers does the right thing for      GDB.  I suspect this won't handle NWFPE registers correctly, nor      will the default ARM version (arm_extract_return_value()).  */
name|int
name|regnum
init|=
operator|(
operator|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|)
condition|?
name|ARM_F0_REGNUM
else|:
name|ARM_A1_REGNUM
operator|)
decl_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note: ScottB     This function does not support passing parameters using the FPA    variant of the APCS.  It passes any floating point arguments in the    general registers and/or on the stack.        FIXME:  This and arm_push_arguments should be merged.  However this     	   function breaks on a little endian host, big endian target    	   using the COFF file format.  ELF is ok.      	       	   ScottB.  */
end_comment

begin_comment
comment|/* Addresses for calling Thumb functions have the bit 0 set.    Here are some macros to test, set, or clear bit 0 of addresses.  */
end_comment

begin_define
define|#
directive|define
name|IS_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& 1)
end_define

begin_define
define|#
directive|define
name|MAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr) | 1)
end_define

begin_define
define|#
directive|define
name|UNMAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& ~1)
end_define

begin_function
specifier|static
name|CORE_ADDR
name|arm_linux_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|argnum
decl_stmt|,
name|argreg
decl_stmt|,
name|nstack_size
decl_stmt|;
comment|/* Walk through the list of args and determine how large a temporary      stack is required.  Need to take care here as structs may be      passed on the stack, and we have to to push them.  */
name|nstack_size
operator|=
operator|-
literal|4
operator|*
name|REGISTER_SIZE
expr_stmt|;
comment|/* Some arguments go into A1-A4.  */
if|if
condition|(
name|struct_return
condition|)
comment|/* The struct address goes in A1.  */
name|nstack_size
operator|+=
name|REGISTER_SIZE
expr_stmt|;
comment|/* Walk through the arguments and add their size to nstack_size.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
comment|/* ANSI C code passes float arguments as integers, K&R code          passes float arguments as doubles.  Correct for this here.  */
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|&&
name|REGISTER_SIZE
operator|==
name|len
condition|)
name|nstack_size
operator|+=
name|FP_REGISTER_VIRTUAL_SIZE
expr_stmt|;
else|else
name|nstack_size
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Allocate room on the stack, and initialize our stack frame      pointer.  */
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nstack_size
operator|>
literal|0
condition|)
block|{
name|sp
operator|-=
name|nstack_size
expr_stmt|;
name|fp
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
expr_stmt|;
block|}
comment|/* Initialize the integer argument register pointer.  */
name|argreg
operator|=
name|ARM_A1_REGNUM
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter passing      register.  */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Process arguments from left to right.  Store as many as allowed      in the parameter passing registers (A1-A4), and save the rest on      the temporary stack.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|enum
name|type_code
name|typecode
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|,
modifier|*
name|target_type
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|target_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
comment|/* ANSI C code passes float arguments as integers, K&R code          passes float arguments as doubles.  The .stabs record for           for ANSI prototype floating point arguments records the          type as FP_INTEGER, while a K&R style (no prototype)          .stabs records the type as FP_FLOAT.  In this latter case          the compiler converts the float arguments to double before          calling the function.  */
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|typecode
operator|&&
name|REGISTER_SIZE
operator|==
name|len
condition|)
block|{
name|DOUBLEST
name|dblval
decl_stmt|;
name|dblval
operator|=
name|extract_floating
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
name|val
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|store_floating
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|dblval
argument_list|)
expr_stmt|;
block|}
comment|/* If the argument is a pointer to a function, and it is a Thumb          function, set the low bit of the pointer.  */
if|if
condition|(
name|TYPE_CODE_PTR
operator|==
name|typecode
operator|&&
name|NULL
operator|!=
name|target_type
operator|&&
name|TYPE_CODE_FUNC
operator|==
name|TYPE_CODE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|regval
init|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|regval
argument_list|)
condition|)
name|store_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|MAKE_THUMB_ADDR
argument_list|(
name|regval
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the argument to general registers or the stack in          register-sized pieces.  Large arguments are split between          registers and stack.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|partial_len
init|=
name|len
operator|<
name|REGISTER_SIZE
condition|?
name|len
else|:
name|REGISTER_SIZE
decl_stmt|;
if|if
condition|(
name|argreg
operator|<=
name|ARM_LAST_ARG_REGNUM
condition|)
block|{
comment|/* It's an argument being passed in a general register.  */
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Push the arguments onto the stack.  */
name|write_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|fp
argument_list|,
name|val
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|REGISTER_SIZE
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
block|}
block|}
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*    Dynamic Linking on ARM GNU/Linux    --------------------------------     Note: PLT = procedure linkage table    GOT = global offset table     As much as possible, ELF dynamic linking defers the resolution of    jump/call addresses until the last minute. The technique used is    inspired by the i386 ELF design, and is based on the following    constraints.     1) The calling technique should not force a change in the assembly    code produced for apps; it MAY cause changes in the way assembly    code is produced for position independent code (i.e. shared    libraries).     2) The technique must be such that all executable areas must not be    modified; and any modified areas must not be executed.     To do this, there are three steps involved in a typical jump:     1) in the code    2) through the PLT    3) using a pointer from the GOT     When the executable or library is first loaded, each GOT entry is    initialized to point to the code which implements dynamic name    resolution and code finding.  This is normally a function in the    program interpreter (on ARM GNU/Linux this is usually    ld-linux.so.2, but it does not have to be).  On the first    invocation, the function is located and the GOT entry is replaced    with the real function address.  Subsequent calls go through steps    1, 2 and 3 and end up calling the real code.     1) In the code:      b    function_call    bl   function_call     This is typical ARM code using the 26 bit relative branch or branch    and link instructions.  The target of the instruction    (function_call is usually the address of the function to be called.    In position independent code, the target of the instruction is    actually an entry in the PLT when calling functions in a shared    library.  Note that this call is identical to a normal function    call, only the target differs.     2) In the PLT:     The PLT is a synthetic area, created by the linker. It exists in    both executables and libraries. It is an array of stubs, one per    imported function call. It looks like this:     PLT[0]:    str     lr, [sp, #-4]!       @push the return address (lr)    ldr     lr, [pc, #16]   @load from 6 words ahead    add     lr, pc, lr      @form an address for GOT[0]    ldr     pc, [lr, #8]!   @jump to the contents of that addr     The return address (lr) is pushed on the stack and used for    calculations.  The load on the second line loads the lr with&GOT[3] - . - 20.  The addition on the third leaves:     lr = (&GOT[3] - . - 20) + (. + 8)    lr = (&GOT[3] - 12)    lr =&GOT[0]     On the fourth line, the pc and lr are both updated, so that:     pc = GOT[2]    lr =&GOT[0] + 8    =&GOT[2]     NOTE: PLT[0] borrows an offset .word from PLT[1]. This is a little    "tight", but allows us to keep all the PLT entries the same size.     PLT[n+1]:    ldr     ip, [pc, #4]    @load offset from gotoff    add     ip, pc, ip      @add the offset to the pc    ldr     pc, [ip]        @jump to that address    gotoff: .word   GOT[n+3] - .     The load on the first line, gets an offset from the fourth word of    the PLT entry.  The add on the second line makes ip =&GOT[n+3],    which contains either a pointer to PLT[0] (the fixup trampoline) or    a pointer to the actual code.     3) In the GOT:     The GOT contains helper pointers for both code (PLT) fixups and    data fixups.  The first 3 entries of the GOT are special. The next    M entries (where M is the number of entries in the PLT) belong to    the PLT fixups. The next D (all remaining) entries belong to    various data fixups. The actual size of the GOT is 3 + M + D.     The GOT is also a synthetic area, created by the linker. It exists    in both executables and libraries.  When the GOT is first    initialized , all the GOT entries relating to PLT fixups are    pointing to code back at PLT[0].     The special entries in the GOT are:     GOT[0] = linked list pointer used by the dynamic loader    GOT[1] = pointer to the reloc table for this module    GOT[2] = pointer to the fixup/resolver code     The first invocation of function call comes through and uses the    fixup/resolver code.  On the entry to the fixup/resolver code:     ip =&GOT[n+3]    lr =&GOT[2]    stack[0] = return address (lr) of the function call    [r0, r1, r2, r3] are still the arguments to the function call     This is enough information for the fixup/resolver code to work    with.  Before the fixup/resolver code returns, it actually calls    the requested function and repairs&GOT[n+3].  */
end_comment

begin_comment
comment|/* Find the minimal symbol named NAME, and return both the minsym    struct and its objfile.  This probably ought to be in minsym.c, but    everything there is trying to deal with things like C++ and    SOFUN_ADDRESS_MAYBE_TURQUOISE, ...  Since this is so simple, it may    be considered too special-purpose for general consumption.  */
end_comment

begin_function
specifier|static
name|struct
name|minimal_symbol
modifier|*
name|find_minsym_and_objfile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
modifier|*
name|objfile_p
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|ALL_OBJFILE_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msym
argument_list|)
block|{
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|objfile_p
operator|=
name|objfile
expr_stmt|;
return|return
name|msym
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|skip_hurd_resolver
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* The HURD dynamic linker is part of the GNU C library, so many      GNU/Linux distributions use it.  (All ELF versions, as far as I      know.)  An unresolved PLT entry points to "_dl_runtime_resolve",      which calls "fixup" to patch the PLT, and then passes control to      the function.       We look for the symbol `_dl_runtime_resolve', and find `fixup' in      the same objfile.  If we are at the entry point of `fixup', then      we set a breakpoint at the return address (at the top of the      stack), and continue.         It's kind of gross to do all these checks every time we're      called, since they don't change once the executable has gotten      started.  But this is only a temporary hack --- upcoming versions      of GNU/Linux will provide a portable, efficient interface for      debugging programs that use shared libraries.  */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|resolver
init|=
name|find_minsym_and_objfile
argument_list|(
literal|"_dl_runtime_resolve"
argument_list|,
operator|&
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolver
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|fixup
init|=
name|lookup_minimal_symbol
argument_list|(
literal|"fixup"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixup
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fixup
argument_list|)
operator|==
name|pc
condition|)
return|return
operator|(
name|SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See the comments for SKIP_SOLIB_RESOLVER at the top of infrun.c.    This function:    1) decides whether a PLT has sent us into the linker to resolve       a function reference, and     2) if so, tells us where to set a temporary breakpoint that will       trigger when the dynamic linker is done.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_linux_skip_solib_resolver
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|result
decl_stmt|;
comment|/* Plug in functions for other kinds of resolvers here.  */
name|result
operator|=
name|skip_hurd_resolver
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The constants below were determined by examining the following files    in the linux kernel sources:        arch/arm/kernel/signal.c 	  - see SWI_SYS_SIGRETURN and SWI_SYS_RT_SIGRETURN       include/asm-arm/unistd.h 	  - see __NR_sigreturn, __NR_rt_sigreturn, and __NR_SYSCALL_BASE */
end_comment

begin_define
define|#
directive|define
name|ARM_LINUX_SIGRETURN_INSTR
value|0xef900077
end_define

begin_define
define|#
directive|define
name|ARM_LINUX_RT_SIGRETURN_INSTR
value|0xef9000ad
end_define

begin_comment
comment|/* arm_linux_in_sigtramp determines if PC points at one of the    instructions which cause control to return to the Linux kernel upon    return from a signal handler.  FUNC_NAME is unused.  */
end_comment

begin_function
name|int
name|arm_linux_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|inst
operator|==
name|ARM_LINUX_SIGRETURN_INSTR
operator|||
name|inst
operator|==
name|ARM_LINUX_RT_SIGRETURN_INSTR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_linux_sigcontext_register_address returns the address in the    sigcontext of register REGNO given a stack pointer value SP and    program counter value PC.  The value 0 is returned if PC is not    pointing at one of the signal return instructions or if REGNO is    not saved in the sigcontext struct.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_linux_sigcontext_register_address
parameter_list|(
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|CORE_ADDR
name|reg_addr
init|=
literal|0
decl_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|==
name|ARM_LINUX_SIGRETURN_INSTR
operator|||
name|inst
operator|==
name|ARM_LINUX_RT_SIGRETURN_INSTR
condition|)
block|{
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
comment|/* The sigcontext structure is at different places for the two          signal return instructions.  For ARM_LINUX_SIGRETURN_INSTR, 	 it starts at the SP value.  For ARM_LINUX_RT_SIGRETURN_INSTR, 	 it is at SP+8.  For the latter instruction, it may also be 	 the case that the address of this structure may be determined 	 by reading the 4 bytes at SP, but I'm not convinced this is 	 reliable.  	 In any event, these magic constants (0 and 8) may be 	 determined by examining struct sigframe and struct 	 rt_sigframe in arch/arm/kernel/signal.c in the Linux kernel 	 sources.  */
if|if
condition|(
name|inst
operator|==
name|ARM_LINUX_RT_SIGRETURN_INSTR
condition|)
name|sigcontext_addr
operator|=
name|sp
operator|+
literal|8
expr_stmt|;
else|else
comment|/* inst == ARM_LINUX_SIGRETURN_INSTR */
name|sigcontext_addr
operator|=
name|sp
operator|+
literal|0
expr_stmt|;
comment|/* The layout of the sigcontext structure for ARM GNU/Linux is          in include/asm-arm/sigcontext.h in the Linux kernel sources.  	 There are three 4-byte fields which precede the saved r0 	 field.  (This accounts for the 12 in the code below.)  The 	 sixteen registers (4 bytes per field) follow in order.  The 	 PSR value follows the sixteen registers which accounts for 	 the constant 19 below. */
if|if
condition|(
literal|0
operator|<=
name|regno
operator|&&
name|regno
operator|<=
name|ARM_PC_REGNUM
condition|)
name|reg_addr
operator|=
name|sigcontext_addr
operator|+
literal|12
operator|+
operator|(
literal|4
operator|*
name|regno
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARM_PS_REGNUM
condition|)
name|reg_addr
operator|=
name|sigcontext_addr
operator|+
literal|19
operator|*
literal|4
expr_stmt|;
block|}
return|return
name|reg_addr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_linux_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|tdep
operator|->
name|lowest_pc
operator|=
literal|0x8000
expr_stmt|;
name|tdep
operator|->
name|arm_breakpoint
operator|=
name|arm_linux_arm_le_breakpoint
expr_stmt|;
name|tdep
operator|->
name|arm_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_linux_arm_le_breakpoint
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|jb_pc
operator|=
name|JB_PC
expr_stmt|;
name|tdep
operator|->
name|jb_elt_size
operator|=
name|JB_ELEMENT_SIZE
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|arm_linux_call_dummy_words
argument_list|)
expr_stmt|;
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_linux_call_dummy_words
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The following two overrides shouldn't be needed.  */
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|arm_linux_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|arm_linux_push_arguments
argument_list|)
expr_stmt|;
comment|/* Shared library handling.  */
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|in_plt_section
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|find_solib_trampoline_target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_arm_linux_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|arm_gdbarch_register_os_abi
argument_list|(
name|ARM_ABI_LINUX
argument_list|,
name|arm_linux_init_abi
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

