begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Acorn Risc Machine host machine support.    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"arm-opcode.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0x8000
end_define

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|(hdr.a_text + 0x8000)
end_define

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
comment|/* Original value discarded */
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_ar0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
decl_stmt|;
name|offset
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|offset
argument_list|,
literal|0
argument_list|)
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
name|regno
operator|++
control|)
block|{
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
literal|4
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|GET_PC_PART
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|offset
operator|+
name|PC
operator|*
literal|4
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* set virtual register ps same as pc */
comment|/* read the floating point registers */
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_fp_regs
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPS_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|16
init|;
name|regno
operator|<
literal|24
condition|;
name|regno
operator|++
control|)
block|{
name|regaddr
operator|=
name|offset
operator|+
literal|4
operator|+
literal|12
operator|*
operator|(
name|regno
operator|-
literal|16
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_ar0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
decl_stmt|;
name|offset
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|offset
argument_list|,
literal|0
argument_list|)
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|16
condition|)
return|return;
name|regaddr
operator|=
name|offset
operator|+
literal|4
operator|*
name|regno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|value
operator|=
name|SET_PC_PART
argument_list|(
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|15
condition|;
name|regno
operator|++
control|)
block|{
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
literal|4
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|value
operator|=
name|SET_PC_PART
argument_list|(
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing all regs, number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Work with core dump and executable files, for GDB.     This code would be in corefile.c if it weren't machine-dependent. */
end_comment

begin_comment
comment|/* Structure to describe the chain of shared libraries used    by the execfile.    e.g. prog shares Xt which shares X11 which shares c. */
end_comment

begin_struct
struct|struct
name|shared_library
block|{
name|struct
name|exec_header
name|header
decl_stmt|;
name|char
name|name
index|[
name|SHLIBLEN
index|]
decl_stmt|;
name|CORE_ADDR
name|text_start
decl_stmt|;
comment|/* CORE_ADDR of 1st byte of text, this file */
name|long
name|data_offset
decl_stmt|;
comment|/* offset of data section in file */
name|int
name|chan
decl_stmt|;
comment|/* file descriptor for the file */
name|struct
name|shared_library
modifier|*
name|shares
decl_stmt|;
comment|/* library this one shares */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|shared_library
modifier|*
name|shlib
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|unshared_text_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extended header from exec file (for shared library info) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|exec_header
name|exec_header
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the program with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 4.2-style (and perhaps also sysV-style) core dump file.  */
block|{
name|struct
name|user
name|u
decl_stmt|;
name|unsigned
name|int
name|reg_offset
decl_stmt|,
name|fp_reg_offset
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Not a core file: reading upage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
name|error
argument_list|(
literal|"Not a core file: could only read %d bytes"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* We are depending on exec_file_command having been called 	   previously to set exec_data_start.  Since the executable 	   and the core file share the same text segment, the address 	   of the data segment will be the same in both.  */
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|)
expr_stmt|;
comment|/* Some machines put an absolute address in here and some put 	   the offset in the upage of the regs.  */
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|>
name|NBPG
operator|*
name|UPAGES
condition|)
name|reg_offset
operator|-=
name|KERNEL_U_ADDR
expr_stmt|;
name|fp_reg_offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_fp_regs
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
comment|/* I don't know where to find this info. 	   So, for now, mark it as not available.  */
name|N_SET_MAGIC
argument_list|(
name|core_aouthdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the register values out of the core file and store 	   them where `read_register' will find them.  */
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|16
condition|)
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|reg_offset
operator|+
literal|4
operator|*
name|regno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|<
literal|24
condition|)
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|fp_reg_offset
operator|+
literal|4
operator|+
literal|12
operator|*
operator|(
name|regno
operator|-
literal|24
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
literal|24
condition|)
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|fp_reg_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
literal|25
condition|)
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|reg_offset
operator|+
literal|4
operator|*
name|PC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"Reading register "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
operator|=
name|GET_PC_PART
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work with core dump and executable files, for GDB.     This code would be in corefile.c if it weren't machine-dependent. */
end_comment

begin_comment
comment|/* Structure to describe the chain of shared libraries used    by the execfile.    e.g. prog shares Xt which shares X11 which shares c. */
end_comment

begin_comment
unit|struct shared_library {     struct exec_header header;     char name[SHLIBLEN];     CORE_ADDR text_start;
comment|/* CORE_ADDR of 1st byte of text, this file */
end_comment

begin_comment
unit|long data_offset;
comment|/* offset of data section in file */
end_comment

begin_comment
unit|int chan;
comment|/* file descriptor for the file */
end_comment

begin_comment
unit|struct shared_library *shares;
comment|/* library this one shares */
end_comment

begin_comment
unit|}; static struct shared_library *shlib = 0;
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_comment
unit|extern void (*exec_file_display_hook) ();     static CORE_ADDR unshared_text_start;
comment|/* extended header from exec file (for shared library info) */
end_comment

begin_comment
unit|static struct exec_header exec_header;  void exec_file_command (filename, from_tty)      char *filename;      int from_tty; {   int val;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
end_comment

begin_comment
unit|if (execfile)     free (execfile);   execfile = 0;   data_start = 0;   data_end -= exec_data_start;   text_start = 0;   unshared_text_start = 0;   text_end = 0;   exec_data_start = 0;   exec_data_end = 0;   if (execchan>= 0)     close (execchan);   execchan = -1;   if (shlib) {       close_shared_library(shlib);       shlib = 0;   }
comment|/* Now open and digest the file the user requested, if any.  */
end_comment

begin_ifdef
unit|if (filename)     {       filename = tilde_expand (filename);       make_cleanup (free, filename);        execchan = openp (getenv ("PATH"), 1, filename, O_RDONLY, 0,&execfile);       if (execchan< 0) 	perror_with_name (filename);        { 	struct stat st_exec;
ifdef|#
directive|ifdef
name|HEADER_SEEK_FD
end_ifdef

begin_endif
unit|HEADER_SEEK_FD (execchan);
endif|#
directive|endif
end_endif

begin_comment
unit|val = myread (execchan,&exec_header, sizeof exec_header); 	exec_aouthdr = exec_header.a_exec;  	if (val< 0) 	  perror_with_name (filename);  	text_start = 0x8000;
comment|/* Look for shared library if needed */
end_comment

begin_comment
unit|if (exec_header.a_exec.a_magic& MF_USES_SL) 	    shlib = open_shared_library(exec_header.a_shlibname, text_start);  	text_offset = N_TXTOFF (exec_aouthdr); 	exec_data_offset = N_TXTOFF (exec_aouthdr) + exec_aouthdr.a_text;  	if (shlib) { 	    unshared_text_start = shared_text_end(shlib)& ~0x7fff; 	    stack_start = shlib->header.a_exec.a_sldatabase; 	    stack_end = STACK_END_ADDR; 	} else 	    unshared_text_start = 0x8000; 	text_end = unshared_text_start + exec_aouthdr.a_text;  	exec_data_start = unshared_text_start + exec_aouthdr.a_text;         exec_data_end = exec_data_start + exec_aouthdr.a_data;  	data_start = exec_data_start; 	data_end += exec_data_start;  	fstat (execchan,&st_exec); 	exec_mtime = st_exec.st_mtime;       }        validate_files ();     }   else if (from_tty)     printf ("No executable file now.\n");
comment|/* Tell display code (if any) about the changed file name.  */
end_comment

begin_endif
unit|if (exec_file_display_hook)     (*exec_file_display_hook) (filename); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Read from the program's memory (except for inferior processes).    This function is misnamed, since it only reads, never writes; and    since it will use the core file and/or executable file as necessary.     It should be extended to write as well as read, FIXME, for patching files.     Return 0 if address could be read, EIO if addresss out of bounds.  */
end_comment

begin_comment
unit|int xfer_core_file (memaddr, myaddr, len)      CORE_ADDR memaddr;      char *myaddr;      int len; {   register int i;   register int val;   int xferchan;   char **xferfile;   int fileptr;   int returnval = 0;    while (len> 0)     {       xferfile = 0;       xferchan = 0;
comment|/* Determine which file the next bunch of addresses reside in, 	 and where in the file.  Set the file's read/write pointer 	 to point at the proper place for the desired address 	 and set xferfile and xferchan for the correct file.  	 If desired address is nonexistent, leave them zero.  	 i is set to the number of bytes that can be handled 	 along with the next address.  	 We put the most likely tests first for efficiency.  */
end_comment

begin_comment
comment|/* Note that if there is no core file 	 data_start and data_end are equal.  */
end_comment

begin_comment
unit|if (memaddr>= data_start&& memaddr< data_end) 	{ 	  i = min (len, data_end - memaddr); 	  fileptr = memaddr - data_start + data_offset; 	  xferfile =&corefile; 	  xferchan = corechan; 	}
comment|/* Note that if there is no core file 	 stack_start and stack_end define the shared library data.  */
end_comment

begin_comment
unit|else if (memaddr>= stack_start&& memaddr< stack_end) 	{ 	    if (corechan< 0) { 		struct shared_library *lib; 		for (lib = shlib; lib; lib = lib->shares) 		    if (memaddr>= lib->header.a_exec.a_sldatabase&& 			memaddr< lib->header.a_exec.a_sldatabase + 			  lib->header.a_exec.a_data) 			break; 		if (lib) { 		    i = min (len, lib->header.a_exec.a_sldatabase + 			     lib->header.a_exec.a_data - memaddr); 		    fileptr = lib->data_offset + memaddr - 			lib->header.a_exec.a_sldatabase; 		    xferfile = execfile; 		    xferchan = lib->chan; 		} 	    } else { 		i = min (len, stack_end - memaddr); 		fileptr = memaddr - stack_start + stack_offset; 		xferfile =&corefile; 		xferchan = corechan; 	    } 	}       else if (corechan< 0&& memaddr>= exec_data_start&& memaddr< exec_data_end) 	{ 	  i = min (len, exec_data_end - memaddr); 	  fileptr = memaddr - exec_data_start + exec_data_offset; 	  xferfile =&execfile; 	  xferchan = execchan; 	}       else if (memaddr>= text_start&& memaddr< text_end) 	{ 	    struct shared_library *lib; 	    for (lib = shlib; lib; lib = lib->shares) 		if (memaddr>= lib->text_start&& 		    memaddr< lib->text_start + lib->header.a_exec.a_text) 		    break; 	    if (lib) { 		i = min (len, lib->header.a_exec.a_text + 			 lib->text_start - memaddr); 		fileptr = memaddr - lib->text_start + text_offset; 		xferfile =&execfile; 		xferchan = lib->chan; 	    } else { 		i = min (len, text_end - memaddr); 		fileptr = memaddr - unshared_text_start + text_offset; 		xferfile =&execfile; 		xferchan = execchan; 	    } 	}       else if (memaddr< text_start) 	{ 	  i = min (len, text_start - memaddr); 	}       else if (memaddr>= text_end&& memaddr< (corechan>= 0? data_start : exec_data_start)) 	{ 	  i = min (len, data_start - memaddr); 	}       else if (corechan>= 0&& memaddr>= data_end&& memaddr< stack_start) 	{ 	  i = min (len, stack_start - memaddr); 	}       else if (corechan< 0&& memaddr>= exec_data_end) 	{ 	  i = min (len, - memaddr); 	}       else if (memaddr>= stack_end&& stack_end != 0) 	{ 	  i = min (len, - memaddr); 	}       else 	{
comment|/* Address did not classify into one of the known ranges. 	     This shouldn't happen; we catch the endpoints.  */
end_comment

begin_comment
unit|fatal ("Internal: Bad case logic in xfer_core_file."); 	}
comment|/* Now we know which file to use. 	 Set up its pointer and transfer the data.  */
end_comment

begin_comment
unit|if (xferfile) 	{ 	  if (*xferfile == 0) 	    if (xferfile ==&execfile) 	      error ("No program file to examine."); 	    else 	      error ("No core dump file or running program to examine."); 	  val = lseek (xferchan, fileptr, 0); 	  if (val< 0) 	    perror_with_name (*xferfile); 	  val = myread (xferchan, myaddr, i); 	  if (val< 0) 	    perror_with_name (*xferfile); 	}
comment|/* If this address is for nonexistent memory, 	 read zeros if reading, or do nothing if writing. 	 Actually, we never right.  */
end_comment

begin_endif
unit|else 	{ 	  memset (myaddr, '\0', i); 	  returnval = EIO; 	}        memaddr += i;       myaddr += i;       len -= i;     }   return returnval; }
endif|#
directive|endif
end_endif

end_unit

