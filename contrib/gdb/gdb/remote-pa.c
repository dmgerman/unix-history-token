begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for serial-line targets in custom GDB protocol    Copyright 1988, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Remote communication protocol.     A debug packet whose contents are<data>    is encapsulated for transmission in the form:  	$<data> # CSUM1 CSUM2<data> must be ASCII alphanumeric and cannot include characters 	'$' or '#'.  If<data> starts with two characters followed by 	':', then the existing stubs interpret this as a sequence number.  	CSUM1 and CSUM2 are ascii hex representation of an 8-bit  	checksum of<data>, the most significant nibble is sent first. 	the hex digits 0-9,a-f are used.     Receiver responds with:  	+	- if CSUM is correct and ready for next packet 	-	- if CSUM is incorrect<data> is as follows:    All values are encoded in ascii hex digits.  	Request		Packet  	read registers  g 	reply		XX....X		Each byte of register data 					is described by two hex digits. 					Registers are in the internal order 					for GDB, and the bytes in a register 					are in the same order the machine uses. 			or ENN		for an error.  	write regs	GXX..XX		Each byte of register data 					is described by two hex digits. 	reply		OK		for success 			ENN		for an error          write reg	Pn...=r...	Write register n... with value r..., 					which contains two hex digits for each 					byte in the register (target byte 					order). 	reply		OK		for success 			ENN		for an error 	(not supported by all stubs).  	read mem	mAA..AA,LLLL	AA..AA is address, LLLL is length. 	reply		XX..XX		XX..XX is mem contents 					Can be fewer bytes than requested 					if able to read only part of the data. 			or ENN		NN is errno  	write mem	MAA..AA,LLLL:XX..XX 					AA..AA is address, 					LLLL is number of bytes, 					XX..XX is data 	reply		OK		for success 			ENN		for an error (this includes the case 					where only part of the data was 					written).  	cont		cAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	step		sAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	last signal     ?               Reply the current reason for stopping.                                         This is the same reply as is generated 					for step or cont : SAA where AA is the 					signal number.  	There is no immediate reply to step or cont. 	The reply comes when the machine stops. 	It is		SAA		AA is the "signal number"  	or...		TAAn...:r...;n:r...;n...:r...; 					AA = signal number 					n... = register number 					r... = register contents 	or...		WAA		The process exited, and AA is 					the exit status.  This is only 					applicable for certains sorts of 					targets. 	kill request	k  	toggle debug	d		toggle debug flag (see 386& 68k stubs) 	reset		r		reset -- see sparc stub. 	reserved<other>		On other requests, the stub should 					ignore the request and send an empty 					response ($#<checksum>).  This way 					we can extend the protocol and GDB 					can tell whether the stub it is 					talking to uses the old or the new. 	search		tAA:PP,MM	Search backwards starting at address 					AA for a match with pattern PP and 					mask MM.  PP and MM are 4 bytes. 					Not supported by all stubs.  	general query	qXXXX		Request info about XXXX. 	general set	QXXXX=yyyy	Set value of XXXX to yyyy. 	query sect offs	qOffsets	Get section offsets.  Reply is 					Text=xxx;Data=yyy;Bss=zzz 	console output	Otext		Send text to stdout.  Only comes from 					remote target.  	Responses can be run-length encoded to save space.  A '*' means that 	the next character is an ASCII encoding giving a repeat count which 	stands for that many repititions of the character preceding the '*'. 	The encoding is n+29, yielding a printable character where n>=3  	(which is where rle starts to win).  Don't use an n> 126.  	So  	"0* " means the same as "0000".  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_write_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_read_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|should_write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_start_remote
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|forever
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_send
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tohex
name|PARAMS
argument_list|(
operator|(
name|int
name|nib
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fromhex
name|PARAMS
argument_list|(
operator|(
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt_twice
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|interrupt_query
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hppro_load
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_comment
comment|/* This was 5 seconds, which is a long time to sit and wait.    Unless this is going though some terminal server or multiplexer or    other form of hairy serial connection, I would think 2 seconds would    be plenty.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    remote_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|extern
name|serial_t
name|remote_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Having this larger than 400 causes us to be incompatible with m68k-stub.c    and i386-stub.c.  Normally, no one would notice because it only matters    for writing large chunks of memory (e.g. in downloads).  Also, this needs    to be more than 400 if required to hold the registers (see below, where    we round it up based on REGISTER_BYTES).  */
end_comment

begin_define
define|#
directive|define
name|PBUFSIZ
value|400
end_define

begin_comment
comment|/* Maximum number of bytes to read/write at once.  The value here    is chosen to fill up a packet (the headers account for the 32).  */
end_comment

begin_define
define|#
directive|define
name|MAXBUFBYTES
value|((PBUFSIZ-32)/2)
end_define

begin_comment
comment|/* Round up PBUFSIZ to hold all the registers, at least.  */
end_comment

begin_comment
comment|/* The blank line after the #if seems to be required to work around a    bug in HP's PA compiler.  */
end_comment

begin_if
if|#
directive|if
name|REGISTER_BYTES
operator|>
name|MAXBUFBYTES
end_if

begin_undef
undef|#
directive|undef
name|PBUFSIZ
end_undef

begin_define
define|#
directive|define
name|PBUFSIZ
value|(REGISTER_BYTES * 2 + 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Should we try the 'P' request?  If this is set to one when the stub    doesn't support 'P', the only consequence is some unnecessary traffic.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stub_supports_P
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sets the download protocol, choices are srec, generic, boot */
end_comment

begin_decl_stmt
name|char
modifier|*
name|loadtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|loadtype_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_loadtype_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|hppro_load
parameter_list|(
name|file
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|puts
argument_list|(
literal|"Loading... HA!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|remote_desc
condition|)
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Query the remote side for the text, data and bss offsets. */
end_comment

begin_function
specifier|static
name|void
name|get_offsets
parameter_list|()
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|nvals
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|,
name|data_addr
decl_stmt|,
name|bss_addr
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
name|putpkt
argument_list|(
literal|"qOffsets"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return;
comment|/* Return silently.  Stub doesn't support this 				   command. */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvals
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"Text=%lx;Data=%lx;Bss=%lx"
argument_list|,
operator|&
name|text_addr
argument_list|,
operator|&
name|data_addr
argument_list|,
operator|&
name|bss_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvals
operator|!=
literal|3
condition|)
name|error
argument_list|(
literal|"Malformed response to offset query, %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
name|offs
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This code assumes gdb-stabs.h is being used; it's broken      for xcoff, dwarf, sdb-coff, etc.  But there is no simple      canonical representation for this stuff.  (Just what does "text"      as seen by the stub mean, anyway?  I think it means all sections      with SEC_CODE set, but we currently have no way to deal with that).  */
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
name|text_addr
expr_stmt|;
comment|/* This is a temporary kludge to force data and bss to use the same offsets      because that's what nlmconv does now.  The real solution requires changes      to the stub and remote.c that I don't have time to do right now.  */
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|INBUFSIZE
value|10
end_define

begin_function
name|void
name|boot_board
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|char
name|buf
index|[
name|INBUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* See if we can connect to the boot ROM command line */
name|ptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr_get_debug
argument_list|()
operator|>
literal|2
operator|)
operator|&&
operator|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|puts_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|2
condition|)
name|puts
argument_list|(
literal|"Got ACK from stub"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|2
condition|)
name|puts
argument_list|(
literal|"Got prompt from ROM monitor"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|remote_start_remote
parameter_list|(
name|dummy
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|timeout
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Ack any packet which the remote side has already sent.  */
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|puts
argument_list|(
literal|"Trying a '+' to ACK the target."
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|boot_board();    get_offsets ();
comment|/* Get text, data& bss offsets */
endif|#
directive|endif
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
comment|/* initiate a query from remote machine */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
comment|/* Initialize gdb process mechanisms */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|remote_dcache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a remote debug connection, you need to specify what serial\n\ device is attached to the remote system (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|remote_dcache
operator|=
name|dcache_init
argument_list|(
name|remote_read_bytes
argument_list|,
name|remote_write_bytes
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|remote_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote debugging using "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
comment|/* Start out by trying the 'P' request to set registers.  We set this each      time that we open a new target so that if the user switches from one      stub to another, we can (if the target is closed and reopened) cope.  */
name|stub_supports_P
operator|=
literal|1
expr_stmt|;
comment|/* Without this, some commands which require an active target (such as kill)      won't work.  This variable serves (at least) double duty as both the pid      of the target process (if it has such), and as a flag indicating that a      target is active.  These functions should be split out into seperate      variables, especially since GDB will someday have a notion of debugging      several processes.  */
name|inferior_pid
operator|=
literal|42000
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|remote_start_remote
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remote_detach()    takes a program previously attached to and detaches it.    We better not have left any breakpoints    in the program or it'll die when it hits one.    Close the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|remote_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|remote_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|siggnal
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Can't send signals to a remote system.  %s not sent.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|siggnal
argument_list|)
argument_list|)
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
name|dcache_flush
argument_list|(
name|remote_dcache
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"remote_interrupt called\n"
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send a ^C */
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt_twice
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid" (though it's not clear what, if anything, that    means in the case of this target).  */
end_comment

begin_function
specifier|static
name|int
name|remote_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Error of some sort */
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* Status with PC, SP, FP, ... */
block|{
name|int
name|i
decl_stmt|;
name|long
name|regno
decl_stmt|;
name|char
name|regs
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
comment|/* Expedited reply, containing Signal, {regno, reg} repeat */
comment|/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where 		ss = signal number 		n... = register number 		r... = register contents 		*/
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
comment|/* after Txx */
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|regno
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Read the register number */
if|if
condition|(
name|p1
operator|==
name|p
condition|)
name|warning
argument_list|(
literal|"Remote sent badly formed register number: %s\nPacket: '%s'\n"
argument_list|,
name|p1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
name|warning
argument_list|(
literal|"Malformed packet (missing colon): %s\nPacket: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|warning
argument_list|(
literal|"Remote sent bad register number %d: %s\nPacket: '%s'\n"
argument_list|,
name|regno
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|';'
condition|)
name|warning
argument_list|(
literal|"Remote register badly formatted: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fall through */
case|case
literal|'S'
case|:
comment|/* Old style status, just signal only */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
return|return
name|inferior_pid
return|;
case|case
literal|'W'
case|:
comment|/* Target exited */
block|{
comment|/* The remote process exited.  */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
case|case
literal|'O'
case|:
comment|/* Console output */
name|fputs_filtered
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|warning
argument_list|(
literal|"Invalid remote reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of registers this stub implements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|register_bytes_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|regs
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"g"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* We can get out of synch in various cases.  If the first character      in the buffer is not a hex character, assume that has happened      and try to fetch another packet to read.  */
while|while
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'a'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'f'
operator|)
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Bad register packet; fetching a new packet\n"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Reply describes registers byte by byte, each byte encoded as two      hex characters.  Suck them all up, then supply them to the      register cacheing/storage mechanism.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_BYTES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Remote reply is of odd length: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't change register_bytes_found in this case, and don't 	     print a second warning.  */
goto|goto
name|supply_them
goto|;
block|}
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|register_bytes_found
condition|)
block|{
name|register_bytes_found
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_BYTES_OK
if|if
condition|(
operator|!
name|REGISTER_BYTES_OK
argument_list|(
name|i
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|supply_them
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|regs
index|[
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we may send them all (using a    'G' request), we have to read out the ones we don't want to change    first.  */
end_comment

begin_function
specifier|static
name|void
name|remote_prepare_to_store
parameter_list|()
block|{
comment|/* Make sure the entire registers array is valid.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|remote_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|stub_supports_P
condition|)
block|{
comment|/* Try storing a single register.  */
name|char
modifier|*
name|regp
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"P%x="
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regp
operator|=
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|regp
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|regp
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* The stub understands the 'P' request.  We are done.  */
return|return;
block|}
comment|/* The stub does not support the 'P' request.  Use 'G' instead, 	 and don't try using 'P' in the future (it will just waste our 	 time).  */
name|stub_supports_P
operator|=
literal|0
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'G'
expr_stmt|;
comment|/* Command describes registers byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
comment|/* remote_prepare_to_store insures that register_bytes_found gets set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_bytes_found
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|registers
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|registers
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Use of the data cache is disabled because it loses for looking at    and changing hardware I/O ports and the like.  Accepting `volatile'    would perhaps be one way to fix it.  Another idea would be to use the    executable file for the text segment (for all SEC_CODE sections?    For all SEC_READONLY sections?).  This has problems if you want to    actually see what the memory contains (e.g. self-modifying code,    clobbered memory, user downloaded the wrong thing).  */
end_comment

begin_comment
comment|/* Read a word from remote address ADDR and return it.    This goes through the data cache.  */
end_comment

begin_comment
unit|static int remote_fetch_word (addr)      CORE_ADDR addr; {   return dcache_fetch (remote_dcache, addr); }
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_endif
unit|static void remote_store_word (addr, word)      CORE_ADDR addr;      int word; {   dcache_poke (remote_dcache, addr, word); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_write_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* FIXME-32x64: Need a version of print_address_numeric which puts the      result in a buffer like sprintf.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"M%lx,%x:"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* We send target system values byte by byte, in increasing byte addresses,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|myaddr
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	 for errors and errno codes.  We would like a cleaner way of 	 representing errors (big enough to include errno codes, bfd_error 	 codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_read_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|PBUFSIZ
operator|/
literal|2
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME-32x64: Need a version of print_address_numeric which puts the      result in a buffer like sprintf.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m%lx,%x"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	 for errors and errno codes.  We would like a cleaner way of 	 representing errors (big enough to include errno codes, bfd_error 	 codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Reply describes memory byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* Reply is short.  This means that we were able to read only part 	   of what we wanted to.  */
break|break;
name|myaddr
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.  Returns length of data written or read; 0 for error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|remote_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|xfersize
decl_stmt|;
name|int
name|bytes_xferred
decl_stmt|;
name|int
name|total_xferred
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|MAXBUFBYTES
condition|)
name|xfersize
operator|=
name|MAXBUFBYTES
expr_stmt|;
else|else
name|xfersize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|should_write
condition|)
name|bytes_xferred
operator|=
name|remote_write_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
else|else
name|bytes_xferred
operator|=
name|remote_read_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
comment|/* If we get an error, we are done xferring.  */
if|if
condition|(
name|bytes_xferred
operator|==
literal|0
condition|)
break|break;
name|memaddr
operator|+=
name|bytes_xferred
expr_stmt|;
name|myaddr
operator|+=
name|bytes_xferred
expr_stmt|;
name|len
operator|-=
name|bytes_xferred
expr_stmt|;
name|total_xferred
operator|+=
name|bytes_xferred
expr_stmt|;
block|}
return|return
name|total_xferred
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Enable after 4.12.  */
end_comment

begin_comment
unit|void remote_search (len, data, mask, startaddr, increment, lorange, hirange 	       addr_found, data_found)      int len;      char *data;      char *mask;      CORE_ADDR startaddr;      int increment;      CORE_ADDR lorange;      CORE_ADDR hirange;      CORE_ADDR *addr_found;      char *data_found; {   if (increment == -4&& len == 4)     {       long mask_long, data_long;       long data_found_long;       CORE_ADDR addr_we_found;       char buf[PBUFSIZ];       long returned_long[2];       char *p;        mask_long = extract_unsigned_integer (mask, len);       data_long = extract_unsigned_integer (data, len);       sprintf (buf, "t%x:%x,%x", startaddr, data_long, mask_long);       putpkt (buf);       getpkt (buf, 0);       if (buf[0] == '\0') 	{
comment|/* The stub doesn't support the 't' request.  We might want to 	     remember this fact, but on the other hand the stub could be 	     switched on us.  Maybe we should remember it only until 	     the next "target remote".  */
end_comment

begin_comment
unit|generic_search (len, data, mask, startaddr, increment, lorange, 			  hirange, addr_found, data_found); 	  return; 	}        if (buf[0] == 'E')
comment|/* There is no correspondance between what the remote protocol uses 	   for errors and errno codes.  We would like a cleaner way of 	   representing errors (big enough to include errno codes, bfd_error 	   codes, and others).  But for now just use EIO.  */
end_comment

begin_comment
unit|memory_error (EIO, startaddr);       p = buf;       addr_we_found = 0;       while (*p != '\0'&& *p != ',') 	addr_we_found = (addr_we_found<< 4) + fromhex (*p++);       if (*p == '\0') 	error ("Protocol error: short return for search");        data_found_long = 0;       while (*p != '\0'&& *p != ',') 	data_found_long = (data_found_long<< 4) + fromhex (*p++);
comment|/* Ignore anything after this comma, for future extensions.  */
end_comment

begin_endif
unit|if (addr_we_found< lorange || addr_we_found>= hirange) 	{ 	  *addr_found = 0; 	  return; 	}        *addr_found = addr_we_found;       *data_found = store_unsigned_integer (data_we_found, len);       return;     }   generic_search (len, data, mask, startaddr, increment, lorange, 		  hirange, addr_found, data_found); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote end, masking it down to 7 bits. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|remote_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
return|return
name|ch
return|;
default|default:
return|return
name|ch
operator|&
literal|0x7f
return|;
block|}
block|}
end_function

begin_comment
comment|/* Send the command in BUF to the remote machine,    and read the reply into BUF.    Report an error if we get an error reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_send
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.    The data of the packet is in BUF.  */
end_comment

begin_function
specifier|static
name|void
name|putpkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
name|buf2
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|cnt
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
if|if
condition|(
name|cnt
operator|>
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
operator|-
literal|5
condition|)
comment|/* Prosanity check */
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|started_error_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Sending packet: %s..."
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"putpkt: write failed"
argument_list|)
expr_stmt|;
comment|/* read until either a timeout occurs (-2) or '+' is read */
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
case|case
name|SERIAL_TIMEOUT
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|started_error_output
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|started_error_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Got Ack\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERIAL_TIMEOUT
case|:
break|break;
comment|/* Retransmit buffer */
case|case
literal|'$'
case|:
block|{
name|unsigned
name|char
name|junkbuf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* It's probably an old response, and we're out of sync.  Just 		 gobble up the packet and ignore it.  */
name|getpkt
argument_list|(
name|junkbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Now, go look for + */
block|}
default|default:
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
operator|!
name|started_error_output
condition|)
block|{
name|started_error_output
operator|=
literal|1
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"putpkt: Junk: "
argument_list|)
expr_stmt|;
block|}
name|putchar_unfiltered
argument_list|(
name|ch
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
comment|/* Here to retransmit */
block|}
if|#
directive|if
literal|0
comment|/* This is wrong.  If doing a long backtrace, the user should be 	 able to get out next time we call QUIT, without anything as violent 	 as interrupt_query.  If we want to provide a way out of here 	 without getting to the next QUIT, it should be based on hitting 	 ^C twice as in remote_wait.  */
block|if (quit_flag) 	{ 	  quit_flag = 0; 	  interrupt_query (); 	}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Come here after finding the start of the frame.  Collect the rest into BUF,    verifying the checksum, length, and handling run-length compression.    Returns 0 on any error, 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|read_frame
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
name|csum
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timeout in mid-packet, retrying\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Saw new packet start in middle of old one\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Start a new packet, count retries */
case|case
literal|'#'
case|:
block|{
name|unsigned
name|char
name|pktcsum
decl_stmt|;
operator|*
name|bp
operator|=
literal|'\000'
expr_stmt|;
name|pktcsum
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|pktcsum
operator||=
name|fromhex
argument_list|(
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
name|pktcsum
condition|)
return|return
literal|1
return|;
name|printf_filtered
argument_list|(
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf="
argument_list|,
name|pktcsum
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
literal|'*'
case|:
comment|/* Run length encoding */
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|c
operator|-
literal|' '
operator|+
literal|3
expr_stmt|;
comment|/* Compute repeat count */
if|if
condition|(
name|bp
operator|+
name|c
operator|-
literal|1
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bp
argument_list|,
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Repeat count %d too large for buffer: "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|bp
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Remote packet too long: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking,    and store it in BUF.  BUF is expected to be of size PBUFSIZ.    If FOREVER, wait forever rather than timing out; this is used    while the target is executing user code.  */
end_comment

begin_function
specifier|static
name|void
name|getpkt
parameter_list|(
name|buf
parameter_list|,
name|forever
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|forever
decl_stmt|;
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|forever
condition|)
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|timeout
operator|=
name|remote_timeout
expr_stmt|;
define|#
directive|define
name|MAX_TRIES
value|10
for|for
control|(
name|tries
operator|=
literal|1
init|;
name|tries
operator|<=
name|MAX_TRIES
condition|;
name|tries
operator|++
control|)
block|{
comment|/* This can loop forever if the remote side sends us characters 	 continuously, but if it pauses, we'll get a zero from readchar 	 because of timeout.  Then we'll count that as a retry.  */
comment|/* Note that we will only wait forever prior to the start of a packet. 	 After that, we expect characters to arrive at a brisk pace.  They 	 should show up within remote_timeout intervals.  */
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'$'
condition|)
do|;
comment|/* We've found the start of a packet, now collect the data.  */
name|val
operator|=
name|read_frame
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Packet received: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try the whole thing again.  */
name|retry
label|:
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We have tried hard enough, and just can't receive the packet.  Give up. */
name|printf_unfiltered
argument_list|(
literal|"Ignoring packet error, continuing...\n"
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_kill
parameter_list|()
block|{
name|putpkt
argument_list|(
literal|"k"
argument_list|)
expr_stmt|;
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  For the existing stubs, kill is a noop.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_mourn
parameter_list|()
block|{
name|unpush_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REMOTE_BREAKPOINT
end_ifdef

begin_comment
comment|/* On some machines, e.g. 68k, we may use a different breakpoint instruction    than other targets.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No REMOTE_BREAKPOINT.  */
end_comment

begin_comment
comment|/* Same old breakpoint instruction.  This code does nothing different    than mem-break.c.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No REMOTE_BREAKPOINT.  */
end_comment

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better breakpoint    support.  We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.  ADDR is the target    location in the target machine.  CONTENTS_CACHE is a pointer to     memory allocated for saving the target contents.  It is guaranteed    by the caller to be long enough to save sizeof BREAKPOINT bytes (this    is accomplished via BREAKPOINT_MAX).  */
end_comment

begin_function
specifier|static
name|int
name|remote_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|break_insn
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|remote_hppro_ops
init|=
block|{
literal|"hppro"
block|,
comment|/* to_shortname */
literal|"Remote serial target for HP-PRO targets"
block|,
comment|/* to_longname */
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ This is for targets that supports the HP-PRO standard.\n\ Specify the serial device it is connected to (e.g. /dev/ttya) or telnet port."
block|,
comment|/* to_doc */
name|remote_open
block|,
comment|/* to_open */
name|remote_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|remote_detach
block|,
comment|/* to_detach */
name|remote_resume
block|,
comment|/* to_resume */
name|remote_wait
block|,
comment|/* to_wait */
name|remote_fetch_registers
block|,
comment|/* to_fetch_registers */
name|remote_store_registers
block|,
comment|/* to_store_registers */
name|remote_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|remote_xfer_memory
block|,
comment|/* to_xfer_memory */
name|remote_files_info
block|,
comment|/* to_files_info */
name|remote_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|remote_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|remote_kill
block|,
comment|/* to_kill */
name|hppro_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|NULL
block|,
comment|/* to_create_inferior */
name|remote_mourn
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_hppro
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_target
argument_list|(
operator|&
name|remote_hppro_ops
argument_list|)
expr_stmt|;
comment|/* this sets the type of download protocol */
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"loadtype"
argument_list|,
name|no_class
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|loadtype_str
argument_list|,
literal|"Set the type of the remote load protocol.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_loadtype_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|loadtype_str
operator|=
name|savestring
argument_list|(
literal|"generic"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* this adds a command to boot the board */
name|add_com
argument_list|(
literal|"boot"
argument_list|,
name|class_support
argument_list|,
name|boot_board
argument_list|,
literal|"Boot the damn target board.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_loadtype_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|loadtype_str
operator|=
name|savestring
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

