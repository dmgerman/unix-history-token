begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for deciding which macros are currently in scope.    Copyright 2002 Free Software Foundation, Inc.    Contributed by Red Hat, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"macroscope.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_function
name|struct
name|macro_scope
modifier|*
name|sal_macro_scope
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|)
block|{
name|struct
name|macro_source_file
modifier|*
decl|main
decl_stmt|,
modifier|*
name|inclusion
decl_stmt|;
name|struct
name|macro_scope
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|sal
operator|.
name|symtab
operator|||
operator|!
name|sal
operator|.
name|symtab
operator|->
name|macro_table
condition|)
return|return
literal|0
return|;
name|ms
operator|=
operator|(
expr|struct
name|macro_scope
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ms
argument_list|)
argument_list|)
expr_stmt|;
expr|main
operator|=
name|macro_main
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|macro_table
argument_list|)
expr_stmt|;
name|inclusion
operator|=
name|macro_lookup_inclusion
argument_list|(
expr|main
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|inclusion
condition|)
block|{
name|ms
operator|->
name|file
operator|=
name|inclusion
expr_stmt|;
name|ms
operator|->
name|line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
block|}
else|else
block|{
comment|/* There are, unfortunately, cases where a compilation unit can          have a symtab for a source file that doesn't appear in the          macro table.  For example, at the moment, Dwarf doesn't have          any way in the .debug_macinfo section to describe the effect          of #line directives, so if you debug a YACC parser you'll get          a macro table which only mentions the .c files generated by          YACC, but symtabs that mention the .y files consumed by YACC.           In the long run, we should extend the Dwarf macro info          representation to handle #line directives, and get GCC to          emit it.           For the time being, though, we'll just treat these as          occurring at the end of the main source file.  */
name|ms
operator|->
name|file
operator|=
expr|main
expr_stmt|;
name|ms
operator|->
name|line
operator|=
operator|-
literal|1
expr_stmt|;
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"symtab found for `%s', but that file\n"
literal|"is not covered in the compilation unit's macro information"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|ms
return|;
block|}
end_function

begin_function
name|struct
name|macro_scope
modifier|*
name|default_macro_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|macro_source_file
modifier|*
decl|main
decl_stmt|;
name|struct
name|macro_scope
modifier|*
name|ms
decl_stmt|;
comment|/* If there's a selected frame, use its PC.  */
if|if
condition|(
name|deprecated_selected_frame
condition|)
name|sal
operator|=
name|find_pc_line
argument_list|(
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the target has any registers at all, then use its PC.  Why we      would have registers but no stack, I'm not sure.  */
elseif|else
if|if
condition|(
name|target_has_registers
condition|)
name|sal
operator|=
name|find_pc_line
argument_list|(
name|read_pc
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If all else fails, fall back to the current listing position.  */
else|else
block|{
comment|/* Don't call select_source_symtab here.  That can raise an          error if symbols aren't loaded, but GDB calls the expression          evaluator in all sorts of contexts.           For example, commands like `set width' call the expression          evaluator to evaluate their numeric arguments.  If the          current language is C, then that may call this function to          choose a scope for macro expansion.  If you don't have any          symbol files loaded, then get_current_or_default would raise an          error.  But `set width' shouldn't raise an error just because          it can't decide which scope to macro-expand its argument in.  */
name|struct
name|symtab_and_line
name|cursal
init|=
name|get_current_source_symtab_and_line
argument_list|()
decl_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|cursal
operator|.
name|symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|cursal
operator|.
name|line
expr_stmt|;
block|}
return|return
name|sal_macro_scope
argument_list|(
name|sal
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up the definition of the macro named NAME in scope at the source    location given by BATON, which must be a pointer to a `struct    macro_scope' structure.  */
end_comment

begin_function
name|struct
name|macro_definition
modifier|*
name|standard_macro_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|macro_scope
modifier|*
name|ms
init|=
operator|(
expr|struct
name|macro_scope
operator|*
operator|)
name|baton
decl_stmt|;
return|return
name|macro_lookup_definition
argument_list|(
name|ms
operator|->
name|file
argument_list|,
name|ms
operator|->
name|line
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

end_unit

