begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level stuff for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-script.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-setshow.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_comment
comment|/* For job_control.  */
end_comment

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"readline/history.h"
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"cli-out.h"
end_include

begin_comment
comment|/* Default command line prompt.  This is overriden in some configs. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PROMPT
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PROMPT
value|"(gdb) "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialization file name for gdb.  This is overridden in some configs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDBINIT_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|GDBINIT_FILENAME
value|".gdbinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|gdbinit
index|[]
init|=
name|GDBINIT_FILENAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inhibit_gdbinit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, and GDB has been configured to be able to use windows,    attempt to open them upon startup.  */
end_comment

begin_decl_stmt
name|int
name|use_windows
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|lang_frame_mismatch_warn
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* language.c */
end_comment

begin_comment
comment|/* Flag for whether we want all the "from_tty" gubbish printed.  */
end_comment

begin_decl_stmt
name|int
name|caution
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is yes, sigh. */
end_comment

begin_comment
comment|/* stdio stream that command input is being read from.  Set to stdin normally.    Set by source_command to the file we are sourcing.  Set to NULL if we are    executing a user-defined command or interacting via a GUI.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The directory name is actually stored here (usually).  */
end_comment

begin_decl_stmt
name|char
name|gdb_dirbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call before reading a command, if nonzero.    The function receives two args: an input stream,    and a prompt string.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|window_hook
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|epoch_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gdb prints this when reading a command interactively */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gdb_prompt_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the global prompt string */
end_comment

begin_comment
comment|/* Buffer used for reading command lines, and the size    allocated for it so far.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linesize
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current command is modified by "server ".  This    affects things like recording into the command history, commands    repeating on RETURN, etc.  This is so a user interface (emacs, GUI,    whatever) can issue its own commands and also send along commands    from the user, and have the user not notice that the user interface    is issuing commands too.  */
end_comment

begin_decl_stmt
name|int
name|server_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baud rate specified for talking to serial target systems.  Default    is left as -1, so targets can choose their own defaults.  */
end_comment

begin_comment
comment|/* FIXME: This means that "show remotebaud" and gr_files_info can print -1    or (unsigned int)-1.  This is a Bad User Interface.  */
end_comment

begin_decl_stmt
name|int
name|baud_rate
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout limit for response from target. */
end_comment

begin_comment
comment|/* The default value has been changed many times over the years.  It     was originally 5 seconds.  But that was thought to be a long time     to sit and wait, so it was changed to 2 seconds.  That was thought    to be plenty unless the connection was going through some terminal     server or multiplexer or other form of hairy serial connection.     In mid-1996, remote_timeout was moved from remote.c to top.c and     it began being used in other remote-* targets.  It appears that the    default was changed to 20 seconds at that time, perhaps because the    Renesas E7000 ICE didn't always respond in a timely manner.     But if 5 seconds is a long time to sit and wait for retransmissions,    20 seconds is far worse.  This demonstrates the difficulty of using     a single variable for all protocol timeouts.     As remote.c is used much more than remote-e7000.c, it was changed     back to 2 seconds in 1999. */
end_comment

begin_decl_stmt
name|int
name|remote_timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero tells remote* modules to output debugging info.  */
end_comment

begin_decl_stmt
name|int
name|remote_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means the target is running. Note: this is different from    saying that there is an active target and we are stopped at a    breakpoint, for instance. This is a real indicator whether the    target is off and running, which gdb is doing something else. */
end_comment

begin_decl_stmt
name|int
name|target_executing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of control structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|control_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sbrk location on entry to main.  Used for statistics only.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SBRK
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|lim_at_start
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STOP_SIGNAL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_define
define|#
directive|define
name|STOP_SIGNAL
value|SIGTSTP
end_define

begin_function_decl
specifier|static
name|void
name|stop_sig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hooks for alternate command interfaces.  */
end_comment

begin_comment
comment|/* Called after most modules have been initialized, but before taking users    command file.     If the UI fails to initialize and it wants GDB to continue    using the default UI, then it should clear this hook before returning. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|init_ui_hook
function_decl|)
parameter_list|(
name|char
modifier|*
name|argv0
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This hook is called from within gdb's many mini-event loops which could    steal control from a real user interface's event loop. It returns    non-zero if the user is requesting a detach, zero otherwise. */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|ui_loop_hook
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called instead of command_loop at top level.  Can be invoked via    throw_exception().  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|command_loop_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called from print_frame_info to list the line we stopped in.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|print_frame_info_listing_hook
function_decl|)
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Replaces most of query.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|query_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Replaces most of warning.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|warning_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These three functions support getting lines of text from the user.  They    are used in sequence.  First readline_begin_hook is called with a text    string that might be (for example) a message for the user to type in a    sequence of commands to be executed at a breakpoint.  If this function    calls back to a GUI, it might take this opportunity to pop up a text    interaction window with this message.  Next, readline_hook is called    with a prompt that is emitted prior to collecting the user input.    It can be called multiple times.  Finally, readline_end_hook is called    to notify the GUI that we are done with the interaction window and it    can close it. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|readline_begin_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
function_decl|(
modifier|*
name|readline_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|readline_end_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called as appropriate to notify the interface of the specified breakpoint    conditions.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|create_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|delete_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|modify_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called as appropriate to notify the interface that we have attached    to or detached from an already running process. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|attach_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|detach_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called during long calculations to allow GUI to repair window damage, and to    check for stop buttons, etc... */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|interactive_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called when the registers have changed, as a hint to a GUI    to minimize window update. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|registers_changed_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tell the GUI someone changed the register REGNO. -1 means    that the caller does not know which register changed or    that several registers have changed (see value_assign). */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|register_changed_hook
function_decl|)
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tell the GUI someone changed LEN bytes of memory at ADDR */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|memory_changed_hook
function_decl|)
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called when going to wait for the target.  Usually allows the GUI to run    while waiting for target events.  */
end_comment

begin_function_decl
name|ptid_t
function_decl|(
modifier|*
name|target_wait_hook
function_decl|)
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Used by UI as a wrapper around command execution.  May do various things    like enabling/disabling buttons, etc...  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|call_command_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called after a `set' command has finished.  Is only run if the    `set' command succeeded.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|set_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called when the current thread changes.  Argument is thread id.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|context_hook
function_decl|)
parameter_list|(
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Takes control from error ().  Typically used to prevent longjmps out of the    middle of the GUI.  Usually used in conjunction with a catch routine.  */
end_comment

begin_decl_stmt
name|NORETURN
name|void
argument_list|(
operator|*
name|error_hook
argument_list|)
argument_list|(
name|void
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* One should use catch_errors rather than manipulating these    directly.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGSETJMP
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGJMP_BUF
value|sigjmp_buf
end_define

begin_define
define|#
directive|define
name|SIGSETJMP
parameter_list|(
name|buf
parameter_list|)
value|sigsetjmp((buf), 1)
end_define

begin_define
define|#
directive|define
name|SIGLONGJMP
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|)
value|siglongjmp((buf), (val))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIGJMP_BUF
value|jmp_buf
end_define

begin_define
define|#
directive|define
name|SIGSETJMP
parameter_list|(
name|buf
parameter_list|)
value|setjmp(buf)
end_define

begin_define
define|#
directive|define
name|SIGLONGJMP
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|)
value|longjmp((buf), (val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Where to go for throw_exception().  */
end_comment

begin_decl_stmt
specifier|static
name|SIGJMP_BUF
modifier|*
name|catch_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return for reason REASON to the nearest containing catch_errors().  */
end_comment

begin_function
name|NORETURN
name|void
name|throw_exception
parameter_list|(
name|enum
name|return_reason
name|reason
parameter_list|)
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
comment|/* Perhaps it would be cleaner to do this via the cleanup chain (not sure      I can think of a reason why that is vital, though).  */
name|bpstat_clear_actions
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* Clear queued breakpoint commands */
name|disable_current_display
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
operator|&&
operator|!
name|target_executing
condition|)
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_loop_p
operator|&&
name|sync_execution
condition|)
name|do_exec_error_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|RETURN_QUIT
case|:
name|annotate_quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|RETURN_ERROR
case|:
name|annotate_error
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Jump to the containing catch_errors() call, communicating REASON      to that call via setjmp's return value.  Note that REASON can't      be zero, by definition in defs.h. */
operator|(
name|NORETURN
name|void
operator|)
name|SIGLONGJMP
argument_list|(
operator|*
name|catch_return
argument_list|,
operator|(
name|int
operator|)
name|reason
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call FUNC() with args FUNC_UIOUT and FUNC_ARGS, catching any    errors.  Set FUNC_CAUGHT to an ``enum return_reason'' if the    function is aborted (using throw_exception() or zero if the    function returns normally.  Set FUNC_VAL to the value returned by    the function or 0 if the function was aborted.     Must not be called with immediate_quit in effect (bad things might    happen, say we got a signal in the middle of a memcpy to quit_return).    This is an OK restriction; with very few exceptions immediate_quit can    be replaced by judicious use of QUIT.     MASK specifies what to catch; it is normally set to    RETURN_MASK_ALL, if for no other reason than that the code which    calls catch_errors might not be set up to deal with a quit which    isn't caught.  But if the code can deal with it, it generally    should be RETURN_MASK_ERROR, unless for some reason it is more    useful to abort only the portion of the operation inside the    catch_errors.  Note that quit should return to the command line    fairly quickly, even if some further processing is being done.  */
end_comment

begin_comment
comment|/* MAYBE: cagney/1999-11-05: catch_errors() in conjunction with    error() et.al. could maintain a set of flags that indicate the the    current state of each of the longjmp buffers.  This would give the    longjmp code the chance to detect a longjmp botch (before it gets    to longjmperror()).  Prior to 1999-11-05 this wasn't possible as    code also randomly used a SET_TOP_LEVEL macro that directly    initialize the longjmp buffers. */
end_comment

begin_comment
comment|/* MAYBE: cagney/1999-11-05: Should the catch_errors and cleanups code    be consolidated into a single file instead of being distributed    between utils.c and top.c? */
end_comment

begin_function
specifier|static
name|void
name|catcher
parameter_list|(
name|catch_exceptions_ftype
modifier|*
name|func
parameter_list|,
name|struct
name|ui_out
modifier|*
name|func_uiout
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|int
modifier|*
name|func_val
parameter_list|,
name|enum
name|return_reason
modifier|*
name|func_caught
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|char
modifier|*
modifier|*
name|gdberrmsg
parameter_list|,
name|return_mask
name|mask
parameter_list|)
block|{
name|SIGJMP_BUF
modifier|*
name|saved_catch
decl_stmt|;
name|SIGJMP_BUF
name|catch
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|saved_cleanup_chain
decl_stmt|;
name|char
modifier|*
name|saved_error_pre_print
decl_stmt|;
name|char
modifier|*
name|saved_quit_pre_print
decl_stmt|;
name|struct
name|ui_out
modifier|*
name|saved_uiout
decl_stmt|;
comment|/* Return value from SIGSETJMP(): enum return_reason if error or      quit caught, 0 otherwise. */
name|int
name|caught
decl_stmt|;
comment|/* Return value from FUNC(): Hopefully non-zero. Explicitly set to      zero if an error quit was caught.  */
name|int
name|val
decl_stmt|;
comment|/* Override error/quit messages during FUNC. */
name|saved_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|saved_quit_pre_print
operator|=
name|quit_pre_print
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
name|error_pre_print
operator|=
name|errstring
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
name|quit_pre_print
operator|=
name|errstring
expr_stmt|;
comment|/* Override the global ``struct ui_out'' builder.  */
name|saved_uiout
operator|=
name|uiout
expr_stmt|;
name|uiout
operator|=
name|func_uiout
expr_stmt|;
comment|/* Prevent error/quit during FUNC from calling cleanups established      prior to here. */
name|saved_cleanup_chain
operator|=
name|save_cleanups
argument_list|()
expr_stmt|;
comment|/* Call FUNC, catching error/quit events. */
name|saved_catch
operator|=
name|catch_return
expr_stmt|;
name|catch_return
operator|=
operator|&
name|catch
expr_stmt|;
name|caught
operator|=
name|SIGSETJMP
argument_list|(
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|caught
condition|)
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|func_uiout
argument_list|,
name|func_args
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
literal|0
expr_stmt|;
comment|/* If caller wants a copy of the low-level error message, make one.            This is used in the case of a silent error whereby the caller          may optionally want to issue the message.  */
if|if
condition|(
name|gdberrmsg
condition|)
operator|*
name|gdberrmsg
operator|=
name|error_last_message
argument_list|()
expr_stmt|;
block|}
name|catch_return
operator|=
name|saved_catch
expr_stmt|;
comment|/* FIXME: cagney/1999-11-05: A correct FUNC implementation will      clean things up (restoring the cleanup chain) to the state they      were just prior to the call.  Unfortunately, many FUNC's are not      that well behaved.  This could be fixed by adding either a      do_cleanups call (to cover the problem) or an assertion check to      detect bad FUNCs code. */
comment|/* Restore the cleanup chain, the error/quit messages, and the uiout      builder, to their original states. */
name|restore_cleanups
argument_list|(
name|saved_cleanup_chain
argument_list|)
expr_stmt|;
name|uiout
operator|=
name|saved_uiout
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
name|quit_pre_print
operator|=
name|saved_quit_pre_print
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
name|error_pre_print
operator|=
name|saved_error_pre_print
expr_stmt|;
comment|/* Return normally if no error/quit event occurred or this catcher      can handle this exception.  The caller analyses the func return      values.  */
if|if
condition|(
operator|!
name|caught
operator|||
operator|(
name|mask
operator|&
name|RETURN_MASK
argument_list|(
name|caught
argument_list|)
operator|)
condition|)
block|{
operator|*
name|func_val
operator|=
name|val
expr_stmt|;
operator|*
name|func_caught
operator|=
name|caught
expr_stmt|;
return|return;
block|}
comment|/* The caller didn't request that the event be caught, relay the      event to the next containing catch_errors(). */
name|throw_exception
argument_list|(
name|caught
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|catch_exceptions
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|catch_exceptions_ftype
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|return_mask
name|mask
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|enum
name|return_reason
name|caught
decl_stmt|;
name|catcher
argument_list|(
name|func
argument_list|,
name|uiout
argument_list|,
name|func_args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|caught
argument_list|,
name|errstring
argument_list|,
name|NULL
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|val
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|caught
operator|<=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|caught
operator|<
literal|0
condition|)
return|return
name|caught
return|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|catch_exceptions_with_msg
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|catch_exceptions_ftype
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|char
modifier|*
modifier|*
name|gdberrmsg
parameter_list|,
name|return_mask
name|mask
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|enum
name|return_reason
name|caught
decl_stmt|;
name|catcher
argument_list|(
name|func
argument_list|,
name|uiout
argument_list|,
name|func_args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|caught
argument_list|,
name|errstring
argument_list|,
name|gdberrmsg
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|val
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|caught
operator|<=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|caught
operator|<
literal|0
condition|)
return|return
name|caught
return|;
return|return
name|val
return|;
block|}
end_function

begin_struct
struct|struct
name|catch_errors_args
block|{
name|catch_errors_ftype
modifier|*
name|func
decl_stmt|;
name|void
modifier|*
name|func_args
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|do_catch_errors
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|catch_errors_args
modifier|*
name|args
init|=
name|data
decl_stmt|;
return|return
name|args
operator|->
name|func
argument_list|(
name|args
operator|->
name|func_args
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|catch_errors
parameter_list|(
name|catch_errors_ftype
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|return_mask
name|mask
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|enum
name|return_reason
name|caught
decl_stmt|;
name|struct
name|catch_errors_args
name|args
decl_stmt|;
name|args
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|args
operator|.
name|func_args
operator|=
name|func_args
expr_stmt|;
name|catcher
argument_list|(
name|do_catch_errors
argument_list|,
name|uiout
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|caught
argument_list|,
name|errstring
argument_list|,
name|NULL
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|caught
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|val
return|;
block|}
end_function

begin_struct
struct|struct
name|captured_command_args
block|{
name|catch_command_errors_ftype
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|do_captured_command
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_command_args
modifier|*
name|context
init|=
name|data
decl_stmt|;
name|context
operator|->
name|command
argument_list|(
name|context
operator|->
name|arg
argument_list|,
name|context
operator|->
name|from_tty
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/1999-11-07: Technically this do_cleanups() call      isn't needed.  Instead an assertion check could be made that      simply confirmed that the called function correctly cleaned up      after itself.  Unfortunately, old code (prior to 1999-11-04) in      main.c was calling SET_TOP_LEVEL(), calling the command function,      and then *always* calling do_cleanups().  For the moment we      remain ``bug compatible'' with that old code..  */
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|catch_command_errors
parameter_list|(
name|catch_command_errors_ftype
modifier|*
name|command
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|return_mask
name|mask
parameter_list|)
block|{
name|struct
name|captured_command_args
name|args
decl_stmt|;
name|args
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|args
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|args
operator|.
name|from_tty
operator|=
name|from_tty
expr_stmt|;
return|return
name|catch_errors
argument_list|(
name|do_captured_command
argument_list|,
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handler for SIGHUP.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGHUP
end_ifdef

begin_comment
comment|/* Just a little helper function for disconnect().  */
end_comment

begin_comment
comment|/* NOTE 1999-04-29: This function will be static again, once we modify    gdb to use the event loop as the default command loop and we merge    event-top.c into this file, top.c */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|int
name|quit_cover
parameter_list|(
name|void
modifier|*
name|s
parameter_list|)
block|{
name|caution
operator|=
literal|0
expr_stmt|;
comment|/* Throw caution to the wind -- we're exiting. 				   This prevents asking the user dumb questions.  */
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|disconnect
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|catch_errors
argument_list|(
name|quit_cover
argument_list|,
name|NULL
argument_list|,
literal|"Could not kill the program being debugged"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined SIGHUP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Line number we are currently in in a file which is being sourced.  */
end_comment

begin_comment
comment|/* NOTE 1999-04-29: This variable will be static again, once we modify    gdb to use the event loop as the default command loop and we merge    event-top.c into this file, top.c */
end_comment

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|int
name|source_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file we are sourcing.  */
end_comment

begin_comment
comment|/* NOTE 1999-04-29: This variable will be static again, once we modify    gdb to use the event loop as the default command loop and we merge    event-top.c into this file, top.c */
end_comment

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer containing the error_pre_print used by the source stuff.    Malloc'd.  */
end_comment

begin_comment
comment|/* NOTE 1999-04-29: This variable will be static again, once we modify    gdb to use the event loop as the default command loop and we merge    event-top.c into this file, top.c */
end_comment

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|source_error_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Something to glom on to the start of error_pre_print if source_file_name    is set.  */
end_comment

begin_comment
comment|/* NOTE 1999-04-29: This variable will be static again, once we modify    gdb to use the event loop as the default command loop and we merge    event-top.c into this file, top.c */
end_comment

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source_pre_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clean up on error during a "source" command (or execution of a    user-defined command).  */
end_comment

begin_function
name|void
name|do_restore_instream_cleanup
parameter_list|(
name|void
modifier|*
name|stream
parameter_list|)
block|{
comment|/* Restore the previous input stream.  */
name|instream
operator|=
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read commands from STREAM.  */
end_comment

begin_function
name|void
name|read_command_file
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|do_restore_instream_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
name|stream
expr_stmt|;
name|command_loop
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|void
function_decl|(
modifier|*
name|pre_init_ui_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_function
name|void
name|do_chdir_cleanup
parameter_list|(
name|void
modifier|*
name|old_dir
parameter_list|)
block|{
name|chdir
argument_list|(
name|old_dir
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|old_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Execute the line P as a command.    Pass FROM_TTY as second argument to the defining function.  */
end_comment

begin_function
name|void
name|execute_command
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|enum
name|language
name|flang
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|free_all_values
argument_list|()
expr_stmt|;
comment|/* Force cleanup of any alloca areas if using C alloca instead of      a builtin alloca.  */
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen when command_line_input hits end of file.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|serial_log_command
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|line
operator|=
name|p
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the target is running, we allow only a limited set of          commands. */
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
operator|&&
name|target_executing
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|name
argument_list|,
literal|"help"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|name
argument_list|,
literal|"pwd"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|name
argument_list|,
literal|"show"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|name
argument_list|,
literal|"stop"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot execute this command while the target is running."
argument_list|)
expr_stmt|;
comment|/* Pass null arg rather than an empty one.  */
name|arg
operator|=
operator|*
name|p
condition|?
name|p
else|:
literal|0
expr_stmt|;
comment|/* FIXME: cagney/2002-02-02: The c->type test is pretty dodgy          while the is_complete_command(cfunc) test is just plain          bogus.  They should both be replaced by a test of the form          c->strip_trailing_white_space_p.  */
comment|/* NOTE: cagney/2002-02-02: The function.cfunc in the below          can't be replaced with func.  This is because it is the          cfunc, and not the func, that has the value that the          is_complete_command hack is testing for.  */
comment|/* Clear off trailing whitespace, except for set and complete          command.  */
if|if
condition|(
name|arg
operator|&&
name|c
operator|->
name|type
operator|!=
name|set_cmd
operator|&&
operator|!
name|is_complete_command
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|p
operator|=
name|arg
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>=
name|arg
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If this command has been pre-hooked, run the hook first. */
name|execute_cmd_pre_hook
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|DEPRECATED_WARN_USER
condition|)
name|deprecated_cmd_warning
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|execute_user_command
argument_list|(
name|c
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|set_cmd
operator|||
name|c
operator|->
name|type
operator|==
name|show_cmd
condition|)
name|do_setshow_command
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cmd_func_p
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"That is not a command, just a help topic."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|call_command_hook
condition|)
name|call_command_hook
argument_list|(
name|c
argument_list|,
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|)
expr_stmt|;
else|else
name|cmd_func
argument_list|(
name|c
argument_list|,
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|)
expr_stmt|;
comment|/* If this command has been post-hooked, run the hook last. */
name|execute_cmd_post_hook
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the user if the language has changed (except first time).  */
if|if
condition|(
name|current_language
operator|!=
name|expected_language
condition|)
block|{
if|if
condition|(
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
name|language_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Print what changed.  */
block|}
name|warned
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Warn the user if the working language does not match the      language of the current frame.  Only warn the user if we are      actually running the program, i.e. there is a stack. */
comment|/* FIXME:  This should be cacheing the frame and only running when      the frame changes.  */
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|flang
operator|!=
name|language_unknown
operator|&&
name|flang
operator|!=
name|current_language
operator|->
name|la_language
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|lang_frame_mismatch_warn
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read commands from `instream' and execute them    until end of file or error reading instream.  */
end_comment

begin_function
name|void
name|command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|stdin_is_tty
init|=
name|ISATTY
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|long
name|time_at_cmd_start
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|long
name|space_at_cmd_start
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|display_time
decl_stmt|;
specifier|extern
name|int
name|display_space
decl_stmt|;
while|while
condition|(
name|instream
operator|&&
operator|!
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
block|{
if|if
condition|(
name|window_hook
operator|&&
name|instream
operator|==
name|stdin
condition|)
call|(
modifier|*
name|window_hook
call|)
argument_list|(
name|instream
argument_list|,
name|get_prompt
argument_list|()
argument_list|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|stdin_is_tty
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get a command-line. This calls the readline package. */
name|command
operator|=
name|command_line_input
argument_list|(
name|instream
operator|==
name|stdin
condition|?
name|get_prompt
argument_list|()
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|instream
operator|==
name|stdin
argument_list|,
literal|"prompt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
literal|0
condition|)
return|return;
name|time_at_cmd_start
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|space_at_cmd_start
operator|=
name|lim
operator|-
name|lim_at_start
expr_stmt|;
endif|#
directive|endif
block|}
name|execute_command
argument_list|(
name|command
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
comment|/* Do any commands attached to breakpoint we stopped at.  */
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_time
condition|)
block|{
name|long
name|cmd_time
init|=
name|get_run_time
argument_list|()
operator|-
name|time_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Command execution time: %ld.%06ld\n"
argument_list|,
name|cmd_time
operator|/
literal|1000000
argument_list|,
name|cmd_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|space_now
init|=
name|lim
operator|-
name|lim_at_start
decl_stmt|;
name|long
name|space_diff
init|=
name|space_now
operator|-
name|space_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Space used: %ld (%c%ld for this command)\n"
argument_list|,
name|space_now
argument_list|,
operator|(
name|space_diff
operator|>=
literal|0
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|space_diff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read commands from `instream' and execute them until end of file or    error reading instream. This command loop doesnt care about any    such things as displaying time and space usage. If the user asks    for those, they won't work. */
end_comment

begin_function
name|void
name|simplified_command_loop
parameter_list|(
name|char
modifier|*
function_decl|(
modifier|*
name|read_input_func
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|execute_command_func
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|stdin_is_tty
init|=
name|ISATTY
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
while|while
condition|(
name|instream
operator|&&
operator|!
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|stdin_is_tty
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get a command-line. */
name|command
operator|=
call|(
modifier|*
name|read_input_func
call|)
argument_list|(
name|instream
operator|==
name|stdin
condition|?
name|get_prompt
argument_list|()
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
literal|0
condition|)
return|return;
call|(
modifier|*
name|execute_command_func
call|)
argument_list|(
name|command
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
comment|/* Do any commands attached to breakpoint we stopped at.  */
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands call this if they do not want to be repeated by null lines.  */
end_comment

begin_function
name|void
name|dont_repeat
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|server_command
condition|)
return|return;
comment|/* If we aren't reading from standard input, we are saving the last      thing read from stdin in line and don't want to delete it.  Null lines      won't repeat here in any case.  */
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
operator|*
name|line
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a line from the stream "instream" without command line editing.     It prints PROMPT_ARG once at the start.    Action is compatible with "readline", e.g. space for the result is    malloc'd and should be freed by the caller.     A NULL return means end of file.  */
end_comment

begin_function
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|char
modifier|*
name|prompt_arg
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
if|if
condition|(
name|prompt_arg
condition|)
block|{
comment|/* Don't use a _filtered function here.  It causes the assumed          character position to be off, since the newline we read from          the user is not accounted for.  */
name|fputs_unfiltered
argument_list|(
name|prompt_arg
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read from stdin if we are executing a user defined command.          This is the right thing for prompt_for_continue, at least.  */
name|c
operator|=
name|fgetc
argument_list|(
name|instream
condition|?
name|instream
else|:
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
condition|)
comment|/* The last line does not end with a newline.  Return it, and 	       if we are called again fgetc will still return EOF and 	       we'll return NULL then.  */
break|break;
name|xfree
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
ifndef|#
directive|ifndef
name|CRLF_SOURCE_FILES
break|break;
else|#
directive|else
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
operator|&&
name|result
index|[
name|input_index
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|input_index
operator|--
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Variables which control command line editing and history    substitution.  These variables are given default values at the end    of this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_editing_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE 1999-04-29: This variable will be static again, once we modify    gdb to use the event loop as the default command loop and we merge    event-top.c into this file, top.c */
end_comment

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|int
name|history_expansion_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_history_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is like readline(), but it has some gdb-specific behavior.    gdb can use readline in both the synchronous and async modes during    a single gdb invocation.  At the ordinary top-level prompt we might    be using the async readline.  That means we can't use    rl_pre_input_hook, since it doesn't work properly in async mode.    However, for a secondary prompt (">", such as occurs during a    `define'), gdb just calls readline() directly, running it in    synchronous mode.  So for operate-and-get-next to work in this    situation, we have to switch the hooks around.  That is what    gdb_readline_wrapper is for.  */
end_comment

begin_function
name|char
modifier|*
name|gdb_readline_wrapper
parameter_list|(
name|char
modifier|*
name|prompt
parameter_list|)
block|{
comment|/* Set the hook that works in this case.  */
if|if
condition|(
name|event_loop_p
operator|&&
name|after_char_processing_hook
condition|)
block|{
name|rl_pre_input_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|after_char_processing_hook
expr_stmt|;
name|after_char_processing_hook
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|readline
argument_list|(
name|prompt
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_function
specifier|static
name|void
name|stop_sig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
if|#
directive|if
name|STOP_SIGNAL
operator|==
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SIGPROCMASK
block|{
name|sigset_t
name|zero
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|zero
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|zero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|HAVE_SIGSETMASK
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|get_prompt
argument_list|()
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Forget about any previous command -- null line now will do nothing.  */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STOP_SIGNAL */
end_comment

begin_comment
comment|/* Initialize signal handlers. */
end_comment

begin_function
specifier|static
name|void
name|float_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* This message is based on ANSI C, section 4.7.  Note that integer      divide by zero causes this, so "float" is a misnomer.  */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Erroneous arithmetic operation."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_nothing
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Under System V the default disposition of a signal is reinstated after      the signal is caught and delivered to an application process.  On such      systems one must restore the replacement signal handler if one wishes      to continue handling the signal in one's program.  On BSD systems this      is not needed but it is harmless, and it simplifies the code to just do      it unconditionally. */
name|signal
argument_list|(
name|signo
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
comment|/* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed      to the inferior and breakpoints will be ignored.  */
ifdef|#
directive|ifdef
name|SIGTRAP
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get      passed to the inferior, which we don't want.  It would be      possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but      on BSD4.3 systems using vfork, that can affect the      GDB process as well as the inferior (the signal handling tables      might be in memory, shared between the two).  Since we establish      a handler for SIGQUIT, when we call exec it will set the signal      to SIG_DFL for us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|do_nothing
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|disconnect
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIGWINCH_HANDLER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The current saved history number from operate-and-get-next.    This is -1 if not valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|operate_saved_history
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is put on the appropriate hook and helps operate-and-get-next    do its work.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_rl_operate_and_get_next_completion
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|delta
init|=
name|where_history
argument_list|()
operator|-
name|operate_saved_history
decl_stmt|;
comment|/* The `key' argument to rl_get_previous_history is ignored.  */
name|rl_get_previous_history
argument_list|(
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operate_saved_history
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* readline doesn't automatically update the display for us.  */
name|rl_redisplay
argument_list|()
expr_stmt|;
name|after_char_processing_hook
operator|=
name|NULL
expr_stmt|;
name|rl_pre_input_hook
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a gdb-local readline command handler.  It accepts the    current command line (like RET does) and, if this command was taken    from the history, arranges for the next command in the history to    appear on the command line when the prompt returns.    We ignore the arguments.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_rl_operate_and_get_next
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|int
name|where
decl_stmt|;
if|if
condition|(
name|event_loop_p
condition|)
block|{
comment|/* Use the async hook.  */
name|after_char_processing_hook
operator|=
name|gdb_rl_operate_and_get_next_completion
expr_stmt|;
block|}
else|else
block|{
comment|/* This hook only works correctly when we are using the 	 synchronous readline.  */
name|rl_pre_input_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|gdb_rl_operate_and_get_next_completion
expr_stmt|;
block|}
comment|/* Find the current line, and find the next line to use.  */
name|where
operator|=
name|where_history
argument_list|()
expr_stmt|;
comment|/* FIXME: kettenis/20020817: max_input_history is renamed into      history_max_entries in readline-4.2.  When we do a new readline      import, we should probably change it here too, even though      readline maintains backwards compatibility for now by still      defining max_input_history.  */
if|if
condition|(
operator|(
name|history_is_stifled
argument_list|()
operator|&&
operator|(
name|history_length
operator|>=
name|max_input_history
operator|)
operator|)
operator|||
operator|(
name|where
operator|>=
name|history_length
operator|-
literal|1
operator|)
condition|)
name|operate_saved_history
operator|=
name|where
expr_stmt|;
else|else
name|operate_saved_history
operator|=
name|where
operator|+
literal|1
expr_stmt|;
return|return
name|rl_newline
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read one line from the command input stream `instream'    into the local static buffer `linebuffer' (whose current length    is `linelength').    The buffer is made bigger as necessary.    Returns the address of the start of the line.     NULL is returned for end of file.     *If* the instream == stdin& stdin is a terminal, the line read    is copied into the file line saver (global var char *line,    length linesize) so that it can be duplicated.     This routine either uses fancy command line editing or    simple input as the user has requested.  */
end_comment

begin_function
name|char
modifier|*
name|command_line_input
parameter_list|(
name|char
modifier|*
name|prompt_arg
parameter_list|,
name|int
name|repeat
parameter_list|,
name|char
modifier|*
name|annotation_suffix
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|linebuffer
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|linelength
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|rl
decl_stmt|;
name|char
modifier|*
name|local_prompt
init|=
name|prompt_arg
decl_stmt|;
name|char
modifier|*
name|nline
decl_stmt|;
name|char
name|got_eof
init|=
literal|0
decl_stmt|;
comment|/* The annotation suffix must be non-NULL.  */
if|if
condition|(
name|annotation_suffix
operator|==
name|NULL
condition|)
name|annotation_suffix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|local_prompt
operator|=
name|alloca
argument_list|(
operator|(
name|prompt_arg
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|prompt_arg
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|annotation_suffix
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt_arg
operator|==
name|NULL
condition|)
name|local_prompt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|local_prompt
argument_list|,
name|prompt_arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_prompt
argument_list|,
literal|"\n\032\032"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_prompt
argument_list|,
name|annotation_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
block|{
name|linelength
operator|=
literal|80
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linelength
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|linebuffer
expr_stmt|;
comment|/* Control-C quits instantly if typed while in this loop      since it should not wait until the user types a newline.  */
name|immediate_quit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
block|{
if|if
condition|(
name|event_loop_p
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|handle_stop_sig
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make sure that all output has been output.  Some machines may let          you get away with leaving out some of the gdb_flush, but not all.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_file_name
operator|!=
name|NULL
condition|)
block|{
operator|++
name|source_line_number
expr_stmt|;
name|sprintf
argument_list|(
name|source_error
argument_list|,
literal|"%s%s:%d: Error in sourced command file:\n"
argument_list|,
name|source_pre_error
argument_list|,
name|source_file_name
argument_list|,
name|source_line_number
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|source_error
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|puts_unfiltered
argument_list|(
literal|"\n\032\032pre-"
argument_list|)
expr_stmt|;
name|puts_unfiltered
argument_list|(
name|annotation_suffix
argument_list|)
expr_stmt|;
name|puts_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Don't use fancy stuff if not talking to stdin.  */
if|if
condition|(
name|readline_hook
operator|&&
name|instream
operator|==
name|NULL
condition|)
block|{
name|rl
operator|=
call|(
modifier|*
name|readline_hook
call|)
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command_editing_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|rl
operator|=
name|gdb_readline_wrapper
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rl
operator|=
name|gdb_readline
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|puts_unfiltered
argument_list|(
literal|"\n\032\032post-"
argument_list|)
expr_stmt|;
name|puts_unfiltered
argument_list|(
name|annotation_suffix
argument_list|)
expr_stmt|;
name|puts_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rl
operator|||
name|rl
operator|==
operator|(
name|char
operator|*
operator|)
name|EOF
condition|)
block|{
name|got_eof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
expr_stmt|;
name|nline
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nline
operator|-
name|linebuffer
expr_stmt|;
name|linebuffer
operator|=
name|nline
expr_stmt|;
block|}
name|p1
operator|=
name|rl
expr_stmt|;
comment|/* Copy line.  Don't copy null at end.  (Leaves line alone          if this was just a newline)  */
while|while
condition|(
operator|*
name|p1
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|xfree
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* Allocated in readline.  */
if|if
condition|(
name|p
operator|==
name|linebuffer
operator|||
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
condition|)
break|break;
name|p
operator|--
expr_stmt|;
comment|/* Put on top of '\'.  */
name|local_prompt
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|got_eof
condition|)
return|return
name|NULL
return|;
define|#
directive|define
name|SERVER_COMMAND_LENGTH
value|7
name|server_command
operator|=
operator|(
name|p
operator|-
name|linebuffer
operator|>
name|SERVER_COMMAND_LENGTH
operator|)
operator|&&
name|strncmp
argument_list|(
name|linebuffer
argument_list|,
literal|"server "
argument_list|,
name|SERVER_COMMAND_LENGTH
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|server_command
condition|)
block|{
comment|/* Note that we don't set `line'.  Between this and the check in          dont_repeat, this insures that repeating will still do the          right thing.  */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|linebuffer
operator|+
name|SERVER_COMMAND_LENGTH
return|;
block|}
comment|/* Do history expansion if that is wished.  */
if|if
condition|(
name|history_expansion_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|char
modifier|*
name|history_value
decl_stmt|;
name|int
name|expanded
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Insert null now.  */
name|expanded
operator|=
name|history_expand
argument_list|(
name|linebuffer
argument_list|,
operator|&
name|history_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
condition|)
block|{
comment|/* Print the changes.  */
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
comment|/* If there was an error, call this function again.  */
if|if
condition|(
name|expanded
operator|<
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
return|return
name|command_line_input
argument_list|(
name|prompt_arg
argument_list|,
name|repeat
argument_list|,
name|annotation_suffix
argument_list|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|+
literal|1
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|linebuffer
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
name|p
operator|=
name|linebuffer
operator|+
name|strlen
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we just got an empty line, and that is supposed      to repeat the previous command, return the value in the      global buffer.  */
if|if
condition|(
name|repeat
operator|&&
name|p
operator|==
name|linebuffer
condition|)
return|return
name|line
return|;
for|for
control|(
name|p1
operator|=
name|linebuffer
init|;
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|;
name|p1
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|repeat
operator|&&
operator|!
operator|*
name|p1
condition|)
return|return
name|line
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Add line to history if appropriate.  */
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|&&
operator|*
name|linebuffer
condition|)
name|add_history
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
comment|/* Note: lines consisting solely of comments are added to the command      history.  This is useful when you type a command, and then      realize you don't want to execute it quite yet.  You can comment      out the command and then later fetch it from the value history      and remove the '#'.  The kill ring is probably better, but some      people are in the habit of commenting things out.  */
if|if
condition|(
operator|*
name|p1
operator|==
literal|'#'
condition|)
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
comment|/* Found a comment. */
comment|/* Save into global buffer if appropriate.  */
if|if
condition|(
name|repeat
condition|)
block|{
if|if
condition|(
name|linelength
operator|>
name|linesize
condition|)
block|{
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|linelength
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
return|return
name|linebuffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the GDB banner. */
end_comment

begin_function
name|void
name|print_gdb_version
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* From GNU coding standards, first line is meant to be easy for a      program to parse, and is just canonical program name and version      number, which starts after last space. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"GNU gdb %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|/* Second line is a copyright notice. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Copyright 2004 Free Software Foundation, Inc.\n"
argument_list|)
expr_stmt|;
comment|/* Following the copyright is a brief statement that the program is      free software, that users are free to copy and change it on      certain conditions, that it is covered by the GNU GPL, and that      there is no warranty. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\ GDB is free software, covered by the GNU General Public License, and you are\n\ welcome to change it and/or distribute copies of it under certain conditions.\n\ Type \"show copying\" to see the conditions.\n\ There is absolutely no warranty for GDB.  Type \"show warranty\" for details.\n"
argument_list|)
expr_stmt|;
comment|/* After the required info we print the configuration information. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"This GDB was configured as \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|host_name
argument_list|,
name|target_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"--host=%s --target=%s"
argument_list|,
name|host_name
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|host_name
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\"."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* get_prompt: access method for the GDB prompt string.  */
end_comment

begin_function
name|char
modifier|*
name|get_prompt
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|event_loop_p
condition|)
return|return
name|PROMPT
argument_list|(
literal|0
argument_list|)
return|;
else|else
return|return
name|gdb_prompt_string
return|;
block|}
end_function

begin_function
name|void
name|set_prompt
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* ??rehrauer: I don't know why this fails, since it looks as though    assignments to prompt are wrapped in calls to savestring...    if (prompt != NULL)    xfree (prompt);  */
if|if
condition|(
name|event_loop_p
condition|)
name|PROMPT
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gdb_prompt_string
operator|=
name|savestring
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If necessary, make the user confirm that we should quit.  Return    non-zero if we should quit, zero if we shouldn't.  */
end_comment

begin_function
name|int
name|quit_confirm
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
operator|&&
name|target_has_execution
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* This is something of a hack.  But there's no reliable way to          see if a GUI is running.  The `use_windows' variable doesn't          cut it.  */
if|if
condition|(
name|init_ui_hook
condition|)
name|s
operator|=
literal|"A debugging session is active.\nDo you still want to close the debugger?"
expr_stmt|;
elseif|else
if|if
condition|(
name|attach_flag
condition|)
name|s
operator|=
literal|"The program is running.  Quit anyway (and detach it)? "
expr_stmt|;
else|else
name|s
operator|=
literal|"The program is running.  Exit anyway? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Helper routine for quit_force that requires error handling.  */
end_comment

begin_struct
struct|struct
name|qt_args
block|{
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|quit_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|qt_args
modifier|*
name|qt
init|=
operator|(
expr|struct
name|qt_args
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
operator|&&
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|attach_flag
condition|)
name|target_detach
argument_list|(
name|qt
operator|->
name|args
argument_list|,
name|qt
operator|->
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|target_kill
argument_list|()
expr_stmt|;
block|}
comment|/* UDI wants this, to kill the TIP.  */
name|target_close
argument_list|(
operator|&
name|current_target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Save the history information if it is appropriate to do so.  */
if|if
condition|(
name|write_history_p
operator|&&
name|history_filename
condition|)
name|write_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
name|do_final_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do any final cleanups before exiting */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Quit without asking for confirmation.  */
end_comment

begin_function
name|void
name|quit_force
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|exit_code
init|=
literal|0
decl_stmt|;
name|struct
name|qt_args
name|qt
decl_stmt|;
comment|/* An optional expression may be used to cause gdb to terminate with the       value of that expression. */
if|if
condition|(
name|args
condition|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|parse_and_eval
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|exit_code
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|qt
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|qt
operator|.
name|from_tty
operator|=
name|from_tty
expr_stmt|;
comment|/* We want to handle any quit errors and exit regardless.  */
name|catch_errors
argument_list|(
name|quit_target
argument_list|,
operator|&
name|qt
argument_list|,
literal|"Quitting: "
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns whether GDB is running on a terminal and whether the user    desires that questions be asked of them on that terminal.  */
end_comment

begin_function
name|int
name|input_from_terminal_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gdb_has_a_terminal
argument_list|()
operator|&&
operator|(
name|instream
operator|==
name|stdin
operator|)
operator|&
name|caution
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dont_repeat_command
parameter_list|(
name|char
modifier|*
name|ignored
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
operator|*
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Can't call dont_repeat here because we're not 				   necessarily reading from stdin.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manipulate command line editing control variables.  */
end_comment

begin_comment
comment|/* Number of commands to print in each call to show_commands.  */
end_comment

begin_define
define|#
directive|define
name|Hist_print
value|10
end_define

begin_function
name|void
name|show_commands
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Index for history commands.  Relative to history_base.  */
name|int
name|offset
decl_stmt|;
comment|/* Number of the history entry which we are planning to display next.      Relative to history_base.  */
specifier|static
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|/* The first command in the history which doesn't exist (i.e. one more      than the number of the last command).  Relative to history_base.  */
name|int
name|hist_len
decl_stmt|;
comment|/* Print out some of the commands from the command history.  */
comment|/* First determine the length of the history list.  */
name|hist_len
operator|=
name|history_size
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|history_size
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
condition|)
block|{
name|hist_len
operator|=
name|offset
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "info editing +" should print from the stored position.  */
empty_stmt|;
else|else
comment|/* "info editing<exp>" should print around command number<exp>.  */
name|num
operator|=
operator|(
name|parse_and_eval_long
argument_list|(
name|args
argument_list|)
operator|-
name|history_base
operator|)
operator|-
name|Hist_print
operator|/
literal|2
expr_stmt|;
block|}
comment|/* "show commands" means print the last Hist_print commands.  */
else|else
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
comment|/* If there are at least Hist_print commands, we want to display the last      Hist_print rather than, say, the last 6.  */
if|if
condition|(
name|hist_len
operator|-
name|num
operator|<
name|Hist_print
condition|)
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
name|num
init|;
name|offset
operator|<
name|num
operator|+
name|Hist_print
operator|&&
name|offset
operator|<
name|hist_len
condition|;
name|offset
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%5d  %s\n"
argument_list|,
name|history_base
operator|+
name|offset
argument_list|,
operator|(
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
operator|)
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* The next command we want to display is the next one that we haven't      displayed yet.  */
name|num
operator|+=
name|Hist_print
expr_stmt|;
comment|/* If the user repeats this command with return, it should do what      "show commands +" does.  This is unnecessary if arg is null,      because "show commands +" is not useful after "show commands".  */
if|if
condition|(
name|from_tty
operator|&&
name|args
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_function
specifier|static
name|void
name|set_history_size_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|history_size
operator|==
name|INT_MAX
condition|)
name|unstifle_history
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|history_size
operator|>=
literal|0
condition|)
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
else|else
block|{
name|history_size
operator|=
name|INT_MAX
expr_stmt|;
name|error
argument_list|(
literal|"History size must be non-negative"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_history
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set history\" must be followed by the name of a history subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|show_history
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showhistlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|info_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default verbose msgs off */
end_comment

begin_comment
comment|/* Called by do_setshow_command.  An elaborate joke.  */
end_comment

begin_function
name|void
name|set_verbose
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|char
modifier|*
name|cmdname
init|=
literal|"verbose"
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|showcmd
decl_stmt|;
name|showcmd
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|cmdname
argument_list|,
name|showlist
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbose printing of informational messages."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbose printing of informational messages."
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbosity."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbosity."
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Init the history buffer.  Note that we are called after the init file(s)  * have been read so that the user can change the history file via his  * .gdbinit file (for instance).  The GDBHISTFILE environment variable  * overrides all of this.  */
end_comment

begin_function
name|void
name|init_history
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tmpenv
decl_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"HISTSIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_size
operator|=
name|atoi
argument_list|(
name|tmpenv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_size
condition|)
name|history_size
operator|=
literal|256
expr_stmt|;
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"GDBHISTFILE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_filename
operator|=
name|savestring
argument_list|(
name|tmpenv
argument_list|,
name|strlen
argument_list|(
name|tmpenv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_filename
condition|)
block|{
comment|/* We include the current directory so that if the user changes          directories the file written will be the same as the one          that was read.  */
ifdef|#
directive|ifdef
name|__MSDOS__
comment|/* No leading dots in file names are allowed on MSDOS.  */
name|history_filename
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/_gdb_history"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|history_filename
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/.gdb_history"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|read_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_main
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
comment|/* If we are running the asynchronous version,      we initialize the prompts differently. */
if|if
condition|(
operator|!
name|event_loop_p
condition|)
block|{
name|gdb_prompt_string
operator|=
name|savestring
argument_list|(
name|DEFAULT_PROMPT
argument_list|,
name|strlen
argument_list|(
name|DEFAULT_PROMPT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* initialize the prompt stack to a simple "(gdb) " prompt or to          whatever the DEFAULT_PROMPT is. */
name|the_prompts
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|PREFIX
argument_list|(
literal|0
argument_list|)
operator|=
literal|""
expr_stmt|;
name|PROMPT
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|DEFAULT_PROMPT
argument_list|,
name|strlen
argument_list|(
name|DEFAULT_PROMPT
argument_list|)
argument_list|)
expr_stmt|;
name|SUFFIX
argument_list|(
literal|0
argument_list|)
operator|=
literal|""
expr_stmt|;
comment|/* Set things up for annotation_level> 1, if the user ever decides          to use it. */
name|async_annotation_suffix
operator|=
literal|"prompt"
expr_stmt|;
comment|/* Set the variable associated with the setshow prompt command. */
name|new_async_prompt
operator|=
name|savestring
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If gdb was started with --annotate=2, this is equivalent to 	 the user entering the command 'set annotate 2' at the gdb 	 prompt, so we need to do extra processing. */
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|set_async_annotation_level
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set the important stuff up for command editing.  */
name|command_editing_p
operator|=
literal|1
expr_stmt|;
name|history_expansion_p
operator|=
literal|0
expr_stmt|;
name|write_history_p
operator|=
literal|0
expr_stmt|;
comment|/* Setup important stuff for command line editing.  */
name|rl_completion_entry_function
operator|=
name|readline_line_completion_function
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|default_word_break_characters
argument_list|()
expr_stmt|;
name|rl_completer_quote_characters
operator|=
name|get_gdb_completer_quote_characters
argument_list|()
expr_stmt|;
name|rl_readline_name
operator|=
literal|"gdb"
expr_stmt|;
name|rl_terminal_name
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
comment|/* The name for this defun comes from Bash, where it originated.      15 is Control-o, the same binding this function has in Bash.  */
name|rl_add_defun
argument_list|(
literal|"operate-and-get-next"
argument_list|,
name|gdb_rl_operate_and_get_next
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* The set prompt command is different depending whether or not the      async version is run. NOTE: this difference is going to      disappear as we make the event loop be the default engine of      gdb. */
if|if
condition|(
operator|!
name|event_loop_p
condition|)
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"prompt"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gdb_prompt_string
argument_list|,
literal|"Set gdb's prompt"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"prompt"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|new_async_prompt
argument_list|,
literal|"Set gdb's prompt"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_async_prompt
argument_list|)
expr_stmt|;
block|}
name|add_com
argument_list|(
literal|"dont-repeat"
argument_list|,
name|class_support
argument_list|,
name|dont_repeat_command
argument_list|,
literal|"Don't repeat this command.\n\ Primarily used inside of user-defined commands that should not be repeated when\n\ hitting return."
argument_list|)
expr_stmt|;
comment|/* The set editing command is different depending whether or not the      async version is run. NOTE: this difference is going to disappear      as we make the event loop be the default engine of gdb. */
if|if
condition|(
operator|!
name|event_loop_p
condition|)
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"editing"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|command_editing_p
argument_list|,
literal|"Set editing of command lines as they are typed.\n\ Use \"on\" to enable the editing, and \"off\" to disable it.\n\ Without an argument, command line editing is enabled.  To edit, use\n\ EMACS-like or VI-like commands like control-P or ESC."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"editing"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|async_command_editing_p
argument_list|,
literal|"Set editing of command lines as they are typed.\n\ Use \"on\" to enable the editing, and \"off\" to disable it.\n\ Without an argument, command line editing is enabled.  To edit, use\n\ EMACS-like or VI-like commands like control-P or ESC."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_async_editing_command
argument_list|)
expr_stmt|;
block|}
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"save"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_history_p
argument_list|,
literal|"Set saving of the history record on exit.\n\ Use \"on\" to enable the saving, and \"off\" to disable it.\n\ Without an argument, saving is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"size"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_size
argument_list|,
literal|"Set the size of the command history,\n\ ie. the number of previous commands to keep a record of."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_history_size_command
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"filename"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_filename
argument_list|,
literal|"Set the filename in which to record the command history\n\ (the list of previous commands of which a record is kept)."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"confirm"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|caution
argument_list|,
literal|"Set whether to confirm potentially dangerous operations."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* The set annotate command is different depending whether or not      the async version is run. NOTE: this difference is going to      disappear as we make the event loop be the default engine of      gdb. */
if|if
condition|(
operator|!
name|event_loop_p
condition|)
block|{
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"annotate"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|annotation_level
argument_list|,
literal|"Set annotation_level.\n\ 0 == normal;     1 == fullname (for use when running under emacs)\n\ 2 == output annotated suitably for use by programs that control GDB."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"annotate"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|annotation_level
argument_list|,
literal|"Set annotation_level.\n\ 0 == normal;     1 == fullname (for use when running under emacs)\n\ 2 == output annotated suitably for use by programs that control GDB."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_async_annotation_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event_loop_p
condition|)
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"exec-done-display"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|exec_done_display_p
argument_list|,
literal|"Set notification of completion for asynchronous execution commands.\n\ Use \"on\" to enable the notification, and \"off\" to disable it."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gdb_init
parameter_list|(
name|char
modifier|*
name|argv0
parameter_list|)
block|{
if|if
condition|(
name|pre_init_ui_hook
condition|)
name|pre_init_ui_hook
argument_list|()
expr_stmt|;
comment|/* Run the init function of each source file */
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|gdb_dirbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
comment|/* Make sure we return to the original directory upon exit, come      what may, since the OS doesn't do that for us.  */
name|make_final_cleanup
argument_list|(
name|do_chdir_cleanup
argument_list|,
name|xstrdup
argument_list|(
name|current_directory
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_cmd_lists
argument_list|()
expr_stmt|;
comment|/* This needs to be done first */
name|initialize_targets
argument_list|()
expr_stmt|;
comment|/* Setup target_terminal macros for utils.c */
name|initialize_utils
argument_list|()
expr_stmt|;
comment|/* Make errors and warnings possible */
name|initialize_all_files
argument_list|()
expr_stmt|;
name|initialize_current_architecture
argument_list|()
expr_stmt|;
name|init_cli_cmds
argument_list|()
expr_stmt|;
name|init_main
argument_list|()
expr_stmt|;
comment|/* But that omits this file!  Do it now */
comment|/* The signal handling mechanism is different depending whether or      not the async version is run. NOTE: in the future we plan to make      the event loop be the default engine of gdb, and this difference      will disappear. */
if|if
condition|(
name|event_loop_p
condition|)
name|async_init_signals
argument_list|()
expr_stmt|;
else|else
name|init_signals
argument_list|()
expr_stmt|;
comment|/* We need a default language for parsing expressions, so simple things like      "set width 0" won't fail if no language is explicitly set in a config file      or implicitly set by reading an executable during startup. */
name|set_language
argument_list|(
name|language_c
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* don't warn about the change.  */
comment|/* Allow another UI to initialize. If the UI fails to initialize, and      it wants GDB to revert to the CLI, it should clear init_ui_hook. */
if|if
condition|(
name|init_ui_hook
condition|)
name|init_ui_hook
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

