begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level stuff for GDB, the GNU debugger.    Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_comment
comment|/* For job_control.  */
end_comment

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|extern
name|void
name|initialize_utils
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dont_repeat_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|source_cleanup_lines
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|user_defined_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|stop_sig
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|line_completion_function
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|readline_line_completion_function
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|command_loop_marker
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|while_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|if_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command_line
modifier|*
name|build_command_line
name|PARAMS
argument_list|(
operator|(
expr|enum
name|command_control_type
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command_line
modifier|*
name|get_command_line
name|PARAMS
argument_list|(
operator|(
expr|enum
name|command_control_type
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|realloc_body_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|command_line
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|misc_command_type
name|read_next_line
name|PARAMS
argument_list|(
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|command_control_type
name|recurse_read_control_structure
name|PARAMS
argument_list|(
operator|(
expr|struct
name|command_line
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|setup_user_args
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|locate_arg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|insert_args
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arg_cleanup
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_main
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_cmd_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|float_handler
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_verbose
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_history
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_history
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_history_size_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_commands
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|echo_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pwd_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_version
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|document_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_comname
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|complete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_nothing
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGHUP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|quit_cover
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disconnect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|source_cleanup
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialization file name for gdb.  This is overridden in some configs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDBINIT_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|GDBINIT_FILENAME
value|".gdbinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|gdbinit
index|[]
init|=
name|GDBINIT_FILENAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inhibit_gdbinit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, and GDB has been configured to be able to use windows,    attempt to open them upon startup.  */
end_comment

begin_decl_stmt
name|int
name|use_windows
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Version number of GDB, as a string.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Canonical host name as a string. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|host_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Canonical target name as a string. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|target_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|lang_frame_mismatch_warn
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* language.c */
end_comment

begin_comment
comment|/* Flag for whether we want all the "from_tty" gubbish printed.  */
end_comment

begin_decl_stmt
name|int
name|caution
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is yes, sigh. */
end_comment

begin_comment
comment|/* Define all cmd_list_elements.  */
end_comment

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined info subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|infolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined enable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined disable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|disablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined toggle subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|togglelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined stop subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|stoplist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined delete subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "enable breakpoint" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined unset subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined show subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"set history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|sethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"show history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showhistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"unset history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined maintenance subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenancelist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain containing all defined "maintenance info" subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceinfolist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain containing all defined "maintenance print" subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceprintlist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setchecklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showchecklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdio stream that command input is being read from.  Set to stdin normally.    Set by source_command to the file we are sourcing.  Set to NULL if we are    executing a user-defined command or interacting via a GUI.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The directory name is actually stored here (usually).  */
end_comment

begin_decl_stmt
name|char
name|gdb_dirbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call before reading a command, if nonzero.    The function receives two args: an input stream,    and a prompt string.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*window_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|epoch_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gdb prints this when reading a command interactively */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer used for reading command lines, and the size    allocated for it so far.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linesize
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current command is modified by "server ".  This    affects things like recording into the command history, comamnds    repeating on RETURN, etc.  This is so a user interface (emacs, GUI,    whatever) can issue its own commands and also send along commands    from the user, and have the user not notice that the user interface    is issuing commands too.  */
end_comment

begin_decl_stmt
name|int
name|server_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baud rate specified for talking to serial target systems.  Default    is left as -1, so targets can choose their own defaults.  */
end_comment

begin_comment
comment|/* FIXME: This means that "show remotebaud" and gr_files_info can print -1    or (unsigned int)-1.  This is a Bad User Interface.  */
end_comment

begin_decl_stmt
name|int
name|baud_rate
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout limit for response from target. */
end_comment

begin_decl_stmt
name|int
name|remote_timeout
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set default to 1 second */
end_comment

begin_comment
comment|/* Non-zero tells remote* modules to output debugging info.  */
end_comment

begin_decl_stmt
name|int
name|remote_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of control structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|control_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for arguments to user defined functions.  */
end_comment

begin_define
define|#
directive|define
name|MAXUSERARGS
value|10
end_define

begin_struct
struct|struct
name|user_args
block|{
name|struct
name|user_args
modifier|*
name|next
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|a
index|[
name|MAXUSERARGS
index|]
struct|;
name|int
name|count
decl_stmt|;
block|}
modifier|*
name|user_args
struct|;
end_struct

begin_comment
comment|/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STOP_SIGNAL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_define
define|#
directive|define
name|STOP_SIGNAL
value|SIGTSTP
end_define

begin_decl_stmt
specifier|static
name|void
name|stop_sig
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some System V have job control but not sigsetmask(). */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SIGSETMASK
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_SIGSETMASK
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HAVE_SIGSETMASK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
operator|==
operator|(
name|HAVE_SIGSETMASK
operator|)
end_if

begin_define
define|#
directive|define
name|sigsetmask
parameter_list|(
name|n
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hooks for alternate command interfaces.  */
end_comment

begin_comment
comment|/* Called after most modules have been initialized, but before taking users    command file.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*init_ui_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|argv0
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN32__
end_ifdef

begin_macro
name|void
argument_list|(
argument|*ui_loop_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called instead of command_loop at top level.  Can be invoked via    return_to_top_level.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*command_loop_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called instead of fputs for all output.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*fputs_unfiltered_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|linebuffer
operator|,
name|GDB_FILE
operator|*
name|stream
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called when the target says something to the host, which may    want to appear in a different window. */
end_comment

begin_macro
name|void
argument_list|(
argument|*target_output_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called from print_frame_info to list the line we stopped in.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*print_frame_info_listing_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
name|s
operator|,
name|int
name|line
operator|,
name|int
name|stopline
operator|,
name|int
name|noerror
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Replaces most of query.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*query_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Replaces most of warning.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*warning_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called from gdb_flush to flush output.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*flush_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
name|stream
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* These three functions support getting lines of text from the user.  They    are used in sequence.  First readline_begin_hook is called with a text    string that might be (for example) a message for the user to type in a    sequence of commands to be executed at a breakpoint.  If this function    calls back to a GUI, it might take this opportunity to pop up a text    interaction window with this message.  Next, readline_hook is called    with a prompt that is emitted prior to collecting the user input.    It can be called multiple times.  Finally, readline_end_hook is called    to notify the GUI that we are done with the interaction window and it    can close it. */
end_comment

begin_macro
name|void
argument_list|(
argument|*readline_begin_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|char
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|readline_hook
operator|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*readline_end_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called as appropriate to notify the interface of the specified breakpoint    conditions.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*create_breakpoint_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*delete_breakpoint_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*modify_breakpoint_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called during long calculations to allow GUI to repair window damage, and to    check for stop buttons, etc... */
end_comment

begin_macro
name|void
argument_list|(
argument|*interactive_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called when the registers have changed, as a hint to a GUI    to minimize window update. */
end_comment

begin_macro
name|void
argument_list|(
argument|*registers_changed_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tell the GUI someone changed the register REGNO. -1 means    that the caller does not know which register changed or    that several registers have changed (see value_assign).*/
end_comment

begin_macro
name|void
argument_list|(
argument|*register_changed_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tell the GUI someone changed LEN bytes of memory at ADDR */
end_comment

begin_macro
name|void
argument_list|(
argument|*memory_changed_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|int
name|len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called when going to wait for the target.  Usually allows the GUI to run    while waiting for target events.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*target_wait_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Used by UI as a wrapper around command execution.  May do various things    like enabling/disabling buttons, etc...  */
end_comment

begin_macro
name|void
argument_list|(
argument|*call_command_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
name|c
operator|,
name|char
operator|*
name|cmd
operator|,
name|int
name|from_tty
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Called when the current thread changes.  Argument is thread id.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*context_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
name|id
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Takes control from error ().  Typically used to prevent longjmps out of the    middle of the GUI.  Usually used in conjunction with a catch routine.  */
end_comment

begin_decl_stmt
name|NORETURN
name|void
argument_list|(
operator|*
name|error_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Where to go for return_to_top_level (RETURN_ERROR).  */
end_comment

begin_decl_stmt
name|SIGJMP_BUF
name|error_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to go for return_to_top_level (RETURN_QUIT).  */
end_comment

begin_decl_stmt
name|SIGJMP_BUF
name|quit_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return for reason REASON.  This generally gets back to the command    loop, but can be caught via catch_errors.  */
end_comment

begin_function
name|NORETURN
name|void
name|return_to_top_level
parameter_list|(
name|reason
parameter_list|)
name|enum
name|return_reason
name|reason
decl_stmt|;
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
comment|/* Perhaps it would be cleaner to do this via the cleanup chain (not sure      I can think of a reason why that is vital, though).  */
name|bpstat_clear_actions
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* Clear queued breakpoint commands */
name|disable_current_display
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|RETURN_QUIT
case|:
name|annotate_quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|RETURN_ERROR
case|:
name|annotate_error
argument_list|()
expr_stmt|;
break|break;
block|}
operator|(
name|NORETURN
name|void
operator|)
name|SIGLONGJMP
argument_list|(
name|reason
operator|==
name|RETURN_ERROR
condition|?
name|error_return
else|:
name|quit_return
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call FUNC with arg ARGS, catching any errors.  If there is no    error, return the value returned by FUNC.  If there is an error,    print ERRSTRING, print the specific error message, then return    zero.     Must not be called with immediate_quit in effect (bad things might    happen, say we got a signal in the middle of a memcpy to quit_return).    This is an OK restriction; with very few exceptions immediate_quit can    be replaced by judicious use of QUIT.     MASK specifies what to catch; it is normally set to    RETURN_MASK_ALL, if for no other reason than that the code which    calls catch_errors might not be set up to deal with a quit which    isn't caught.  But if the code can deal with it, it generally    should be RETURN_MASK_ERROR, unless for some reason it is more    useful to abort only the portion of the operation inside the    catch_errors.  Note that quit should return to the command line    fairly quickly, even if some further processing is being done.  */
end_comment

begin_function
name|int
name|catch_errors
parameter_list|(
name|func
parameter_list|,
name|args
parameter_list|,
name|errstring
parameter_list|,
name|mask
parameter_list|)
name|catch_errors_ftype
modifier|*
name|func
decl_stmt|;
name|PTR
name|args
decl_stmt|;
name|char
modifier|*
name|errstring
decl_stmt|;
name|return_mask
name|mask
decl_stmt|;
block|{
name|SIGJMP_BUF
name|saved_error
decl_stmt|;
name|SIGJMP_BUF
name|saved_quit
decl_stmt|;
name|SIGJMP_BUF
name|tmp_jmp
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|saved_cleanup_chain
decl_stmt|;
name|char
modifier|*
name|saved_error_pre_print
decl_stmt|;
name|char
modifier|*
name|saved_quit_pre_print
decl_stmt|;
name|saved_cleanup_chain
operator|=
name|save_cleanups
argument_list|()
expr_stmt|;
name|saved_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|saved_quit_pre_print
operator|=
name|quit_pre_print
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|saved_error
argument_list|,
operator|(
name|char
operator|*
operator|)
name|error_return
argument_list|,
sizeof|sizeof
argument_list|(
name|SIGJMP_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|errstring
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
block|{
name|memcpy
argument_list|(
name|saved_quit
argument_list|,
name|quit_return
argument_list|,
sizeof|sizeof
argument_list|(
name|SIGJMP_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pre_print
operator|=
name|errstring
expr_stmt|;
block|}
if|if
condition|(
name|SIGSETJMP
argument_list|(
name|tmp_jmp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
name|memcpy
argument_list|(
name|error_return
argument_list|,
name|tmp_jmp
argument_list|,
sizeof|sizeof
argument_list|(
name|SIGJMP_BUF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
name|memcpy
argument_list|(
name|quit_return
argument_list|,
name|tmp_jmp
argument_list|,
sizeof|sizeof
argument_list|(
name|SIGJMP_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|restore_cleanups
argument_list|(
name|saved_cleanup_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
block|{
name|memcpy
argument_list|(
name|error_return
argument_list|,
name|saved_error
argument_list|,
sizeof|sizeof
argument_list|(
name|SIGJMP_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|saved_error_pre_print
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
block|{
name|memcpy
argument_list|(
name|quit_return
argument_list|,
name|saved_quit
argument_list|,
sizeof|sizeof
argument_list|(
name|SIGJMP_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pre_print
operator|=
name|saved_quit_pre_print
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Handler for SIGHUP.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGHUP
end_ifdef

begin_function
specifier|static
name|void
name|disconnect
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|catch_errors
argument_list|(
name|quit_cover
argument_list|,
name|NULL
argument_list|,
literal|"Could not kill the program being debugged"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just a little helper function for disconnect().  */
end_comment

begin_function
specifier|static
name|int
name|quit_cover
parameter_list|(
name|s
parameter_list|)
name|PTR
name|s
decl_stmt|;
block|{
name|caution
operator|=
literal|0
expr_stmt|;
comment|/* Throw caution to the wind -- we're exiting. 			   This prevents asking the user dumb questions.  */
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined SIGHUP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Line number we are currently in in a file which is being sourced.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|source_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file we are sourcing.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|source_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer containing the error_pre_print used by the source stuff.    Malloc'd.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|source_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|source_error_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Something to glom on to the start of error_pre_print if source_file_name    is set.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|source_pre_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clean up on error during a "source" command (or execution of a    user-defined command).  */
end_comment

begin_function
specifier|static
name|void
name|source_cleanup
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* Restore the previous input stream.  */
name|instream
operator|=
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read commands from STREAM.  */
end_comment

begin_function
name|void
name|read_command_file
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
name|stream
expr_stmt|;
name|command_loop
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|void
name|init_proc
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*pre_init_ui_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|gdb_init
parameter_list|(
name|argv0
parameter_list|)
name|char
modifier|*
name|argv0
decl_stmt|;
block|{
if|if
condition|(
name|pre_init_ui_hook
condition|)
name|pre_init_ui_hook
argument_list|()
expr_stmt|;
comment|/* Run the init function of each source file */
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|gdb_dirbuf
expr_stmt|;
name|init_cmd_lists
argument_list|()
expr_stmt|;
comment|/* This needs to be done first */
name|initialize_targets
argument_list|()
expr_stmt|;
comment|/* Setup target_terminal macros for utils.c */
name|initialize_utils
argument_list|()
expr_stmt|;
comment|/* Make errors and warnings possible */
name|initialize_all_files
argument_list|()
expr_stmt|;
name|init_main
argument_list|()
expr_stmt|;
comment|/* But that omits this file!  Do it now */
name|init_signals
argument_list|()
expr_stmt|;
name|init_proc
argument_list|()
expr_stmt|;
comment|/* We need a default language for parsing expressions, so simple things like      "set width 0" won't fail if no language is explicitly set in a config file      or implicitly set by reading an executable during startup. */
name|set_language
argument_list|(
name|language_c
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* don't warn about the change.  */
if|if
condition|(
name|init_ui_hook
condition|)
name|init_ui_hook
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate, initialize a new command line structure for one of the    control commands (if/while).  */
end_comment

begin_function
specifier|static
name|struct
name|command_line
modifier|*
name|build_command_line
parameter_list|(
name|type
parameter_list|,
name|args
parameter_list|)
name|enum
name|command_control_type
name|type
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"if/while commands require arguments.\n"
argument_list|)
expr_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|->
name|control_type
operator|=
name|type
expr_stmt|;
name|cmd
operator|->
name|body_count
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|body_list
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|cmd
operator|->
name|body_count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cmd
operator|->
name|body_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|cmd
operator|->
name|body_count
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|args
argument_list|,
name|strlen
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/* Build and return a new command structure for the control commands    such as "if" and "while".  */
end_comment

begin_function
specifier|static
name|struct
name|command_line
modifier|*
name|get_command_line
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|)
name|enum
name|command_control_type
name|type
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
comment|/* Allocate and build a new command line structure.  */
name|cmd
operator|=
name|build_command_line
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_command_lines
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/* Read in the body of this command.  */
if|if
condition|(
name|recurse_read_control_structure
argument_list|(
name|cmd
argument_list|)
operator|==
name|invalid_control
condition|)
block|{
name|warning
argument_list|(
literal|"error reading in control structure\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/* Recursively print a command (including full control structures).  */
end_comment

begin_function
name|void
name|print_command_line
parameter_list|(
name|cmd
parameter_list|,
name|depth
parameter_list|)
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
name|unsigned
name|int
name|depth
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|depth
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* A simple command, print it and return.  */
if|if
condition|(
name|cmd
operator|->
name|control_type
operator|==
name|simple_control
condition|)
block|{
name|fputs_filtered
argument_list|(
name|cmd
operator|->
name|line
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* loop_continue to jump to the start of a while loop, print it      and return. */
if|if
condition|(
name|cmd
operator|->
name|control_type
operator|==
name|continue_control
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"loop_continue\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* loop_break to break out of a while loop, print it and return.  */
if|if
condition|(
name|cmd
operator|->
name|control_type
operator|==
name|break_control
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"loop_break\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* A while command.  Recursively print its subcommands before returning.  */
if|if
condition|(
name|cmd
operator|->
name|control_type
operator|==
name|while_control
condition|)
block|{
name|struct
name|command_line
modifier|*
name|list
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|"while "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|cmd
operator|->
name|line
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|list
operator|=
operator|*
name|cmd
operator|->
name|body_list
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|print_command_line
argument_list|(
name|list
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* An if command.  Recursively print both arms before returning.  */
if|if
condition|(
name|cmd
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"if "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|cmd
operator|->
name|line
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* The true arm. */
name|print_command_line
argument_list|(
name|cmd
operator|->
name|body_list
index|[
literal|0
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Show the false arm if it exists.  */
if|if
condition|(
name|cmd
operator|->
name|body_count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|depth
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"else\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|print_command_line
argument_list|(
name|cmd
operator|->
name|body_list
index|[
literal|1
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"end\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Execute the command in CMD.  */
end_comment

begin_function
name|enum
name|command_control_type
name|execute_control_command
parameter_list|(
name|cmd
parameter_list|)
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|command_line
modifier|*
name|current
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|value_ptr
name|val_mark
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|char
modifier|*
name|new_line
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|control_type
condition|)
block|{
case|case
name|simple_control
case|:
comment|/* A simple command, execute it and return.  */
name|new_line
operator|=
name|insert_args
argument_list|(
name|cmd
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_line
condition|)
return|return
name|invalid_control
return|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|new_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cmd
operator|->
name|control_type
expr_stmt|;
break|break;
case|case
name|continue_control
case|:
case|case
name|break_control
case|:
comment|/* Return for "continue", and "break" so we can either 	 continue the loop at the top, or break out.  */
name|ret
operator|=
name|cmd
operator|->
name|control_type
expr_stmt|;
break|break;
case|case
name|while_control
case|:
block|{
comment|/* Parse the loop control expression for the while statement.  */
name|new_line
operator|=
name|insert_args
argument_list|(
name|cmd
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_line
condition|)
return|return
name|invalid_control
return|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|simple_control
expr_stmt|;
name|loop
operator|=
literal|1
expr_stmt|;
comment|/* Keep iterating so long as the expression is true.  */
while|while
condition|(
name|loop
operator|==
literal|1
condition|)
block|{
name|int
name|cond_result
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* Evaluate the expression.  */
name|val_mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|cond_result
operator|=
name|value_true
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|val_mark
argument_list|)
expr_stmt|;
comment|/* If the value is false, then break out of the loop.  */
if|if
condition|(
operator|!
name|cond_result
condition|)
break|break;
comment|/* Execute the body of the while statement.  */
name|current
operator|=
operator|*
name|cmd
operator|->
name|body_list
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|ret
operator|=
name|execute_control_command
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* If we got an error, or a "break" command, then stop 		   looping.  */
if|if
condition|(
name|ret
operator|==
name|invalid_control
operator|||
name|ret
operator|==
name|break_control
condition|)
block|{
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If we got a "continue" command, then restart the loop 		   at this point.  */
if|if
condition|(
name|ret
operator|==
name|continue_control
condition|)
break|break;
comment|/* Get the next statement.  */
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Reset RET so that we don't recurse the break all the way down.  */
if|if
condition|(
name|ret
operator|==
name|break_control
condition|)
name|ret
operator|=
name|simple_control
expr_stmt|;
break|break;
block|}
case|case
name|if_control
case|:
block|{
name|new_line
operator|=
name|insert_args
argument_list|(
name|cmd
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_line
condition|)
return|return
name|invalid_control
return|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
comment|/* Parse the conditional for the if statement.  */
name|expr
operator|=
name|parse_expression
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|current
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|simple_control
expr_stmt|;
comment|/* Evaluate the conditional.  */
name|val_mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Choose which arm to take commands from based on the value of the 	   conditional expression.  */
if|if
condition|(
name|value_true
argument_list|(
name|val
argument_list|)
condition|)
name|current
operator|=
operator|*
name|cmd
operator|->
name|body_list
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|body_count
operator|==
literal|2
condition|)
name|current
operator|=
operator|*
operator|(
name|cmd
operator|->
name|body_list
operator|+
literal|1
operator|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|val_mark
argument_list|)
expr_stmt|;
comment|/* Execute commands in the given arm.  */
while|while
condition|(
name|current
condition|)
block|{
name|ret
operator|=
name|execute_control_command
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* If we got an error, get out.  */
if|if
condition|(
name|ret
operator|!=
name|simple_control
condition|)
break|break;
comment|/* Get the next statement in the body.  */
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|warning
argument_list|(
literal|"Invalid control type in command structure."
argument_list|)
expr_stmt|;
return|return
name|invalid_control
return|;
block|}
if|if
condition|(
name|old_chain
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* "while" command support.  Executes a body of statements while the    loop condition is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|while_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|command
init|=
name|NULL
decl_stmt|;
name|control_level
operator|=
literal|1
expr_stmt|;
name|command
operator|=
name|get_command_line
argument_list|(
name|while_control
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|NULL
condition|)
return|return;
name|execute_control_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "if" command support.  Execute either the true or false arm depending    on the value of the if conditional.  */
end_comment

begin_function
specifier|static
name|void
name|if_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|command
init|=
name|NULL
decl_stmt|;
name|control_level
operator|=
literal|1
expr_stmt|;
name|command
operator|=
name|get_command_line
argument_list|(
name|if_control
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|NULL
condition|)
return|return;
name|execute_control_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup */
end_comment

begin_function
specifier|static
name|void
name|arg_cleanup
parameter_list|()
block|{
name|struct
name|user_args
modifier|*
name|oargs
init|=
name|user_args
decl_stmt|;
if|if
condition|(
operator|!
name|user_args
condition|)
name|fatal
argument_list|(
literal|"Internal error, arg_cleanup called with no user args.\n"
argument_list|)
expr_stmt|;
name|user_args
operator|=
name|user_args
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|oargs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind the incomming arguments for a user defined command to    $arg0, $arg1 ... $argMAXUSERARGS.  */
end_comment

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|setup_user_args
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|user_args
modifier|*
name|args
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|unsigned
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|user_args
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|user_args
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|user_args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|next
operator|=
name|user_args
expr_stmt|;
name|user_args
operator|=
name|args
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|arg_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|old_chain
return|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|start_arg
decl_stmt|;
name|int
name|squote
init|=
literal|0
decl_stmt|;
name|int
name|dquote
init|=
literal|0
decl_stmt|;
name|int
name|bsquote
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg_count
operator|>=
name|MAXUSERARGS
condition|)
block|{
name|error
argument_list|(
literal|"user defined function may only have %d arguments.\n"
argument_list|,
name|MAXUSERARGS
argument_list|)
expr_stmt|;
return|return
name|old_chain
return|;
block|}
comment|/* Strip whitespace.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* P now points to an argument.  */
name|start_arg
operator|=
name|p
expr_stmt|;
name|user_args
operator|->
name|a
index|[
name|arg_count
index|]
operator|.
name|arg
operator|=
name|p
expr_stmt|;
comment|/* Get to the end of this argument.  */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
operator|)
operator|&&
operator|!
name|squote
operator|&&
operator|!
name|dquote
operator|&&
operator|!
name|bsquote
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|bsquote
condition|)
name|bsquote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|bsquote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|squote
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|squote
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dquote
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|dquote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|squote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|dquote
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
name|user_args
operator|->
name|a
index|[
name|arg_count
index|]
operator|.
name|len
operator|=
name|p
operator|-
name|start_arg
expr_stmt|;
name|arg_count
operator|++
expr_stmt|;
name|user_args
operator|->
name|count
operator|++
expr_stmt|;
block|}
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Given character string P, return a point to the first argument ($arg),    or NULL if P contains no arguments.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|locate_arg
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'$'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"$arg"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
condition|)
return|return
name|p
return|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert the user defined arguments stored in user_arg into the $arg    arguments found in line, with the updated copy being placed into nline.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|insert_args
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|save_line
decl_stmt|,
modifier|*
name|new_line
decl_stmt|;
name|unsigned
name|len
decl_stmt|,
name|i
decl_stmt|;
comment|/* First we need to know how much memory to allocate for the new line.  */
name|save_line
operator|=
name|line
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|locate_arg
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|len
operator|+=
name|p
operator|-
name|line
expr_stmt|;
name|i
operator|=
name|p
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|user_args
operator|->
name|count
condition|)
block|{
name|error
argument_list|(
literal|"Missing argument %d in user function.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|+=
name|user_args
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|line
operator|=
name|p
operator|+
literal|5
expr_stmt|;
block|}
comment|/* Don't forget the tail.  */
name|len
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Allocate space for the new line and fill it in.  */
name|new_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_line
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Restore pointer to beginning of old line.  */
name|line
operator|=
name|save_line
expr_stmt|;
comment|/* Save pointer to beginning of new line.  */
name|save_line
operator|=
name|new_line
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|locate_arg
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|memcpy
argument_list|(
name|new_line
argument_list|,
name|line
argument_list|,
name|p
operator|-
name|line
argument_list|)
expr_stmt|;
name|new_line
operator|+=
name|p
operator|-
name|line
expr_stmt|;
name|i
operator|=
name|p
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
name|len
operator|=
name|user_args
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|memcpy
argument_list|(
name|new_line
argument_list|,
name|user_args
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_line
operator|+=
name|len
expr_stmt|;
block|}
name|line
operator|=
name|p
operator|+
literal|5
expr_stmt|;
block|}
comment|/* Don't forget the tail.  */
name|strcpy
argument_list|(
name|new_line
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Return a pointer to the beginning of the new line.  */
return|return
name|save_line
return|;
block|}
end_function

begin_function
name|void
name|execute_user_command
parameter_list|(
name|c
parameter_list|,
name|args
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|old_chain
operator|=
name|setup_user_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|c
operator|->
name|user_commands
expr_stmt|;
if|if
condition|(
name|cmdlines
operator|==
literal|0
condition|)
comment|/* Null command */
return|return;
comment|/* Set the instream to 0, indicating execution of a      user-defined function.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|cmdlines
condition|)
block|{
name|ret
operator|=
name|execute_control_command
argument_list|(
name|cmdlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|simple_control
operator|&&
name|ret
operator|!=
name|break_control
condition|)
block|{
name|warning
argument_list|(
literal|"Error in control structure.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cmdlines
operator|=
name|cmdlines
operator|->
name|next
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute the line P as a command.    Pass FROM_TTY as second argument to the defining function.  */
end_comment

begin_function
name|void
name|execute_command
parameter_list|(
name|p
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|register
name|enum
name|language
name|flang
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
comment|/* FIXME: These should really be in an appropriate header file */
specifier|extern
name|void
name|serial_log_command
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|free_all_values
argument_list|()
expr_stmt|;
comment|/* Force cleanup of any alloca areas if using C alloca instead of      a builtin alloca.  */
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen when command_line_input hits end of file.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|serial_log_command
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pass null arg rather than an empty one.  */
name|arg
operator|=
operator|*
name|p
condition|?
name|p
else|:
literal|0
expr_stmt|;
comment|/* Clear off trailing whitespace, except for set and complete command.  */
if|if
condition|(
name|arg
operator|&&
name|c
operator|->
name|type
operator|!=
name|set_cmd
operator|&&
name|c
operator|->
name|function
operator|.
name|cfunc
operator|!=
name|complete_command
condition|)
block|{
name|p
operator|=
name|arg
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>=
name|arg
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If this command has been hooked, run the hook first. */
if|if
condition|(
name|c
operator|->
name|hook
condition|)
name|execute_user_command
argument_list|(
name|c
operator|->
name|hook
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|execute_user_command
argument_list|(
name|c
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|set_cmd
operator|||
name|c
operator|->
name|type
operator|==
name|show_cmd
condition|)
name|do_setshow_command
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|NO_FUNCTION
condition|)
name|error
argument_list|(
literal|"That is not a command, just a help topic."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|call_command_hook
condition|)
name|call_command_hook
argument_list|(
name|c
argument_list|,
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|c
operator|->
name|function
operator|.
name|cfunc
call|)
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the user if the language has changed (except first time).  */
if|if
condition|(
name|current_language
operator|!=
name|expected_language
condition|)
block|{
if|if
condition|(
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
name|language_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Print what changed.  */
block|}
name|warned
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Warn the user if the working language does not match the      language of the current frame.  Only warn the user if we are      actually running the program, i.e. there is a stack. */
comment|/* FIXME:  This should be cacheing the frame and only running when      the frame changes.  */
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|flang
operator|!=
name|language_unknown
operator|&&
name|flang
operator|!=
name|current_language
operator|->
name|la_language
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|lang_frame_mismatch_warn
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|command_loop_marker
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Read commands from `instream' and execute them    until end of file or error reading instream.  */
end_comment

begin_function
name|void
name|command_loop
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|stdin_is_tty
init|=
name|ISATTY
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|long
name|time_at_cmd_start
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|long
name|space_at_cmd_start
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|display_time
decl_stmt|;
specifier|extern
name|int
name|display_space
decl_stmt|;
while|while
condition|(
name|instream
operator|&&
operator|!
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
specifier|extern
name|int
name|insert_mode
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|window_hook
operator|&&
name|instream
operator|==
name|stdin
condition|)
call|(
modifier|*
name|window_hook
call|)
argument_list|(
name|instream
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|stdin_is_tty
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|command_loop_marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/* A bit of paranoia: I want to make sure the "insert_mode" global        * is clear except when it is being used for command-line editing        * (see tuiIO.c, utils.c); otherwise normal output will        * get messed up in the TUI. So clear it before/after        * the command-line-input call. - RT        */
name|insert_mode
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Get a command-line. This calls the readline package. */
name|command
operator|=
name|command_line_input
argument_list|(
name|instream
operator|==
name|stdin
condition|?
name|prompt
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|instream
operator|==
name|stdin
argument_list|,
literal|"prompt"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
name|insert_mode
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|command
operator|==
literal|0
condition|)
return|return;
name|time_at_cmd_start
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|space_at_cmd_start
operator|=
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|execute_command
argument_list|(
name|command
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
comment|/* Do any commands attached to breakpoint we stopped at.  */
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_time
condition|)
block|{
name|long
name|cmd_time
init|=
name|get_run_time
argument_list|()
operator|-
name|time_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Command execution time: %ld.%06ld\n"
argument_list|,
name|cmd_time
operator|/
literal|1000000
argument_list|,
name|cmd_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|space_now
init|=
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
decl_stmt|;
name|long
name|space_diff
init|=
name|space_now
operator|-
name|space_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Space used: %ld (%c%ld for this command)\n"
argument_list|,
name|space_now
argument_list|,
operator|(
name|space_diff
operator|>=
literal|0
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|space_diff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands call this if they do not want to be repeated by null lines.  */
end_comment

begin_function
name|void
name|dont_repeat
parameter_list|()
block|{
if|if
condition|(
name|server_command
condition|)
return|return;
comment|/* If we aren't reading from standard input, we are saving the last      thing read from stdin in line and don't want to delete it.  Null lines      won't repeat here in any case.  */
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
operator|*
name|line
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a line from the stream "instream" without command line editing.     It prints PRROMPT once at the start.    Action is compatible with "readline", e.g. space for the result is    malloc'd and should be freed by the caller.     A NULL return means end of file.  */
end_comment

begin_function
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|prrompt
parameter_list|)
name|char
modifier|*
name|prrompt
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
if|if
condition|(
name|prrompt
condition|)
block|{
comment|/* Don't use a _filtered function here.  It causes the assumed 	 character position to be off, since the newline we read from 	 the user is not accounted for.  */
name|fputs_unfiltered
argument_list|(
name|prrompt
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MPW
comment|/* Move to a new line so the entered line doesn't have a prompt 	 on the front of it. */
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MPW */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read from stdin if we are executing a user defined command. 	 This is the right thing for prompt_for_continue, at least.  */
name|c
operator|=
name|fgetc
argument_list|(
name|instream
condition|?
name|instream
else|:
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
condition|)
comment|/* The last line does not end with a newline.  Return it, and 	       if we are called again fgetc will still return EOF and 	       we'll return NULL then.  */
break|break;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
ifndef|#
directive|ifndef
name|CRLF_SOURCE_FILES
break|break;
else|#
directive|else
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
operator|&&
name|result
index|[
name|input_index
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|input_index
operator|--
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Variables which control command line editing and history    substitution.  These variables are given default values at the end    of this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_editing_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_expansion_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_history_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* readline uses the word breaks for two things:    (1) In figuring out where to point the TEXT parameter to the    rl_completion_entry_function.  Since we don't use TEXT for much,    it doesn't matter a lot what the word breaks are for this purpose, but    it does affect how much stuff M-? lists.    (2) If one of the matches contains a word break character, readline    will quote it.  That's why we switch between    gdb_completer_word_break_characters and    gdb_completer_command_word_break_characters.  I'm not sure when    we need this behavior (perhaps for funky characters in C++ symbols?).  */
end_comment

begin_comment
comment|/* Variables which are necessary for fancy command line editing.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';:?/>.<,-"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When completing on command names, we remove '-' from the list of    word break characters, since we use it in command names.  If the    readline library sees one in any of the current completion strings,    it thinks that the string needs to be quoted and automatically supplies    a leading quote. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_command_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';:?/>.<,"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to quote completion strings.  Note that we    can't include '"' because the gdb C parser treats such quoted sequences    as strings. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_quote_characters
init|=
literal|"'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions that are used as part of the fancy command line editing.  */
end_comment

begin_comment
comment|/* This can be used for functions which don't want to complete on symbols    but don't want to complete on anything else either.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|noop_completer
parameter_list|(
name|text
parameter_list|,
name|prefix
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Complete on filenames.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|filename_completer
parameter_list|(
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
comment|/* From readline.  */
specifier|extern
name|char
modifier|*
name|filename_completion_function
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
name|int
name|subsequent_name
decl_stmt|;
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
name|int
name|return_val_used
decl_stmt|;
name|int
name|return_val_alloced
decl_stmt|;
name|return_val_used
operator|=
literal|0
expr_stmt|;
comment|/* Small for testing.  */
name|return_val_alloced
operator|=
literal|1
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|return_val_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subsequent_name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|filename_completion_function
argument_list|(
name|text
argument_list|,
name|subsequent_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val_used
operator|>=
name|return_val_alloced
condition|)
block|{
name|return_val_alloced
operator|*=
literal|2
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|return_val
argument_list|,
name|return_val_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
block|}
comment|/* Like emacs, don't complete on old versions.  Especially useful 	 in the "source" command.  */
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'~'
condition|)
continue|continue;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
comment|/* Return exactly p.  */
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of p.  */
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of TEXT plus p.  */
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
operator|(
name|text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|q
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|q
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|subsequent_name
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* There is no way to do this just long enough to affect quote inserting      without also affecting the next completion.  This should be fixed in      readline.  FIXME.  */
comment|/* Insure that readline does the right thing      with respect to inserting quotes.  */
block|rl_completer_word_break_characters = "";
endif|#
directive|endif
return|return
name|return_val
return|;
block|}
end_function

begin_comment
comment|/* Here are some useful test cases for completion.  FIXME: These should    be put in the test suite.  They should be tested with both M-? and TAB.     "show output-" "radix"    "show output" "-radix"    "p" ambiguous (commands starting with p--path, print, printf, etc.)    "p "  ambiguous (all symbols)    "info t foo" no completions    "info t " no completions    "info t" ambiguous ("info target", "info terminal", etc.)    "info ajksdlfk" no completions    "info ajksdlfk " no completions    "info" " "    "info " ambiguous (all info commands)    "p \"a" no completions (string constant)    "p 'a" ambiguous (all symbols starting with a)    "p b-a" ambiguous (all symbols starting with a)    "p b-" ambiguous (all symbols)    "file Make" "file" (word break hard to screw up here)    "file ../gdb.stabs/we" "ird" (needs to not break word at slash)    */
end_comment

begin_comment
comment|/* Generate completions one by one for the completer.  Each time we are    called return another potential completion to the caller.    line_completion just completes on commands or passes the buck to the    command's completer function, the stuff specific to symbol completion    is in make_symbol_completion_list.     TEXT is the caller's idea of the "word" we are looking at.     MATCHES is the number of matches that have currently been collected from    calling this completion function.  When zero, then we need to initialize,    otherwise the initialization has already taken place and we can just    return the next potential completion string.     LINE_BUFFER is available to be looked at; it contains the entire text    of the line.  POINT is the offset in that line of the cursor.  You    should pretend that the line ends at POINT.     Returns NULL if there are no more completions, else a pointer to a string    which is a possible completion, it is the caller's responsibility to    free the string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|line_completion_function
parameter_list|(
name|text
parameter_list|,
name|matches
parameter_list|,
name|line_buffer
parameter_list|,
name|point
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|char
modifier|*
name|line_buffer
decl_stmt|;
name|int
name|point
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Cache of completions */
specifier|static
name|int
name|index
decl_stmt|;
comment|/* Next cached completion */
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp_command
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Pointer within tmp_command which corresponds to text.  */
name|char
modifier|*
name|word
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|result_list
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
comment|/* The caller is beginning to accumulate a new set of completions, so 	 we need to find all of them now, and cache them for returning one at 	 a time on future calls. */
if|if
condition|(
name|list
condition|)
block|{
comment|/* Free the storage used by LIST, but not by the strings inside. 	     This is because rl_complete_internal () frees the strings. */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Choose the default set of word break characters to break completions. 	 If we later find out that we are doing completions on command strings 	 (as opposed to strings supplied by the individual command completer 	 functions, which can be any string) then we will switch to the 	 special word break set for command strings, which leaves out the 	 '-' character used in some commands.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
comment|/* Decide whether to complete on a list of gdb commands or on symbols. */
name|tmp_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_command
expr_stmt|;
name|strncpy
argument_list|(
name|tmp_command
argument_list|,
name|line_buffer
argument_list|,
name|point
argument_list|)
expr_stmt|;
name|tmp_command
index|[
name|point
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Since text always contains some number of characters leading up 	 to point, we can find the equivalent position in tmp_command 	 by subtracting that many characters from the end of tmp_command.  */
name|word
operator|=
name|tmp_command
operator|+
name|point
operator|-
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|==
literal|0
condition|)
block|{
comment|/* An empty line we want to consider ambiguous; that is, it 	     could be any command.  */
name|c
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|result_list
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|result_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Move p up to the next interesting thing.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* It is an unrecognized command.  So there are no 	     possible completions.  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* lookup_cmd_1 advances p up to the first ambiguous thing, but 	     doesn't advance over that thing itself.  Do so now.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|)
condition|)
operator|++
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|tmp_command
operator|+
name|point
condition|)
block|{
comment|/* There is something beyond the ambiguous 		 command, so there are no possible completions.  For 		 example, "info t " or "info t foo" does not complete 		 to anything, because "info t" can be "info target" or 		 "info terminal".  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We're trying to complete on the command which was ambiguous. 		 This we can deal with.  */
if|if
condition|(
name|result_list
condition|)
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|result_list
operator|->
name|prefixlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|cmdlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Insure that readline does the right thing with respect to 		 inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We've recognized a full command.  */
if|if
condition|(
name|p
operator|==
name|tmp_command
operator|+
name|point
condition|)
block|{
comment|/* There is no non-whitespace in the line beyond the command.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* The command is followed by whitespace; we need to complete 		     on whatever comes after command.  */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
block|{
comment|/* It is a prefix command; what comes after it is 			 a subcommand (e.g. "info ").  */
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* Insure that readline does the right thing 			 with respect to inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|enums
condition|)
block|{
name|list
operator|=
name|complete_on_enum
argument_list|(
name|c
operator|->
name|enums
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a normal command; what comes after it is 			 completed by the command's completer function.  */
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The command is not followed by whitespace; we need to 		     complete on the command itself.  e.g. "p" which is a 		     command itself but also can complete to "print", "ptype" 		     etc.  */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Find the command we are completing on.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|>
name|tmp_command
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
operator|--
name|q
expr_stmt|;
else|else
break|break;
block|}
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|result_list
argument_list|,
name|q
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* Insure that readline does the right thing 		     with respect to inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is non-whitespace beyond the command.  */
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
block|{
comment|/* It is an unrecognized subcommand of a prefix command, 		     e.g. "info adsfkdj".  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|enums
condition|)
block|{
name|list
operator|=
name|complete_on_enum
argument_list|(
name|c
operator|->
name|enums
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a normal command.  */
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we found a list of potential completions during initialization then      dole them out one at a time.  The vector of completions is NULL      terminated, so after returning the last one, return NULL (and continue      to do so) each time we are called after that, until a new list is      available. */
if|if
condition|(
name|list
condition|)
block|{
name|output
operator|=
name|list
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Can't do this because readline hasn't yet checked the word breaks      for figuring out whether to insert a quote.  */
block|if (output == NULL)
comment|/* Make sure the word break characters are set back to normal for the        next time that readline tries to complete something.  */
block|rl_completer_word_break_characters =       gdb_completer_word_break_characters;
endif|#
directive|endif
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Line completion interface function for readline.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readline_line_completion_function
parameter_list|(
name|text
parameter_list|,
name|matches
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|matches
decl_stmt|;
block|{
return|return
name|line_completion_function
argument_list|(
name|text
argument_list|,
name|matches
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Skip over a possibly quoted word (as defined by the quote characters    and word break characters the completer uses).  Returns pointer to the    location after the "word". */
end_comment

begin_function
name|char
modifier|*
name|skip_quoted
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|quote_char
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|str
init|;
operator|*
name|scan
operator|!=
literal|'\0'
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char */
if|if
condition|(
operator|*
name|scan
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close quote. */
name|scan
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted string. */
name|quote_char
operator|=
operator|*
name|scan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_word_break_characters
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|scan
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_function
specifier|static
name|void
name|stop_sig
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|#
directive|if
name|STOP_SIGNAL
operator|==
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Forget about any previous command -- null line now will do nothing.  */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STOP_SIGNAL */
end_comment

begin_comment
comment|/* Initialize signal handlers. */
end_comment

begin_function
specifier|static
name|void
name|do_nothing
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* Under System V the default disposition of a signal is reinstated after      the signal is caught and delivered to an application process.  On such      systems one must restore the replacement signal handler if one wishes      to continue handling the signal in one's program.  On BSD systems this      is not needed but it is harmless, and it simplifies the code to just do      it unconditionally. */
name|signal
argument_list|(
name|signo
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_signals
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
comment|/* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed      to the inferior and breakpoints will be ignored.  */
ifdef|#
directive|ifdef
name|SIGTRAP
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get      passed to the inferior, which we don't want.  It would be      possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but      on BSD4.3 systems using vfork, that can affect the      GDB process as well as the inferior (the signal handling tables      might be in memory, shared between the two).  Since we establish      a handler for SIGQUIT, when we call exec it will set the signal      to SIG_DFL for us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|do_nothing
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|disconnect
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIGWINCH_HANDLER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read one line from the command input stream `instream'    into the local static buffer `linebuffer' (whose current length    is `linelength').    The buffer is made bigger as necessary.    Returns the address of the start of the line.     NULL is returned for end of file.     *If* the instream == stdin& stdin is a terminal, the line read    is copied into the file line saver (global var char *line,    length linesize) so that it can be duplicated.     This routine either uses fancy command line editing or    simple input as the user has requested.  */
end_comment

begin_function
name|char
modifier|*
name|command_line_input
parameter_list|(
name|prrompt
parameter_list|,
name|repeat
parameter_list|,
name|annotation_suffix
parameter_list|)
name|char
modifier|*
name|prrompt
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|char
modifier|*
name|annotation_suffix
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|linebuffer
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|linelength
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|rl
decl_stmt|;
name|char
modifier|*
name|local_prompt
init|=
name|prrompt
decl_stmt|;
name|char
modifier|*
name|nline
decl_stmt|;
name|char
name|got_eof
init|=
literal|0
decl_stmt|;
comment|/* The annotation suffix must be non-NULL.  */
if|if
condition|(
name|annotation_suffix
operator|==
name|NULL
condition|)
name|annotation_suffix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|local_prompt
operator|=
name|alloca
argument_list|(
operator|(
name|prrompt
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|prrompt
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|annotation_suffix
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|prrompt
operator|==
name|NULL
condition|)
name|local_prompt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|local_prompt
argument_list|,
name|prrompt
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_prompt
argument_list|,
literal|"\n\032\032"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_prompt
argument_list|,
name|annotation_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
block|{
name|linelength
operator|=
literal|80
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linelength
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|linebuffer
expr_stmt|;
comment|/* Control-C quits instantly if typed while in this loop      since it should not wait until the user types a newline.  */
name|immediate_quit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make sure that all output has been output.  Some machines may let 	 you get away with leaving out some of the gdb_flush, but not all.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_file_name
operator|!=
name|NULL
condition|)
block|{
operator|++
name|source_line_number
expr_stmt|;
name|sprintf
argument_list|(
name|source_error
argument_list|,
literal|"%s%s:%d: Error in sourced command file:\n"
argument_list|,
name|source_pre_error
argument_list|,
name|source_file_name
argument_list|,
name|source_line_number
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|source_error
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\n\032\032pre-"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
name|annotation_suffix
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Don't use fancy stuff if not talking to stdin.  */
if|if
condition|(
name|readline_hook
operator|&&
name|instream
operator|==
name|NULL
condition|)
block|{
name|rl
operator|=
call|(
modifier|*
name|readline_hook
call|)
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command_editing_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|rl
operator|=
name|readline
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rl
operator|=
name|gdb_readline
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\n\032\032post-"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
name|annotation_suffix
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rl
operator|||
name|rl
operator|==
operator|(
name|char
operator|*
operator|)
name|EOF
condition|)
block|{
name|got_eof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
expr_stmt|;
name|nline
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nline
operator|-
name|linebuffer
expr_stmt|;
name|linebuffer
operator|=
name|nline
expr_stmt|;
block|}
name|p1
operator|=
name|rl
expr_stmt|;
comment|/* Copy line.  Don't copy null at end.  (Leaves line alone          if this was just a newline)  */
while|while
condition|(
operator|*
name|p1
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|free
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* Allocated in readline.  */
if|if
condition|(
name|p
operator|==
name|linebuffer
operator|||
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
condition|)
break|break;
name|p
operator|--
expr_stmt|;
comment|/* Put on top of '\'.  */
name|local_prompt
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|got_eof
condition|)
return|return
name|NULL
return|;
define|#
directive|define
name|SERVER_COMMAND_LENGTH
value|7
name|server_command
operator|=
operator|(
name|p
operator|-
name|linebuffer
operator|>
name|SERVER_COMMAND_LENGTH
operator|)
operator|&&
name|STREQN
argument_list|(
name|linebuffer
argument_list|,
literal|"server "
argument_list|,
name|SERVER_COMMAND_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_command
condition|)
block|{
comment|/* Note that we don't set `line'.  Between this and the check in 	 dont_repeat, this insures that repeating will still do the 	 right thing.  */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|linebuffer
operator|+
name|SERVER_COMMAND_LENGTH
return|;
block|}
comment|/* Do history expansion if that is wished.  */
if|if
condition|(
name|history_expansion_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|char
modifier|*
name|history_value
decl_stmt|;
name|int
name|expanded
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Insert null now.  */
name|expanded
operator|=
name|history_expand
argument_list|(
name|linebuffer
argument_list|,
operator|&
name|history_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
condition|)
block|{
comment|/* Print the changes.  */
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
comment|/* If there was an error, call this function again.  */
if|if
condition|(
name|expanded
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
return|return
name|command_line_input
argument_list|(
name|prrompt
argument_list|,
name|repeat
argument_list|,
name|annotation_suffix
argument_list|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|+
literal|1
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|linebuffer
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
name|p
operator|=
name|linebuffer
operator|+
name|strlen
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we just got an empty line, and that is supposed      to repeat the previous command, return the value in the      global buffer.  */
if|if
condition|(
name|repeat
operator|&&
name|p
operator|==
name|linebuffer
condition|)
return|return
name|line
return|;
for|for
control|(
name|p1
operator|=
name|linebuffer
init|;
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|;
name|p1
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|repeat
operator|&&
operator|!
operator|*
name|p1
condition|)
return|return
name|line
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Add line to history if appropriate.  */
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|&&
operator|*
name|linebuffer
condition|)
name|add_history
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
comment|/* Note: lines consisting solely of comments are added to the command      history.  This is useful when you type a command, and then      realize you don't want to execute it quite yet.  You can comment      out the command and then later fetch it from the value history      and remove the '#'.  The kill ring is probably better, but some      people are in the habit of commenting things out.  */
if|if
condition|(
operator|*
name|p1
operator|==
literal|'#'
condition|)
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
comment|/* Found a comment. */
comment|/* Save into global buffer if appropriate.  */
if|if
condition|(
name|repeat
condition|)
block|{
if|if
condition|(
name|linelength
operator|>
name|linesize
condition|)
block|{
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|linelength
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
return|return
name|linebuffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand the body_list of COMMAND so that it can hold NEW_LENGTH    code bodies.  This is typically used when we encounter an "else"    clause for an "if" command.  */
end_comment

begin_function
specifier|static
name|void
name|realloc_body_list
parameter_list|(
name|command
parameter_list|,
name|new_length
parameter_list|)
name|struct
name|command_line
modifier|*
name|command
decl_stmt|;
name|int
name|new_length
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_list
decl_stmt|;
name|n
operator|=
name|command
operator|->
name|body_count
expr_stmt|;
comment|/* Nothing to do?  */
if|if
condition|(
name|new_length
operator|<=
name|n
condition|)
return|return;
name|body_list
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|new_length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|body_list
argument_list|,
name|command
operator|->
name|body_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
operator|->
name|body_list
argument_list|)
expr_stmt|;
name|command
operator|->
name|body_list
operator|=
name|body_list
expr_stmt|;
name|command
operator|->
name|body_count
operator|=
name|new_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read one line from the input stream.  If the command is an "else" or    "end", return such an indication to the caller.  */
end_comment

begin_function
specifier|static
name|enum
name|misc_command_type
name|read_next_line
parameter_list|(
name|command
parameter_list|)
name|struct
name|command_line
modifier|*
modifier|*
name|command
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|prompt_ptr
decl_stmt|,
name|control_prompt
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|control_level
operator|>=
literal|254
condition|)
name|error
argument_list|(
literal|"Control nesting too deep!\n"
argument_list|)
expr_stmt|;
comment|/* Set a prompt based on the nesting of the control commands.  */
if|if
condition|(
name|instream
operator|==
name|stdin
operator|||
operator|(
name|instream
operator|==
literal|0
operator|&&
name|readline_hook
operator|!=
name|NULL
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|control_level
condition|;
name|i
operator|++
control|)
name|control_prompt
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|control_prompt
index|[
name|i
index|]
operator|=
literal|'>'
expr_stmt|;
name|control_prompt
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prompt_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|control_prompt
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|prompt_ptr
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|command_line_input
argument_list|(
name|prompt_ptr
argument_list|,
name|instream
operator|==
name|stdin
argument_list|,
literal|"commands"
argument_list|)
expr_stmt|;
comment|/* Not sure what to do here.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|end_command
return|;
comment|/* Strip leading and trailing whitespace.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|p
operator|&&
operator|(
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p1
operator|--
expr_stmt|;
comment|/* Blanks and comments don't really do anything, but we need to      distinguish them from else, end and other commands which can be      executed.  */
if|if
condition|(
name|p1
operator|==
name|p
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
return|return
name|nop_command
return|;
comment|/* Is this the end of a simple, while, or if control structure?  */
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|end_command
return|;
comment|/* Is the else clause of an if control structure?  */
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|else_command
return|;
comment|/* Check for while, if, break, continue, etc and build a new command      line structure for them.  */
if|if
condition|(
name|p1
operator|-
name|p
operator|>
literal|5
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"while"
argument_list|,
literal|5
argument_list|)
condition|)
operator|*
name|command
operator|=
name|build_command_line
argument_list|(
name|while_control
argument_list|,
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|-
name|p
operator|>
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"if"
argument_list|,
literal|2
argument_list|)
condition|)
operator|*
name|command
operator|=
name|build_command_line
argument_list|(
name|if_control
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|10
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"loop_break"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|*
name|command
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|control_type
operator|=
name|break_control
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|13
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"loop_continue"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
operator|*
name|command
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|control_type
operator|=
name|continue_control
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* A normal command.  */
operator|*
name|command
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|control_type
operator|=
name|simple_control
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Nothing special.  */
return|return
name|ok_command
return|;
block|}
end_function

begin_comment
comment|/* Recursively read in the control structures and create a command_line     structure from them.     The parent_control parameter is the control structure in which the    following commands are nested.  */
end_comment

begin_function
specifier|static
name|enum
name|command_control_type
name|recurse_read_control_structure
parameter_list|(
name|current_cmd
parameter_list|)
name|struct
name|command_line
modifier|*
name|current_cmd
decl_stmt|;
block|{
name|int
name|current_body
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|misc_command_type
name|val
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_ptr
decl_stmt|,
modifier|*
name|child_tail
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|child_tail
operator|=
name|NULL
expr_stmt|;
name|current_body
operator|=
literal|1
expr_stmt|;
comment|/* Sanity checks.  */
if|if
condition|(
name|current_cmd
operator|->
name|control_type
operator|==
name|simple_control
condition|)
block|{
name|error
argument_list|(
literal|"Recursed on a simple control type\n"
argument_list|)
expr_stmt|;
return|return
name|invalid_control
return|;
block|}
if|if
condition|(
name|current_body
operator|>
name|current_cmd
operator|->
name|body_count
condition|)
block|{
name|error
argument_list|(
literal|"Allocated body is smaller than this command type needs\n"
argument_list|)
expr_stmt|;
return|return
name|invalid_control
return|;
block|}
comment|/* Read lines from the input stream and build control structures.  */
while|while
condition|(
literal|1
condition|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|read_next_line
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
comment|/* Just skip blanks and comments.  */
if|if
condition|(
name|val
operator|==
name|nop_command
condition|)
continue|continue;
if|if
condition|(
name|val
operator|==
name|end_command
condition|)
block|{
if|if
condition|(
name|current_cmd
operator|->
name|control_type
operator|==
name|while_control
operator|||
name|current_cmd
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
comment|/* Success reading an entire control structure.  */
name|ret
operator|=
name|simple_control
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ret
operator|=
name|invalid_control
expr_stmt|;
break|break;
block|}
block|}
comment|/* Not the end of a control structure.  */
if|if
condition|(
name|val
operator|==
name|else_command
condition|)
block|{
if|if
condition|(
name|current_cmd
operator|->
name|control_type
operator|==
name|if_control
operator|&&
name|current_body
operator|==
literal|1
condition|)
block|{
name|realloc_body_list
argument_list|(
name|current_cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|current_body
operator|=
literal|2
expr_stmt|;
name|child_tail
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|ret
operator|=
name|invalid_control
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|child_tail
condition|)
block|{
name|child_tail
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|body_ptr
operator|=
name|current_cmd
operator|->
name|body_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|current_body
condition|;
name|i
operator|++
control|)
name|body_ptr
operator|++
expr_stmt|;
operator|*
name|body_ptr
operator|=
name|next
expr_stmt|;
block|}
name|child_tail
operator|=
name|next
expr_stmt|;
comment|/* If the latest line is another control structure, then recurse 	 on it.  */
if|if
condition|(
name|next
operator|->
name|control_type
operator|==
name|while_control
operator|||
name|next
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
name|control_level
operator|++
expr_stmt|;
name|ret
operator|=
name|recurse_read_control_structure
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|control_level
operator|--
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|simple_control
condition|)
break|break;
block|}
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Read lines from the input stream and accumulate them in a chain of    struct command_line's, which is then returned.  For input from a    terminal, the special command "end" is used to mark the end of the    input, and is not included in the returned chain of commands. */
end_comment

begin_define
define|#
directive|define
name|END_MESSAGE
value|"End with a line saying just \"end\"."
end_define

begin_function
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|(
name|prompt
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|enum
name|misc_command_type
name|val
decl_stmt|;
if|if
condition|(
name|readline_begin_hook
condition|)
block|{
comment|/* Note - intentional to merge messages with no newline */
call|(
modifier|*
name|readline_begin_hook
call|)
argument_list|(
literal|"%s  %s\n"
argument_list|,
name|prompt
argument_list|,
name|END_MESSAGE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
operator|&&
name|input_from_terminal_p
argument_list|()
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%s\n%s\n"
argument_list|,
name|prompt
argument_list|,
name|END_MESSAGE
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|tail
operator|=
name|NULL
expr_stmt|;
name|old_chain
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|val
operator|=
name|read_next_line
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
comment|/* Ignore blank lines or comments.  */
if|if
condition|(
name|val
operator|==
name|nop_command
condition|)
continue|continue;
if|if
condition|(
name|val
operator|==
name|end_command
condition|)
block|{
name|ret
operator|=
name|simple_control
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
operator|!=
name|ok_command
condition|)
block|{
name|ret
operator|=
name|invalid_control
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|next
operator|->
name|control_type
operator|==
name|while_control
operator|||
name|next
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
name|control_level
operator|++
expr_stmt|;
name|ret
operator|=
name|recurse_read_control_structure
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|control_level
operator|--
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|invalid_control
condition|)
break|break;
block|}
if|if
condition|(
name|tail
condition|)
block|{
name|tail
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
name|next
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_command_lines
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
block|}
name|tail
operator|=
name|next
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|head
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|invalid_control
condition|)
block|{
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readline_end_hook
condition|)
block|{
call|(
modifier|*
name|readline_end_hook
call|)
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a chain of struct command_line's.  */
end_comment

begin_function
name|void
name|free_command_lines
parameter_list|(
name|lptr
parameter_list|)
name|struct
name|command_line
modifier|*
modifier|*
name|lptr
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|l
init|=
operator|*
name|lptr
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|blist
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|body_count
operator|>
literal|0
condition|)
block|{
name|blist
operator|=
name|l
operator|->
name|body_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|body_count
condition|;
name|i
operator|++
operator|,
name|blist
operator|++
control|)
name|free_command_lines
argument_list|(
name|blist
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of info subcommands.  */
end_comment

begin_function_decl
name|void
name|add_info
parameter_list|(
name|name
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|no_class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias to the list of info subcommands.  */
end_comment

begin_function
name|void
name|add_info_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
literal|0
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "info" command is defined as a prefix, with allow_unknown = 0.    Therefore, its own definition is called only for "info" with no args.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|info_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|infolist
argument_list|,
literal|"info "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "complete" command is used by Emacs to implement completion.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|complete_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|argpoint
decl_stmt|;
name|char
modifier|*
name|completion
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
literal|""
expr_stmt|;
name|argpoint
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
name|completion
operator|=
name|line_completion_function
argument_list|(
name|arg
argument_list|,
name|i
operator|=
literal|0
argument_list|,
name|arg
argument_list|,
name|argpoint
argument_list|)
init|;
name|completion
condition|;
name|completion
operator|=
name|line_completion_function
argument_list|(
name|arg
argument_list|,
operator|++
name|i
argument_list|,
name|arg
argument_list|,
name|argpoint
argument_list|)
control|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|completion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|completion
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The "show" command with no arguments shows all the settings.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of commands.  */
end_comment

begin_function_decl
name|void
name|add_com
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias or abbreviation command to the list of commands.  */
end_comment

begin_function
name|void
name|add_com_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|class
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
name|class
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error_no_arg
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Argument required (%s)."
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|help_command
parameter_list|(
name|command
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
comment|/* Ignored */
block|{
name|help_cmd
argument_list|(
name|command
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_comname
parameter_list|(
name|comname
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|comname
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"name of command to define"
argument_list|)
expr_stmt|;
name|p
operator|=
name|comname
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|'_'
condition|)
name|error
argument_list|(
literal|"Junk in argument list: \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is just a placeholder in the command data structures.  */
end_comment

begin_function
specifier|static
name|void
name|user_defined_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|define_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|newc
decl_stmt|,
modifier|*
name|hookc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
define|#
directive|define
name|HOOK_STRING
value|"hook-"
define|#
directive|define
name|HOOK_LEN
value|5
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
comment|/* Look it up, and verify that we got an exact match.  */
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|!
name|STREQ
argument_list|(
name|comname
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
operator|||
name|c
operator|->
name|class
operator|==
name|class_alias
condition|)
name|tem
operator|=
literal|"Redefine command \"%s\"? "
expr_stmt|;
else|else
name|tem
operator|=
literal|"Really redefine built-in command \"%s\"? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|tem
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Command \"%s\" not redefined."
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* If this new command is a hook, then mark the command which it      is hooking.  Note that we allow hooking `help' commands, so that      we can hook the `stop' pseudo-command.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|comname
argument_list|,
name|HOOK_STRING
argument_list|,
name|HOOK_LEN
argument_list|)
condition|)
block|{
comment|/* Look up cmd it hooks, and verify that we got an exact match.  */
name|tem
operator|=
name|comname
operator|+
name|HOOK_LEN
expr_stmt|;
name|hookc
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hookc
operator|&&
operator|!
name|STREQ
argument_list|(
name|comname
operator|+
name|HOOK_LEN
argument_list|,
name|hookc
operator|->
name|name
argument_list|)
condition|)
name|hookc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hookc
condition|)
block|{
name|warning
argument_list|(
literal|"Your new `%s' command does not hook any existing command."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Proceed? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
block|}
name|comname
operator|=
name|savestring
argument_list|(
name|comname
argument_list|,
name|strlen
argument_list|(
name|comname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the rest of the commands will be case insensitive, this one      should behave in the same manner. */
for|for
control|(
name|tem
operator|=
name|comname
init|;
operator|*
name|tem
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|tem
argument_list|)
condition|)
operator|*
name|tem
operator|=
name|tolower
argument_list|(
operator|*
name|tem
argument_list|)
expr_stmt|;
name|control_level
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Type commands for definition of \"%s\"."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|cmds
operator|=
name|read_command_lines
argument_list|(
name|tmpbuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|free_command_lines
argument_list|(
operator|&
name|c
operator|->
name|user_commands
argument_list|)
expr_stmt|;
name|newc
operator|=
name|add_cmd
argument_list|(
name|comname
argument_list|,
name|class_user
argument_list|,
name|user_defined_command
argument_list|,
operator|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
operator|)
condition|?
name|c
operator|->
name|doc
else|:
name|savestring
argument_list|(
literal|"User-defined."
argument_list|,
literal|13
argument_list|)
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|newc
operator|->
name|user_commands
operator|=
name|cmds
expr_stmt|;
comment|/* If this new command is a hook, then mark both commands as being      tied.  */
if|if
condition|(
name|hookc
condition|)
block|{
name|hookc
operator|->
name|hook
operator|=
name|newc
expr_stmt|;
comment|/* Target gets hooked.  */
name|newc
operator|->
name|hookee
operator|=
name|hookc
expr_stmt|;
comment|/* We are marked as hooking target cmd.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|document_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|doclines
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Command \"%s\" is built-in."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Type documentation for \"%s\"."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|doclines
operator|=
name|read_command_lines
argument_list|(
name|tmpbuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|doc
condition|)
name|free
argument_list|(
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cl1
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|cl1
operator|->
name|line
argument_list|)
operator|+
literal|1
expr_stmt|;
name|c
operator|->
name|doc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|c
operator|->
name|doc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
block|{
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|cl1
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl1
operator|->
name|next
condition|)
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
operator|&
name|doclines
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the GDB banner. */
end_comment

begin_function
name|void
name|print_gdb_version
parameter_list|(
name|stream
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* From GNU coding standards, first line is meant to be easy for a      program to parse, and is just canonical program name and version      number, which starts after last space. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"GNU gdb %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|/* Second line is a copyright notice. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Copyright 1998 Free Software Foundation, Inc.\n"
argument_list|)
expr_stmt|;
comment|/* Following the copyright is a brief statement that the program is      free software, that users are free to copy and change it on      certain conditions, that it is covered by the GNU GPL, and that      there is no warranty. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\ GDB is free software, covered by the GNU General Public License, and you are\n\ welcome to change it and/or distribute copies of it under certain conditions.\n\ Type \"show copying\" to see the conditions.\n\ There is absolutely no warranty for GDB.  Type \"show warranty\" for details.\n"
argument_list|)
expr_stmt|;
comment|/* After the required info we print the configuration information. */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"This GDB was configured as \""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|host_name
argument_list|,
name|target_name
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"--host=%s --target=%s"
argument_list|,
name|host_name
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|host_name
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\"."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_version
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* xgdb calls this to reprint the usual GDB prompt.  Obsolete now that xgdb    is obsolete.  */
end_comment

begin_function
name|void
name|print_prompt
parameter_list|()
block|{
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This replaces the above for the frontends: it returns a pointer    to the prompt. */
end_comment

begin_function
name|char
modifier|*
name|get_prompt
parameter_list|()
block|{
return|return
name|prompt
return|;
block|}
end_function

begin_function
name|void
name|set_prompt
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* ??rehrauer: I don't know why this fails, since it looks as though    assignments to prompt are wrapped in calls to savestring...   if (prompt != NULL)     free (prompt); */
name|prompt
operator|=
name|savestring
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If necessary, make the user confirm that we should quit.  Return    non-zero if we should quit, zero if we shouldn't.  */
end_comment

begin_function
name|int
name|quit_confirm
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
operator|&&
name|target_has_execution
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* This is something of a hack.  But there's no reliable way to 	 see if a GUI is running.  The `use_windows' variable doesn't 	 cut it.  */
if|if
condition|(
name|init_ui_hook
condition|)
name|s
operator|=
literal|"A debugging session is active.\nDo you still want to close the debugger?"
expr_stmt|;
elseif|else
if|if
condition|(
name|attach_flag
condition|)
name|s
operator|=
literal|"The program is running.  Quit anyway (and detach it)? "
expr_stmt|;
else|else
name|s
operator|=
literal|"The program is running.  Exit anyway? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Quit without asking for confirmation.  */
end_comment

begin_function
name|void
name|quit_force
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|exit_code
init|=
literal|0
decl_stmt|;
comment|/* An optional expression may be used to cause gdb to terminate with the       value of that expression. */
if|if
condition|(
name|args
condition|)
block|{
name|value_ptr
name|val
init|=
name|parse_and_eval
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|exit_code
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
operator|&&
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|attach_flag
condition|)
name|target_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|target_kill
argument_list|()
expr_stmt|;
block|}
comment|/* UDI wants this, to kill the TIP.  */
name|target_close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Save the history information if it is appropriate to do so.  */
if|if
condition|(
name|write_history_p
operator|&&
name|history_filename
condition|)
name|write_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
name|do_final_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do any final cleanups before exiting */
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/* tuiDo((TuiOpaqueFuncPtr)tuiCleanUp); */
comment|/* The above does not need to be inside a tuiDo(), since    * it is not manipulating the curses screen, but rather,    * it is tearing it down.    */
if|if
condition|(
name|tui_version
condition|)
name|tuiCleanUp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the quit command.  */
end_comment

begin_function
name|void
name|quit_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quit_confirm
argument_list|()
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|quit_force
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns whether GDB is running on a terminal and whether the user    desires that questions be asked of them on that terminal.  */
end_comment

begin_function
name|int
name|input_from_terminal_p
parameter_list|()
block|{
return|return
name|gdb_has_a_terminal
argument_list|()
operator|&&
operator|(
name|instream
operator|==
name|stdin
operator|)
operator|&
name|caution
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|pwd_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"The \"pwd\" command does not take an argument: %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|gdb_dirbuf
argument_list|,
name|current_directory
argument_list|)
condition|)
name|printf_unfiltered
argument_list|(
literal|"Working directory %s\n (canonically %s).\n"
argument_list|,
name|current_directory
argument_list|,
name|gdb_dirbuf
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Working directory %s.\n"
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cd_command
parameter_list|(
name|dir
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
comment|/* Found something other than leading repetitions of "/..".  */
name|int
name|found_real_path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If the new directory is absolute, repeat is a no-op; if relative,      repeat might be useful but is more likely to be a mistake.  */
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"new working directory"
argument_list|)
expr_stmt|;
name|dir
operator|=
name|tilde_expand
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|savestring
argument_list|(
name|dir
argument_list|,
name|len
operator|-
operator|(
name|len
operator|>
literal|1
operator|&&
name|SLASH_P
argument_list|(
name|dir
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ROOTED_P
argument_list|(
name|dir
argument_list|)
condition|)
name|current_directory
operator|=
name|dir
expr_stmt|;
else|else
block|{
if|if
condition|(
name|SLASH_P
argument_list|(
name|current_directory
index|[
literal|0
index|]
argument_list|)
operator|&&
name|current_directory
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|SLASH_STRING
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Now simplify any occurrences of `.' and `..' in the pathname.  */
name|found_real_path
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_directory
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|SLASH_P
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|SLASH_P
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SLASH_P
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|SLASH_P
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|found_real_path
condition|)
block|{
comment|/* Search backwards for the directory just before the "/.." 		 and obliterate it and the "/..".  */
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
name|q
operator|!=
name|current_directory
operator|&&
operator|!
name|SLASH_P
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|current_directory
condition|)
comment|/* current_directory is 		   a relative pathname ("can't happen"--leave it alone).  */
operator|++
name|p
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|q
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* We are dealing with leading repetitions of "/..", for example 	       "/../..", which is the Mach super-root.  */
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|found_real_path
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|forget_cached_source_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|pwd_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|source_cleanup_lines_args
block|{
name|int
name|old_line
decl_stmt|;
name|char
modifier|*
name|old_file
decl_stmt|;
name|char
modifier|*
name|old_pre_error
decl_stmt|;
name|char
modifier|*
name|old_error_pre_print
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|source_cleanup_lines
parameter_list|(
name|args
parameter_list|)
name|PTR
name|args
decl_stmt|;
block|{
name|struct
name|source_cleanup_lines_args
modifier|*
name|p
init|=
operator|(
expr|struct
name|source_cleanup_lines_args
operator|*
operator|)
name|args
decl_stmt|;
name|source_line_number
operator|=
name|p
operator|->
name|old_line
expr_stmt|;
name|source_file_name
operator|=
name|p
operator|->
name|old_file
expr_stmt|;
name|source_pre_error
operator|=
name|p
operator|->
name|old_pre_error
expr_stmt|;
name|error_pre_print
operator|=
name|p
operator|->
name|old_error_pre_print
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|source_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|args
decl_stmt|;
name|struct
name|source_cleanup_lines_args
name|old_lines
decl_stmt|;
name|int
name|needed_length
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"source command requires pathname of file to source."
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|tilde_expand
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
if|if
condition|(
name|from_tty
condition|)
name|perror_with_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
return|return;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|fclose
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|old_lines
operator|.
name|old_line
operator|=
name|source_line_number
expr_stmt|;
name|old_lines
operator|.
name|old_file
operator|=
name|source_file_name
expr_stmt|;
name|old_lines
operator|.
name|old_pre_error
operator|=
name|source_pre_error
expr_stmt|;
name|old_lines
operator|.
name|old_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|make_cleanup
argument_list|(
name|source_cleanup_lines
argument_list|,
operator|&
name|old_lines
argument_list|)
expr_stmt|;
name|source_line_number
operator|=
literal|0
expr_stmt|;
name|source_file_name
operator|=
name|file
expr_stmt|;
name|source_pre_error
operator|=
name|error_pre_print
operator|==
name|NULL
condition|?
literal|""
else|:
name|error_pre_print
expr_stmt|;
name|source_pre_error
operator|=
name|savestring
argument_list|(
name|source_pre_error
argument_list|,
name|strlen
argument_list|(
name|source_pre_error
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|source_pre_error
argument_list|)
expr_stmt|;
comment|/* This will get set every time we read a line.  So it won't stay "" for      long.  */
name|error_pre_print
operator|=
literal|""
expr_stmt|;
name|needed_length
operator|=
name|strlen
argument_list|(
name|source_file_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|source_pre_error
argument_list|)
operator|+
literal|80
expr_stmt|;
if|if
condition|(
name|source_error_allocated
operator|<
name|needed_length
condition|)
block|{
name|source_error_allocated
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|source_error_allocated
operator|<
name|needed_length
condition|)
name|source_error_allocated
operator|=
name|needed_length
expr_stmt|;
if|if
condition|(
name|source_error
operator|==
name|NULL
condition|)
name|source_error
operator|=
name|xmalloc
argument_list|(
name|source_error_allocated
argument_list|)
expr_stmt|;
else|else
name|source_error
operator|=
name|xrealloc
argument_list|(
name|source_error
argument_list|,
name|source_error_allocated
argument_list|)
expr_stmt|;
block|}
name|read_command_file
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|echo_command
parameter_list|(
name|text
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|text
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	       so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Force this output to appear now.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dont_repeat_command
parameter_list|(
name|ignored
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignored
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
operator|*
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Can't call dont_repeat here because we're not 			   necessarily reading from stdin.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manipulate command line editing control variables.  */
end_comment

begin_comment
comment|/* Number of commands to print in each call to show_commands.  */
end_comment

begin_define
define|#
directive|define
name|Hist_print
value|10
end_define

begin_function
specifier|static
name|void
name|show_commands
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Index for history commands.  Relative to history_base.  */
name|int
name|offset
decl_stmt|;
comment|/* Number of the history entry which we are planning to display next.      Relative to history_base.  */
specifier|static
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|/* The first command in the history which doesn't exist (i.e. one more      than the number of the last command).  Relative to history_base.  */
name|int
name|hist_len
decl_stmt|;
specifier|extern
name|HIST_ENTRY
modifier|*
name|history_get
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Print out some of the commands from the command history.  */
comment|/* First determine the length of the history list.  */
name|hist_len
operator|=
name|history_size
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|history_size
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
condition|)
block|{
name|hist_len
operator|=
name|offset
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "info editing +" should print from the stored position.  */
empty_stmt|;
else|else
comment|/* "info editing<exp>" should print around command number<exp>.  */
name|num
operator|=
operator|(
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
operator|-
name|history_base
operator|)
operator|-
name|Hist_print
operator|/
literal|2
expr_stmt|;
block|}
comment|/* "show commands" means print the last Hist_print commands.  */
else|else
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
comment|/* If there are at least Hist_print commands, we want to display the last      Hist_print rather than, say, the last 6.  */
if|if
condition|(
name|hist_len
operator|-
name|num
operator|<
name|Hist_print
condition|)
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
name|num
init|;
name|offset
operator|<
name|num
operator|+
name|Hist_print
operator|&&
name|offset
operator|<
name|hist_len
condition|;
name|offset
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%5d  %s\n"
argument_list|,
name|history_base
operator|+
name|offset
argument_list|,
operator|(
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
operator|)
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* The next command we want to display is the next one that we haven't      displayed yet.  */
name|num
operator|+=
name|Hist_print
expr_stmt|;
comment|/* If the user repeats this command with return, it should do what      "show commands +" does.  This is unnecessary if arg is null,      because "show commands +" is not useful after "show commands".  */
if|if
condition|(
name|from_tty
operator|&&
name|args
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_history_size_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|history_size
operator|==
name|INT_MAX
condition|)
name|unstifle_history
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|history_size
operator|>=
literal|0
condition|)
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
else|else
block|{
name|history_size
operator|=
name|INT_MAX
expr_stmt|;
name|error
argument_list|(
literal|"History size must be non-negative"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_history
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set history\" must be followed by the name of a history subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_history
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showhistlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|info_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default verbose msgs off */
end_comment

begin_comment
comment|/* Called by do_setshow_command.  An elaborate joke.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_verbose
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|cmdname
init|=
literal|"verbose"
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|showcmd
decl_stmt|;
name|showcmd
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|cmdname
argument_list|,
name|showlist
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbose printing of informational messages."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbose printing of informational messages."
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbosity."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbosity."
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|float_handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* This message is based on ANSI C, section 4.7.  Note that integer      divide by zero causes this, so "float" is a misnomer.  */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Erroneous arithmetic operation."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|init_cmd_lists
parameter_list|()
block|{
name|cmdlist
operator|=
name|NULL
expr_stmt|;
name|infolist
operator|=
name|NULL
expr_stmt|;
name|enablelist
operator|=
name|NULL
expr_stmt|;
name|disablelist
operator|=
name|NULL
expr_stmt|;
name|togglelist
operator|=
name|NULL
expr_stmt|;
name|stoplist
operator|=
name|NULL
expr_stmt|;
name|deletelist
operator|=
name|NULL
expr_stmt|;
name|enablebreaklist
operator|=
name|NULL
expr_stmt|;
name|setlist
operator|=
name|NULL
expr_stmt|;
name|unsetlist
operator|=
name|NULL
expr_stmt|;
name|showlist
operator|=
name|NULL
expr_stmt|;
name|sethistlist
operator|=
name|NULL
expr_stmt|;
name|showhistlist
operator|=
name|NULL
expr_stmt|;
name|unsethistlist
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|maintenancelist
operator|=
name|NULL
expr_stmt|;
name|maintenanceinfolist
operator|=
name|NULL
expr_stmt|;
name|maintenanceprintlist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|setprintlist
operator|=
name|NULL
expr_stmt|;
name|showprintlist
operator|=
name|NULL
expr_stmt|;
name|setchecklist
operator|=
name|NULL
expr_stmt|;
name|showchecklist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Init the history buffer.  Note that we are called after the init file(s)  * have been read so that the user can change the history file via his  * .gdbinit file (for instance).  The GDBHISTFILE environment variable  * overrides all of this.  */
end_comment

begin_function
name|void
name|init_history
parameter_list|()
block|{
name|char
modifier|*
name|tmpenv
decl_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"HISTSIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_size
operator|=
name|atoi
argument_list|(
name|tmpenv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_size
condition|)
name|history_size
operator|=
literal|256
expr_stmt|;
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"GDBHISTFILE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_filename
operator|=
name|savestring
argument_list|(
name|tmpenv
argument_list|,
name|strlen
argument_list|(
name|tmpenv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_filename
condition|)
block|{
comment|/* We include the current directory so that if the user changes        directories the file written will be the same as the one        that was read.  */
name|history_filename
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/.gdb_history"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|read_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_main
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_PROMPT
name|prompt
operator|=
name|savestring
argument_list|(
name|DEFAULT_PROMPT
argument_list|,
name|strlen
argument_list|(
name|DEFAULT_PROMPT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|prompt
operator|=
name|savestring
argument_list|(
literal|"(gdb) "
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the important stuff up for command editing.  */
name|command_editing_p
operator|=
literal|1
expr_stmt|;
name|history_expansion_p
operator|=
literal|0
expr_stmt|;
name|write_history_p
operator|=
literal|0
expr_stmt|;
comment|/* Setup important stuff for command line editing.  */
name|rl_completion_entry_function
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|readline_line_completion_function
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
name|rl_completer_quote_characters
operator|=
name|gdb_completer_quote_characters
expr_stmt|;
name|rl_readline_name
operator|=
literal|"gdb"
expr_stmt|;
comment|/* Define the classes of commands.      They will appear in the help list in the reverse of this order.  */
name|add_cmd
argument_list|(
literal|"internals"
argument_list|,
name|class_maintenance
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Maintenance commands.\n\ Some gdb commands are provided just for use by gdb maintainers.\n\ These commands are subject to frequent change, and may not be as\n\ well documented as user commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"obscure"
argument_list|,
name|class_obscure
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Obscure features."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"aliases"
argument_list|,
name|class_alias
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Aliases of other commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user-defined"
argument_list|,
name|class_user
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"User-defined commands.\n\ The commands in this class are those defined by the user.\n\ Use the \"define\" command to define a command."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"support"
argument_list|,
name|class_support
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Support facilities."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbx_commands
condition|)
name|add_cmd
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Status inquiries."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"files"
argument_list|,
name|class_files
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Specifying and examining files."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Making program stop at certain points."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"data"
argument_list|,
name|class_vars
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Examining data."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stack"
argument_list|,
name|class_stack
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Examining the stack.\n\ The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\ counting from zero for the innermost (currently executing) frame.\n\n\ At any time gdb identifies one frame as the \"selected\" frame.\n\ Variable lookups are done with respect to the selected frame.\n\ When the program being debugged stops, gdb selects the innermost frame.\n\ The commands below can be used to select other frames by number or address."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"running"
argument_list|,
name|class_run
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Running the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pwd"
argument_list|,
name|class_files
argument_list|,
name|pwd_command
argument_list|,
literal|"Print working directory.  This is used for your program as well."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"cd"
argument_list|,
name|class_files
argument_list|,
name|cd_command
argument_list|,
literal|"Set working directory to DIR for debugger and program being debugged.\n\ The change does not take effect for the program being debugged\n\ until the next time it is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"prompt"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prompt
argument_list|,
literal|"Set gdb's prompt"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"echo"
argument_list|,
name|class_support
argument_list|,
name|echo_command
argument_list|,
literal|"Print a constant string.  Give string as argument.\n\ C escape sequences may be used in the argument.\n\ No newline is added at the end of the argument;\n\ use \"\\n\" if you want a newline to be printed.\n\ Since leading and trailing whitespace are ignored in command arguments,\n\ if you want to print some you must use \"\\\" before leading whitespace\n\ to be printed or after trailing whitespace."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"document"
argument_list|,
name|class_support
argument_list|,
name|document_command
argument_list|,
literal|"Document a user-defined command.\n\ Give command name as argument.  Give documentation on following lines.\n\ End with a line of just \"end\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"define"
argument_list|,
name|class_support
argument_list|,
name|define_command
argument_list|,
literal|"Define a new command name.  Command name is argument.\n\ Definition appears on following lines, one command per line.\n\ End with a line of just \"end\".\n\ Use the \"document\" command to give documentation for the new command.\n\ Commands defined in this way may have up to ten arguments."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|c
operator|=
name|add_cmd
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \""
name|GDBINIT_FILENAME
literal|"\" is read automatically in this way\n\ when gdb is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Punt file name, we can't help it easily.  */
name|c
operator|=
name|add_cmd
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \".gdbinit\" is read automatically in this way\n\ when gdb is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"quit"
argument_list|,
name|class_support
argument_list|,
name|quit_command
argument_list|,
literal|"Exit gdb."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"help"
argument_list|,
name|class_support
argument_list|,
name|help_command
argument_list|,
literal|"Print list of commands."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"q"
argument_list|,
literal|"quit"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"dont-repeat"
argument_list|,
name|class_support
argument_list|,
name|dont_repeat_command
argument_list|,
literal|"Don't repeat this command.\n\ Primarily used inside of user-defined commands that should not be repeated when\n\ hitting return."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"verbose"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|info_verbose
argument_list|,
literal|"Set "
argument_list|,
operator|&
name|setlist
argument_list|)
operator|,
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_verbose
expr_stmt|;
name|set_verbose
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"editing"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|command_editing_p
argument_list|,
literal|"Set editing of command lines as they are typed.\n\ Use \"on\" to enable the editing, and \"off\" to disable it.\n\ Without an argument, command line editing is enabled.  To edit, use\n\ EMACS-like or VI-like commands like control-P or ESC."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|set_history
argument_list|,
literal|"Generic command for setting command history parameters."
argument_list|,
operator|&
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|show_history
argument_list|,
literal|"Generic command for showing command history parameters."
argument_list|,
operator|&
name|showhistlist
argument_list|,
literal|"show history "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expansion"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_expansion_p
argument_list|,
literal|"Set history expansion on command input.\n\ Without an argument, history expansion is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"save"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_history_p
argument_list|,
literal|"Set saving of the history record on exit.\n\ Use \"on\" to enable the saving, and \"off\" to disable it.\n\ Without an argument, saving is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"size"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_size
argument_list|,
literal|"Set the size of the command history, \n\ ie. the number of previous commands to keep a record of."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_history_size_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"filename"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_filename
argument_list|,
literal|"Set the filename in which to record the command history\n\  (the list of previous commands of which a record is kept)."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"confirm"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|caution
argument_list|,
literal|"Set whether to confirm potentially dangerous operations."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_info
argument_list|,
name|info_command
argument_list|,
literal|"Generic command for showing things about the program being debugged."
argument_list|,
operator|&
name|infolist
argument_list|,
literal|"info "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"complete"
argument_list|,
name|class_obscure
argument_list|,
name|complete_command
argument_list|,
literal|"List the completions for the rest of the line as a command."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"show"
argument_list|,
name|class_info
argument_list|,
name|show_command
argument_list|,
literal|"Generic command for showing things about the debugger."
argument_list|,
operator|&
name|showlist
argument_list|,
literal|"show "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Another way to get at the same thing.  */
name|add_info
argument_list|(
literal|"set"
argument_list|,
name|show_command
argument_list|,
literal|"Show all GDB settings."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"commands"
argument_list|,
name|no_class
argument_list|,
name|show_commands
argument_list|,
literal|"Show the history of commands you typed.\n\ You can supply a command number to start with, or a `+' to start after\n\ the previous command number shown."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"version"
argument_list|,
name|no_class
argument_list|,
name|show_version
argument_list|,
literal|"Show what version of GDB this is."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"while"
argument_list|,
name|class_support
argument_list|,
name|while_command
argument_list|,
literal|"Execute nested commands WHILE the conditional expression is non zero.\n\ The conditional expression must follow the word `while' and must in turn be\n\ followed by a new line.  The nested commands must be entered one per line,\n\ and should be terminated by the word `end'."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"if"
argument_list|,
name|class_support
argument_list|,
name|if_command
argument_list|,
literal|"Execute nested commands once IF the conditional expression is non zero.\n\ The conditional expression must follow the word `if' and must in turn be\n\ followed by a new line.  The nested commands must be entered one per line,\n\ and should be terminated by the word 'else' or `end'.  If an else clause\n\ is used, the same rules apply to its nested commands as to the first ones."
argument_list|)
expr_stmt|;
comment|/* If target is open when baud changes, it doesn't take effect until the      next open (I think, not sure).  */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotebaud"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|baud_rate
argument_list|,
literal|"Set baud rate for remote serial I/O.\n\ This value is used to set the speed of the serial port when debugging\n\ using remote targets."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotedebug"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_debug
argument_list|,
literal|"Set debugging of remote protocol.\n\ When enabled, each packet sent or received with the remote target\n\ is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout limit to wait for target to respond.\n\ This value is used to set the time limit for gdb to wait for a response\n\ from the target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"annotate"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|annotation_level
argument_list|,
literal|"Set annotation_level.\n\ 0 == normal;     1 == fullname (for use when running under emacs)\n\ 2 == output annotated suitably for use by programs that control GDB."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

