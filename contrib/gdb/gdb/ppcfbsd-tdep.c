begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for PowerPC systems running FreeBSD.     Copyright 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Wasabi Systems, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_include
include|#
directive|include
file|"ppcfbsd-tdep.h"
end_include

begin_include
include|#
directive|include
file|"trad-frame.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_define
define|#
directive|define
name|REG_FIXREG_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((x) * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_LR_OFFSET
value|(32 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_CR_OFFSET
value|(33 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_XER_OFFSET
value|(34 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_CTR_OFFSET
value|(35 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|REG_PC_OFFSET
value|(36 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|SIZEOF_STRUCT_REG
value|(37 * sizeof(register_t))
end_define

begin_define
define|#
directive|define
name|FPREG_FPR_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((x) * 8)
end_define

begin_define
define|#
directive|define
name|FPREG_FPSCR_OFFSET
value|(32 * 8)
end_define

begin_define
define|#
directive|define
name|SIZEOF_STRUCT_FPREG
value|(33 * 8)
end_define

begin_function
name|void
name|ppcfbsd_supply_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
init|;
name|i
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|REG_FIXREG_OFFSET
argument_list|(
name|i
operator|-
name|tdep
operator|->
name|ppc_gp0_regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|regs
operator|+
name|REG_LR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
name|regs
operator|+
name|REG_CR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
name|regs
operator|+
name|REG_XER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
name|regs
operator|+
name|REG_CTR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|PC_REGNUM
argument_list|,
name|regs
operator|+
name|REG_PC_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ppcfbsd_fill_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
init|;
name|i
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|REG_FIXREG_OFFSET
argument_list|(
name|i
operator|-
name|tdep
operator|->
name|ppc_gp0_regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|regs
operator|+
name|REG_LR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
name|regs
operator|+
name|REG_CR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
name|regs
operator|+
name|REG_XER_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
name|regs
operator|+
name|REG_CTR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|PC_REGNUM
argument_list|,
name|regs
operator|+
name|REG_PC_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ppcfbsd_supply_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* FIXME: jimb/2004-05-05: Some PPC variants don't have floating      point registers.  Traditionally, GDB's register set has still      listed the floating point registers for such machines, so this      code is harmless.  However, the new E500 port actually omits the      floating point registers entirely from the register set --- they      don't even have register numbers assigned to them.       It's not clear to me how best to update this code, so this assert      will alert the first person to encounter the NetBSD/E500      combination to the problem.  */
name|gdb_assert
argument_list|(
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|FPLAST_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|fpregs
operator|+
name|FPREG_FPR_OFFSET
argument_list|(
name|i
operator|-
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_fpscr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|,
name|fpregs
operator|+
name|FPREG_FPSCR_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ppcfbsd_fill_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* FIXME: jimb/2004-05-05: Some PPC variants don't have floating      point registers.  Traditionally, GDB's register set has still      listed the floating point registers for such machines, so this      code is harmless.  However, the new E500 port actually omits the      floating point registers entirely from the register set --- they      don't even have register numbers assigned to them.       It's not clear to me how best to update this code, so this assert      will alert the first person to encounter the NetBSD/E500      combination to the problem.  */
name|gdb_assert
argument_list|(
name|ppc_floating_point_unit_p
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|FPLAST_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|i
argument_list|,
name|fpregs
operator|+
name|FPREG_FPR_OFFSET
argument_list|(
name|i
operator|-
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_fpscr_regnum
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|,
name|fpregs
operator|+
name|FPREG_FPSCR_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|ignore
parameter_list|)
block|{
name|char
modifier|*
name|regs
decl_stmt|,
modifier|*
name|fpregs
decl_stmt|;
comment|/* We get everything from one section.  */
if|if
condition|(
name|which
operator|!=
literal|0
condition|)
return|return;
name|regs
operator|=
name|core_reg_sect
expr_stmt|;
name|fpregs
operator|=
name|core_reg_sect
operator|+
name|SIZEOF_STRUCT_REG
expr_stmt|;
comment|/* Integer registers.  */
name|ppcfbsd_supply_reg
argument_list|(
name|regs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Floating point registers.  */
name|ppcfbsd_supply_fpreg
argument_list|(
name|fpregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_elfcore_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|ignore
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
comment|/* Integer registers.  */
if|if
condition|(
name|core_reg_size
operator|!=
name|SIZEOF_STRUCT_REG
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Wrong size register set in core file."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ppcfbsd_supply_reg
argument_list|(
name|core_reg_sect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Floating point registers.  */
if|if
condition|(
name|core_reg_size
operator|!=
name|SIZEOF_STRUCT_FPREG
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Wrong size FP register set in core file."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ppcfbsd_supply_fpreg
argument_list|(
name|core_reg_sect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't know what kind of register request this is; just ignore it.  */
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|ppcfbsd_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|ppcfbsd_elfcore_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_elfcore_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppcfbsd_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
return|return
operator|(
name|pc
operator|>=
literal|0x7fffef00U
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NetBSD is confused.  It appears that 1.5 was using the correct SVr4    convention but, 1.6 switched to the below broken convention.  For    the moment use the broken convention.  Ulgh!.  */
end_comment

begin_function
specifier|static
name|enum
name|return_value_convention
name|ppcfbsd_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
operator|!
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|16
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|8
operator|)
operator|)
operator|&&
operator|!
operator|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|1
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|2
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|4
operator|||
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|8
operator|)
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
else|else
return|return
name|ppc_sysv_abi_broken_return_value
argument_list|(
name|gdbarch
argument_list|,
name|valtype
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppcfbsd_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|ppcfbsd_pc_in_sigtramp
argument_list|)
expr_stmt|;
comment|/* For NetBSD, this is an on again, off again thing.  Some systems      do use the broken struct convention, and some don't.  */
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ppcfbsd_return_value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|svr4_lp64_fetch_link_map_offsets
argument_list|)
expr_stmt|;
else|#
directive|else
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|svr4_ilp32_fetch_link_map_offsets
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_initialize_ppcfbsd_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_rs6000
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_FREEBSD_ELF
argument_list|,
name|ppcfbsd_init_abi
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_powerpc
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_FREEBSD_ELF
argument_list|,
name|ppcfbsd_init_abi
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|ppcfbsd_core_fns
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|ppcfbsd_elfcore_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

