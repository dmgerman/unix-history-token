begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or it's performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for M32R by Michael Snyder, Cygnus Support.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *  The external function exceptionHandler() is  *  used to attach a specific handler to a specific M32R vector number.  *  It should use the same privilege level it runs at.  It should  *  install it as an interrupt gate so that interrupts are masked  *  while the handler runs.  *  *  Because gdb will sometimes write to the stack area to execute function  *  calls, this program cannot rely on using the supervisor stack so it  *  uses it's own stack area reserved in the int array remcomStack.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN  *                  AA..AA  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::<two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_comment
comment|/************************************************************************  *  * external low-level support routines  */
end_comment

begin_function_decl
specifier|extern
name|void
name|putDebugChar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* write a single character      */
end_comment

begin_function_decl
specifier|extern
name|int
name|getDebugChar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* read and return a single char */
end_comment

begin_function_decl
specifier|extern
name|void
name|exceptionHandler
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* assign an exception handler   */
end_comment

begin_comment
comment|/*****************************************************************************  * BUFMAX defines the maximum number of characters in inbound/outbound buffers  * at least NUMREGBYTES*2 are needed for register packets   */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|400
end_define

begin_decl_stmt
specifier|static
name|char
name|initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean flag. != 0 means we've been initialized */
end_comment

begin_decl_stmt
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  debug>  0 prints ill-formed commands in valid packets& checksum errors */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMREGS
value|24
end_define

begin_comment
comment|/* Number of bytes of registers.  */
end_comment

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(NUMREGS * 4)
end_define

begin_enum
enum|enum
name|regnames
block|{
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,
name|R12
block|,
name|R13
block|,
name|R14
block|,
name|R15
block|,
name|PSW
block|,
name|CBR
block|,
name|SPI
block|,
name|SPU
block|,
name|BPC
block|,
name|PC
block|,
name|ACCL
block|,
name|ACCH
block|}
enum|;
end_enum

begin_enum
enum|enum
name|SYS_calls
block|{
name|SYS_null
block|,
name|SYS_exit
block|,
name|SYS_open
block|,
name|SYS_close
block|,
name|SYS_read
block|,
name|SYS_write
block|,
name|SYS_lseek
block|,
name|SYS_unlink
block|,
name|SYS_getpid
block|,
name|SYS_kill
block|,
name|SYS_fstat
block|,
name|SYS_sbrk
block|,
name|SYS_fork
block|,
name|SYS_execve
block|,
name|SYS_wait4
block|,
name|SYS_link
block|,
name|SYS_chdir
block|,
name|SYS_stat
block|,
name|SYS_utime
block|,
name|SYS_chown
block|,
name|SYS_chmod
block|,
name|SYS_time
block|,
name|SYS_pipe
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|registers
index|[
name|NUMREGS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STACKSIZE
value|8096
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remcomStack
index|[
name|STACKSIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|stackPtr
init|=
operator|&
name|remcomStack
index|[
name|STACKSIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|save_vectors
index|[
literal|18
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous exception vectors */
end_comment

begin_comment
comment|/* Indicate to caller of mem2hex or hex2mem that there has been an error. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|mem_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store the vector number here (since GDB only gets the signal    number through the usual means, and that's not very specific).  */
end_comment

begin_decl_stmt
name|int
name|gdb_m32r_vector
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"syscall.h"
end_include

begin_comment
comment|/* for SYS_exit, SYS_write etc. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global entry points:  */
end_comment

begin_function_decl
specifier|extern
name|void
name|handle_exception
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|set_debug_traps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|breakpoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions:  */
end_comment

begin_function_decl
specifier|static
name|int
name|computeSignal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putpacket
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getpacket
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|hex2mem
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hexToInt
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|bin2mem
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stash_registers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_registers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prepare_to_step
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finish_from_step
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdb_error
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|gdb_putchar
argument_list|(
name|int
argument_list|)
decl_stmt|,
name|gdb_puts
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|,
name|gdb_write
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|strcpy
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strlen
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  */
end_comment

begin_function
name|void
name|handle_exception
parameter_list|(
name|int
name|exceptionVector
parameter_list|)
block|{
name|int
name|sigval
decl_stmt|;
name|int
name|addr
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|binary
decl_stmt|;
if|if
condition|(
operator|!
name|finish_from_step
argument_list|()
condition|)
return|return;
comment|/* "false step": let the target continue */
name|gdb_m32r_vector
operator|=
name|exceptionVector
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|exceptionVector
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"Handle exception %s, "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"PC == 0x%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* reply to host that an exception has occurred */
name|sigval
operator|=
name|computeSignal
argument_list|(
name|exceptionVector
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
comment|/* notify gdb with signo, PC, FP and SP */
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* PC */
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R13
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R13
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|R13
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FP */
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R15
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R15
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|R15
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SP */
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exceptionVector
operator|==
literal|0
condition|)
comment|/* simulated SYS call stuff */
block|{
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|registers
index|[
name|R0
index|]
condition|)
block|{
case|case
name|SYS_exit
case|:
name|gdb_error
argument_list|(
literal|"Target program has exited at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'W'
expr_stmt|;
name|sigval
operator|=
name|registers
index|[
name|R1
index|]
operator|&
literal|0xff
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SYS_open
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_open call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_close
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_close call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_read
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_read call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_write
case|:
if|if
condition|(
name|registers
index|[
name|R1
index|]
operator|==
literal|1
operator|||
comment|/* write to stdout  */
name|registers
index|[
name|R1
index|]
operator|==
literal|2
condition|)
comment|/* write to stderr  */
block|{
comment|/* (we can do that) */
name|registers
index|[
name|R0
index|]
operator|=
name|gdb_write
argument_list|(
operator|(
name|void
operator|*
operator|)
name|registers
index|[
name|R2
index|]
argument_list|,
name|registers
index|[
name|R3
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|gdb_error
argument_list|(
literal|"Target attempts SYS_write call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_lseek
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_lseek call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_unlink
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_unlink call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_getpid
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_getpid call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_kill
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_kill call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_fstat
case|:
name|gdb_error
argument_list|(
literal|"Target attempts SYS_fstat call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gdb_error
argument_list|(
literal|"Target attempts unknown SYS call at %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
operator|==
literal|1
condition|)
block|{
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|getpacket
argument_list|(
name|remcomInBuffer
argument_list|)
expr_stmt|;
name|binary
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
condition|)
block|{
default|default:
comment|/* Unknown code.  Return an empty reply message. */
break|break;
case|case
literal|'R'
case|:
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
name|registers
index|[
name|PC
index|]
operator|=
name|addr
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* XAA..AA,LLLL:<binary data>#cs */
name|binary
operator|=
literal|1
expr_stmt|;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
block|{
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
condition|)
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|':'
condition|)
block|{
name|mem_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|binary
condition|)
name|bin2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"memory fault"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ptr
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"malformed write memory command: %s"
argument_list|,
name|remcomInBuffer
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
condition|)
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
name|ptr
operator|=
literal|0
expr_stmt|;
name|mem_err
operator|=
literal|0
expr_stmt|;
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"memory fault"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptr
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"malformed read memory command: %s"
argument_list|,
name|remcomInBuffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|remcomOutBuffer
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|%
literal|16
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|remote_debug
operator|=
operator|!
operator|(
name|remote_debug
operator|)
expr_stmt|;
comment|/* toggle debug flag */
break|break;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|registers
argument_list|,
name|remcomOutBuffer
argument_list|,
name|NUMREGBYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* set the value of a single CPU register - return OK */
block|{
name|int
name|regno
decl_stmt|;
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|regno
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|'='
condition|)
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NUMREGS
condition|)
block|{
name|int
name|stackmode
decl_stmt|;
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|regno
index|]
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Since we just changed a single CPU register, let's 		 * make sure to keep the several stack pointers consistant. 		 */
name|stackmode
operator|=
name|registers
index|[
name|PSW
index|]
operator|&
literal|0x80
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|R15
condition|)
comment|/* stack pointer changed */
block|{
comment|/* need to change SPI or SPU */
if|if
condition|(
name|stackmode
operator|==
literal|0
condition|)
name|registers
index|[
name|SPI
index|]
operator|=
name|registers
index|[
name|R15
index|]
expr_stmt|;
else|else
name|registers
index|[
name|SPU
index|]
operator|=
name|registers
index|[
name|R15
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|SPU
condition|)
comment|/* "user" stack pointer changed */
block|{
if|if
condition|(
name|stackmode
operator|!=
literal|0
condition|)
comment|/* stack in user mode: copy SP */
name|registers
index|[
name|R15
index|]
operator|=
name|registers
index|[
name|SPU
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|SPI
condition|)
comment|/* "interrupt" stack pointer changed */
block|{
if|if
condition|(
name|stackmode
operator|==
literal|0
condition|)
comment|/* stack in interrupt mode: copy SP */
name|registers
index|[
name|R15
index|]
operator|=
name|registers
index|[
name|SPI
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PSW
condition|)
comment|/* stack mode may have changed! */
block|{
comment|/* force SP to either SPU or SPI */
if|if
condition|(
name|stackmode
operator|==
literal|0
condition|)
comment|/* stack in user mode */
name|registers
index|[
name|R15
index|]
operator|=
name|registers
index|[
name|SPI
index|]
expr_stmt|;
else|else
comment|/* stack in interrupt mode */
name|registers
index|[
name|R15
index|]
operator|=
name|registers
index|[
name|SPU
index|]
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"P01"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'G'
case|:
comment|/* set the value of the CPU registers - return OK */
name|hex2mem
argument_list|(
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|registers
argument_list|,
name|NUMREGBYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* sAA..AA	Step one instruction from AA..AA(optional) */
case|case
literal|'c'
case|:
comment|/* cAA..AA	Continue from address AA..AA(optional) */
comment|/* try to read optional parameter, pc unchanged if no parm */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
name|registers
index|[
name|PC
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
comment|/* single-stepping */
block|{
if|if
condition|(
operator|!
name|prepare_to_step
argument_list|(
literal|0
argument_list|)
condition|)
comment|/* set up for single-step */
block|{
comment|/* prepare_to_step has already emulated the target insn: 		   Send SIGTRAP to gdb, don't resume the target at all.  */
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
comment|/* Simulate stopping with SIGTRAP */
operator|*
name|ptr
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'5'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* send PC */
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R13
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* send FP */
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R13
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|R13
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R15
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* send SP */
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|R15
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|R15
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* continuing, not single-stepping */
block|{
comment|/* OK, about to do a "continue".  First check to see if the  	       target pc is on an odd boundary (second instruction in the  	       word).  If so, we must do a single-step first, because  	       ya can't jump or return back to an odd boundary!  */
if|if
condition|(
operator|(
name|registers
index|[
name|PC
index|]
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
name|prepare_to_step
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'D'
case|:
comment|/* Detach */
comment|/* I am interpreting this to mean, release the board from control  	   by the remote stub.  To do this, I am restoring the original 	   (or at least previous) exception vectors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|exceptionHandler
argument_list|(
name|i
argument_list|,
name|save_vectors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putpacket
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
return|return;
comment|/* continue the inferior */
case|case
literal|'k'
case|:
comment|/* kill the program */
continue|continue;
block|}
comment|/* switch */
comment|/* reply to the request */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|ch
parameter_list|)
name|unsigned
name|char
name|ch
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
specifier|static
name|void
name|getpacket
parameter_list|(
name|buffer
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
do|do
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|!=
literal|0x7d
operator|)
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|xmitcsum
operator|=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|checksum
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"Bad checksum: my count = %s, "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mem2hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|xmitcsum
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|"sent count = %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|gdb_error
argument_list|(
literal|" -- Bad buffer: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
block|}
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* remove sequence chars from buffer */
name|count
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
do|;
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|buffer
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
condition|)
block|{
name|putDebugChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|%
literal|16
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|getDebugChar
argument_list|()
operator|!=
literal|'+'
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Address of a routine to RTE to if we get a memory fault.  */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|mem_fault_routine
argument_list|)
argument_list|()
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|set_mem_err
parameter_list|()
block|{
name|mem_err
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the address for safe access ranges.  As currently defined,    this routine will reject the "expansion bus" address range(s).    To make those ranges useable, someone must implement code to detect    whether there's anything connected to the expansion bus. */
end_comment

begin_function
specifier|static
name|int
name|mem_safe
parameter_list|(
name|addr
parameter_list|)
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
block|{
define|#
directive|define
name|BAD_RANGE_ONE_START
value|((unsigned char *) 0x600000)
define|#
directive|define
name|BAD_RANGE_ONE_END
value|((unsigned char *) 0xa00000)
define|#
directive|define
name|BAD_RANGE_TWO_START
value|((unsigned char *) 0xff680000)
define|#
directive|define
name|BAD_RANGE_TWO_END
value|((unsigned char *) 0xff800000)
if|if
condition|(
name|addr
operator|<
name|BAD_RANGE_ONE_START
condition|)
return|return
literal|1
return|;
comment|/* safe */
if|if
condition|(
name|addr
operator|<
name|BAD_RANGE_ONE_END
condition|)
return|return
literal|0
return|;
comment|/* unsafe */
if|if
condition|(
name|addr
operator|<
name|BAD_RANGE_TWO_START
condition|)
return|return
literal|1
return|;
comment|/* safe */
if|if
condition|(
name|addr
operator|<
name|BAD_RANGE_TWO_END
condition|)
return|return
literal|0
return|;
comment|/* unsafe */
block|}
end_function

begin_comment
comment|/* These are separate functions so that they are so short and sweet    that the compiler won't save any registers (if there is a fault    to mem_fault, they won't get restored, so there better not be any    saved).  */
end_comment

begin_function
specifier|static
name|int
name|get_char
parameter_list|(
name|addr
parameter_list|)
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
block|{
if|#
directive|if
literal|1
if|if
condition|(
name|mem_fault_routine
operator|&&
operator|!
name|mem_safe
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|mem_fault_routine
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
operator|*
name|addr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_char
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
block|{
if|#
directive|if
literal|1
if|if
condition|(
name|mem_fault_routine
operator|&&
operator|!
name|mem_safe
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|mem_fault_routine
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
operator|*
name|addr
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the memory pointed to by mem into hex, placing result in buf.    Return a pointer to the last char put in buf (null).    If MAY_FAULT is non-zero, then we should set mem_err in response to    a fault; if zero treat a fault like any other fault in the stub.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|mem
parameter_list|,
name|buf
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|may_fault
condition|)
name|mem_fault_routine
operator|=
name|set_mem_err
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|mem
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_fault
operator|&&
name|mem_err
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|%
literal|16
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|may_fault
condition|)
name|mem_fault_routine
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert the hex array pointed to by buf into binary to be placed in mem.    Return a pointer to the character AFTER the last byte written. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|hex2mem
parameter_list|(
name|buf
parameter_list|,
name|mem
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|may_fault
condition|)
name|mem_fault_routine
operator|=
name|set_mem_err
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|ch
operator|+
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|set_char
argument_list|(
name|mem
operator|++
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_fault
operator|&&
name|mem_err
condition|)
return|return
operator|(
name|mem
operator|)
return|;
block|}
if|if
condition|(
name|may_fault
condition|)
name|mem_fault_routine
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert the binary stream in BUF to memory.     Gdb will escape $, #, and the escape char (0x7d).    COUNT is the total number of bytes to write into    memory. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|bin2mem
parameter_list|(
name|buf
parameter_list|,
name|mem
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|may_fault
condition|)
name|mem_fault_routine
operator|=
name|set_mem_err
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check for any escaped characters. Be paranoid and          only unescape chars that should be escaped. */
if|if
condition|(
operator|*
name|buf
operator|==
literal|0x7d
condition|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|0x3
case|:
comment|/* # */
case|case
literal|0x4
case|:
comment|/* $ */
case|case
literal|0x5d
case|:
comment|/* escape char */
name|buf
operator|++
expr_stmt|;
operator|*
name|buf
operator|+=
literal|0x20
expr_stmt|;
break|break;
default|default:
comment|/* nothing */
break|break;
block|}
block|}
name|set_char
argument_list|(
name|mem
operator|++
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_fault
operator|&&
name|mem_err
condition|)
return|return
name|mem
return|;
block|}
if|if
condition|(
name|may_fault
condition|)
name|mem_fault_routine
operator|=
literal|0
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* this function takes the m32r exception vector and attempts to    translate this number into a unix compatible signal value */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|exceptionVector
parameter_list|)
name|int
name|exceptionVector
decl_stmt|;
block|{
name|int
name|sigval
decl_stmt|;
switch|switch
condition|(
name|exceptionVector
condition|)
block|{
case|case
literal|0
case|:
name|sigval
operator|=
literal|23
expr_stmt|;
break|break;
comment|/* I/O trap                    */
case|case
literal|1
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|2
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|3
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|4
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|5
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|6
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|7
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|8
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|9
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|10
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|11
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|12
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|13
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|14
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|15
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint                  */
case|case
literal|16
case|:
name|sigval
operator|=
literal|10
expr_stmt|;
break|break;
comment|/* BUS ERROR (alignment)       */
case|case
literal|17
case|:
name|sigval
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* INTerrupt                   */
default|default :
name|sigval
operator|=
literal|7
expr_stmt|;
break|break;
comment|/* "software generated"        */
block|}
return|return
operator|(
name|sigval
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************/
end_comment

begin_comment
comment|/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
end_comment

begin_comment
comment|/* RETURN NUMBER OF CHARS PROCESSED           */
end_comment

begin_comment
comment|/**********************************************/
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|ptr
parameter_list|,
name|intValue
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
modifier|*
name|intValue
decl_stmt|;
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|>=
literal|0
condition|)
block|{
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
block|}
else|else
break|break;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   Table of branch instructions:      10B6		RTE	return from trap or exception   1FCr		JMP	jump   1ECr		JL	jump and link   7Fxx		BRA	branch   FFxxxxxx	BRA	branch (long)   B09rxxxx	BNEZ	branch not-equal-zero   Br1rxxxx	BNE	branch not-equal   7Dxx		BNC	branch not-condition   FDxxxxxx	BNC	branch not-condition (long)   B0Arxxxx	BLTZ	branch less-than-zero   B0Crxxxx	BLEZ	branch less-equal-zero   7Exx		BL	branch and link   FExxxxxx	BL	branch and link (long)   B0Drxxxx	BGTZ	branch greater-than-zero   B0Brxxxx	BGEZ	branch greater-equal-zero   B08rxxxx	BEQZ	branch equal-zero   Br0rxxxx	BEQ	branch equal   7Cxx		BC	branch condition   FCxxxxxx	BC	branch condition (long)   */
end_comment

begin_function
specifier|static
name|int
name|isShortBranch
parameter_list|(
name|instr
parameter_list|)
name|unsigned
name|char
modifier|*
name|instr
decl_stmt|;
block|{
name|unsigned
name|char
name|instr0
init|=
name|instr
index|[
literal|0
index|]
operator|&
literal|0x7F
decl_stmt|;
comment|/* mask off high bit */
if|if
condition|(
name|instr0
operator|==
literal|0x10
operator|&&
name|instr
index|[
literal|1
index|]
operator|==
literal|0xB6
condition|)
comment|/* RTE */
return|return
literal|1
return|;
comment|/* return from trap or exception */
if|if
condition|(
name|instr0
operator|==
literal|0x1E
operator|||
name|instr0
operator|==
literal|0x1F
condition|)
comment|/* JL or JMP */
if|if
condition|(
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0xC0
condition|)
return|return
literal|2
return|;
comment|/* jump thru a register */
if|if
condition|(
name|instr0
operator|==
literal|0x7C
operator|||
name|instr0
operator|==
literal|0x7D
operator|||
comment|/* BC, BNC, BL, BRA */
name|instr0
operator|==
literal|0x7E
operator|||
name|instr0
operator|==
literal|0x7F
condition|)
return|return
literal|3
return|;
comment|/* eight bit PC offset */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isLongBranch
parameter_list|(
name|instr
parameter_list|)
name|unsigned
name|char
modifier|*
name|instr
decl_stmt|;
block|{
if|if
condition|(
name|instr
index|[
literal|0
index|]
operator|==
literal|0xFC
operator|||
name|instr
index|[
literal|0
index|]
operator|==
literal|0xFD
operator|||
comment|/* BRA, BNC, BL, BC */
name|instr
index|[
literal|0
index|]
operator|==
literal|0xFE
operator|||
name|instr
index|[
literal|0
index|]
operator|==
literal|0xFF
condition|)
comment|/* 24 bit relative */
return|return
literal|4
return|;
if|if
condition|(
operator|(
name|instr
index|[
literal|0
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0xB0
condition|)
comment|/* 16 bit relative */
block|{
if|if
condition|(
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0x00
operator|||
comment|/* BNE, BEQ */
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0x10
condition|)
return|return
literal|5
return|;
if|if
condition|(
name|instr
index|[
literal|0
index|]
operator|==
literal|0xB0
condition|)
comment|/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
if|if
condition|(
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0x80
operator|||
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0x90
operator|||
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0xA0
operator|||
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0xB0
operator|||
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0xC0
operator|||
operator|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0xD0
condition|)
return|return
literal|6
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* if address is NOT on a 4-byte boundary, or high-bit of instr is zero,     then it's a 2-byte instruction, else it's a 4-byte instruction.  */
end_comment

begin_define
define|#
directive|define
name|INSTRUCTION_SIZE
parameter_list|(
name|addr
parameter_list|)
define|\
value|((((int) addr& 2) || (((unsigned char *) addr)[0]& 0x80) == 0) ? 2 : 4)
end_define

begin_function
specifier|static
name|int
name|isBranch
parameter_list|(
name|instr
parameter_list|)
name|unsigned
name|char
modifier|*
name|instr
decl_stmt|;
block|{
if|if
condition|(
name|INSTRUCTION_SIZE
argument_list|(
name|instr
argument_list|)
operator|==
literal|2
condition|)
return|return
name|isShortBranch
argument_list|(
name|instr
argument_list|)
return|;
else|else
return|return
name|isLongBranch
argument_list|(
name|instr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|willBranch
parameter_list|(
name|instr
parameter_list|,
name|branchCode
parameter_list|)
name|unsigned
name|char
modifier|*
name|instr
decl_stmt|;
block|{
switch|switch
condition|(
name|branchCode
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
comment|/* not a branch */
case|case
literal|1
case|:
return|return
literal|1
return|;
comment|/* RTE */
case|case
literal|2
case|:
return|return
literal|1
return|;
comment|/* JL or JMP    */
case|case
literal|3
case|:
comment|/* BC, BNC, BL, BRA (short) */
case|case
literal|4
case|:
comment|/* BC, BNC, BL, BRA (long) */
switch|switch
condition|(
name|instr
index|[
literal|0
index|]
operator|&
literal|0x0F
condition|)
block|{
case|case
literal|0xC
case|:
comment|/* Branch if Condition Register */
return|return
operator|(
name|registers
index|[
name|CBR
index|]
operator|!=
literal|0
operator|)
return|;
case|case
literal|0xD
case|:
comment|/* Branch if NOT Condition Register */
return|return
operator|(
name|registers
index|[
name|CBR
index|]
operator|==
literal|0
operator|)
return|;
case|case
literal|0xE
case|:
comment|/* Branch and Link */
case|case
literal|0xF
case|:
comment|/* Branch (unconditional) */
return|return
literal|1
return|;
default|default:
comment|/* oops? */
return|return
literal|0
return|;
block|}
case|case
literal|5
case|:
comment|/* BNE, BEQ */
switch|switch
condition|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Branch if r1 equal to r2 */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|0
index|]
operator|&
literal|0x0F
index|]
operator|==
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|)
return|;
case|case
literal|0x10
case|:
comment|/* Branch if r1 NOT equal to r2 */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|0
index|]
operator|&
literal|0x0F
index|]
operator|!=
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|)
return|;
default|default:
comment|/* oops? */
return|return
literal|0
return|;
block|}
case|case
literal|6
case|:
comment|/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
switch|switch
condition|(
name|instr
index|[
literal|1
index|]
operator|&
literal|0xF0
condition|)
block|{
case|case
literal|0x80
case|:
comment|/* Branch if reg equal to zero */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|==
literal|0
operator|)
return|;
case|case
literal|0x90
case|:
comment|/* Branch if reg NOT equal to zero */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|!=
literal|0
operator|)
return|;
case|case
literal|0xA0
case|:
comment|/* Branch if reg less than zero */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|<
literal|0
operator|)
return|;
case|case
literal|0xB0
case|:
comment|/* Branch if reg greater or equal to zero */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|>=
literal|0
operator|)
return|;
case|case
literal|0xC0
case|:
comment|/* Branch if reg less than or equal to zero */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|<=
literal|0
operator|)
return|;
case|case
literal|0xD0
case|:
comment|/* Branch if reg greater than zero */
return|return
operator|(
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|>
literal|0
operator|)
return|;
default|default:
comment|/* oops? */
return|return
literal|0
return|;
block|}
default|default:
comment|/* oops? */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|branchDestination
parameter_list|(
name|instr
parameter_list|,
name|branchCode
parameter_list|)
name|unsigned
name|char
modifier|*
name|instr
decl_stmt|;
block|{
switch|switch
condition|(
name|branchCode
condition|)
block|{
default|default:
case|case
literal|0
case|:
comment|/* not a branch */
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* RTE */
return|return
name|registers
index|[
name|BPC
index|]
operator|&
operator|~
literal|3
return|;
comment|/* pop BPC into PC */
case|case
literal|2
case|:
comment|/* JL or JMP */
return|return
name|registers
index|[
name|instr
index|[
literal|1
index|]
operator|&
literal|0x0F
index|]
operator|&
operator|~
literal|3
return|;
comment|/* jump thru a register */
case|case
literal|3
case|:
comment|/* BC, BNC, BL, BRA (short, 8-bit relative offset) */
return|return
operator|(
operator|(
operator|(
name|int
operator|)
name|instr
operator|)
operator|&
operator|~
literal|3
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|instr
index|[
literal|1
index|]
operator|<<
literal|2
operator|)
return|;
case|case
literal|4
case|:
comment|/* BC, BNC, BL, BRA (long, 24-bit relative offset) */
return|return
operator|(
operator|(
name|int
operator|)
name|instr
operator|+
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|instr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|instr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|instr
index|[
literal|3
index|]
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|)
return|;
case|case
literal|5
case|:
comment|/* BNE, BEQ (16-bit relative offset) */
case|case
literal|6
case|:
comment|/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */
return|return
operator|(
operator|(
name|int
operator|)
name|instr
operator|+
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|instr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|instr
index|[
literal|3
index|]
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|)
return|;
block|}
comment|/* An explanatory note: in the last three return expressions, I have      cast the most-significant byte of the return offset to char.      What this accomplishes is sign extension.  If the other      less-significant bytes were signed as well, they would get sign      extended too and, if negative, their leading bits would clobber      the bits of the more-significant bytes ahead of them.  There are      other ways I could have done this, but sign extension from      odd-sized integers is always a pain. */
block|}
end_function

begin_function
specifier|static
name|void
name|branchSideEffects
parameter_list|(
name|instr
parameter_list|,
name|branchCode
parameter_list|)
name|unsigned
name|char
modifier|*
name|instr
decl_stmt|;
name|int
name|branchCode
decl_stmt|;
block|{
switch|switch
condition|(
name|branchCode
condition|)
block|{
case|case
literal|1
case|:
comment|/* RTE */
return|return;
comment|/* I<THINK> this is already handled... */
case|case
literal|2
case|:
comment|/* JL (or JMP) */
case|case
literal|3
case|:
comment|/* BL (or BC, BNC, BRA) */
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|instr
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|==
literal|0x0E
condition|)
comment|/* branch/jump and link */
name|registers
index|[
name|R14
index|]
operator|=
operator|(
name|registers
index|[
name|PC
index|]
operator|&
operator|~
literal|3
operator|)
operator|+
literal|4
expr_stmt|;
return|return;
default|default:
comment|/* any other branch has no side effects */
return|return;
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
name|STEPPING_CONTEXT
block|{
name|int
name|stepping
decl_stmt|;
comment|/* true when we've started a single-step */
name|unsigned
name|long
name|target_addr
decl_stmt|;
comment|/* the instr we're trying to execute */
name|unsigned
name|long
name|target_size
decl_stmt|;
comment|/* the size of the target instr */
name|unsigned
name|long
name|noop_addr
decl_stmt|;
comment|/* where we've inserted a no-op, if any */
name|unsigned
name|long
name|trap1_addr
decl_stmt|;
comment|/* the trap following the target instr */
name|unsigned
name|long
name|trap2_addr
decl_stmt|;
comment|/* the trap at a branch destination, if any */
name|unsigned
name|short
name|noop_save
decl_stmt|;
comment|/* instruction overwritten by our no-op */
name|unsigned
name|short
name|trap1_save
decl_stmt|;
comment|/* instruction overwritten by trap1 */
name|unsigned
name|short
name|trap2_save
decl_stmt|;
comment|/* instruction overwritten by trap2 */
name|unsigned
name|short
name|continue_p
decl_stmt|;
comment|/* true if NOT returning to gdb after step */
block|}
name|stepping
struct|;
end_struct

begin_comment
comment|/* Function: prepare_to_step    Called from handle_exception to prepare the user program to single-step.    Places a trap instruction after the target instruction, with special     extra handling for branch instructions and for instructions in the     second half-word of a word.       Returns: True  if we should actually execute the instruction;  	    False if we are going to emulate executing the instruction, 	    in which case we simply report to GDB that the instruction  	    has already been executed.  */
end_comment

begin_define
define|#
directive|define
name|TRAP1
value|0x10f1;
end_define

begin_comment
comment|/* trap #1 instruction */
end_comment

begin_define
define|#
directive|define
name|NOOP
value|0x7000;
end_define

begin_comment
comment|/* noop    instruction */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|trap1
init|=
name|TRAP1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|noop
init|=
name|NOOP
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|prepare_to_step
parameter_list|(
name|continue_p
parameter_list|)
name|int
name|continue_p
decl_stmt|;
comment|/* if this isn't REALLY a single-step (see below) */
block|{
name|unsigned
name|long
name|pc
init|=
name|registers
index|[
name|PC
index|]
decl_stmt|;
name|int
name|branchCode
init|=
name|isBranch
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pc
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* zero out the stepping context       (paranoia -- it should already be zeroed) */
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|stepping
init|;
name|p
operator|<
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|stepping
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|stepping
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|branchCode
operator|!=
literal|0
condition|)
comment|/* next instruction is a branch */
block|{
name|branchSideEffects
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pc
argument_list|,
name|branchCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|willBranch
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pc
argument_list|,
name|branchCode
argument_list|)
condition|)
name|registers
index|[
name|PC
index|]
operator|=
name|branchDestination
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pc
argument_list|,
name|branchCode
argument_list|)
expr_stmt|;
else|else
name|registers
index|[
name|PC
index|]
operator|=
name|pc
operator|+
name|INSTRUCTION_SIZE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* branch "executed" -- just notify GDB */
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|pc
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
comment|/* "second-slot" instruction */
block|{
comment|/* insert no-op before pc */
name|stepping
operator|.
name|noop_addr
operator|=
name|pc
operator|-
literal|2
expr_stmt|;
name|stepping
operator|.
name|noop_save
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|noop_addr
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|noop_addr
operator|=
name|noop
expr_stmt|;
comment|/* insert trap  after  pc */
name|stepping
operator|.
name|trap1_addr
operator|=
name|pc
operator|+
literal|2
expr_stmt|;
name|stepping
operator|.
name|trap1_save
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|trap1_addr
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|trap1_addr
operator|=
name|trap1
expr_stmt|;
block|}
else|else
comment|/* "first-slot" instruction */
block|{
comment|/* insert trap  after  pc */
name|stepping
operator|.
name|trap1_addr
operator|=
name|pc
operator|+
name|INSTRUCTION_SIZE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|stepping
operator|.
name|trap1_save
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|trap1_addr
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|trap1_addr
operator|=
name|trap1
expr_stmt|;
block|}
comment|/* "continue_p" means that we are actually doing a continue, and not       being requested to single-step by GDB.  Sometimes we have to do      one single-step before continuing, because the PC is on a half-word      boundary.  There's no way to simply resume at such an address.  */
name|stepping
operator|.
name|continue_p
operator|=
name|continue_p
expr_stmt|;
name|stepping
operator|.
name|stepping
operator|=
literal|1
expr_stmt|;
comment|/* starting a single-step */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Function: finish_from_step    Called from handle_exception to finish up when the user program     returns from a single-step.  Replaces the instructions that had    been overwritten by traps or no-ops,      Returns: True  if we should notify GDB that the target stopped. 	    False if we only single-stepped because we had to before we 	    could continue (ie. we were trying to continue at a  	    half-word boundary).  In that case don't notify GDB: 	    just "continue continuing".  */
end_comment

begin_function
specifier|static
name|int
name|finish_from_step
parameter_list|()
block|{
if|if
condition|(
name|stepping
operator|.
name|stepping
condition|)
comment|/* anything to do? */
block|{
name|int
name|continue_p
init|=
name|stepping
operator|.
name|continue_p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|stepping
operator|.
name|noop_addr
condition|)
comment|/* replace instr "under" our no-op */
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|noop_addr
operator|=
name|stepping
operator|.
name|noop_save
expr_stmt|;
if|if
condition|(
name|stepping
operator|.
name|trap1_addr
condition|)
comment|/* replace instr "under" our trap  */
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|trap1_addr
operator|=
name|stepping
operator|.
name|trap1_save
expr_stmt|;
if|if
condition|(
name|stepping
operator|.
name|trap2_addr
condition|)
comment|/* ditto our other trap, if any    */
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|stepping
operator|.
name|trap2_addr
operator|=
name|stepping
operator|.
name|trap2_save
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|stepping
init|;
comment|/* zero out the stepping context */
name|p
operator|<
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|stepping
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|stepping
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|!
operator|(
name|continue_p
operator|)
return|;
block|}
else|else
comment|/* we didn't single-step, therefore this must be a legitimate stop */
return|return
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|PSWreg
block|{
comment|/* separate out the bit flags in the PSW register */
name|int
name|pad1
range|:
literal|16
decl_stmt|;
name|int
name|bsm
range|:
literal|1
decl_stmt|;
name|int
name|bie
range|:
literal|1
decl_stmt|;
name|int
name|pad2
range|:
literal|5
decl_stmt|;
name|int
name|bc
range|:
literal|1
decl_stmt|;
name|int
name|sm
range|:
literal|1
decl_stmt|;
name|int
name|ie
range|:
literal|1
decl_stmt|;
name|int
name|pad3
range|:
literal|5
decl_stmt|;
name|int
name|c
range|:
literal|1
decl_stmt|;
block|}
modifier|*
name|psw
struct|;
end_struct

begin_comment
comment|/* Upon entry the value for LR to save has been pushed.    We unpush that so that the value for the stack pointer saved is correct.    Upon entry, all other registers are assumed to have not been modified    since the interrupt/trap occured.  */
end_comment

begin_asm
asm|asm (" stash_registers: 	push r0 	push r1 	seth r1, #shigh(registers) 	add3 r1, r1, #low(registers) 	pop r0		; r1 	st r0, @(4,r1) 	pop r0		; r0 	st r0, @r1 	addi r1, #4	; only add 4 as subsequent saves are `pre inc' 	st r2, @+r1 	st r3, @+r1 	st r4, @+r1 	st r5, @+r1 	st r6, @+r1 	st r7, @+r1 	st r8, @+r1 	st r9, @+r1 	st r10, @+r1 	st r11, @+r1 	st r12, @+r1 	st r13, @+r1    ; fp 	pop r0		; lr (r14) 	st r0, @+r1 	st sp, @+r1	; sp contains right value at this point 	mvfc r0, cr0 	st r0, @+r1	; cr0 == PSW 	mvfc r0, cr1 	st r0, @+r1	; cr1 == CBR 	mvfc r0, cr2 	st r0, @+r1	; cr2 == SPI 	mvfc r0, cr3 	st r0, @+r1	; cr3 == SPU 	mvfc r0, cr6 	st r0, @+r1	; cr6 == BPC 	st r0, @+r1	; PC  == BPC 	mvfaclo r0 	st r0, @+r1	; ACCL 	mvfachi r0 	st r0, @+r1	; ACCH 	jmp lr");
end_asm

begin_comment
comment|/* C routine to clean up what stash_registers did.    It is called after calling stash_registers.    This is separate from stash_registers as we want to do this in C    but doing stash_registers in C isn't straightforward.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_stash
parameter_list|()
block|{
name|psw
operator|=
operator|(
expr|struct
name|PSWreg
operator|*
operator|)
operator|&
name|registers
index|[
name|PSW
index|]
expr_stmt|;
comment|/* fields of PSW register */
name|psw
operator|->
name|sm
operator|=
name|psw
operator|->
name|bsm
expr_stmt|;
comment|/* fix up pre-trap values of psw fields */
name|psw
operator|->
name|ie
operator|=
name|psw
operator|->
name|bie
expr_stmt|;
name|psw
operator|->
name|c
operator|=
name|psw
operator|->
name|bc
expr_stmt|;
name|registers
index|[
name|CBR
index|]
operator|=
name|psw
operator|->
name|bc
expr_stmt|;
comment|/* fix up pre-trap "C" register */
if|#
directive|if
literal|0
comment|/* FIXME: Was in previous version.  Necessary? 	 (Remember that we use the "rte" insn to return from the 	 trap/interrupt so the values of bsm, bie, bc are important.  */
block|psw->bsm = psw->bie = psw->bc = 0;
comment|/* zero post-trap values */
endif|#
directive|endif
comment|/* FIXME: Copied from previous version.  This can probably be deleted      since methinks stash_registers has already done this.  */
name|registers
index|[
name|PC
index|]
operator|=
name|registers
index|[
name|BPC
index|]
expr_stmt|;
comment|/* pre-trap PC */
comment|/* FIXME: Copied from previous version.  Necessary?  */
if|if
condition|(
name|psw
operator|->
name|sm
condition|)
comment|/* copy R15 into (psw->sm ? SPU : SPI) */
name|registers
index|[
name|SPU
index|]
operator|=
name|registers
index|[
name|R15
index|]
expr_stmt|;
else|else
name|registers
index|[
name|SPI
index|]
operator|=
name|registers
index|[
name|R15
index|]
expr_stmt|;
block|}
end_function

begin_asm
asm|asm (" restore_and_return: 	seth r0, #shigh(registers+8) 	add3 r0, r0, #low(registers+8) 	ld r2, @r0+	; restore r2 	ld r3, @r0+	; restore r3 	ld r4, @r0+	; restore r4 	ld r5, @r0+	; restore r5 	ld r6, @r0+	; restore r6 	ld r7, @r0+	; restore r7 	ld r8, @r0+	; restore r8 	ld r9, @r0+	; restore r9 	ld r10, @r0+	; restore r10 	ld r11, @r0+	; restore r11 	ld r12, @r0+	; restore r12 	ld r13, @r0+	; restore r13 	ld r14, @r0+	; restore r14 	ld r15, @r0+	; restore r15 	ld r1, @r0+	; restore cr0 == PSW 	mvtc r1, cr0 	ld r1, @r0+	; restore cr1 == CBR (no-op, because it's read only) 	mvtc r1, cr1 	ld r1, @r0+	; restore cr2 == SPI 	mvtc r1, cr2 	ld r1, @r0+	; restore cr3 == SPU 	mvtc r1, cr3 	addi r0, #4	; skip BPC 	ld r1, @r0+	; restore cr6 (BPC) == PC 	mvtc r1, cr6 	ld r1, @r0+	; restore ACCL 	mvtaclo r1 	ld r1, @r0+	; restore ACCH 	mvtachi r1 	seth r0, #shigh(registers) 	add3 r0, r0, #low(registers) 	ld r1, @(4,r0)	; restore r1 	ld r0, @r0	; restore r0 	rte");
end_asm

begin_comment
comment|/* General trap handler, called after the registers have been stashed.    NUM is the trap/exception number.  */
end_comment

begin_function
specifier|static
name|void
name|process_exception
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|cleanup_stash
argument_list|()
expr_stmt|;
asm|asm
specifier|volatile
asm|(" 	seth r1, #shigh(stackPtr) 	add3 r1, r1, #low(stackPtr) 	ld r15, @r1		; setup local stack (protect user stack) 	mv r0, %0 	bl handle_exception 	bl restore_and_return" 		: : "r" (num) : "r0", "r1");
block|}
end_function

begin_function_decl
name|void
name|_catchException0
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException0: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #0 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException1
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException1: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	bl cleanup_stash 	seth r1, #shigh(stackPtr) 	add3 r1, r1, #low(stackPtr) 	ld r15, @r1		; setup local stack (protect user stack) 	seth r1, #shigh(registers + 21*4) ; PC 	add3 r1, r1, #low(registers + 21*4) 	ld r0, @r1 	addi r0, #-4		; back up PC for breakpoint trap. 	st r0, @r1		; FIXME: what about bp in right slot? 	ldi r0, #1 	bl handle_exception 	bl restore_and_return");
end_asm

begin_function_decl
name|void
name|_catchException2
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException2: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #2 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException3
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException3: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #3 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException4
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException4: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #4 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException5
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException5: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #5 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException6
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException6: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #6 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException7
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException7: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #7 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException8
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException8: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #8 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException9
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException9: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #9 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException10
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException10: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #10 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException11
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException11: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #11 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException12
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException12: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #12 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException13
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException13: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #13 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException14
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException14: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #14 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException15
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException15: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #15 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException16
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException16: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #16 	bl process_exception");
end_asm

begin_function_decl
name|void
name|_catchException17
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm (" _catchException17: 	push lr 	bl stash_registers 	; Note that at this point the pushed value of `lr' has been popped 	ldi r0, #17 	bl process_exception");
end_asm

begin_comment
comment|/* this function is used to set up exception handlers for tracing and    breakpoints */
end_comment

begin_function
name|void
name|set_debug_traps
parameter_list|()
block|{
comment|/*  extern void remcomHandler(); */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
comment|/* keep a copy of old vectors */
if|if
condition|(
name|save_vectors
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* only copy them the first time */
name|save_vectors
index|[
name|i
index|]
operator|=
name|getExceptionHandler
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|stackPtr
operator|=
operator|&
name|remcomStack
index|[
name|STACKSIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|0
argument_list|,
name|_catchException0
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|1
argument_list|,
name|_catchException1
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|2
argument_list|,
name|_catchException2
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|3
argument_list|,
name|_catchException3
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|4
argument_list|,
name|_catchException4
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|5
argument_list|,
name|_catchException5
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|6
argument_list|,
name|_catchException6
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|7
argument_list|,
name|_catchException7
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|8
argument_list|,
name|_catchException8
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|9
argument_list|,
name|_catchException9
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|10
argument_list|,
name|_catchException10
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|11
argument_list|,
name|_catchException11
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|12
argument_list|,
name|_catchException12
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|13
argument_list|,
name|_catchException13
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|14
argument_list|,
name|_catchException14
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|15
argument_list|,
name|_catchException15
argument_list|)
expr_stmt|;
name|exceptionHandler
argument_list|(
literal|16
argument_list|,
name|_catchException16
argument_list|)
expr_stmt|;
comment|/*  exceptionHandler (17, _catchException17); */
comment|/* In case GDB is started before us, ack any packets (presumably      "$?#xx") sitting there.  */
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will generate a breakpoint exception.  It is used at the    beginning of a program to sync up with a debugger and can be used    otherwise as a quick means to stop program execution and "break" into    the debugger. */
end_comment

begin_define
define|#
directive|define
name|BREAKPOINT
parameter_list|()
value|asm volatile ("	trap #2");
end_define

begin_function
name|void
name|breakpoint
parameter_list|()
block|{
if|if
condition|(
name|initialized
condition|)
name|BREAKPOINT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* STDOUT section:    Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.    Functions: gdb_putchar(char ch)               gdb_puts(char *str)               gdb_write(char *str, int len)               gdb_error(char *format, char *parm) 	      */
end_comment

begin_comment
comment|/* Function: gdb_putchar(int)    Make gdb write a char to stdout.    Returns: the char */
end_comment

begin_function
specifier|static
name|int
name|gdb_putchar
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'O'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|ch
operator|&
literal|0x0F
index|]
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Function: gdb_write(char *, int)    Make gdb write n bytes to stdout (not assumed to be null-terminated).    Returns: number of bytes written */
end_comment

begin_function
specifier|static
name|int
name|gdb_write
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|cpy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
operator|=
name|remcomOutBuffer
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'O'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
for|for
control|(
name|cpy
operator|=
name|buf
operator|+
literal|1
init|;
name|i
operator|<
name|len
operator|&&
name|cpy
operator|<
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|remcomOutBuffer
argument_list|)
operator|-
literal|3
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cpy
operator|++
operator|=
name|hexchars
index|[
name|data
index|[
name|i
index|]
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|cpy
operator|++
operator|=
name|hexchars
index|[
name|data
index|[
name|i
index|]
operator|&
literal|0x0F
index|]
expr_stmt|;
block|}
operator|*
name|cpy
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Function: gdb_puts(char *)    Make gdb write a null-terminated string to stdout.    Returns: the length of the string */
end_comment

begin_function
specifier|static
name|int
name|gdb_puts
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|gdb_write
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: gdb_error(char *, char *)    Send an error message to gdb's stdout.    First string may have 1 (one) optional "%s" in it, which    will cause the optional second string to be inserted.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_error
parameter_list|(
name|format
parameter_list|,
name|parm
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|parm
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|400
index|]
decl_stmt|,
modifier|*
name|cpy
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
name|format
operator|&&
operator|*
name|format
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* empty input */
if|if
condition|(
name|parm
operator|&&
operator|*
name|parm
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|parm
argument_list|)
expr_stmt|;
for|for
control|(
name|cpy
operator|=
name|buf
init|;
operator|*
name|format
condition|;
control|)
block|{
if|if
condition|(
name|format
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|format
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
comment|/* include second string */
block|{
name|format
operator|+=
literal|2
expr_stmt|;
comment|/* advance two chars instead of just one */
while|while
condition|(
name|parm
operator|&&
operator|*
name|parm
condition|)
operator|*
name|cpy
operator|++
operator|=
operator|*
name|parm
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|cpy
operator|++
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
operator|*
name|cpy
operator|=
literal|'\0'
expr_stmt|;
name|gdb_puts
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|strcpy
parameter_list|(
name|unsigned
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ret
init|=
name|dest
decl_stmt|;
if|if
condition|(
name|dest
operator|&&
name|src
condition|)
block|{
while|while
condition|(
operator|*
name|src
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strlen
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
for|for
control|(
name|ret
operator|=
literal|0
init|;
operator|*
name|src
condition|;
name|src
operator|++
control|)
name|ret
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void exit (code)      int code; {   _exit (code); }  int atexit (void *p) {   return 0; }  void abort (void) {   _exit (1); }
endif|#
directive|endif
end_endif

end_unit

