begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main code for remote server for GDB.    Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_decl_stmt
name|int
name|cont_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|general_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|step_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|thread_from_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|old_thread_from_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extended_protocol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|server_waiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The PID of the originally created or attached inferior.  Used to    send signals to the process when GDB sends us an asynchronous interrupt    (user hitting Control-C in the client), and to wait for the child to exit    when no longer debugging it.  */
end_comment

begin_decl_stmt
name|int
name|signal_pid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
name|start_inferior
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|statusptr
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal_pid
operator|=
name|create_inferior
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Process %s created; pid = %d\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|signal_pid
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tcsetpgrp
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|signal_pid
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in program, return signal number.  */
return|return
name|mywait
argument_list|(
name|statusptr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|attach_inferior
parameter_list|(
name|int
name|pid
parameter_list|,
name|char
modifier|*
name|statusptr
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigptr
parameter_list|)
block|{
comment|/* myattach should return -1 if attaching is unsupported,      0 if it succeeded, and call error() otherwise.  */
if|if
condition|(
name|myattach
argument_list|(
name|pid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Attached; pid = %d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
comment|/* FIXME - It may be that we should get the SIGNAL_PID from the      attach function, so that it can be the main thread instead of      whichever we were told to attach to.  */
name|signal_pid
operator|=
name|pid
expr_stmt|;
operator|*
name|sigptr
operator|=
name|mywait
argument_list|(
name|statusptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle all of the extended 'q' packets.  */
end_comment

begin_function
name|void
name|handle_query
parameter_list|(
name|char
modifier|*
name|own_buf
parameter_list|)
block|{
specifier|static
name|struct
name|inferior_list_entry
modifier|*
name|thread_ptr
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"qSymbol::"
argument_list|,
name|own_buf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|the_target
operator|->
name|look_up_symbols
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|the_target
operator|->
name|look_up_symbols
call|)
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|own_buf
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
literal|"qfThreadInfo"
argument_list|,
name|own_buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|thread_ptr
operator|=
name|all_threads
operator|.
name|head
expr_stmt|;
name|sprintf
argument_list|(
name|own_buf
argument_list|,
literal|"m%x"
argument_list|,
name|thread_ptr
operator|->
name|id
argument_list|)
expr_stmt|;
name|thread_ptr
operator|=
name|thread_ptr
operator|->
name|next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
literal|"qsThreadInfo"
argument_list|,
name|own_buf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|thread_ptr
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|own_buf
argument_list|,
literal|"m%x"
argument_list|,
name|thread_ptr
operator|->
name|id
argument_list|)
expr_stmt|;
name|thread_ptr
operator|=
name|thread_ptr
operator|->
name|next
expr_stmt|;
return|return;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|own_buf
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|the_target
operator|->
name|read_auxv
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
literal|"qPart:auxv:read::"
argument_list|,
name|own_buf
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|data
index|[
operator|(
name|PBUFSIZ
operator|-
literal|1
operator|)
operator|/
literal|2
index|]
decl_stmt|;
name|CORE_ADDR
name|ofs
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|n
decl_stmt|;
name|decode_m_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|17
index|]
argument_list|,
operator|&
name|ofs
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* "OFS,LEN" */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
name|data
condition|)
name|len
operator|=
sizeof|sizeof
name|data
expr_stmt|;
name|n
operator|=
call|(
modifier|*
name|the_target
operator|->
name|read_auxv
call|)
argument_list|(
name|ofs
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|convert_int_to_ascii
argument_list|(
name|data
argument_list|,
name|own_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise we didn't know what packet it was.  Say we didn't      understand it.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse vCont packets.  */
end_comment

begin_function
name|void
name|handle_v_cont
parameter_list|(
name|char
modifier|*
name|own_buf
parameter_list|,
name|char
modifier|*
name|status
parameter_list|,
name|unsigned
name|char
modifier|*
name|signal
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|thread_resume
modifier|*
name|resume_info
decl_stmt|,
name|default_action
decl_stmt|;
comment|/* Count the number of semicolons in the packet.  There should be one      for every action.  */
name|p
operator|=
operator|&
name|own_buf
index|[
literal|5
index|]
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate room for one extra action, for the default remain-stopped      behavior; if no default action is in the list, we'll need the extra      slot.  */
name|resume_info
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|resume_info
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|default_action
operator|.
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|default_action
operator|.
name|leave_stopped
operator|=
literal|1
expr_stmt|;
name|default_action
operator|.
name|step
operator|=
literal|0
expr_stmt|;
name|default_action
operator|.
name|sig
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|own_buf
index|[
literal|5
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|resume_info
index|[
name|i
index|]
operator|.
name|leave_stopped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
name|resume_info
index|[
name|i
index|]
operator|.
name|step
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
name|resume_info
index|[
name|i
index|]
operator|.
name|step
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|err
goto|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
block|{
name|int
name|sig
decl_stmt|;
name|sig
operator|=
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|q
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
goto|goto
name|err
goto|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|!
name|target_signal_to_host_p
argument_list|(
name|sig
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|resume_info
index|[
name|i
index|]
operator|.
name|sig
operator|=
name|target_signal_to_host
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resume_info
index|[
name|i
index|]
operator|.
name|sig
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|resume_info
index|[
name|i
index|]
operator|.
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|default_action
operator|=
name|resume_info
index|[
name|i
index|]
expr_stmt|;
comment|/* Note: we don't increment i here, we'll overwrite this entry 	     the next time through.  */
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|resume_info
index|[
name|i
index|]
operator|.
name|thread
operator|=
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|q
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
goto|goto
name|err
goto|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|';'
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|resume_info
index|[
name|i
index|]
operator|=
name|default_action
expr_stmt|;
comment|/* Still used in occasional places in the backend.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|resume_info
index|[
literal|0
index|]
operator|.
name|thread
operator|!=
operator|-
literal|1
condition|)
name|cont_thread
operator|=
name|resume_info
index|[
literal|0
index|]
operator|.
name|thread
expr_stmt|;
else|else
name|cont_thread
operator|=
operator|-
literal|1
expr_stmt|;
name|set_desired_inferior
argument_list|(
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|the_target
operator|->
name|resume
call|)
argument_list|(
name|resume_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resume_info
argument_list|)
expr_stmt|;
operator|*
name|signal
operator|=
name|mywait
argument_list|(
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
operator|*
name|status
argument_list|,
operator|*
name|signal
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
comment|/* No other way to report an error... */
name|strcpy
argument_list|(
name|own_buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resume_info
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Handle all of the extended 'v' packets.  */
end_comment

begin_function
name|void
name|handle_v_requests
parameter_list|(
name|char
modifier|*
name|own_buf
parameter_list|,
name|char
modifier|*
name|status
parameter_list|,
name|unsigned
name|char
modifier|*
name|signal
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|own_buf
argument_list|,
literal|"vCont;"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|handle_v_cont
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|own_buf
argument_list|,
literal|"vCont?"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|own_buf
argument_list|,
literal|"vCont;c;C;s;S"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise we didn't know what packet it was.  Say we didn't      understand it.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|myresume
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|thread_resume
name|resume_info
index|[
literal|2
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|||
name|sig
operator|||
name|cont_thread
operator|>
literal|0
condition|)
block|{
name|resume_info
index|[
literal|0
index|]
operator|.
name|thread
operator|=
operator|(
operator|(
expr|struct
name|inferior_list_entry
operator|*
operator|)
name|current_inferior
operator|)
operator|->
name|id
expr_stmt|;
name|resume_info
index|[
literal|0
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|resume_info
index|[
literal|0
index|]
operator|.
name|sig
operator|=
name|sig
expr_stmt|;
name|resume_info
index|[
literal|0
index|]
operator|.
name|leave_stopped
operator|=
literal|0
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|resume_info
index|[
name|n
index|]
operator|.
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|resume_info
index|[
name|n
index|]
operator|.
name|step
operator|=
literal|0
expr_stmt|;
name|resume_info
index|[
name|n
index|]
operator|.
name|sig
operator|=
literal|0
expr_stmt|;
name|resume_info
index|[
name|n
index|]
operator|.
name|leave_stopped
operator|=
operator|(
name|cont_thread
operator|>
literal|0
operator|)
expr_stmt|;
call|(
modifier|*
name|the_target
operator|->
name|resume
call|)
argument_list|(
name|resume_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|attached
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gdbserver_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Usage:\tgdbserver COMM PROG [ARGS ...]\n"
literal|"\tgdbserver COMM --attach PID\n"
literal|"\n"
literal|"COMM may either be a tty device (for serial debugging), or \n"
literal|"HOST:PORT to listen for a TCP connection.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|ch
decl_stmt|,
name|status
decl_stmt|,
modifier|*
name|own_buf
decl_stmt|,
name|mem_buf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|signal
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|CORE_ADDR
name|mem_addr
decl_stmt|;
name|int
name|bad_attach
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|arg_end
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|toplevel
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bad_attach
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
name|attached
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|3
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"--attach"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|4
operator|&&
name|argv
index|[
literal|3
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|pid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|arg_end
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|arg_end
operator|==
literal|'\0'
condition|)
block|{
empty_stmt|;
block|}
else|else
name|bad_attach
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|bad_attach
condition|)
name|gdbserver_usage
argument_list|()
expr_stmt|;
name|initialize_low
argument_list|()
expr_stmt|;
name|own_buf
operator|=
name|malloc
argument_list|(
name|PBUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Wait till we are at first instruction in program.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* We are now stopped at the first instruction of the target process */
block|}
else|else
block|{
switch|switch
condition|(
name|attach_inferior
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|signal
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"Attaching not supported on this target"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|attached
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|remote_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|restart
label|:
name|setjmp
argument_list|(
name|toplevel
argument_list|)
expr_stmt|;
while|while
condition|(
name|getpkt
argument_list|(
name|own_buf
argument_list|)
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|sig
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|own_buf
index|[
name|i
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'q'
case|:
name|handle_query
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|remote_debug
operator|=
operator|!
name|remote_debug
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Detaching from inferior\n"
argument_list|)
expr_stmt|;
name|detach_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|remote_close
argument_list|()
expr_stmt|;
comment|/* If we are attached, then we can exit.  Otherwise, we need to 		 hang around doing nothing, until the child is gone.  */
if|if
condition|(
operator|!
name|attached
condition|)
block|{
name|int
name|status
decl_stmt|,
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|waitpid
argument_list|(
name|signal_pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|ret
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ECHILD
condition|)
do|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
if|if
condition|(
name|attached
operator|==
literal|0
condition|)
block|{
name|extended_protocol
operator|=
literal|1
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can not use the extended protocol if we are 		     attached, because we can not restart the running 		     program.  So return unrecognized.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
switch|switch
condition|(
name|own_buf
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'g'
case|:
name|general_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|set_desired_inferior
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cont_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|step_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Silently ignore it so that gdb can extend the protocol 		     without compatibility headaches.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'g'
case|:
name|set_desired_inferior
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|registers_to_string
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|set_desired_inferior
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|registers_from_string
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|decode_m_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|mem_addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_inferior_memory
argument_list|(
name|mem_addr
argument_list|,
name|mem_buf
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|convert_int_to_ascii
argument_list|(
name|mem_buf
argument_list|,
name|own_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|decode_M_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|mem_addr
argument_list|,
operator|&
name|len
argument_list|,
name|mem_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_inferior_memory
argument_list|(
name|mem_addr
argument_list|,
name|mem_buf
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|convert_ascii_to_int
argument_list|(
name|own_buf
operator|+
literal|1
argument_list|,
operator|&
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_signal_to_host_p
argument_list|(
name|sig
argument_list|)
condition|)
name|signal
operator|=
name|target_signal_to_host
argument_list|(
name|sig
argument_list|)
expr_stmt|;
else|else
name|signal
operator|=
literal|0
expr_stmt|;
name|set_desired_inferior
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|myresume
argument_list|(
literal|0
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|convert_ascii_to_int
argument_list|(
name|own_buf
operator|+
literal|1
argument_list|,
operator|&
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_signal_to_host_p
argument_list|(
name|sig
argument_list|)
condition|)
name|signal
operator|=
name|target_signal_to_host
argument_list|(
name|sig
argument_list|)
expr_stmt|;
else|else
name|signal
operator|=
literal|0
expr_stmt|;
name|set_desired_inferior
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|myresume
argument_list|(
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|set_desired_inferior
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|myresume
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|set_desired_inferior
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|myresume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Killing inferior\n"
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
comment|/* When using the extended protocol, we start up a new 	         debugging session.   The traditional protocol will 	         exit instead.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|mythread_alive
argument_list|(
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Restarting the inferior is only supported in the 	         extended protocol.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|kill_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
comment|/* It is a request we don't understand.  Respond with an 		     empty packet so that gdb knows that we don't support this 		     request.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
case|case
literal|'v'
case|:
comment|/* Extended (long) request.  */
name|handle_v_requests
argument_list|(
name|own_buf
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|signal
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* It is a request we don't understand.  Respond with an 	         empty packet so that gdb knows that we don't support this 	         request.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|putpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'W'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with status %d\n"
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'X'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = 0x%x\n"
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'W'
operator|||
name|status
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Killing inferior\n"
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We come here when getpkt fails.           For the extended remote protocol we exit (and this is the only          way we gracefully exit!).           For the traditional remote protocol close the connection,          and re-open it at the top of the loop.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|remote_close
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote side has terminated connection.  "
literal|"GDBserver will reopen the connection.\n"
argument_list|)
expr_stmt|;
name|remote_close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

