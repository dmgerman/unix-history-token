begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main code for remote server for GDB.    Copyright (C) 1989, 1993 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_decl_stmt
name|int
name|cont_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|general_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|thread_from_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|old_thread_from_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extended_protocol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inferior_pid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
name|start_inferior
parameter_list|(
name|argv
parameter_list|,
name|statusptr
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
name|statusptr
decl_stmt|;
block|{
name|inferior_pid
operator|=
name|create_inferior
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Process %s created; pid = %d\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in program, return signal number.  */
return|return
name|mywait
argument_list|(
name|statusptr
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|,
name|status
decl_stmt|,
name|own_buf
index|[
literal|2000
index|]
decl_stmt|,
name|mem_buf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|signal
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|CORE_ADDR
name|mem_addr
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|toplevel
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Usage: gdbserver tty prog [args ...]"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at first instruction in program.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* We are now stopped at the first instruction of the target process */
while|while
condition|(
literal|1
condition|)
block|{
name|remote_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|restart
label|:
name|setjmp
argument_list|(
name|toplevel
argument_list|)
expr_stmt|;
while|while
condition|(
name|getpkt
argument_list|(
name|own_buf
argument_list|)
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|sig
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|own_buf
index|[
name|i
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|remote_debug
operator|=
operator|!
name|remote_debug
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|extended_protocol
operator|=
literal|1
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
switch|switch
condition|(
name|own_buf
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'g'
case|:
name|general_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cont_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Silently ignore it so that gdb can extend the protocol 		     without compatibility headaches.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'g'
case|:
name|convert_int_to_ascii
argument_list|(
name|registers
argument_list|,
name|own_buf
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|convert_ascii_to_int
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|store_inferior_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|decode_m_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|mem_addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|read_inferior_memory
argument_list|(
name|mem_addr
argument_list|,
name|mem_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|convert_int_to_ascii
argument_list|(
name|mem_buf
argument_list|,
name|own_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|decode_M_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|mem_addr
argument_list|,
operator|&
name|len
argument_list|,
name|mem_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_inferior_memory
argument_list|(
name|mem_addr
argument_list|,
name|mem_buf
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|convert_ascii_to_int
argument_list|(
name|own_buf
operator|+
literal|1
argument_list|,
operator|&
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|myresume
argument_list|(
literal|0
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|convert_ascii_to_int
argument_list|(
name|own_buf
operator|+
literal|1
argument_list|,
operator|&
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|myresume
argument_list|(
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|myresume
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|myresume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Killing inferior\n"
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
comment|/* When using the extended protocol, we start up a new 		 debugging session.   The traditional protocol will 	         exit instead.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|mythread_alive
argument_list|(
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Restarting the inferior is only supported in the 		 extended protocol.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|kill_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
comment|/* It is a request we don't understand.  Respond with an 		     empty packet so that gdb knows that we don't support this 		     request.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
default|default:
comment|/* It is a request we don't understand.  Respond with an 		 empty packet so that gdb knows that we don't support this 		 request.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|putpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'W'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with status %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'X'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = 0x%x\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'W'
operator|||
name|status
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Killing inferior\n"
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We come here when getpkt fails.  	 For the extended remote protocol we exit (and this is the only 	 way we gracefully exit!).  	 For the traditional remote protocol close the connection, 	 and re-open it at the top of the loop.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|remote_close
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote side has terminated connection.  GDBserver will reopen the connection.\n"
argument_list|)
expr_stmt|;
name|remote_close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

