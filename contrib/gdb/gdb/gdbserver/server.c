begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main code for remote server for GDB.    Copyright 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_decl_stmt
name|int
name|cont_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|general_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|thread_from_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|old_thread_from_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extended_protocol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inferior_pid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
name|start_inferior
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|statusptr
parameter_list|)
block|{
name|inferior_pid
operator|=
name|create_inferior
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Process %s created; pid = %d\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in program, return signal number.  */
return|return
name|mywait
argument_list|(
name|statusptr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|attach_inferior
parameter_list|(
name|int
name|pid
parameter_list|,
name|char
modifier|*
name|statusptr
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigptr
parameter_list|)
block|{
comment|/* myattach should return -1 if attaching is unsupported,      0 if it succeeded, and call error() otherwise.  */
if|if
condition|(
name|myattach
argument_list|(
name|pid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
operator|*
name|sigptr
operator|=
name|mywait
argument_list|(
name|statusptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|ch
decl_stmt|,
name|status
decl_stmt|,
modifier|*
name|own_buf
decl_stmt|,
name|mem_buf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|signal
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|CORE_ADDR
name|mem_addr
decl_stmt|;
name|int
name|bad_attach
init|=
literal|0
decl_stmt|;
name|int
name|pid
init|=
literal|0
decl_stmt|;
name|int
name|attached
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arg_end
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|toplevel
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>=
literal|3
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"--attach"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|4
operator|&&
name|argv
index|[
literal|3
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|pid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|arg_end
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|arg_end
operator|==
literal|'\0'
condition|)
block|{
empty_stmt|;
block|}
else|else
name|bad_attach
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|bad_attach
condition|)
name|error
argument_list|(
literal|"Usage:\tgdbserver tty prog [args ...]\n"
literal|"\tgdbserver tty --attach pid"
argument_list|)
expr_stmt|;
name|initialize_low
argument_list|()
expr_stmt|;
name|own_buf
operator|=
name|malloc
argument_list|(
name|PBUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Wait till we are at first instruction in program.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* We are now stopped at the first instruction of the target process */
block|}
else|else
block|{
switch|switch
condition|(
name|attach_inferior
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|signal
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"Attaching not supported on this target"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|attached
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|remote_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|restart
label|:
name|setjmp
argument_list|(
name|toplevel
argument_list|)
expr_stmt|;
while|while
condition|(
name|getpkt
argument_list|(
name|own_buf
argument_list|)
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|sig
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|own_buf
index|[
name|i
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|remote_debug
operator|=
operator|!
name|remote_debug
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|attached
operator|==
literal|0
condition|)
block|{
name|extended_protocol
operator|=
literal|1
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can not use the extended protocol if we are 		     attached, because we can not restart the running 		     program.  So return unrecognized.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
switch|switch
condition|(
name|own_buf
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'g'
case|:
name|general_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cont_thread
operator|=
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Silently ignore it so that gdb can extend the protocol 		     without compatibility headaches.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'g'
case|:
name|registers_to_string
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|registers_from_string
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|store_inferior_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|decode_m_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|mem_addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|read_inferior_memory
argument_list|(
name|mem_addr
argument_list|,
name|mem_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|convert_int_to_ascii
argument_list|(
name|mem_buf
argument_list|,
name|own_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|decode_M_packet
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|mem_addr
argument_list|,
operator|&
name|len
argument_list|,
name|mem_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_inferior_memory
argument_list|(
name|mem_addr
argument_list|,
name|mem_buf
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|convert_ascii_to_int
argument_list|(
name|own_buf
operator|+
literal|1
argument_list|,
operator|&
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_signal_to_host_p
argument_list|(
name|sig
argument_list|)
condition|)
name|signal
operator|=
name|target_signal_to_host
argument_list|(
name|sig
argument_list|)
expr_stmt|;
else|else
name|signal
operator|=
literal|0
expr_stmt|;
name|myresume
argument_list|(
literal|0
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|convert_ascii_to_int
argument_list|(
name|own_buf
operator|+
literal|1
argument_list|,
operator|&
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_signal_to_host_p
argument_list|(
name|sig
argument_list|)
condition|)
name|signal
operator|=
name|target_signal_to_host
argument_list|(
name|sig
argument_list|)
expr_stmt|;
else|else
name|signal
operator|=
literal|0
expr_stmt|;
name|myresume
argument_list|(
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|myresume
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|myresume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
operator|=
name|mywait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|prepare_resume_reply
argument_list|(
name|own_buf
argument_list|,
name|status
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Killing inferior\n"
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
comment|/* When using the extended protocol, we start up a new 	         debugging session.   The traditional protocol will 	         exit instead.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|mythread_alive
argument_list|(
name|strtol
argument_list|(
operator|&
name|own_buf
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
else|else
name|write_enn
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Restarting the inferior is only supported in the 	         extended protocol.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|kill_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
comment|/* It is a request we don't understand.  Respond with an 		     empty packet so that gdb knows that we don't support this 		     request.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
default|default:
comment|/* It is a request we don't understand.  Respond with an 	         empty packet so that gdb knows that we don't support this 	         request.  */
name|own_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|putpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'W'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with status %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'X'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = 0x%x\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'W'
operator|||
name|status
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Killing inferior\n"
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
name|write_ok
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver restarting\n"
argument_list|)
expr_stmt|;
comment|/* Wait till we are at 1st instruction in prog.  */
name|signal
operator|=
name|start_inferior
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We come here when getpkt fails.           For the extended remote protocol we exit (and this is the only          way we gracefully exit!).           For the traditional remote protocol close the connection,          and re-open it at the top of the loop.  */
if|if
condition|(
name|extended_protocol
condition|)
block|{
name|remote_close
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote side has terminated connection.  "
literal|"GDBserver will reopen the connection.\n"
argument_list|)
expr_stmt|;
name|remote_close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

