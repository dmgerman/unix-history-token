begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for the remote server for GDB.    Copyright 1986, 1987, 1993, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/***************Begin MY defs*********************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|my_registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|registers
init|=
name|my_registers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************End MY defs*********************/
end_comment

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_define
define|#
directive|define
name|RF
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|memcpy(&registers[REGISTER_BYTE(dst)],&src, sizeof(src))
end_define

begin_define
define|#
directive|define
name|RS
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|memcpy(&dst,&registers[REGISTER_BYTE(src)], sizeof(dst))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* i386_register_raw_size[i] is the number of bytes of storage in the    actual machine representation for register i.  */
end_comment

begin_decl_stmt
name|int
name|i386_register_raw_size
index|[
name|MAX_NUM_REGS
index|]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i386_register_byte
index|[
name|MAX_NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|initialize_arch
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the table saying where each register starts in the      register file.  */
block|{
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|i386_register_byte
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|i386_register_raw_size
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__i386__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__m68k__
end_ifdef

begin_function
specifier|static
name|void
name|initialize_arch
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__m68k__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__ns32k__
end_ifdef

begin_function
specifier|static
name|void
name|initialize_arch
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__ns32k__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_function
specifier|static
name|void
name|initialize_arch
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__powerpc__ */
end_comment

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a vector of program-name and args. */
end_comment

begin_function
name|int
name|create_inferior
parameter_list|(
name|char
modifier|*
name|program
parameter_list|,
name|char
modifier|*
modifier|*
name|allargs
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|ptrace
argument_list|(
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|program
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|program
argument_list|,
name|errno
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"unknown error"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Attaching is not supported.  */
end_comment

begin_function
name|int
name|myattach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
name|PT_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*************inferior_died ();****VK**************/
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|char
modifier|*
name|status
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|w
decl_stmt|;
name|enable_async_io
argument_list|()
expr_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
name|perror_with_name
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = %x \n"
argument_list|,
name|WTERMSIG
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'X'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WTERMSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|signal
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|step
condition|?
name|PT_STEP
else|:
name|PT_CONTINUE
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_comment
comment|/* Fetch one or more registers from the inferior.  REGNO == -1 to get    them all.  We actually fetch more than requested, when convenient,    marking them as valid so we won't fetch them again.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|ignored
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|struct
name|env387
name|inferior_fp_registers
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|0
argument_list|,
name|inferior_registers
operator|.
name|r_eax
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|1
argument_list|,
name|inferior_registers
operator|.
name|r_ecx
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|2
argument_list|,
name|inferior_registers
operator|.
name|r_edx
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|3
argument_list|,
name|inferior_registers
operator|.
name|r_ebx
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|4
argument_list|,
name|inferior_registers
operator|.
name|r_esp
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|5
argument_list|,
name|inferior_registers
operator|.
name|r_ebp
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|6
argument_list|,
name|inferior_registers
operator|.
name|r_esi
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|7
argument_list|,
name|inferior_registers
operator|.
name|r_edi
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|8
argument_list|,
name|inferior_registers
operator|.
name|r_eip
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|9
argument_list|,
name|inferior_registers
operator|.
name|r_eflags
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|10
argument_list|,
name|inferior_registers
operator|.
name|r_cs
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|11
argument_list|,
name|inferior_registers
operator|.
name|r_ss
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|12
argument_list|,
name|inferior_registers
operator|.
name|r_ds
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|13
argument_list|,
name|inferior_registers
operator|.
name|r_es
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|14
argument_list|,
name|inferior_registers
operator|.
name|r_fs
argument_list|)
expr_stmt|;
name|RF
argument_list|(
literal|15
argument_list|,
name|inferior_registers
operator|.
name|r_gs
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|2
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|3
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|4
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|5
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|6
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|7
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FCTRL_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|control
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FSTAT_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|status
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FTAG_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|tag
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FCS_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|code_seg
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FCOFF_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|eip
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FDS_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|operand_seg
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FDOFF_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|operand
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FOP_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|ignored
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|struct
name|env387
name|inferior_fp_registers
decl_stmt|;
name|RS
argument_list|(
literal|0
argument_list|,
name|inferior_registers
operator|.
name|r_eax
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|1
argument_list|,
name|inferior_registers
operator|.
name|r_ecx
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|2
argument_list|,
name|inferior_registers
operator|.
name|r_edx
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|3
argument_list|,
name|inferior_registers
operator|.
name|r_ebx
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|4
argument_list|,
name|inferior_registers
operator|.
name|r_esp
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|5
argument_list|,
name|inferior_registers
operator|.
name|r_ebp
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|6
argument_list|,
name|inferior_registers
operator|.
name|r_esi
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|7
argument_list|,
name|inferior_registers
operator|.
name|r_edi
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|8
argument_list|,
name|inferior_registers
operator|.
name|r_eip
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|9
argument_list|,
name|inferior_registers
operator|.
name|r_eflags
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|10
argument_list|,
name|inferior_registers
operator|.
name|r_cs
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|11
argument_list|,
name|inferior_registers
operator|.
name|r_ss
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|12
argument_list|,
name|inferior_registers
operator|.
name|r_ds
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|13
argument_list|,
name|inferior_registers
operator|.
name|r_es
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|14
argument_list|,
name|inferior_registers
operator|.
name|r_fs
argument_list|)
expr_stmt|;
name|RS
argument_list|(
literal|15
argument_list|,
name|inferior_registers
operator|.
name|r_gs
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|2
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|3
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|4
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|5
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|6
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|7
argument_list|,
name|inferior_fp_registers
operator|.
name|regs
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FCTRL_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|control
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FSTAT_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|status
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FTAG_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|tag
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FCS_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|code_seg
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FCOFF_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|eip
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FDS_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|operand_seg
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FDOFF_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|operand
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FOP_REGNUM
argument_list|,
name|inferior_fp_registers
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__i386__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__m68k__
end_ifdef

begin_comment
comment|/* Fetch one or more registers from the inferior.  REGNO == -1 to get    them all.  We actually fetch more than requested, when convenient,    marking them as valid so we won't fetch them again.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|struct
name|fpreg
name|inferior_fp_registers
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_registers
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_registers
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_fp_registers
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_fp_registers
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|struct
name|fpreg
name|inferior_fp_registers
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|inferior_registers
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_registers
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inferior_fp_registers
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_fp_registers
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__m68k__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__ns32k__
end_ifdef

begin_comment
comment|/* Fetch one or more registers from the inferior.  REGNO == -1 to get    them all.  We actually fetch more than requested, when convenient,    marking them as valid so we won't fetch them again.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|struct
name|fpreg
name|inferior_fpregisters
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fpregisters
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|0
argument_list|,
name|inferior_registers
operator|.
name|r_r0
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|1
argument_list|,
name|inferior_registers
operator|.
name|r_r1
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|2
argument_list|,
name|inferior_registers
operator|.
name|r_r2
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|3
argument_list|,
name|inferior_registers
operator|.
name|r_r3
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|4
argument_list|,
name|inferior_registers
operator|.
name|r_r4
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|5
argument_list|,
name|inferior_registers
operator|.
name|r_r5
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|6
argument_list|,
name|inferior_registers
operator|.
name|r_r6
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|R0_REGNUM
operator|+
literal|7
argument_list|,
name|inferior_registers
operator|.
name|r_r7
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|SP_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_sp
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_fp
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PC_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_pc
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PS_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_psr
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FPS_REGNUM
argument_list|,
name|inferior_fpregisters
operator|.
name|r_fsr
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|0
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|2
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|4
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
literal|6
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|LP0_REGNUM
operator|+
literal|1
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|LP0_REGNUM
operator|+
literal|3
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|LP0_REGNUM
operator|+
literal|5
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|LP0_REGNUM
operator|+
literal|7
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|struct
name|fpreg
name|inferior_fpregisters
decl_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|0
argument_list|,
name|inferior_registers
operator|.
name|r_r0
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|1
argument_list|,
name|inferior_registers
operator|.
name|r_r1
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|2
argument_list|,
name|inferior_registers
operator|.
name|r_r2
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|3
argument_list|,
name|inferior_registers
operator|.
name|r_r3
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|4
argument_list|,
name|inferior_registers
operator|.
name|r_r4
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|5
argument_list|,
name|inferior_registers
operator|.
name|r_r5
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|6
argument_list|,
name|inferior_registers
operator|.
name|r_r6
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|R0_REGNUM
operator|+
literal|7
argument_list|,
name|inferior_registers
operator|.
name|r_r7
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|SP_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_sp
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_fp
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PC_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_pc
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PS_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|r_psr
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FPS_REGNUM
argument_list|,
name|inferior_fpregisters
operator|.
name|r_fsr
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|0
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|2
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|4
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
literal|6
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|LP0_REGNUM
operator|+
literal|1
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|LP0_REGNUM
operator|+
literal|3
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|LP0_REGNUM
operator|+
literal|5
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|LP0_REGNUM
operator|+
literal|7
argument_list|,
name|inferior_fpregisters
operator|.
name|r_freg
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fpregisters
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__ns32k__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_comment
comment|/* Fetch one or more registers from the inferior.  REGNO == -1 to get    them all.  We actually fetch more than requested, when convenient,    marking them as valid so we won't fetch them again.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
ifdef|#
directive|ifdef
name|PT_GETFPREGS
name|struct
name|fpreg
name|inferior_fp_registers
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|RF
argument_list|(
name|i
argument_list|,
name|inferior_registers
operator|.
name|fixreg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PPC_LR_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|lr
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PPC_CR_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|cr
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PPC_XER_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|xer
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PPC_CTR_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|ctr
argument_list|)
expr_stmt|;
name|RF
argument_list|(
name|PC_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|pc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETFPREGS
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|RF
argument_list|(
name|FP0_REGNUM
operator|+
name|i
argument_list|,
name|inferior_fp_registers
operator|.
name|r_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
ifdef|#
directive|ifdef
name|PT_SETFPREGS
name|struct
name|fpreg
name|inferior_fp_registers
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|RS
argument_list|(
name|i
argument_list|,
name|inferior_registers
operator|.
name|fixreg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PPC_LR_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|lr
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PPC_CR_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|cr
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PPC_XER_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|xer
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PPC_CTR_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|ctr
argument_list|)
expr_stmt|;
name|RS
argument_list|(
name|PC_REGNUM
argument_list|,
name|inferior_registers
operator|.
name|pc
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_SETFPREGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|RS
argument_list|(
name|FP0_REGNUM
operator|+
name|i
argument_list|,
name|inferior_fp_registers
operator|.
name|r_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__powerpc__ */
end_comment

begin_comment
comment|/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_PTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
name|void
name|read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_D
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_D
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_D
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_D
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize_low
parameter_list|(
name|void
parameter_list|)
block|{
name|initialize_arch
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

