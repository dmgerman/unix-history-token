begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for the remote server for GDB.    Copyright (C) 1995, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/***************Begin MY defs*********************/
end_comment

begin_decl_stmt
name|int
name|quit_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index within `registers' of the first byte of the space for    register N.  */
end_comment

begin_decl_stmt
name|char
name|buf2
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************End MY defs*********************/
end_comment

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_if
if|#
directive|if
name|__GLIBC__
operator|>
literal|2
operator|||
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|>=
literal|1
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|quit
argument_list|()
decl_stmt|,
name|perror_with_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|query
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a vector of program-name and args.    ENV is the environment vector to pass.  */
end_comment

begin_function
name|int
name|create_inferior
parameter_list|(
name|program
parameter_list|,
name|allargs
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
modifier|*
name|allargs
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|ptrace
argument_list|(
name|PTRACE_TRACEME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|program
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|program
argument_list|,
name|errno
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"unknown error"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
name|PTRACE_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*************inferior_died ();****VK**************/
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|status
parameter_list|)
name|char
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|union
name|wait
name|w
decl_stmt|;
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
name|perror_with_name
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = %x \n"
argument_list|,
name|WTERMSIG
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'X'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WTERMSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|step
condition|?
name|PTRACE_SINGLESTEP
else|:
name|PTRACE_CONT
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|offsetof
argument_list|)
end_if

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* U_REGS_OFFSET is the offset of the registers within the u area.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|U_REGS_OFFSET
argument_list|)
end_if

begin_define
define|#
directive|define
name|U_REGS_OFFSET
define|\
value|ptrace (PT_READ_U, inferior_pid, \           (PTRACE_ARG3_TYPE) (offsetof (struct user, u_ar0)), 0) \     - KERNEL_U_ADDR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_M68K
end_ifndef

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386v.h */
end_comment

begin_comment
comment|/* symbols like 'EAX' come from<sys/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
name|EAX
block|,
name|ECX
block|,
name|EDX
block|,
name|EBX
block|,
name|UESP
block|,
name|EBP
block|,
name|ESI
block|,
name|EDI
block|,
name|EIP
block|,
name|EFL
block|,
name|CS
block|,
name|SS
block|,
name|DS
block|,
name|ES
block|,
name|FS
block|,
name|GS
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* this will be needed if fp registers are reinstated */
comment|/* for now, you can look at them with 'info float'    * sys5 wont let you change them with ptrace anyway    */
block|if (regnum>= FP0_REGNUM&& regnum<= FP7_REGNUM)      {       int ubase, fpstate;       struct user u;       ubase = blockend + 4 * (SS + 1) - KSTKSZ;       fpstate = ubase + ((char *)&u.u_fpstate - (char *)&u);       return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));     }    else
endif|#
directive|endif
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TARGET_M68K */
end_comment

begin_comment
comment|/* This table must line up with REGISTER_NAMES in tm-m68k.h */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PT_D0
name|PT_D0
block|,
name|PT_D1
block|,
name|PT_D2
block|,
name|PT_D3
block|,
name|PT_D4
block|,
name|PT_D5
block|,
name|PT_D6
block|,
name|PT_D7
block|,
name|PT_A0
block|,
name|PT_A1
block|,
name|PT_A2
block|,
name|PT_A3
block|,
name|PT_A4
block|,
name|PT_A5
block|,
name|PT_A6
block|,
name|PT_USP
block|,
name|PT_SR
block|,
name|PT_PC
block|,
else|#
directive|else
literal|14
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|18
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PT_FP0
name|PT_FP0
block|,
name|PT_FP1
block|,
name|PT_FP2
block|,
name|PT_FP3
block|,
name|PT_FP4
block|,
name|PT_FP5
block|,
name|PT_FP6
block|,
name|PT_FP7
block|,
name|PT_FPCR
block|,
name|PT_FPSR
block|,
name|PT_FPIAR
else|#
directive|else
literal|21
block|,
literal|24
block|,
literal|27
block|,
literal|30
block|,
literal|33
block|,
literal|36
block|,
literal|39
block|,
literal|42
block|,
literal|45
block|,
literal|46
block|,
literal|47
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BLOCKEND is the value of u.u_ar0, and points to the place where GS    is stored.  */
end_comment

begin_function
name|int
name|m68k_linux_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|CORE_ADDR
name|register_addr
parameter_list|(
name|regno
parameter_list|,
name|blockend
parameter_list|)
name|int
name|regno
decl_stmt|;
name|CORE_ADDR
name|blockend
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
name|ARCH_NUM_REGS
condition|)
name|error
argument_list|(
literal|"Invalid register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|REGISTER_U_ADDR
argument_list|(
name|addr
argument_list|,
name|blockend
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|unsigned
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|U_REGS_OFFSET
expr_stmt|;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|regno
operator|*
literal|4
operator|+
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKUSR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 	     kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"reading register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
name|error_exit
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers, or just one, from the child process.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
operator|-
name|NUM_FREGS
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
name|U_REGS_OFFSET
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|if (CANNOT_STORE_REGISTER (regno)) 	return;
endif|#
directive|endif
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)         {           scratch = *(int *)&registers[REGISTER_BYTE (regno)] | 0x3;           ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,                   scratch, 0);           if (errno != 0)             {
comment|/* Error, even if attached.  Failing to write these two 		 registers is pretty serious.  */
block|sprintf (buf, "writing register number %d", regno);               perror_with_name (buf);             }         }       else
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEUSR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 		   kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"writing register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
operator|-
name|NUM_FREGS
condition|;
name|regno
operator|++
control|)
name|store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_PTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
name|void
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKETEXT
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize
parameter_list|()
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|have_inferior_p
parameter_list|()
block|{
return|return
name|inferior_pid
operator|!=
literal|0
return|;
block|}
end_function

end_unit

