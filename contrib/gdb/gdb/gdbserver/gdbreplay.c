begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Replay a remote debug session logfile for GDB.    Copyright (C) 1996 Free Software Foundation, Inc.    Written by Fred Fish (fnf@cygnus.com) from pieces of gdbserver.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* Sort of a hack... */
end_comment

begin_define
define|#
directive|define
name|EOL
value|(EOF - 1)
end_define

begin_decl_stmt
specifier|static
name|int
name|remote_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the system error message for errno, and also mention STRING    as the file name for which the error was encountered.    Then return to command level.  */
end_comment

begin_function
name|void
name|perror_with_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s.\n"
argument_list|,
name|combined
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sync_error
parameter_list|(
name|fp
parameter_list|,
name|desc
parameter_list|,
name|expect
parameter_list|,
name|got
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|int
name|expect
decl_stmt|;
name|int
name|got
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s\n"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"At logfile offset %ld, expected '0x%x' got '0x%x'\n"
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|,
name|expect
argument_list|,
name|got
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remote_close
parameter_list|()
block|{
name|close
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Must specify tcp connection as host:addr\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|port_str
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|sockaddr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protoent
decl_stmt|;
name|int
name|tmp_desc
decl_stmt|;
name|port_str
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|port
operator|=
name|atoi
argument_list|(
name|port_str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp_desc
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Can't open socket"
argument_list|)
expr_stmt|;
comment|/* Allow rapid reuse of this port. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|tmp_desc
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr
operator|.
name|sin_family
operator|=
name|PF_INET
expr_stmt|;
name|sockaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sockaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|tmp_desc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
argument_list|)
operator|||
name|listen
argument_list|(
name|tmp_desc
argument_list|,
literal|1
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"Can't bind address"
argument_list|)
expr_stmt|;
name|tmp
operator|=
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|accept
argument_list|(
name|tmp_desc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_desc
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Accept failed"
argument_list|)
expr_stmt|;
name|protoent
operator|=
name|getprotobyname
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protoent
condition|)
name|perror_with_name
argument_list|(
literal|"getprotobyname"
argument_list|)
expr_stmt|;
comment|/* Enable TCP keep alive process. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|tmp_desc
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell TCP not to delay small packets.  This greatly speeds up 	 interactive response. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|remote_desc
argument_list|,
name|protoent
operator|->
name|p_proto
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmp_desc
argument_list|)
expr_stmt|;
comment|/* No longer need this */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* If we don't do this, then gdbreplay simply 				    exits when the remote side dies.  */
block|}
name|fcntl
argument_list|(
name|remote_desc
argument_list|,
name|F_SETFL
argument_list|,
name|FASYNC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Replay logfile using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
block|{
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
block|{
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nInvalid hex digit '%c'\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|logchar
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|ch2
decl_stmt|;
name|ch
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\n'
case|:
name|ch
operator|=
name|EOL
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|ch
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\\'
case|:
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ch
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ch2
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|ch2
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ch
operator|=
name|tohex
argument_list|(
name|ch2
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch2
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|ch2
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ch
operator||=
name|tohex
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Treat any other char as just itself */
break|break;
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Accept input from gdb and match with chars from fp (after skipping one    blank) up until a \n is read from fp (which is not matched) */
end_comment

begin_function
name|void
name|expect
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|fromlog
decl_stmt|;
name|unsigned
name|char
name|fromgdb
decl_stmt|;
if|if
condition|(
operator|(
name|fromlog
operator|=
name|logchar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
condition|)
block|{
name|sync_error
argument_list|(
name|fp
argument_list|,
literal|"Sync error during gdb read of leading blank"
argument_list|,
literal|' '
argument_list|,
name|fromlog
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|fromlog
operator|=
name|logchar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromlog
operator|==
name|EOL
condition|)
block|{
break|break;
block|}
name|read
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|fromgdb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fromlog
operator|==
name|fromgdb
condition|)
do|;
if|if
condition|(
name|fromlog
operator|!=
name|EOL
condition|)
block|{
name|sync_error
argument_list|(
name|fp
argument_list|,
literal|"Sync error during read of gdb packet"
argument_list|,
name|fromlog
argument_list|,
name|fromgdb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Play data back to gdb from fp (after skipping leading blank) up until a    \n is read from fp (which is discarded and not sent to gdb). */
end_comment

begin_function
name|void
name|play
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|fromlog
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|(
name|fromlog
operator|=
name|logchar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
condition|)
block|{
name|sync_error
argument_list|(
name|fp
argument_list|,
literal|"Sync error skipping blank during write to gdb"
argument_list|,
literal|' '
argument_list|,
name|fromlog
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|fromlog
operator|=
name|logchar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOL
condition|)
block|{
name|ch
operator|=
name|fromlog
expr_stmt|;
name|write
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: gdbreplay<logfile><host:port>\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|remote_open
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|logchar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'w'
case|:
comment|/* data sent from gdb to gdbreplay, accept and match it */
name|expect
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* data sent from gdbreplay to gdb, play it */
name|play
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Command executed by gdb */
while|while
condition|(
operator|(
name|ch
operator|=
name|logchar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOL
condition|)
empty_stmt|;
break|break;
block|}
block|}
name|remote_close
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

