begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to simulators, for the remote server for GDB.    Copyright (C) 1995, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"callback.h"
end_include

begin_comment
comment|/* GDB simulator callback interface */
end_comment

begin_include
include|#
directive|include
file|"remote-sim.h"
end_include

begin_comment
comment|/* GDB simulator interface */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|host_callback
name|default_callback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in sim/common/callback.c */
end_comment

begin_decl_stmt
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
name|__attribute__
argument_list|(
operator|(
name|aligned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_byte_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by simulator */
end_comment

begin_comment
comment|/* We record the result of sim_open so we can pass it    back to the other sim_foo routines.  */
end_comment

begin_decl_stmt
specifier|static
name|SIM_DESC
name|gdbsim_desc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This version of "load" should be usable for any simulator that    does not support loading itself.  */
end_comment

begin_function
specifier|static
name|void
name|generic_load
parameter_list|(
name|loadfile_bfd
parameter_list|)
name|bfd
modifier|*
name|loadfile_bfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|loadfile_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
comment|/* use load address, not virtual address */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
comment|/* Is this really necessary?  I guess it gives the user something 		 to look at during a long download.  */
name|printf
argument_list|(
literal|"Loading section %s, size 0x%lx lma 0x%lx\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lma
argument_list|)
expr_stmt|;
comment|/* chops high 32 bits.  FIXME!! */
name|bfd_get_section_contents
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|write_inferior_memory
argument_list|(
name|lma
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"Start address 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|loadfile_bfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
comment|/* We were doing this in remote-mips.c, I suspect it is right      for other targets too.  */
comment|/* write_pc (loadfile_bfd->start_address); */
comment|/* FIXME!! */
block|}
end_function

begin_function
name|int
name|create_inferior
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|pid
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_BYTE_ORDER_SELECTABLE
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
name|int
name|nargs
decl_stmt|;
endif|#
directive|endif
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|program
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gdbserver: can't open %s: %s\n"
argument_list|,
name|program
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gdbserver: unknown load format for %s: %s\n"
argument_list|,
name|program
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_BYTE_ORDER_SELECTABLE
comment|/* Add "-E big" or "-E little" to the argument list depending on the      endianness of the program to be loaded.  */
for|for
control|(
name|nargs
operator|=
literal|0
init|;
name|argv
index|[
name|nargs
index|]
operator|!=
name|NULL
condition|;
name|nargs
operator|++
control|)
comment|/* count the args */
empty_stmt|;
name|new_argv
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
comment|/* allocate new args */
for|for
control|(
name|nargs
operator|=
literal|0
init|;
name|argv
index|[
name|nargs
index|]
operator|!=
name|NULL
condition|;
name|nargs
operator|++
control|)
comment|/* copy old to new */
name|new_argv
index|[
name|nargs
index|]
operator|=
name|argv
index|[
name|nargs
index|]
expr_stmt|;
name|new_argv
index|[
name|nargs
index|]
operator|=
literal|"-E"
expr_stmt|;
name|new_argv
index|[
name|nargs
operator|+
literal|1
index|]
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
literal|"big"
else|:
literal|"little"
expr_stmt|;
name|new_argv
index|[
name|nargs
operator|+
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|argv
operator|=
name|new_argv
expr_stmt|;
endif|#
directive|endif
comment|/* Create an instance of the simulator.  */
name|default_callback
operator|.
name|init
argument_list|(
operator|&
name|default_callback
argument_list|)
expr_stmt|;
name|gdbsim_desc
operator|=
name|sim_open
argument_list|(
name|SIM_OPEN_STANDALONE
argument_list|,
operator|&
name|default_callback
argument_list|,
name|abfd
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbsim_desc
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Load the program into the simulator.  */
if|if
condition|(
name|abfd
condition|)
if|if
condition|(
name|sim_load
argument_list|(
name|gdbsim_desc
argument_list|,
name|program
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|SIM_RC_FAIL
condition|)
name|generic_load
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Create an inferior process in the simulator.  This initializes SP.  */
name|sim_create_inferior
argument_list|(
name|gdbsim_desc
argument_list|,
name|abfd
argument_list|,
name|argv
argument_list|,
comment|/* env */
name|NULL
argument_list|)
expr_stmt|;
name|sim_resume
argument_list|(
name|gdbsim_desc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* execute one instr */
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|()
block|{
name|sim_close
argument_list|(
name|gdbsim_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|default_callback
operator|.
name|shutdown
argument_list|(
operator|&
name|default_callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|sim_fetch_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|regno
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers, or just one, from the child process.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
comment|/*-NUM_FREGS*/
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|sim_store_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|regno
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|status
parameter_list|)
name|char
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|sigrc
decl_stmt|;
name|enum
name|sim_stop
name|reason
decl_stmt|;
name|sim_stop_reason
argument_list|(
name|gdbsim_desc
argument_list|,
operator|&
name|reason
argument_list|,
operator|&
name|sigrc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|sim_exited
case|:
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|sigrc
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
name|sigrc
return|;
if|#
directive|if
literal|0
block|case sim_stopped:       if (remote_debug) 	printf ("\nChild terminated with signal = %x \n", sigrc);       *status = 'X';       return sigrc;
endif|#
directive|endif
default|default:
comment|/* should this be sim_signalled or sim_stopped?  FIXME!! */
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"\nChild received signal = %x \n"
argument_list|,
name|sigrc
argument_list|)
expr_stmt|;
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|sigrc
return|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
comment|/* Should be using target_signal_to_host() or signal numbers in target.h      to convert GDB signal number to target signal number.  */
name|sim_resume
argument_list|(
name|gdbsim_desc
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
name|void
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|sim_read
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|sim_write
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* should check for error.  FIXME!! */
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void initialize () {   inferior_pid = 0; }  int have_inferior_p () {   return inferior_pid != 0; }
endif|#
directive|endif
end_endif

end_unit

