begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to simulators, for the remote server for GDB.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"callback.h"
end_include

begin_comment
comment|/* GDB simulator callback interface */
end_comment

begin_include
include|#
directive|include
file|"remote-sim.h"
end_include

begin_comment
comment|/* GDB simulator interface */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|host_callback
name|default_callback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in sim/common/callback.c */
end_comment

begin_decl_stmt
specifier|static
name|char
name|my_registers
index|[
name|REGISTER_BYTES
index|]
name|__attribute__
argument_list|(
operator|(
name|aligned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|registers
init|=
name|my_registers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_byte_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by simulator */
end_comment

begin_comment
comment|/* We record the result of sim_open so we can pass it    back to the other sim_foo routines.  */
end_comment

begin_decl_stmt
specifier|static
name|SIM_DESC
name|gdbsim_desc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This version of "load" should be usable for any simulator that    does not support loading itself.  */
end_comment

begin_function
specifier|static
name|void
name|mygeneric_load
parameter_list|(
name|bfd
modifier|*
name|loadfile_bfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|loadfile_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
comment|/* use load address, not virtual address */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
comment|/* Is this really necessary?  I guess it gives the user something 	         to look at during a long download.  */
name|printf
argument_list|(
literal|"Loading section %s, size 0x%lx lma 0x%lx\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lma
argument_list|)
expr_stmt|;
comment|/* chops high 32 bits.  FIXME!! */
name|bfd_get_section_contents
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|write_inferior_memory
argument_list|(
name|lma
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"Start address 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|loadfile_bfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
comment|/* We were doing this in remote-mips.c, I suspect it is right      for other targets too.  */
comment|/* write_pc (loadfile_bfd->start_address); */
comment|/* FIXME!! */
block|}
end_function

begin_function
name|int
name|create_inferior
parameter_list|(
name|char
modifier|*
name|program
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|pid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|program
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gdbserver: can't open %s: %s\n"
argument_list|,
name|program
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gdbserver: unknown load format for %s: %s\n"
argument_list|,
name|program
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Add "-E big" or "-E little" to the argument list depending on the      endianness of the program to be loaded.  */
for|for
control|(
name|nargs
operator|=
literal|0
init|;
name|argv
index|[
name|nargs
index|]
operator|!=
name|NULL
condition|;
name|nargs
operator|++
control|)
comment|/* count the args */
empty_stmt|;
name|new_argv
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
comment|/* allocate new args */
for|for
control|(
name|nargs
operator|=
literal|0
init|;
name|argv
index|[
name|nargs
index|]
operator|!=
name|NULL
condition|;
name|nargs
operator|++
control|)
comment|/* copy old to new */
name|new_argv
index|[
name|nargs
index|]
operator|=
name|argv
index|[
name|nargs
index|]
expr_stmt|;
name|new_argv
index|[
name|nargs
index|]
operator|=
literal|"-E"
expr_stmt|;
name|new_argv
index|[
name|nargs
operator|+
literal|1
index|]
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
literal|"big"
else|:
literal|"little"
expr_stmt|;
name|new_argv
index|[
name|nargs
operator|+
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|argv
operator|=
name|new_argv
expr_stmt|;
comment|/* Create an instance of the simulator.  */
name|default_callback
operator|.
name|init
argument_list|(
operator|&
name|default_callback
argument_list|)
expr_stmt|;
name|gdbsim_desc
operator|=
name|sim_open
argument_list|(
name|SIM_OPEN_STANDALONE
argument_list|,
operator|&
name|default_callback
argument_list|,
name|abfd
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbsim_desc
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Load the program into the simulator.  */
if|if
condition|(
name|abfd
condition|)
if|if
condition|(
name|sim_load
argument_list|(
name|gdbsim_desc
argument_list|,
name|program
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|SIM_RC_FAIL
condition|)
name|mygeneric_load
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Create an inferior process in the simulator.  This initializes SP.  */
name|sim_create_inferior
argument_list|(
name|gdbsim_desc
argument_list|,
name|abfd
argument_list|,
name|argv
argument_list|,
comment|/* env */
name|NULL
argument_list|)
expr_stmt|;
name|sim_resume
argument_list|(
name|gdbsim_desc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* execute one instr */
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Attaching is not supported.  */
end_comment

begin_function
name|int
name|myattach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|sim_close
argument_list|(
name|gdbsim_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|default_callback
operator|.
name|shutdown
argument_list|(
operator|&
name|default_callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|sim_fetch_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|regno
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers, or just one, from the child process.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
comment|/*-NUM_FREGS*/
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|sim_store_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|regno
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|char
modifier|*
name|status
parameter_list|)
block|{
name|int
name|sigrc
decl_stmt|;
name|enum
name|sim_stop
name|reason
decl_stmt|;
name|sim_stop_reason
argument_list|(
name|gdbsim_desc
argument_list|,
operator|&
name|reason
argument_list|,
operator|&
name|sigrc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|sim_exited
case|:
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|sigrc
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
name|sigrc
return|;
if|#
directive|if
literal|0
block|case sim_stopped:       if (remote_debug) 	printf ("\nChild terminated with signal = %x \n", sigrc);       *status = 'X';       return sigrc;
endif|#
directive|endif
default|default:
comment|/* should this be sim_signalled or sim_stopped?  FIXME!! */
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"\nChild received signal = %x \n"
argument_list|,
name|sigrc
argument_list|)
expr_stmt|;
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|sigrc
return|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
comment|/* Should be using target_signal_to_host() or signal numbers in target.h      to convert GDB signal number to target signal number.  */
name|sim_resume
argument_list|(
name|gdbsim_desc
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
name|void
name|read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|sim_read
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|sim_write
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* should check for error.  FIXME!! */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|initialize_low
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

