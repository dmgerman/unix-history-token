begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for the remote server for GDB.    Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"linux-low.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|PTRACE_ARG3_TYPE
value|long
end_define

begin_define
define|#
directive|define
name|PTRACE_XFER_TYPE
value|long
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|use_regsets_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|num_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|regmap
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a vector of program-name and args. */
end_comment

begin_function
name|int
name|create_inferior
parameter_list|(
name|char
modifier|*
name|program
parameter_list|,
name|char
modifier|*
modifier|*
name|allargs
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|ptrace
argument_list|(
name|PTRACE_TRACEME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|program
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|program
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Attach to an inferior process.  */
end_comment

begin_function
name|int
name|myattach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_ATTACH
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot attach to process %d: %s (%d)\n"
argument_list|,
name|pid
argument_list|,
name|errno
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"unknown error"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
name|PTRACE_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|char
modifier|*
name|status
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|w
decl_stmt|;
name|enable_async_io
argument_list|()
expr_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
name|perror_with_name
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = %x \n"
argument_list|,
name|WTERMSIG
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'X'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WTERMSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|signal
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|step
condition|?
name|PTRACE_SINGLESTEP
else|:
name|PTRACE_CONT
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
end_ifdef

begin_define
define|#
directive|define
name|REGISTER_RAW_SIZE
parameter_list|(
name|regno
parameter_list|)
value|register_size((regno))
end_define

begin_function
name|int
name|register_addr
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|int
name|addr
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
operator|||
name|regnum
operator|>=
name|num_regs
condition|)
name|error
argument_list|(
literal|"Invalid register number %d."
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|addr
operator|=
name|regmap
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
name|addr
operator|=
literal|0
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|CORE_ADDR
name|regaddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|num_regs
condition|)
return|return;
if|if
condition|(
name|cannot_fetch_register
argument_list|(
name|regno
argument_list|)
condition|)
return|return;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regaddr
operator|==
operator|-
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|(
name|register_data
argument_list|(
name|regno
argument_list|)
operator|+
name|i
operator|)
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKUSER
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 	     kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"reading register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
name|error_exit
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers, or just one, from the child process.  */
end_comment

begin_function
specifier|static
name|void
name|usr_fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|num_regs
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
specifier|static
name|void
name|usr_store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|CORE_ADDR
name|regaddr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
name|num_regs
condition|)
return|return;
if|if
condition|(
name|cannot_store_register
argument_list|(
name|regno
argument_list|)
condition|)
return|return;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regaddr
operator|==
operator|-
literal|1
condition|)
return|return;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEUSER
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|register_data
argument_list|(
name|regno
argument_list|)
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 		 kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"writing register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|num_regs
condition|;
name|regno
operator|++
control|)
name|store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_USRREGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
end_ifdef

begin_function
specifier|static
name|int
name|regsets_fetch_inferior_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|regset_info
modifier|*
name|regset
decl_stmt|;
name|regset
operator|=
name|target_regsets
expr_stmt|;
while|while
condition|(
name|regset
operator|->
name|size
operator|>=
literal|0
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|regset
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|regset
operator|++
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|regset
operator|->
name|size
argument_list|)
expr_stmt|;
name|res
operator|=
name|ptrace
argument_list|(
name|regset
operator|->
name|get_request
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
comment|/* If we get EIO on the first regset, do not try regsets again. 		 If we get EIO on a later regset, disable that regset.  */
if|if
condition|(
name|regset
operator|==
name|target_regsets
condition|)
block|{
name|use_regsets_p
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|regset
operator|->
name|size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|perror
argument_list|(
literal|"Warning: ptrace(regsets_fetch_inferior_registers)"
argument_list|)
expr_stmt|;
block|}
block|}
name|regset
operator|->
name|store_function
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|regsets_store_inferior_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|regset_info
modifier|*
name|regset
decl_stmt|;
name|regset
operator|=
name|target_regsets
expr_stmt|;
while|while
condition|(
name|regset
operator|->
name|size
operator|>=
literal|0
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|regset
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|regset
operator|++
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|regset
operator|->
name|size
argument_list|)
expr_stmt|;
name|regset
operator|->
name|fill_function
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|res
operator|=
name|ptrace
argument_list|(
name|regset
operator|->
name|set_request
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
comment|/* If we get EIO on the first regset, do not try regsets again. 		 If we get EIO on a later regset, disable that regset.  */
if|if
condition|(
name|regset
operator|==
name|target_regsets
condition|)
block|{
name|use_regsets_p
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|regset
operator|->
name|size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|perror
argument_list|(
literal|"Warning: ptrace(regsets_fetch_inferior_registers)"
argument_list|)
expr_stmt|;
block|}
block|}
name|regset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_REGSETS */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
if|if
condition|(
name|use_regsets_p
condition|)
block|{
if|if
condition|(
name|regsets_fetch_inferior_registers
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
name|usr_fetch_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
if|if
condition|(
name|use_regsets_p
condition|)
block|{
if|if
condition|(
name|regsets_store_inferior_registers
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
name|usr_store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
name|void
name|read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|PTRACE_XFER_TYPE
modifier|*
name|buffer
init|=
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|PTRACE_XFER_TYPE
modifier|*
name|buffer
init|=
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKETEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize_low
parameter_list|(
name|void
parameter_list|)
block|{
name|init_registers
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

