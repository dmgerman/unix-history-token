begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for the remote server for GDB.    Copyright 1986, 1987, 1993, 1994, 1995, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|LYNXOS
end_define

begin_include
include|#
directive|include
file|<sys/mem.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__LYNXOS
end_ifndef

begin_define
define|#
directive|define
name|__LYNXOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/itimer.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/fpp.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|my_registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|registers
init|=
name|my_registers
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a vector of program-name and args. */
end_comment

begin_function
name|int
name|create_inferior
parameter_list|(
name|char
modifier|*
name|program
parameter_list|,
name|char
modifier|*
modifier|*
name|allargs
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|pgrp
decl_stmt|;
comment|/* Switch child to it's own process group so that signals won't          directly affect gdbserver. */
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrp
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_TRACEME
argument_list|,
literal|0
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|program
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GDBserver (process %d):  Cannot exec %s: %s.\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|program
argument_list|,
name|errno
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"unknown error"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Attaching is not supported.  */
end_comment

begin_function
name|int
name|myattach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
name|PTRACE_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* Arggh.  Apparently pthread_kill only works for threads within      the process that calls pthread_kill.       We want to avoid the lynx signal extensions as they simply don't      map well to the generic gdb interface we want to keep.       All we want to do is determine if a particular thread is alive;      it appears as if we can just make a harmless thread specific      ptrace call to do that.  */
return|return
operator|(
name|ptrace
argument_list|(
name|PTRACE_THREADUSER
argument_list|,
name|BUILDPID
argument_list|(
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|,
name|pid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|char
modifier|*
name|status
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|union
name|wait
name|w
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|enable_async_io
argument_list|()
expr_stmt|;
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
name|thread_from_wait
operator|=
name|w
operator|.
name|w_tid
expr_stmt|;
name|inferior_pid
operator|=
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|w
operator|.
name|w_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|==
name|SIGTRAP
condition|)
block|{
name|int
name|realsig
decl_stmt|;
name|realsig
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETTRACESIG
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|realsig
operator|==
name|SIGNEWTHREAD
condition|)
block|{
comment|/* It's a new thread notification.  Nothing to do here since 	         the machine independent code in wait_for_inferior will 	         add the thread to the thread list and restart the thread 	         when pid != inferior_pid and pid is not in the thread list. 	         We don't even want to muck with realsig -- the code in 	         wait_for_inferior expects SIGTRAP.  */
empty_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
operator|*
name|status
operator|=
literal|'X'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WTERMSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|signal
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|step
condition|?
name|PTRACE_SINGLESTEP_ONE
else|:
name|PTRACE_CONT
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|cont_thread
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|cont_thread
argument_list|)
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|offsetof
end_undef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_comment
comment|/* Mapping between GDB register #s and offsets into econtext.  Must be    consistent with REGISTER_NAMES macro in various tmXXX.h files. */
end_comment

begin_define
define|#
directive|define
name|X
parameter_list|(
name|ENTRY
parameter_list|)
value|(offsetof(struct econtext, ENTRY))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|I386
end_ifdef

begin_comment
comment|/* Mappings from tm-i386v.h */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
name|X
argument_list|(
name|eax
argument_list|)
block|,
name|X
argument_list|(
name|ecx
argument_list|)
block|,
name|X
argument_list|(
name|edx
argument_list|)
block|,
name|X
argument_list|(
name|ebx
argument_list|)
block|,
name|X
argument_list|(
name|esp
argument_list|)
block|,
comment|/* sp */
name|X
argument_list|(
name|ebp
argument_list|)
block|,
comment|/* fp */
name|X
argument_list|(
name|esi
argument_list|)
block|,
name|X
argument_list|(
name|edi
argument_list|)
block|,
name|X
argument_list|(
name|eip
argument_list|)
block|,
comment|/* pc */
name|X
argument_list|(
name|flags
argument_list|)
block|,
comment|/* ps */
name|X
argument_list|(
name|cs
argument_list|)
block|,
name|X
argument_list|(
name|ss
argument_list|)
block|,
name|X
argument_list|(
name|ds
argument_list|)
block|,
name|X
argument_list|(
name|es
argument_list|)
block|,
name|X
argument_list|(
name|ecode
argument_list|)
block|,
comment|/* Lynx doesn't give us either fs or gs, so */
name|X
argument_list|(
name|fault
argument_list|)
block|,
comment|/* we just substitute these two in the hopes 				   that they are useful. */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|M68K
end_ifdef

begin_comment
comment|/* Mappings from tm-m68k.h */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
name|X
argument_list|(
name|regs
index|[
literal|0
index|]
argument_list|)
block|,
comment|/* d0 */
name|X
argument_list|(
name|regs
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* d1 */
name|X
argument_list|(
name|regs
index|[
literal|2
index|]
argument_list|)
block|,
comment|/* d2 */
name|X
argument_list|(
name|regs
index|[
literal|3
index|]
argument_list|)
block|,
comment|/* d3 */
name|X
argument_list|(
name|regs
index|[
literal|4
index|]
argument_list|)
block|,
comment|/* d4 */
name|X
argument_list|(
name|regs
index|[
literal|5
index|]
argument_list|)
block|,
comment|/* d5 */
name|X
argument_list|(
name|regs
index|[
literal|6
index|]
argument_list|)
block|,
comment|/* d6 */
name|X
argument_list|(
name|regs
index|[
literal|7
index|]
argument_list|)
block|,
comment|/* d7 */
name|X
argument_list|(
name|regs
index|[
literal|8
index|]
argument_list|)
block|,
comment|/* a0 */
name|X
argument_list|(
name|regs
index|[
literal|9
index|]
argument_list|)
block|,
comment|/* a1 */
name|X
argument_list|(
name|regs
index|[
literal|10
index|]
argument_list|)
block|,
comment|/* a2 */
name|X
argument_list|(
name|regs
index|[
literal|11
index|]
argument_list|)
block|,
comment|/* a3 */
name|X
argument_list|(
name|regs
index|[
literal|12
index|]
argument_list|)
block|,
comment|/* a4 */
name|X
argument_list|(
name|regs
index|[
literal|13
index|]
argument_list|)
block|,
comment|/* a5 */
name|X
argument_list|(
name|regs
index|[
literal|14
index|]
argument_list|)
block|,
comment|/* fp */
literal|0
block|,
comment|/* sp */
name|X
argument_list|(
name|status
argument_list|)
block|,
comment|/* ps */
name|X
argument_list|(
name|pc
argument_list|)
block|,
name|X
argument_list|(
name|fregs
index|[
literal|0
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp0 */
name|X
argument_list|(
name|fregs
index|[
literal|1
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp1 */
name|X
argument_list|(
name|fregs
index|[
literal|2
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp2 */
name|X
argument_list|(
name|fregs
index|[
literal|3
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp3 */
name|X
argument_list|(
name|fregs
index|[
literal|4
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp4 */
name|X
argument_list|(
name|fregs
index|[
literal|5
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp5 */
name|X
argument_list|(
name|fregs
index|[
literal|6
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp6 */
name|X
argument_list|(
name|fregs
index|[
literal|7
operator|*
literal|3
index|]
argument_list|)
block|,
comment|/* fp7 */
name|X
argument_list|(
name|fcregs
index|[
literal|0
index|]
argument_list|)
block|,
comment|/* fpcontrol */
name|X
argument_list|(
name|fcregs
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* fpstatus */
name|X
argument_list|(
name|fcregs
index|[
literal|2
index|]
argument_list|)
block|,
comment|/* fpiaddr */
name|X
argument_list|(
name|ssw
argument_list|)
block|,
comment|/* fpcode */
name|X
argument_list|(
name|fault
argument_list|)
block|,
comment|/* fpflags */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SPARC
end_ifdef

begin_comment
comment|/* Mappings from tm-sparc.h */
end_comment

begin_define
define|#
directive|define
name|FX
parameter_list|(
name|ENTRY
parameter_list|)
value|(offsetof(struct fcontext, ENTRY))
end_define

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
operator|-
literal|1
block|,
comment|/* g0 */
name|X
argument_list|(
name|g1
argument_list|)
block|,
name|X
argument_list|(
name|g2
argument_list|)
block|,
name|X
argument_list|(
name|g3
argument_list|)
block|,
name|X
argument_list|(
name|g4
argument_list|)
block|,
operator|-
literal|1
block|,
comment|/* g5->g7 aren't saved by Lynx */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|X
argument_list|(
name|o
index|[
literal|0
index|]
argument_list|)
block|,
name|X
argument_list|(
name|o
index|[
literal|1
index|]
argument_list|)
block|,
name|X
argument_list|(
name|o
index|[
literal|2
index|]
argument_list|)
block|,
name|X
argument_list|(
name|o
index|[
literal|3
index|]
argument_list|)
block|,
name|X
argument_list|(
name|o
index|[
literal|4
index|]
argument_list|)
block|,
name|X
argument_list|(
name|o
index|[
literal|5
index|]
argument_list|)
block|,
name|X
argument_list|(
name|o
index|[
literal|6
index|]
argument_list|)
block|,
comment|/* sp */
name|X
argument_list|(
name|o
index|[
literal|7
index|]
argument_list|)
block|,
comment|/* ra */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* l0 -> l7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* i0 -> i7 */
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|0
index|]
argument_list|)
block|,
comment|/* f0 */
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|1
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|2
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|3
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|4
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|5
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|6
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|7
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|8
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|9
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|10
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|11
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|12
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|13
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|14
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|15
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|16
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|17
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|18
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|19
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|20
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|21
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|22
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|23
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|24
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|25
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|26
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|27
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|28
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|29
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|30
index|]
argument_list|)
block|,
name|FX
argument_list|(
name|f
operator|.
name|fregs
index|[
literal|31
index|]
argument_list|)
block|,
name|X
argument_list|(
name|y
argument_list|)
block|,
name|X
argument_list|(
name|psr
argument_list|)
block|,
name|X
argument_list|(
name|wim
argument_list|)
block|,
name|X
argument_list|(
name|tbr
argument_list|)
block|,
name|X
argument_list|(
name|pc
argument_list|)
block|,
name|X
argument_list|(
name|npc
argument_list|)
block|,
name|FX
argument_list|(
name|fsr
argument_list|)
block|,
comment|/* fpsr */
operator|-
literal|1
block|,
comment|/* cpsr */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SPARC
end_ifdef

begin_comment
comment|/* This routine handles some oddball cases for Sparc registers and LynxOS.    In partucular, it causes refs to G0, g5->7, and all fp regs to return zero.    It also handles knows where to find the I& L regs on the stack.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int whatregs = 0;
define|#
directive|define
name|WHATREGS_FLOAT
value|1
define|#
directive|define
name|WHATREGS_GEN
value|2
define|#
directive|define
name|WHATREGS_STACK
value|4
block|if (regno == -1)     whatregs = WHATREGS_FLOAT | WHATREGS_GEN | WHATREGS_STACK;   else if (regno>= L0_REGNUM&& regno<= I7_REGNUM)     whatregs = WHATREGS_STACK;   else if (regno>= FP0_REGNUM&& regno< FP0_REGNUM + 32)     whatregs = WHATREGS_FLOAT;   else     whatregs = WHATREGS_GEN;    if (whatregs& WHATREGS_GEN)     {       struct econtext ec;
comment|/* general regs */
block|char buf[MAX_REGISTER_RAW_SIZE];       int retval;       int i;        errno = 0;       retval = ptrace (PTRACE_GETREGS, 		       BUILDPID (inferior_pid, general_thread), 		       (PTRACE_ARG3_TYPE)& ec, 		       0);       if (errno) 	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");        memset (buf, 0, REGISTER_RAW_SIZE (G0_REGNUM));       supply_register (G0_REGNUM, buf);       supply_register (TBR_REGNUM, (char *)&ec.tbr);        memcpy (&registers[REGISTER_BYTE (G1_REGNUM)],&ec.g1, 	      4 * REGISTER_RAW_SIZE (G1_REGNUM));       for (i = G1_REGNUM; i<= G1_REGNUM + 3; i++) 	register_valid[i] = 1;        supply_register (PS_REGNUM, (char *)&ec.psr);       supply_register (Y_REGNUM, (char *)&ec.y);       supply_register (PC_REGNUM, (char *)&ec.pc);       supply_register (NPC_REGNUM, (char *)&ec.npc);       supply_register (WIM_REGNUM, (char *)&ec.wim);        memcpy (&registers[REGISTER_BYTE (O0_REGNUM)], ec.o, 	      8 * REGISTER_RAW_SIZE (O0_REGNUM));       for (i = O0_REGNUM; i<= O0_REGNUM + 7; i++) 	register_valid[i] = 1;     }    if (whatregs& WHATREGS_STACK)     {       CORE_ADDR sp;       int i;        sp = read_register (SP_REGNUM);        target_xfer_memory (sp + FRAME_SAVED_I0,&registers[REGISTER_BYTE (I0_REGNUM)], 			  8 * REGISTER_RAW_SIZE (I0_REGNUM), 0);       for (i = I0_REGNUM; i<= I7_REGNUM; i++) 	register_valid[i] = 1;        target_xfer_memory (sp + FRAME_SAVED_L0,&registers[REGISTER_BYTE (L0_REGNUM)], 			  8 * REGISTER_RAW_SIZE (L0_REGNUM), 0);       for (i = L0_REGNUM; i<= L0_REGNUM + 7; i++) 	register_valid[i] = 1;     }    if (whatregs& WHATREGS_FLOAT)     {       struct fcontext fc;
comment|/* fp regs */
block|int retval;       int i;        errno = 0;       retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE)& fc, 		       0);       if (errno) 	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");        memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs, 	      32 * REGISTER_RAW_SIZE (FP0_REGNUM));       for (i = FP0_REGNUM; i<= FP0_REGNUM + 31; i++) 	register_valid[i] = 1;        supply_register (FPS_REGNUM, (char *)&fc.fsr);     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This routine handles storing of the I& L regs for the Sparc.  The trick    here is that they actually live on the stack.  The really tricky part is    that when changing the stack pointer, the I& L regs must be written to    where the new SP points, otherwise the regs will be incorrect when the    process is started up again.   We assume that the I& L regs are valid at    this point.  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int whatregs = 0;    if (regno == -1)     whatregs = WHATREGS_FLOAT | WHATREGS_GEN | WHATREGS_STACK;   else if (regno>= L0_REGNUM&& regno<= I7_REGNUM)     whatregs = WHATREGS_STACK;   else if (regno>= FP0_REGNUM&& regno< FP0_REGNUM + 32)     whatregs = WHATREGS_FLOAT;   else if (regno == SP_REGNUM)     whatregs = WHATREGS_STACK | WHATREGS_GEN;   else     whatregs = WHATREGS_GEN;    if (whatregs& WHATREGS_GEN)     {       struct econtext ec;
comment|/* general regs */
block|int retval;        ec.tbr = read_register (TBR_REGNUM);       memcpy (&ec.g1,&registers[REGISTER_BYTE (G1_REGNUM)], 	      4 * REGISTER_RAW_SIZE (G1_REGNUM));        ec.psr = read_register (PS_REGNUM);       ec.y = read_register (Y_REGNUM);       ec.pc = read_register (PC_REGNUM);       ec.npc = read_register (NPC_REGNUM);       ec.wim = read_register (WIM_REGNUM);        memcpy (ec.o,&registers[REGISTER_BYTE (O0_REGNUM)], 	      8 * REGISTER_RAW_SIZE (O0_REGNUM));        errno = 0;       retval = ptrace (PTRACE_SETREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE)& ec, 		       0);       if (errno) 	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");     }    if (whatregs& WHATREGS_STACK)     {       int regoffset;       CORE_ADDR sp;        sp = read_register (SP_REGNUM);        if (regno == -1 || regno == SP_REGNUM) 	{ 	  if (!register_valid[L0_REGNUM + 5]) 	    abort (); 	  target_xfer_memory (sp + FRAME_SAVED_I0,&registers[REGISTER_BYTE (I0_REGNUM)], 			      8 * REGISTER_RAW_SIZE (I0_REGNUM), 1);  	  target_xfer_memory (sp + FRAME_SAVED_L0,&registers[REGISTER_BYTE (L0_REGNUM)], 			      8 * REGISTER_RAW_SIZE (L0_REGNUM), 1); 	}       else if (regno>= L0_REGNUM&& regno<= I7_REGNUM) 	{ 	  if (!register_valid[regno]) 	    abort (); 	  if (regno>= L0_REGNUM&& regno<= L0_REGNUM + 7) 	    regoffset = REGISTER_BYTE (regno) - REGISTER_BYTE (L0_REGNUM) 	      + FRAME_SAVED_L0; 	  else 	    regoffset = REGISTER_BYTE (regno) - REGISTER_BYTE (I0_REGNUM) 	      + FRAME_SAVED_I0; 	  target_xfer_memory (sp + regoffset,&registers[REGISTER_BYTE (regno)], 			      REGISTER_RAW_SIZE (regno), 1); 	}     }    if (whatregs& WHATREGS_FLOAT)     {       struct fcontext fc;
comment|/* fp regs */
block|int retval;
comment|/* We read fcontext first so that we can get good values for fq_t... */
block|errno = 0;       retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE)& fc, 		       0);       if (errno) 	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");        memcpy (fc.f.fregs,&registers[REGISTER_BYTE (FP0_REGNUM)], 	      32 * REGISTER_RAW_SIZE (FP0_REGNUM));        fc.fsr = read_register (FPS_REGNUM);        errno = 0;       retval = ptrace (PTRACE_SETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE)& fc, 		       0);       if (errno) 	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");     }
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SPARC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SPARC
end_ifndef

begin_comment
comment|/* Return the offset relative to the start of the per-thread data to the    saved context block.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|lynx_registers_addr
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|stblock
decl_stmt|;
name|int
name|ecpoff
init|=
name|offsetof
argument_list|(
name|st_t
argument_list|,
name|ecp
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|ecp
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|stblock
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ptrace
argument_list|(
name|PTRACE_THREADUSER
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"PTRACE_THREADUSER"
argument_list|)
expr_stmt|;
name|ecp
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ptrace
argument_list|(
name|PTRACE_PEEKTHREAD
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|ecpoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"lynx_registers_addr(PTRACE_PEEKTHREAD)"
argument_list|)
expr_stmt|;
return|return
name|ecp
operator|-
name|stblock
return|;
block|}
end_function

begin_comment
comment|/* Fetch one or more registers from the inferior.  REGNO == -1 to get    them all.  We actually fetch more than requested, when convenient,    marking them as valid so we won't fetch them again.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|ignored
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|reg
decl_stmt|;
name|unsigned
name|long
name|ecp
decl_stmt|;
name|ecp
operator|=
name|lynx_registers_addr
argument_list|()
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|ptrace_fun
init|=
name|PTRACE_PEEKTHREAD
decl_stmt|;
ifdef|#
directive|ifdef
name|PTRACE_PEEKUSP
name|ptrace_fun
operator|=
name|regno
operator|==
name|SP_REGNUM
condition|?
name|PTRACE_PEEKUSP
else|:
name|PTRACE_PEEKTHREAD
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|ptrace
argument_list|(
name|ptrace_fun
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|ecp
operator|+
name|regmap
index|[
name|regno
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"fetch_inferior_registers(PTRACE_PEEKTHREAD)"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
operator|=
name|reg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|ignored
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|reg
decl_stmt|;
name|unsigned
name|long
name|ecp
decl_stmt|;
name|ecp
operator|=
name|lynx_registers_addr
argument_list|()
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|ptrace_fun
init|=
name|PTRACE_POKEUSER
decl_stmt|;
ifdef|#
directive|ifdef
name|PTRACE_POKEUSP
name|ptrace_fun
operator|=
name|regno
operator|==
name|SP_REGNUM
condition|?
name|PTRACE_POKEUSP
else|:
name|PTRACE_POKEUSER
expr_stmt|;
endif|#
directive|endif
name|reg
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|ptrace_fun
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|ecp
operator|+
name|regmap
index|[
name|regno
index|]
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"PTRACE_POKEUSER"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! SPARC */
end_comment

begin_comment
comment|/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_PTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
name|void
name|read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKETEXT
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ ptrace (PTRACE_POKETEXT): errno=%d, pid=0x%x, addr=0x%x, buffer[i] = 0x%x\n"
argument_list|,
name|errno
argument_list|,
name|BUILDPID
argument_list|(
name|inferior_pid
argument_list|,
name|general_thread
argument_list|)
argument_list|,
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sleeping for 1 second\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize_low
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

