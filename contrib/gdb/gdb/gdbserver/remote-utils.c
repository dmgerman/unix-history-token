begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote utility routines for the remote server for GDB.    Copyright 1986, 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_decl_stmt
name|int
name|remote_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdlog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME headerize? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|using_threads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug_threads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
name|void
name|remote_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|save_fcntl_flags
decl_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|remote_desc
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Could not open remote device"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
block|{
name|struct
name|termios
name|termios
decl_stmt|;
name|tcgetattr
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
name|termios
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|termios
operator|.
name|c_cflag
operator||=
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|tcsetattr
argument_list|(
name|remote_desc
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
block|{
name|struct
name|termio
name|termio
decl_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
name|termio
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator||=
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|termio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
block|{
name|struct
name|sgttyb
name|sg
decl_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
name|sg
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote debugging using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|port_str
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|sockaddr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|tmp_desc
decl_stmt|;
name|port_str
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|port
operator|=
name|atoi
argument_list|(
name|port_str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp_desc
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Can't open socket"
argument_list|)
expr_stmt|;
comment|/* Allow rapid reuse of this port. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|tmp_desc
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr
operator|.
name|sin_family
operator|=
name|PF_INET
expr_stmt|;
name|sockaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sockaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|tmp_desc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
argument_list|)
operator|||
name|listen
argument_list|(
name|tmp_desc
argument_list|,
literal|1
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"Can't bind address"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Listening on port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|tmp
operator|=
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|accept
argument_list|(
name|tmp_desc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_desc
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Accept failed"
argument_list|)
expr_stmt|;
comment|/* Enable TCP keep alive process. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|tmp_desc
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell TCP not to delay small packets.  This greatly speeds up          interactive response. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|remote_desc
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmp_desc
argument_list|)
expr_stmt|;
comment|/* No longer need this */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* If we don't do this, then gdbserver simply 					   exits when the remote side dies.  */
comment|/* Convert IP address to string.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote debugging from host %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|F_SETFL
argument_list|)
operator|&&
name|defined
argument_list|(
name|FASYNC
argument_list|)
name|save_fcntl_flags
operator|=
name|fcntl
argument_list|(
name|remote_desc
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|remote_desc
argument_list|,
name|F_SETFL
argument_list|,
name|save_fcntl_flags
operator||
name|FASYNC
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|F_SETOWN
argument_list|)
name|fcntl
argument_list|(
name|remote_desc
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|disable_async_io
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remote_close
parameter_list|(
name|void
parameter_list|)
block|{
name|close
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|int
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|unhexify
parameter_list|(
name|char
modifier|*
name|bin
parameter_list|,
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hex
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|hex
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Hex string is short, or of uneven length.              Return the count that has been converted so far. */
return|return
name|i
return|;
block|}
operator|*
name|bin
operator|++
operator|=
name|fromhex
argument_list|(
name|hex
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|hex
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hex
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_address
parameter_list|(
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|start
index|[
name|i
index|]
expr_stmt|;
name|addr
operator|=
name|addr
operator|<<
literal|4
expr_stmt|;
name|addr
operator|=
name|addr
operator||
operator|(
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|nib
parameter_list|)
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_function
name|int
name|hexify
parameter_list|(
name|char
modifier|*
name|hex
parameter_list|,
specifier|const
name|char
modifier|*
name|bin
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* May use a length, or a nul-terminated string as input. */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
name|strlen
argument_list|(
name|bin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|hex
operator|++
operator|=
name|tohex
argument_list|(
operator|(
operator|*
name|bin
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|hex
operator|++
operator|=
name|tohex
argument_list|(
operator|*
name|bin
operator|++
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|hex
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.    The data of the packet is in BUF.  Returns>= 0 on success, -1 otherwise. */
end_comment

begin_function
name|int
name|putpkt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf2
decl_stmt|;
name|char
name|buf3
index|[
literal|1
index|]
decl_stmt|;
name|int
name|cnt
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|buf2
operator|=
name|malloc
argument_list|(
name|PBUFSIZ
argument_list|)
expr_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
do|do
block|{
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
operator|!=
name|p
operator|-
name|buf2
condition|)
block|{
name|perror
argument_list|(
literal|"putpkt(write)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"putpkt (\"%s\"); [looking for ack]\n"
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|read
argument_list|(
name|remote_desc
argument_list|,
name|buf3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[received '%c' (0x%x)]\n"
argument_list|,
name|buf3
index|[
literal|0
index|]
argument_list|,
name|buf3
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"putpkt(read): Got EOF\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"putpkt(read)"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check for an input interrupt while we're here.  */
if|if
condition|(
name|buf3
index|[
literal|0
index|]
operator|==
literal|'\003'
condition|)
call|(
modifier|*
name|the_target
operator|->
name|send_signal
call|)
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buf3
index|[
literal|0
index|]
operator|!=
literal|'+'
condition|)
do|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Success! */
block|}
end_function

begin_comment
comment|/* Come here when we get an input interrupt from the remote side.  This    interrupt should only be active while we are waiting for the child to do    something.  About the only thing that should come through is a ^C, which    will cause us to send a SIGINT to the child.  */
end_comment

begin_function
specifier|static
name|void
name|input_interrupt
parameter_list|(
name|int
name|unused
parameter_list|)
block|{
name|fd_set
name|readset
decl_stmt|;
name|struct
name|timeval
name|immediate
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Protect against spurious interrupts.  This has been observed to      be a problem under NetBSD 1.4 and 1.5.  */
name|FD_ZERO
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|remote_desc
operator|+
literal|1
argument_list|,
operator|&
name|readset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|immediate
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|char
name|c
decl_stmt|;
name|cc
operator|=
name|read
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|1
operator|||
name|c
operator|!=
literal|'\003'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"input_interrupt, cc = %d c = %d\n"
argument_list|,
name|cc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|the_target
operator|->
name|send_signal
call|)
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|block_async_io
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|sigio_set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigio_set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sigio_set
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sigio_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unblock_async_io
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|sigio_set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigio_set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sigio_set
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sigio_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enable_async_io
parameter_list|(
name|void
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|input_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_async_io
parameter_list|(
name|void
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns next char from remote GDB.  -1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|int
name|bufcnt
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|bufp
decl_stmt|;
if|if
condition|(
name|bufcnt
operator|--
operator|>
literal|0
condition|)
return|return
operator|*
name|bufp
operator|++
operator|&
literal|0x7f
return|;
name|bufcnt
operator|=
name|read
argument_list|(
name|remote_desc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|bufcnt
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readchar: Got EOF\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"readchar"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
name|bufcnt
operator|--
expr_stmt|;
return|return
operator|*
name|bufp
operator|++
operator|&
literal|0x7f
return|;
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking,    and store it in BUF.  Returns length of packet, or negative if error. */
end_comment

begin_function
name|int
name|getpkt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|char
name|csum
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|csum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
break|break;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[getpkt: discarding char '%c']\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
name|c2
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|c2
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s\n"
argument_list|,
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|c2
argument_list|,
name|csum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getpkt (\"%s\");  [sending ack] \n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[sent ack]\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function

begin_function
name|void
name|write_ok
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'O'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'K'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_enn
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
comment|/* Some day, we should define the meanings of the error codes... */
name|buf
index|[
literal|0
index|]
operator|=
literal|'E'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'1'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_int_to_ascii
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|nib
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|ch
operator|=
operator|*
name|from
operator|++
expr_stmt|;
name|nib
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
name|nib
operator|=
name|ch
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
block|}
operator|*
name|to
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_ascii_to_int
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|nib1
decl_stmt|,
name|nib2
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|nib1
operator|=
name|fromhex
argument_list|(
operator|*
name|from
operator|++
argument_list|)
expr_stmt|;
name|nib2
operator|=
name|fromhex
argument_list|(
operator|*
name|from
operator|++
argument_list|)
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|(
operator|(
operator|(
name|nib1
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|nib2
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|outreg
parameter_list|(
name|int
name|regno
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|regno
operator|>>
literal|12
operator|)
operator|!=
literal|0
condition|)
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|regno
operator|>>
literal|12
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>>
literal|8
operator|)
operator|!=
literal|0
condition|)
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|regno
operator|>>
literal|8
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|regno
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|regno
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|':'
expr_stmt|;
name|collect_register_as_string
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|2
operator|*
name|register_size
argument_list|(
name|regno
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|';'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|new_thread_notify
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|char
name|own_buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* The `n' response is not yet part of the remote protocol.  Do nothing.  */
if|if
condition|(
literal|1
condition|)
return|return;
if|if
condition|(
name|server_waiting
operator|==
literal|0
condition|)
return|return;
name|sprintf
argument_list|(
name|own_buf
argument_list|,
literal|"n%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
name|putpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|enable_async_io
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dead_thread_notify
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|char
name|own_buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* The `x' response is not yet part of the remote protocol.  Do nothing.  */
if|if
condition|(
literal|1
condition|)
return|return;
name|sprintf
argument_list|(
name|own_buf
argument_list|,
literal|"x%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
name|putpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
name|enable_async_io
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prepare_resume_reply
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
name|status
parameter_list|,
name|unsigned
name|char
name|signo
parameter_list|)
block|{
name|int
name|nib
decl_stmt|,
name|sig
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|status
expr_stmt|;
name|sig
operator|=
operator|(
name|int
operator|)
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|nib
operator|=
operator|(
operator|(
name|sig
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
name|nib
operator|=
name|sig
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'T'
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|regp
init|=
name|gdbserver_expedite_regs
decl_stmt|;
while|while
condition|(
operator|*
name|regp
condition|)
block|{
name|buf
operator|=
name|outreg
argument_list|(
name|find_regno
argument_list|(
operator|*
name|regp
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regp
operator|++
expr_stmt|;
block|}
comment|/* Formerly, if the debugger had not used any thread features we would not 	 burden it with a thread status response.  This was for the benefit of 	 GDB 4.13 and older.  However, in recent GDB versions the check 	 (``if (cont_thread != 0)'') does not have the desired effect because of 	 sillyness in the way that the remote protocol handles specifying a thread. 	 Since thread support relies on qSymbol support anyway, assume GDB can handle 	 threads.  */
if|if
condition|(
name|using_threads
condition|)
block|{
comment|/* FIXME right place to set this? */
name|thread_from_wait
operator|=
operator|(
operator|(
expr|struct
name|inferior_list_entry
operator|*
operator|)
name|current_inferior
operator|)
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing resume reply for %d\n\n"
argument_list|,
name|thread_from_wait
argument_list|)
expr_stmt|;
comment|/* This if (1) ought to be unnecessary.  But remote_wait in GDB 	     will claim this event belongs to inferior_ptid if we do not 	     specify a thread, and there's no way for gdbserver to know 	     what inferior_ptid is.  */
if|if
condition|(
literal|1
operator|||
name|old_thread_from_wait
operator|!=
name|thread_from_wait
condition|)
block|{
name|general_thread
operator|=
name|thread_from_wait
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"thread:%x;"
argument_list|,
name|thread_from_wait
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|old_thread_from_wait
operator|=
name|thread_from_wait
expr_stmt|;
block|}
block|}
block|}
comment|/* For W and X, we're done.  */
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decode_m_packet
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|CORE_ADDR
modifier|*
name|mem_addr_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|len_ptr
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|len_ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|','
condition|)
block|{
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|mem_addr_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|mem_addr_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|==
literal|0
condition|)
break|break;
operator|*
name|len_ptr
operator|=
operator|*
name|len_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|len_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|decode_M_packet
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|CORE_ADDR
modifier|*
name|mem_addr_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|len_ptr
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|len_ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|','
condition|)
block|{
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|mem_addr_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|mem_addr_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|':'
condition|)
block|{
operator|*
name|len_ptr
operator|=
operator|*
name|len_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|len_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
name|convert_ascii_to_int
argument_list|(
operator|&
name|from
index|[
name|i
operator|++
index|]
argument_list|,
name|to
argument_list|,
operator|*
name|len_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|look_up_one_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|)
block|{
name|char
name|own_buf
index|[
literal|266
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Send the request.  */
name|strcpy
argument_list|(
name|own_buf
argument_list|,
literal|"qSymbol:"
argument_list|)
expr_stmt|;
name|hexify
argument_list|(
name|own_buf
operator|+
name|strlen
argument_list|(
literal|"qSymbol:"
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|putpkt
argument_list|(
name|own_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* FIXME:  Eventually add buffer overflow checking (to getpkt?)  */
name|len
operator|=
name|getpkt
argument_list|(
name|own_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|own_buf
argument_list|,
literal|"qSymbol:"
argument_list|,
name|strlen
argument_list|(
literal|"qSymbol:"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Malformed response.  */
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Malformed response to qSymbol, ignoring.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|=
name|own_buf
operator|+
name|strlen
argument_list|(
literal|"qSymbol:"
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|)
name|q
operator|++
expr_stmt|;
comment|/* Make sure we found a value for the symbol.  */
if|if
condition|(
name|p
operator|==
name|q
operator|||
operator|*
name|q
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|decode_address
argument_list|(
name|addrp
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

