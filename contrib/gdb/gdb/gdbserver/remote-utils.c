begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote utility routines for the remote server for GDB.    Copyright (C) 1986, 1989, 1993 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_decl_stmt
name|int
name|remote_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|save_fcntl_flags
decl_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|remote_desc
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Could not open remote device"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
block|{
name|struct
name|termios
name|termios
decl_stmt|;
name|tcgetattr
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
name|termios
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|termios
operator|.
name|c_cflag
operator||=
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|tcsetattr
argument_list|(
name|remote_desc
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
block|{
name|struct
name|termio
name|termio
decl_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
name|termio
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator||=
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|termio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
block|{
name|struct
name|sgttyb
name|sg
decl_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
name|sg
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
name|ioctl
argument_list|(
name|remote_desc
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|char
modifier|*
name|port_str
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|sockaddr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protoent
decl_stmt|;
name|int
name|tmp_desc
decl_stmt|;
name|port_str
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|port
operator|=
name|atoi
argument_list|(
name|port_str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp_desc
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Can't open socket"
argument_list|)
expr_stmt|;
comment|/* Allow rapid reuse of this port. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|tmp_desc
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr
operator|.
name|sin_family
operator|=
name|PF_INET
expr_stmt|;
name|sockaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sockaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|tmp_desc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
argument_list|)
operator|||
name|listen
argument_list|(
name|tmp_desc
argument_list|,
literal|1
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"Can't bind address"
argument_list|)
expr_stmt|;
name|tmp
operator|=
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|accept
argument_list|(
name|tmp_desc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_desc
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Accept failed"
argument_list|)
expr_stmt|;
name|protoent
operator|=
name|getprotobyname
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protoent
condition|)
name|perror_with_name
argument_list|(
literal|"getprotobyname"
argument_list|)
expr_stmt|;
comment|/* Enable TCP keep alive process. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|tmp_desc
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell TCP not to delay small packets.  This greatly speeds up 	 interactive response. */
name|tmp
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|remote_desc
argument_list|,
name|protoent
operator|->
name|p_proto
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmp_desc
argument_list|)
expr_stmt|;
comment|/* No longer need this */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* If we don't do this, then gdbserver simply 				    exits when the remote side dies.  */
block|}
if|#
directive|if
name|defined
argument_list|(
name|F_SETFL
argument_list|)
operator|&&
name|defined
argument_list|(
name|FASYNC
argument_list|)
name|save_fcntl_flags
operator|=
name|fcntl
argument_list|(
name|remote_desc
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|remote_desc
argument_list|,
name|F_SETFL
argument_list|,
name|save_fcntl_flags
operator||
name|FASYNC
argument_list|)
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FASYNC */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote debugging using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remote_close
parameter_list|()
block|{
name|close
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.    The data of the packet is in BUF.  Returns>= 0 on success, -1 otherwise. */
end_comment

begin_function
name|int
name|putpkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
name|buf2
index|[
literal|2000
index|]
decl_stmt|;
name|char
name|buf3
index|[
literal|1
index|]
decl_stmt|;
name|int
name|cnt
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
do|do
block|{
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
operator|!=
name|p
operator|-
name|buf2
condition|)
block|{
name|perror
argument_list|(
literal|"putpkt(write)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"putpkt (\"%s\"); [looking for ack]\n"
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|cc
operator|=
name|read
argument_list|(
name|remote_desc
argument_list|,
name|buf3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"[received '%c' (0x%x)]\n"
argument_list|,
name|buf3
index|[
literal|0
index|]
argument_list|,
name|buf3
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"putpkt(read): Got EOF\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"putpkt(read)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|buf3
index|[
literal|0
index|]
operator|!=
literal|'+'
condition|)
do|;
return|return
literal|1
return|;
comment|/* Success! */
block|}
end_function

begin_comment
comment|/* Come here when we get an input interrupt from the remote side.  This    interrupt should only be active while we are waiting for the child to do    something.  About the only thing that should come through is a ^C, which    will cause us to send a SIGINT to the child.  */
end_comment

begin_function
specifier|static
name|void
name|input_interrupt
parameter_list|()
block|{
name|int
name|cc
decl_stmt|;
name|char
name|c
decl_stmt|;
name|cc
operator|=
name|read
argument_list|(
name|remote_desc
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|1
operator|||
name|c
operator|!=
literal|'\003'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"input_interrupt, cc = %d c = %d\n"
argument_list|,
name|cc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|kill
argument_list|(
name|inferior_pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enable_async_io
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|input_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_async_io
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns next char from remote GDB.  -1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|int
name|bufcnt
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|bufp
decl_stmt|;
if|if
condition|(
name|bufcnt
operator|--
operator|>
literal|0
condition|)
return|return
operator|*
name|bufp
operator|++
operator|&
literal|0x7f
return|;
name|bufcnt
operator|=
name|read
argument_list|(
name|remote_desc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|bufcnt
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readchar: Got EOF\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"readchar"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
name|bufcnt
operator|--
expr_stmt|;
return|return
operator|*
name|bufp
operator|++
operator|&
literal|0x7f
return|;
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking,    and store it in BUF.  Returns length of packet, or negative if error. */
end_comment

begin_function
name|int
name|getpkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|char
name|csum
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|csum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
break|break;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"[getpkt: discarding char '%c']\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
name|c2
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|c2
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s\n"
argument_list|,
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|c2
argument_list|,
name|csum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"getpkt (\"%s\");  [sending ack] \n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"[sent ack]\n"
argument_list|)
expr_stmt|;
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function

begin_function
name|void
name|write_ok
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'O'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'K'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_enn
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'E'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'N'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'N'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_int_to_ascii
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nib
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|ch
operator|=
operator|*
name|from
operator|++
expr_stmt|;
name|nib
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
name|nib
operator|=
name|ch
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
block|}
operator|*
name|to
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|void
name|convert_ascii_to_int
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nib1
decl_stmt|,
name|nib2
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|nib1
operator|=
name|fromhex
argument_list|(
operator|*
name|from
operator|++
argument_list|)
expr_stmt|;
name|nib2
operator|=
name|fromhex
argument_list|(
operator|*
name|from
operator|++
argument_list|)
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|(
operator|(
operator|(
name|nib1
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|nib2
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|outreg
parameter_list|(
name|regno
parameter_list|,
name|buf
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|int
name|regsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|regno
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|regno
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|':'
expr_stmt|;
name|convert_int_to_ascii
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|buf
argument_list|,
name|regsize
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|2
operator|*
name|regsize
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|';'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|prepare_resume_reply
parameter_list|(
name|buf
parameter_list|,
name|status
parameter_list|,
name|signo
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|status
decl_stmt|;
name|unsigned
name|char
name|signo
decl_stmt|;
block|{
name|int
name|nib
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|status
expr_stmt|;
comment|/* FIXME!  Should be converting this signal number (numbered      according to the signal numbering of the system we are running on)      to the signal numbers used by the gdb protocol (see enum target_signal      in gdb/target.h).  */
name|nib
operator|=
operator|(
operator|(
name|signo
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
name|nib
operator|=
name|signo
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|tohex
argument_list|(
name|nib
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|'T'
condition|)
block|{
name|buf
operator|=
name|outreg
argument_list|(
name|PC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|outreg
argument_list|(
name|FP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|outreg
argument_list|(
name|SP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NPC_REGNUM
name|buf
operator|=
name|outreg
argument_list|(
name|NPC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O7_REGNUM
name|buf
operator|=
name|outreg
argument_list|(
name|O7_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the debugger hasn't used any thread features, don't burden it with 	 threads.  If we didn't check this, GDB 4.13 and older would choke.  */
if|if
condition|(
name|cont_thread
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|old_thread_from_wait
operator|!=
name|thread_from_wait
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"thread:%x;"
argument_list|,
name|thread_from_wait
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|old_thread_from_wait
operator|=
name|thread_from_wait
expr_stmt|;
block|}
block|}
block|}
comment|/* For W and X, we're done.  */
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decode_m_packet
parameter_list|(
name|from
parameter_list|,
name|mem_addr_ptr
parameter_list|,
name|len_ptr
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|CORE_ADDR
modifier|*
name|mem_addr_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|len_ptr
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|len_ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|','
condition|)
block|{
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|mem_addr_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|mem_addr_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|==
literal|0
condition|)
break|break;
operator|*
name|len_ptr
operator|=
operator|*
name|len_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|len_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|decode_M_packet
parameter_list|(
name|from
parameter_list|,
name|mem_addr_ptr
parameter_list|,
name|len_ptr
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|CORE_ADDR
modifier|*
name|mem_addr_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
modifier|*
name|len_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|len_ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|','
condition|)
block|{
operator|*
name|mem_addr_ptr
operator|=
operator|*
name|mem_addr_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|mem_addr_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|from
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|':'
condition|)
block|{
operator|*
name|len_ptr
operator|=
operator|*
name|len_ptr
operator|<<
literal|4
expr_stmt|;
operator|*
name|len_ptr
operator||=
name|fromhex
argument_list|(
name|ch
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
name|convert_ascii_to_int
argument_list|(
operator|&
name|from
index|[
name|i
operator|++
index|]
argument_list|,
name|to
argument_list|,
operator|*
name|len_ptr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

