begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print NS 32000 instructions for GDB, the GNU debugger.    Copyright 1986, 1988, 1991, 1992, 1994, 1995, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_function_decl
specifier|static
name|int
name|sign_extend
parameter_list|(
name|int
name|value
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_ns32k_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|tm_print_insn
operator|=
name|print_insn_ns32k
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance PC across any function entry prologue instructions    to reach some "real" code.  */
end_comment

begin_function
name|CORE_ADDR
name|umax_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|op
init|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x82
condition|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|pc
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
name|pc
operator|+=
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|6
expr_stmt|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Return number of args passed to a frame.    Can return -1, meaning no way to tell.    Encore's C compiler often reuses same area on stack for args,    so this will often not work properly.  If the arg names    are known, it's likely most of them will be printed. */
end_comment

begin_function
name|int
name|umax_frame_num_args
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|numargs
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|enter_addr
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
name|unsigned
name|int
name|addr_mode
decl_stmt|;
name|int
name|width
decl_stmt|;
name|numargs
operator|=
operator|-
literal|1
expr_stmt|;
name|enter_addr
operator|=
name|ns32k_get_enter_addr
argument_list|(
operator|(
name|fi
operator|)
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enter_addr
operator|>
literal|0
condition|)
block|{
name|pc
operator|=
operator|(
operator|(
name|enter_addr
operator|==
literal|1
operator|)
condition|?
name|SAVED_PC_AFTER_CALL
argument_list|(
name|fi
argument_list|)
else|:
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
operator|)
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addr_mode
operator|=
operator|(
name|insn
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|insn
operator|=
name|insn
operator|&
literal|0x7ff
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x7fc
operator|)
operator|==
literal|0x57c
operator|&&
name|addr_mode
operator|==
literal|0x14
condition|)
comment|/* immediate */
block|{
if|if
condition|(
name|insn
operator|==
literal|0x57c
condition|)
comment|/* adjspb */
name|width
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x57d
condition|)
comment|/* adjspw */
name|width
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x57f
condition|)
comment|/* adjspd */
name|width
operator|=
literal|4
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad else"
argument_list|)
expr_stmt|;
name|numargs
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|1
condition|)
name|flip_bytes
argument_list|(
operator|&
name|numargs
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|numargs
operator|=
operator|-
name|sign_extend
argument_list|(
name|numargs
argument_list|,
name|width
operator|*
literal|8
argument_list|)
operator|/
literal|4
expr_stmt|;
block|}
block|}
return|return
name|numargs
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sign_extend
parameter_list|(
name|int
name|value
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|value
operator|=
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|?
name|value
operator||
operator|(
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|value
operator|)
return|;
block|}
end_function

begin_function
name|void
name|flip_bytes
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|char
name|tmp
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|ptr
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of locals in the current frame given a pc    pointing to the enter instruction.  This is used in the macro    FRAME_FIND_SAVED_REGS.  */
end_comment

begin_function
name|int
name|ns32k_localcount
parameter_list|(
name|CORE_ADDR
name|enter_pc
parameter_list|)
block|{
name|unsigned
name|char
name|localtype
decl_stmt|;
name|int
name|localcount
decl_stmt|;
name|localtype
operator|=
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|localtype
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|localcount
operator|=
name|localtype
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|localtype
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
name|localcount
operator|=
operator|(
operator|(
operator|(
name|localtype
operator|&
literal|0x3f
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
else|else
name|localcount
operator|=
operator|(
operator|(
operator|(
name|localtype
operator|&
literal|0x3f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|read_memory_integer
argument_list|(
name|enter_pc
operator|+
literal|5
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
return|return
name|localcount
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if instruction at PC is a return instruction.  */
end_comment

begin_function
specifier|static
name|int
name|ns32k_about_to_return
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
operator|(
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
operator|==
literal|0x12
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the address of the enter opcode for the function  * containing PC, if there is an enter for the function,  * and if the pc is between the enter and exit.  * Returns positive address if pc is between enter/exit,  * 1 if pc before enter or after exit, 0 otherwise.  */
end_comment

begin_function
name|CORE_ADDR
name|ns32k_get_enter_addr
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|enter_addr
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ns32k_about_to_return
argument_list|(
name|pc
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* after exit */
name|enter_addr
operator|=
name|get_pc_function_start
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|enter_addr
condition|)
return|return
literal|1
return|;
comment|/* before enter */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|enter_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|0x82
condition|)
return|return
literal|0
return|;
comment|/* function has no enter/exit */
return|return
name|enter_addr
return|;
comment|/* pc is between enter and exit */
block|}
end_function

end_unit

