begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Cache and manage frames for GDB, the GNU debugger.     Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for inferior_ptid */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"user-regs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"dummy-frame.h"
end_include

begin_include
include|#
directive|include
file|"sentinel-frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* We keep a cache of stack frames, each of which is a "struct    frame_info".  The innermost one gets allocated (in    wait_for_inferior) each time the inferior stops; current_frame    points to it.  Additional frames get allocated (in get_prev_frame)    as needed, and are chained through the next and prev fields.  Any    time that the frame cache becomes invalid (most notably when we    execute something, but also if we change how we interpret the    frames (e.g. "set heuristic-fence-post" in mips-tdep.c, or anything    which reads new symbols)), we should call reinit_frame_cache.  */
end_comment

begin_struct
struct|struct
name|frame_info
block|{
comment|/* Level of this frame.  The inner-most (youngest) frame is at level      0.  As you move towards the outer-most (oldest) frame, the level      increases.  This is a cached value.  It could just as easily be      computed by counting back from the selected frame to the inner      most frame.  */
comment|/* NOTE: cagney/2002-04-05: Perhaphs a level of ``-1'' should be      reserved to indicate a bogus frame - one that has been created      just to keep GDB happy (GDB always needs a frame).  For the      moment leave this as speculation.  */
name|int
name|level
decl_stmt|;
comment|/* The frame's type.  */
comment|/* FIXME: cagney/2003-04-02: Should instead be returning      ->unwind->type.  Unfortunately, legacy code is still explicitly      setting the type using the method deprecated_set_frame_type.      Eliminate that method and this field can be eliminated.  */
name|enum
name|frame_type
name|type
decl_stmt|;
comment|/* For each register, address of where it was saved on entry to the      frame, or zero if it was not saved on entry to this frame.  This      includes special registers such as pc and fp saved in special      ways in the stack frame.  The SP_REGNUM is even more special, the      address here is the sp for the previous frame, not the address      where the sp was saved.  */
comment|/* Allocated by frame_saved_regs_zalloc () which is called /      initialized by DEPRECATED_FRAME_INIT_SAVED_REGS(). */
name|CORE_ADDR
modifier|*
name|saved_regs
decl_stmt|;
comment|/*NUM_REGS + NUM_PSEUDO_REGS*/
comment|/* Anything extra for this structure that may have been defined in      the machine dependent files. */
comment|/* Allocated by frame_extra_info_zalloc () which is called /      initialized by DEPRECATED_INIT_EXTRA_FRAME_INFO */
name|struct
name|frame_extra_info
modifier|*
name|extra_info
decl_stmt|;
comment|/* The frame's low-level unwinder and corresponding cache.  The      low-level unwinder is responsible for unwinding register values      for the previous frame.  The low-level unwind methods are      selected based on the presence, or otherwize, of register unwind      information such as CFI.  */
name|void
modifier|*
name|prologue_cache
decl_stmt|;
specifier|const
name|struct
name|frame_unwind
modifier|*
name|unwind
decl_stmt|;
comment|/* Cached copy of the previous frame's resume address.  */
struct|struct
block|{
name|int
name|p
decl_stmt|;
name|CORE_ADDR
name|value
decl_stmt|;
block|}
name|prev_pc
struct|;
comment|/* Cached copy of the previous frame's function address.  */
struct|struct
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|p
decl_stmt|;
block|}
name|prev_func
struct|;
comment|/* This frame's ID.  */
struct|struct
block|{
name|int
name|p
decl_stmt|;
name|struct
name|frame_id
name|value
decl_stmt|;
block|}
name|this_id
struct|;
comment|/* The frame's high-level base methods, and corresponding cache.      The high level base methods are selected based on the frame's      debug info.  */
specifier|const
name|struct
name|frame_base
modifier|*
name|base
decl_stmt|;
name|void
modifier|*
name|base_cache
decl_stmt|;
comment|/* Pointers to the next (down, inner, younger) and previous (up,      outer, older) frame_info's in the frame cache.  */
name|struct
name|frame_info
modifier|*
name|next
decl_stmt|;
comment|/* down, inner, younger */
name|int
name|prev_p
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
comment|/* up, outer, older */
block|}
struct|;
end_struct

begin_comment
comment|/* Flag to control debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frame_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to indicate whether backtraces should stop at main et.al.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|backtrace_past_main
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|backtrace_limit
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|frame_tdep_pc_fixup
function_decl|)
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|fprint_frame_id
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_id
name|id
parameter_list|)
block|{
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"{stack=0x%s,code=0x%s,special=0x%s}"
argument_list|,
name|paddr_nz
argument_list|(
name|id
operator|.
name|stack_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|id
operator|.
name|code_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|id
operator|.
name|special_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fprint_frame_type
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|enum
name|frame_type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UNKNOWN_FRAME
case|:
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"UNKNOWN_FRAME"
argument_list|)
expr_stmt|;
return|return;
case|case
name|NORMAL_FRAME
case|:
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"NORMAL_FRAME"
argument_list|)
expr_stmt|;
return|return;
case|case
name|DUMMY_FRAME
case|:
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"DUMMY_FRAME"
argument_list|)
expr_stmt|;
return|return;
case|case
name|SIGTRAMP_FRAME
case|:
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"SIGTRAMP_FRAME"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fprint_frame
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<NULL frame>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"level=%d"
argument_list|,
name|fi
operator|->
name|level
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"type="
argument_list|)
expr_stmt|;
name|fprint_frame_type
argument_list|(
name|file
argument_list|,
name|fi
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"unwind="
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|unwind
operator|!=
name|NULL
condition|)
name|gdb_print_host_address
argument_list|(
name|fi
operator|->
name|unwind
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"pc="
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|fi
operator|->
name|next
operator|->
name|prev_pc
operator|.
name|p
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|fi
operator|->
name|next
operator|->
name|prev_pc
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"id="
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|this_id
operator|.
name|p
condition|)
name|fprint_frame_id
argument_list|(
name|file
argument_list|,
name|fi
operator|->
name|this_id
operator|.
name|value
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"func="
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|fi
operator|->
name|next
operator|->
name|prev_func
operator|.
name|p
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|fi
operator|->
name|next
operator|->
name|prev_func
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a frame uniq ID that can be used to, later, re-find the    frame.  */
end_comment

begin_function
name|struct
name|frame_id
name|get_frame_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
return|return
name|null_frame_id
return|;
block|}
if|if
condition|(
operator|!
name|fi
operator|->
name|this_id
operator|.
name|p
condition|)
block|{
name|gdb_assert
argument_list|(
operator|!
name|legacy_frame_p
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ get_frame_id (fi=%d) "
argument_list|,
name|fi
operator|->
name|level
argument_list|)
expr_stmt|;
comment|/* Find the unwinder.  */
if|if
condition|(
name|fi
operator|->
name|unwind
operator|==
name|NULL
condition|)
block|{
name|fi
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-04-02: Rather than storing the frame's 	     type in the frame, the unwinder's type should be returned 	     directly.  Unfortunately, legacy code, called by 	     legacy_get_prev_frame, explicitly set the frames type 	     using the method deprecated_set_frame_type().  */
name|fi
operator|->
name|type
operator|=
name|fi
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
block|}
comment|/* Find THIS frame's ID.  */
name|fi
operator|->
name|unwind
operator|->
name|this_id
argument_list|(
name|fi
operator|->
name|next
argument_list|,
operator|&
name|fi
operator|->
name|prologue_cache
argument_list|,
operator|&
name|fi
operator|->
name|this_id
operator|.
name|value
argument_list|)
expr_stmt|;
name|fi
operator|->
name|this_id
operator|.
name|p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|gdb_stdlog
argument_list|,
name|fi
operator|->
name|this_id
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fi
operator|->
name|this_id
operator|.
name|value
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|frame_id
name|null_frame_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All zeros.  */
end_comment

begin_function
name|struct
name|frame_id
name|frame_id_build_special
parameter_list|(
name|CORE_ADDR
name|stack_addr
parameter_list|,
name|CORE_ADDR
name|code_addr
parameter_list|,
name|CORE_ADDR
name|special_addr
parameter_list|)
block|{
name|struct
name|frame_id
name|id
decl_stmt|;
name|id
operator|.
name|stack_addr
operator|=
name|stack_addr
expr_stmt|;
name|id
operator|.
name|code_addr
operator|=
name|code_addr
expr_stmt|;
name|id
operator|.
name|special_addr
operator|=
name|special_addr
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
name|struct
name|frame_id
name|frame_id_build
parameter_list|(
name|CORE_ADDR
name|stack_addr
parameter_list|,
name|CORE_ADDR
name|code_addr
parameter_list|)
block|{
return|return
name|frame_id_build_special
argument_list|(
name|stack_addr
argument_list|,
name|code_addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|frame_id_p
parameter_list|(
name|struct
name|frame_id
name|l
parameter_list|)
block|{
name|int
name|p
decl_stmt|;
comment|/* The .code can be NULL but the .stack cannot.  */
name|p
operator|=
operator|(
name|l
operator|.
name|stack_addr
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ frame_id_p (l="
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|gdb_stdlog
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|") -> %d }\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|frame_id_eq
parameter_list|(
name|struct
name|frame_id
name|l
parameter_list|,
name|struct
name|frame_id
name|r
parameter_list|)
block|{
name|int
name|eq
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|stack_addr
operator|==
literal|0
operator|||
name|r
operator|.
name|stack_addr
operator|==
literal|0
condition|)
comment|/* Like a NaN, if either ID is invalid, the result is false.  */
name|eq
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|.
name|stack_addr
operator|!=
name|r
operator|.
name|stack_addr
condition|)
comment|/* If .stack addresses are different, the frames are different.  */
name|eq
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|.
name|code_addr
operator|==
literal|0
operator|||
name|r
operator|.
name|code_addr
operator|==
literal|0
condition|)
comment|/* A zero code addr is a wild card, always succeed.  */
name|eq
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|.
name|code_addr
operator|!=
name|r
operator|.
name|code_addr
condition|)
comment|/* If .code addresses are different, the frames are different.  */
name|eq
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|.
name|special_addr
operator|==
literal|0
operator|||
name|r
operator|.
name|special_addr
operator|==
literal|0
condition|)
comment|/* A zero special addr is a wild card (or unused), always succeed.  */
name|eq
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|.
name|special_addr
operator|==
name|r
operator|.
name|special_addr
condition|)
comment|/* Frames are equal.  */
name|eq
operator|=
literal|1
expr_stmt|;
else|else
comment|/* No luck.  */
name|eq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ frame_id_eq (l="
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|gdb_stdlog
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|",r="
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|gdb_stdlog
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|") -> %d }\n"
argument_list|,
name|eq
argument_list|)
expr_stmt|;
block|}
return|return
name|eq
return|;
block|}
end_function

begin_function
name|int
name|frame_id_inner
parameter_list|(
name|struct
name|frame_id
name|l
parameter_list|,
name|struct
name|frame_id
name|r
parameter_list|)
block|{
name|int
name|inner
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|stack_addr
operator|==
literal|0
operator|||
name|r
operator|.
name|stack_addr
operator|==
literal|0
condition|)
comment|/* Like NaN, any operation involving an invalid ID always fails.  */
name|inner
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Only return non-zero when strictly inner than.  Note that, per        comment in "frame.h", there is some fuzz here.  Frameless        functions are not strictly inner than (same .stack but        different .code and/or .special address).  */
name|inner
operator|=
name|INNER_THAN
argument_list|(
name|l
operator|.
name|stack_addr
argument_list|,
name|r
operator|.
name|stack_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ frame_id_inner (l="
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|gdb_stdlog
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|",r="
argument_list|)
expr_stmt|;
name|fprint_frame_id
argument_list|(
name|gdb_stdlog
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|") -> %d }\n"
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
return|return
name|inner
return|;
block|}
end_function

begin_function
name|struct
name|frame_info
modifier|*
name|frame_find_by_id
parameter_list|(
name|struct
name|frame_id
name|id
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
comment|/* ZERO denotes the null frame, let the caller decide what to do      about it.  Should it instead return get_current_frame()?  */
if|if
condition|(
operator|!
name|frame_id_p
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|frame
operator|=
name|get_current_frame
argument_list|()
init|;
name|frame
operator|!=
name|NULL
condition|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
control|)
block|{
name|struct
name|frame_id
name|this
init|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame_id_eq
argument_list|(
name|id
argument_list|,
name|this
argument_list|)
condition|)
comment|/* An exact match.  */
return|return
name|frame
return|;
if|if
condition|(
name|frame_id_inner
argument_list|(
name|id
argument_list|,
name|this
argument_list|)
condition|)
comment|/* Gone to far.  */
return|return
name|NULL
return|;
comment|/* Either, we're not yet gone far enough out along the frame          chain (inner(this,id), or we're comparing frameless functions          (same .base, different .func, no test available).  Struggle          on until we've definitly gone to far.  */
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_pc_unwind
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this_frame
operator|->
name|prev_pc
operator|.
name|p
condition|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|gdbarch_unwind_pc_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* The right way.  The `pure' way.  The one true way.  This 	     method depends solely on the register-unwind code to 	     determine the value of registers in THIS frame, and hence 	     the value of this frame's PC (resume address).  A typical 	     implementation is no more than: 	    	     frame_unwind_register (this_frame, ISA_PC_REGNUM, buf); 	     return extract_unsigned_integer (buf, size of ISA_PC_REGNUM);  	     Note: this method is very heavily dependent on a correct 	     register-unwind implementation, it pays to fix that 	     method first; this method is frame type agnostic, since 	     it only deals with register values, it works with any 	     frame.  This is all in stark contrast to the old 	     FRAME_SAVED_PC which would try to directly handle all the 	     different ways that a PC could be unwound.  */
name|pc
operator|=
name|gdbarch_unwind_pc
argument_list|(
name|current_gdbarch
argument_list|,
name|this_frame
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_frame
operator|->
name|level
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: cagney/2003-03-06: Old code and and a sentinel              frame.  Do like was always done.  Fetch the PC's value              direct from the global registers array (via read_pc).              This assumes that this frame belongs to the current              global register cache.  The assumption is dangerous.  */
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_FRAME_SAVED_PC_P
argument_list|()
condition|)
block|{
comment|/* FIXME: cagney/2003-03-06: Old code, but not a sentinel              frame.  Do like was always done.  Note that this method,              unlike unwind_pc(), tries to handle all the different              frame cases directly.  It fails.  */
name|pc
operator|=
name|DEPRECATED_FRAME_SAVED_PC
argument_list|(
name|this_frame
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"No gdbarch_unwind_pc method"
argument_list|)
expr_stmt|;
name|this_frame
operator|->
name|prev_pc
operator|.
name|value
operator|=
name|pc
expr_stmt|;
name|this_frame
operator|->
name|prev_pc
operator|.
name|p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ frame_pc_unwind (this_frame=%d) -> 0x%s }\n"
argument_list|,
name|this_frame
operator|->
name|level
argument_list|,
name|paddr_nz
argument_list|(
name|this_frame
operator|->
name|prev_pc
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this_frame
operator|->
name|prev_pc
operator|.
name|value
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_func_unwind
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fi
operator|->
name|prev_func
operator|.
name|p
condition|)
block|{
comment|/* Make certain that this, and not the adjacent, function is          found.  */
name|CORE_ADDR
name|addr_in_block
init|=
name|frame_unwind_address_in_block
argument_list|(
name|fi
argument_list|)
decl_stmt|;
name|fi
operator|->
name|prev_func
operator|.
name|p
operator|=
literal|1
expr_stmt|;
name|fi
operator|->
name|prev_func
operator|.
name|addr
operator|=
name|get_pc_function_start
argument_list|(
name|addr_in_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ frame_func_unwind (fi=%d) -> 0x%s }\n"
argument_list|,
name|fi
operator|->
name|level
argument_list|,
name|paddr_nz
argument_list|(
name|fi
operator|->
name|prev_func
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
operator|->
name|prev_func
operator|.
name|addr
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_func
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|frame_func_unwind
argument_list|(
name|fi
operator|->
name|next
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_frame_unwind_register
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|frame_unwind_register
argument_list|(
name|src
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|frame_pop
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|scratch_regcache
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
if|if
condition|(
name|DEPRECATED_POP_FRAME_P
argument_list|()
condition|)
block|{
comment|/* A legacy architecture that has implemented a custom pop 	 function.  All new architectures should instead be using the 	 generic code below.  */
name|DEPRECATED_POP_FRAME
expr_stmt|;
block|}
else|else
block|{
comment|/* Make a copy of all the register values unwound from this 	 frame.  Save them in a scratch buffer so that there isn't a 	 race betweening trying to extract the old values from the 	 current_regcache while, at the same time writing new values 	 into that same cache.  */
name|struct
name|regcache
modifier|*
name|scratch
init|=
name|regcache_xmalloc
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup_regcache_xfree
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
name|regcache_save
argument_list|(
name|scratch
argument_list|,
name|do_frame_unwind_register
argument_list|,
name|this_frame
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-03-16: It should be possible to tell the          target's register cache that it is about to be hit with a          burst register transfer and that the sequence of register          writes should be batched.  The pair target_prepare_to_store()          and target_store_registers() kind of suggest this          functionality.  Unfortunately, they don't implement it.  Their          lack of a formal definition can lead to targets writing back          bogus values (arguably a bug in the target code mind).  */
comment|/* Now copy those saved registers into the current regcache.          Here, regcache_cpy() calls regcache_restore().  */
name|regcache_cpy
argument_list|(
name|current_regcache
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
comment|/* We've made right mess of GDB's local state, just discard      everything.  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|frame_register_unwind
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|frame_unwind_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\ { frame_register_unwind (frame=%d,regnum=%d(%s),...) "
argument_list|,
name|frame
operator|->
name|level
argument_list|,
name|regnum
argument_list|,
name|frame_map_regnum_to_name
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates      that the value proper does not need to be fetched.  */
name|gdb_assert
argument_list|(
name|optimizedp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|lvalp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|addrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|realnump
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* gdb_assert (bufferp != NULL); */
comment|/* NOTE: cagney/2002-11-27: A program trying to unwind a NULL frame      is broken.  There is always a frame.  If there, for some reason,      isn't, there is some pretty busted code as it should have      detected the problem before calling here.  */
name|gdb_assert
argument_list|(
name|frame
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the unwinder.  */
if|if
condition|(
name|frame
operator|->
name|unwind
operator|==
name|NULL
condition|)
block|{
name|frame
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|frame
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-04-02: Rather than storing the frame's 	 type in the frame, the unwinder's type should be returned 	 directly.  Unfortunately, legacy code, called by 	 legacy_get_prev_frame, explicitly set the frames type using 	 the method deprecated_set_frame_type().  */
name|frame
operator|->
name|type
operator|=
name|frame
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
block|}
comment|/* Ask this frame to unwind its register.  See comment in      "frame-unwind.h" for why NEXT frame and this unwind cace are      passed in.  */
name|frame
operator|->
name|unwind
operator|->
name|prev_register
argument_list|(
name|frame
operator|->
name|next
argument_list|,
operator|&
name|frame
operator|->
name|prologue_cache
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" *optimizedp=%d"
argument_list|,
operator|(
operator|*
name|optimizedp
operator|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" *lvalp=%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|lvalp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" *addrp=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
operator|(
operator|*
name|addrp
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" *bufferp="
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufferp
operator|==
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"<NULL>"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|buf
init|=
name|bufferp
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|frame_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
comment|/* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates      that the value proper does not need to be fetched.  */
name|gdb_assert
argument_list|(
name|optimizedp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|lvalp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|addrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|realnump
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* gdb_assert (bufferp != NULL); */
comment|/* Ulgh!  Old code that, for lval_register, sets ADDRP to the offset      of the register in the register cache.  It should instead return      the REGNUM corresponding to that register.  Translate the .  */
if|if
condition|(
name|DEPRECATED_GET_SAVED_REGISTER_P
argument_list|()
condition|)
block|{
name|DEPRECATED_GET_SAVED_REGISTER
argument_list|(
name|bufferp
argument_list|,
name|optimizedp
argument_list|,
name|addrp
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
name|lvalp
argument_list|)
expr_stmt|;
comment|/* Compute the REALNUM if the caller wants it.  */
if|if
condition|(
operator|*
name|lvalp
operator|==
name|lval_register
condition|)
block|{
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|addrp
operator|==
name|register_offset_hack
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
condition|)
block|{
operator|*
name|realnump
operator|=
name|regnum
expr_stmt|;
return|return;
block|}
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Failed to compute the register number corresponding"
literal|" to 0x%s"
argument_list|,
name|paddr_d
argument_list|(
operator|*
name|addrp
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Obtain the register value by unwinding the register from the next      (more inner frame).  */
name|gdb_assert
argument_list|(
name|frame
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|frame_register_unwind
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|frame_unwind_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|optimized
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|realnum
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|frame_register_unwind
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|optimized
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_frame_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|frame_unwind_register
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LONGEST
name|frame_unwind_register_signed
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|LONGEST
name|get_frame_register_signed
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
return|return
name|frame_unwind_register_signed
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|regnum
argument_list|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|frame_unwind_register_unsigned
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|get_frame_register_unsigned
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
return|return
name|frame_unwind_register_unsigned
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|regnum
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|frame_unwind_unsigned_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|ULONGEST
modifier|*
name|val
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_frame_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|int
name|realnum
decl_stmt|;
name|int
name|optim
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|optim
condition|)
name|error
argument_list|(
literal|"Attempt to assign to a value that was optimized out."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lval
condition|)
block|{
case|case
name|lval_memory
case|:
block|{
comment|/* FIXME: write_memory doesn't yet take constant buffers.            Arrrg!  */
name|char
name|tmp
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|addr
argument_list|,
name|tmp
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|lval_register
case|:
name|regcache_cooked_write
argument_list|(
name|current_regcache
argument_list|,
name|realnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Attempt to assign to an unmodifiable value."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* frame_register_read ()     Find and return the value of REGNUM for the specified stack frame.    The number of bytes copied is DEPRECATED_REGISTER_RAW_SIZE    (REGNUM).     Returns 0 if the register value could not be found.  */
end_comment

begin_function
name|int
name|frame_register_read
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|myaddr
parameter_list|)
block|{
name|int
name|optimized
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|realnum
decl_stmt|;
name|frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|optimized
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|myaddr
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2002-05-15: This test, is just bogus.       It indicates that the target failed to supply a value for a      register because it was "not available" at this time.  Problem      is, the target still has the register and so get saved_register()      may be returning a value saved on the stack.  */
if|if
condition|(
name|register_cached
argument_list|(
name|regnum
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* register value not available */
return|return
operator|!
name|optimized
return|;
block|}
end_function

begin_comment
comment|/* Map between a frame register number and its name.  A frame register    space is a superset of the cooked register space --- it also    includes builtin registers.  */
end_comment

begin_function
name|int
name|frame_map_name_to_regnum
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|user_reg_map_name_to_regnum
argument_list|(
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|frame_map_regnum_to_name
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
return|return
name|user_reg_map_regnum_to_name
argument_list|(
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
argument_list|,
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a sentinel frame.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_info
modifier|*
name|create_sentinel_frame
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|frame_info
argument_list|)
decl_stmt|;
name|frame
operator|->
name|type
operator|=
name|NORMAL_FRAME
expr_stmt|;
name|frame
operator|->
name|level
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Explicitly initialize the sentinel frame's cache.  Provide it      with the underlying regcache.  In the future additional      information, such as the frame's thread will be added.  */
name|frame
operator|->
name|prologue_cache
operator|=
name|sentinel_frame_cache
argument_list|(
name|regcache
argument_list|)
expr_stmt|;
comment|/* For the moment there is only one sentinel frame implementation.  */
name|frame
operator|->
name|unwind
operator|=
name|sentinel_frame_unwind
expr_stmt|;
comment|/* Link this frame back to itself.  The frame is self referential      (the unwound PC is the same as the pc), so make it so.  */
name|frame
operator|->
name|next
operator|=
name|frame
expr_stmt|;
comment|/* Make the sentinel frame's ID valid, but invalid.  That way all      comparisons with it should fail.  */
name|frame
operator|->
name|this_id
operator|.
name|p
operator|=
literal|1
expr_stmt|;
name|frame
operator|->
name|this_id
operator|.
name|value
operator|=
name|null_frame_id
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ create_sentinel_frame (...) -> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* Info about the innermost stack frame (contents of FP register) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
modifier|*
name|current_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache for frame addresses already read by gdb.  Valid only while    inferior is stopped.  Control variables for the frame cache should    be local to this module.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|frame_obstack_zalloc
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
init|=
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
name|CORE_ADDR
modifier|*
name|frame_saved_regs_zalloc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|fi
operator|->
name|saved_regs
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|frame_obstack_zalloc
argument_list|(
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|saved_regs
return|;
block|}
end_function

begin_function
name|CORE_ADDR
modifier|*
name|deprecated_get_frame_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|fi
operator|->
name|saved_regs
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost (currently executing) stack frame.  This is    split into two functions.  The function unwind_to_current_frame()    is wrapped in catch exceptions so that, even when the unwind of the    sentinel frame fails, the function still returns a stack frame.  */
end_comment

begin_function
specifier|static
name|int
name|unwind_to_current_frame
parameter_list|(
name|struct
name|ui_out
modifier|*
name|ui_out
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_prev_frame
argument_list|(
name|args
argument_list|)
decl_stmt|;
comment|/* A sentinel frame can fail to unwind, eg, because it's PC value      lands in somewhere like start.  */
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|current_frame
operator|=
name|frame
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|frame_info
modifier|*
name|get_current_frame
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* First check, and report, the lack of registers.  Having GDB      report "No stack!" or "No memory" when the target doesn't even      have registers is very confusing.  Besides, "printcmd.exp"      explicitly checks that ``print $pc'' with no registers prints "No      registers".  */
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_memory
condition|)
name|error
argument_list|(
literal|"No memory."
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame
operator|==
name|NULL
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|sentinel_frame
init|=
name|create_sentinel_frame
argument_list|(
name|current_regcache
argument_list|)
decl_stmt|;
if|if
condition|(
name|catch_exceptions
argument_list|(
name|uiout
argument_list|,
name|unwind_to_current_frame
argument_list|,
name|sentinel_frame
argument_list|,
name|NULL
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Oops! Fake a current frame?  Is this useful?  It has a PC              of zero, for instance.  */
name|current_frame
operator|=
name|sentinel_frame
expr_stmt|;
block|}
block|}
return|return
name|current_frame
return|;
block|}
end_function

begin_comment
comment|/* The "selected" stack frame is used by default for local and arg    access.  May be zero, for no selected frame.  */
end_comment

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|deprecated_selected_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the selected frame.  Always non-null (unless there isn't an    inferior sufficient for creating a frame) in which case an error is    thrown.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_selected_frame
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|deprecated_selected_frame
operator|==
name|NULL
condition|)
comment|/* Hey!  Don't trust this.  It should really be re-finding the        last selected frame of the currently selected thread.  This,        though, is better than nothing.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* There is always a frame.  */
name|gdb_assert
argument_list|(
name|deprecated_selected_frame
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|deprecated_selected_frame
return|;
block|}
end_function

begin_comment
comment|/* This is a variant of get_selected_frame which can be called when    the inferior does not have a frame; in that case it will return    NULL instead of calling error ().  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|deprecated_safe_get_selected_frame
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_has_registers
operator|||
operator|!
name|target_has_stack
operator|||
operator|!
name|target_has_memory
condition|)
return|return
name|NULL
return|;
return|return
name|get_selected_frame
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Select frame FI (or NULL - to invalidate the current frame).  */
end_comment

begin_function
name|void
name|select_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|deprecated_selected_frame
operator|=
name|fi
expr_stmt|;
comment|/* NOTE: cagney/2002-05-04: FI can be NULL.  This occures when the      frame is being invalidated.  */
if|if
condition|(
name|selected_frame_level_changed_hook
condition|)
name|selected_frame_level_changed_hook
argument_list|(
name|frame_relative_level
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: kseitz/2002-08-28: It would be nice to call      selected_frame_level_changed_event right here, but due to limitations      in the current interfaces, we would end up flooding UIs with events      because select_frame is used extensively internally.       Once we have frame-parameterized frame (and frame-related) commands,      the event notification can be moved here, since this function will only      be called when the users selected frame is being changed. */
comment|/* Ensure that symbols for this frame are read in.  Also, determine the      source language of this frame, and switch to it if desired.  */
if|if
condition|(
name|fi
condition|)
block|{
comment|/* We retrieve the frame's symtab by using the frame PC.  However          we cannot use the frame pc as is, because it usually points to          the instruction following the "call", which is sometimes the          first instruction of another function.  So we rely on          get_frame_address_in_block() which provides us with a PC which          is guaranteed to be inside the frame's code block.  */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|current_language
operator|->
name|la_language
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_unknown
operator|&&
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
name|set_language
argument_list|(
name|s
operator|->
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the register saved in the simplistic ``saved_regs'' cache.    If the value isn't here AND a value is needed, try the next inner    most frame.  */
end_comment

begin_function
specifier|static
name|void
name|legacy_saved_regs_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
comment|/* HACK: New code is passed the next frame and this cache.      Unfortunately, old code expects this frame.  Since this is a      backward compatibility hack, cheat by walking one level along the      prologue chain to the frame the old code expects.       Do not try this at home.  Professional driver, closed course.  */
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|next_frame
operator|->
name|prev
decl_stmt|;
name|gdb_assert
argument_list|(
name|frame
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* If nothing's initialized the saved regs, do it now.  */
name|gdb_assert
argument_list|(
name|DEPRECATED_FRAME_INIT_SAVED_REGS_P
argument_list|()
argument_list|)
expr_stmt|;
name|DEPRECATED_FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
operator|!=
name|NULL
operator|&&
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
comment|/* SP register treated specially.  */
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
comment|/* NOTE: cagney/2003-05-09: In-lined store_address with                it's body - store_unsigned_integer.  */
name|store_unsigned_integer
argument_list|(
name|bufferp
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Any other register is saved in memory, fetch it but cache              a local copy of its value.  */
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Save each register value, as it is read in, in a                  frame based cache.  */
name|void
modifier|*
modifier|*
name|regs
init|=
operator|(
operator|*
name|this_prologue_cache
operator|)
decl_stmt|;
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
block|{
name|int
name|sizeof_cache
init|=
operator|(
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
decl_stmt|;
name|regs
operator|=
name|frame_obstack_zalloc
argument_list|(
name|sizeof_cache
argument_list|)
expr_stmt|;
operator|(
operator|*
name|this_prologue_cache
operator|)
operator|=
name|regs
expr_stmt|;
block|}
if|if
condition|(
name|regs
index|[
name|regnum
index|]
operator|==
name|NULL
condition|)
block|{
name|regs
index|[
name|regnum
index|]
operator|=
name|frame_obstack_zalloc
argument_list|(
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
argument_list|,
name|regs
index|[
name|regnum
index|]
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|bufferp
argument_list|,
name|regs
index|[
name|regnum
index|]
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
argument_list|,
name|bufferp
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return;
block|}
comment|/* No luck.  Assume this and the next frame have the same register      value.  Pass the unwind request down the frame chain to the next      frame.  Hopefully that frame will find the register's location.  */
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|legacy_saved_regs_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|id
parameter_list|)
block|{
comment|/* A developer is trying to bring up a new architecture, help them      by providing a default unwinder that refuses to unwind anything      (the ID is always NULL).  In the case of legacy code,      legacy_get_prev_frame() will have previously set ->this_id.p, so      this code won't be called.  */
operator|(
operator|*
name|id
operator|)
operator|=
name|null_frame_id
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|frame_unwind
name|legacy_saved_regs_unwinder
init|=
block|{
comment|/* Not really.  It gets overridden by legacy_get_prev_frame.  */
name|UNKNOWN_FRAME
block|,
name|legacy_saved_regs_this_id
block|,
name|legacy_saved_regs_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|frame_unwind
modifier|*
name|legacy_saved_regs_unwind
init|=
operator|&
name|legacy_saved_regs_unwinder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: deprecated_generic_get_saved_register    Find register number REGNUM relative to FRAME and put its (raw,    target format) contents in *RAW_BUFFER.     Set *OPTIMIZED if the variable was optimized out (and thus can't be    fetched).  Note that this is never set to anything other than zero    in this implementation.     Set *LVAL to lval_memory, lval_register, or not_lval, depending on    whether the value was fetched from memory, from a register, or in a    strange and non-modifiable way (e.g. a frame pointer which was    calculated rather than fetched).  We will use not_lval for values    fetched from generic dummy frames.     Set *ADDRP to the address, either in memory or as a    DEPRECATED_REGISTER_BYTE offset into the registers array.  If the    value is stored in a dummy frame, set *ADDRP to zero.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|deprecated_generic_get_saved_register
parameter_list|(
name|char
modifier|*
name|raw_buffer
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lval
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
comment|/* Normal systems don't optimize out things with register numbers.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addrp
condition|)
comment|/* default assumption: not found in memory */
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
comment|/* Note: since the current frame's registers could only have been      saved by frames INTERIOR TO the current frame, we skip examining      the current frame itself: otherwise, we would be getting the      previous frame's registers which were saved by the current frame.  */
if|if
condition|(
name|frame
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|frame
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
init|;
name|frame_relative_level
argument_list|(
name|frame
argument_list|)
operator|>=
literal|0
condition|;
name|frame
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
control|)
block|{
if|if
condition|(
name|get_frame_type
argument_list|(
name|frame
argument_list|)
operator|==
name|DUMMY_FRAME
condition|)
block|{
if|if
condition|(
name|lval
condition|)
comment|/* found it in a CALL_DUMMY frame */
operator|*
name|lval
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|raw_buffer
condition|)
comment|/* FIXME: cagney/2002-06-26: This should be via the 		   gdbarch_register_read() method so that it, on the 		   fly, constructs either a raw or pseudo register 		   from the raw register cache.  */
name|regcache_raw_read
argument_list|(
name|deprecated_find_dummy_frame_regcache
argument_list|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|frame
argument_list|)
argument_list|)
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
return|return;
block|}
name|DEPRECATED_FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
operator|!=
name|NULL
operator|&&
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
condition|)
comment|/* found it saved on the stack */
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
condition|)
comment|/* SP register treated specially */
comment|/* NOTE: cagney/2003-05-09: In-line store_address                        with it's body - store_unsigned_integer.  */
name|store_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addrp
condition|)
comment|/* any other register */
operator|*
name|addrp
operator|=
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|raw_buffer
condition|)
name|read_memory
argument_list|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|frame
argument_list|)
index|[
name|regnum
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
comment|/* If we get thru the loop to this point, it means the register was      not saved in any frame.  Return the actual live-register value.  */
if|if
condition|(
name|lval
condition|)
comment|/* found it in a live register */
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|addrp
condition|)
operator|*
name|addrp
operator|=
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buffer
condition|)
name|deprecated_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the frame's type based on its PC.  */
end_comment

begin_function
specifier|static
name|enum
name|frame_type
name|frame_type_from_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* FIXME: cagney/2002-11-24: Can't yet directly call      pc_in_dummy_frame() as some architectures don't set      PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the      latter is implemented by simply calling pc_in_dummy_frame).  */
if|if
condition|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
operator|&&
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DUMMY_FRAME
return|;
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|SIGTRAMP_FRAME
return|;
else|else
return|return
name|NORMAL_FRAME
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create an arbitrary (i.e. address specified by user) or innermost frame.    Always returns a non-NULL value.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|create_new_frame
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ create_new_frame (addr=0x%s, pc=0x%s) "
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fi
operator|=
name|frame_obstack_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|next
operator|=
name|create_sentinel_frame
argument_list|(
name|current_regcache
argument_list|)
expr_stmt|;
comment|/* Select/initialize both the unwind function and the frame's type      based on the PC.  */
name|fi
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|unwind
operator|->
name|type
operator|!=
name|UNKNOWN_FRAME
condition|)
name|fi
operator|->
name|type
operator|=
name|fi
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
else|else
name|fi
operator|->
name|type
operator|=
name|frame_type_from_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|fi
operator|->
name|this_id
operator|.
name|p
operator|=
literal|1
expr_stmt|;
name|deprecated_update_frame_base_hack
argument_list|(
name|fi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|deprecated_update_frame_pc_hack
argument_list|(
name|fi
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_INIT_EXTRA_FRAME_INFO_P
argument_list|()
condition|)
name|DEPRECATED_INIT_EXTRA_FRAME_INFO
argument_list|(
literal|0
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that THIS_FRAME calls (NULL if THIS_FRAME is the    innermost frame).  Be careful to not fall off the bottom of the    frame chain and onto the sentinel frame.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_next_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>
literal|0
condition|)
return|return
name|this_frame
operator|->
name|next
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Flush the entire frame cache.  */
end_comment

begin_function
name|void
name|flush_cached_frames
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Since we can't really be sure what the first object allocated was */
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
name|current_frame
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cache */
name|select_frame
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|annotate_frames_invalid
argument_list|()
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ flush_cached_frames () }\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the frame cache, and start a new one if necessary.  */
end_comment

begin_function
name|void
name|reinit_frame_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* FIXME: The inferior_ptid test is wrong if there is a corefile.  */
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the previous frame using the deprecated methods    INIT_EXTRA_INFO, INIT_FRAME_PC and INIT_FRAME_PC_FIRST.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_info
modifier|*
name|legacy_get_prev_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
name|int
name|fromleaf
decl_stmt|;
comment|/* Don't frame_debug print legacy_get_prev_frame() here, just      confuses the output.  */
comment|/* Allocate the new frame.       There is no reason to worry about memory leaks, should the      remainder of the function fail.  The allocated memory will be      quickly reclaimed when the frame cache is flushed, and the `we've      been here before' check, in get_prev_frame will stop repeated      memory allocation calls.  */
name|prev
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|frame_info
argument_list|)
expr_stmt|;
name|prev
operator|->
name|level
operator|=
name|this_frame
operator|->
name|level
operator|+
literal|1
expr_stmt|;
comment|/* Do not completely wire it in to the frame chain.  Some (bad) code      in INIT_FRAME_EXTRA_INFO tries to look along frame->prev to pull      some fancy tricks (of course such code is, by definition,      recursive).         On the other hand, methods, such as get_frame_pc() and      get_frame_base() rely on being able to walk along the frame      chain.  Make certain that at least they work by providing that      link.  Of course things manipulating prev can't go back.  */
name|prev
operator|->
name|next
operator|=
name|this_frame
expr_stmt|;
comment|/* NOTE: cagney/2002-11-18: Should have been correctly setting the      frame's type here, before anything else, and not last, at the      bottom of this function.  The various      DEPRECATED_INIT_EXTRA_FRAME_INFO, DEPRECATED_INIT_FRAME_PC,      DEPRECATED_INIT_FRAME_PC_FIRST and      DEPRECATED_FRAME_INIT_SAVED_REGS methods are full of work-arounds      that handle the frame not being correctly set from the start.      Unfortunately those same work-arounds rely on the type defaulting      to NORMAL_FRAME.  Ulgh!  The new frame code does not have this      problem.  */
name|prev
operator|->
name|type
operator|=
name|UNKNOWN_FRAME
expr_stmt|;
comment|/* A legacy frame's ID is always computed here.  Mark it as valid.  */
name|prev
operator|->
name|this_id
operator|.
name|p
operator|=
literal|1
expr_stmt|;
comment|/* Handle sentinel frame unwind as a special case.  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|<
literal|0
condition|)
block|{
comment|/* Try to unwind the PC.  If that doesn't work, assume we've reached 	 the oldest frame and simply return.  Is there a better sentinal 	 value?  The unwound PC value is then used to initialize the new 	 previous frame's type.  	 Note that the pc-unwind is intentionally performed before the 	 frame chain.  This is ok since, for old targets, both 	 frame_pc_unwind (nee, DEPRECATED_FRAME_SAVED_PC) and 	 DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures 	 have already been initialized (using 	 DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order 	 doesn't matter. 	  	 By unwinding the PC first, it becomes possible to, in the case of 	 a dummy frame, avoid also unwinding the frame ID.  This is 	 because (well ignoring the PPC) a dummy frame can be located 	 using THIS_FRAME's frame ID.  */
name|deprecated_update_frame_pc_hack
argument_list|(
name|prev
argument_list|,
name|frame_pc_unwind
argument_list|(
name|this_frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The allocated PREV_FRAME will be reclaimed when the frame 	     obstack is next purged.  */
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // unwound legacy PC zero }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Set the unwind functions based on that identified PC.  Ditto          for the "type" but strongly prefer the unwinder's frame type.  */
name|prev
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|prev
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|unwind
operator|->
name|type
operator|==
name|UNKNOWN_FRAME
condition|)
name|prev
operator|->
name|type
operator|=
name|frame_type_from_pc
argument_list|(
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prev
operator|->
name|type
operator|=
name|prev
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
comment|/* Find the prev's frame's ID.  */
if|if
condition|(
name|prev
operator|->
name|type
operator|==
name|DUMMY_FRAME
operator|&&
name|gdbarch_unwind_dummy_id_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* When unwinding a normal frame, the stack structure is 	     determined by analyzing the frame's function's code (be 	     it using brute force prologue analysis, or the dwarf2 	     CFI).  In the case of a dummy frame, that simply isn't 	     possible.  The The PC is either the program entry point, 	     or some random address on the stack.  Trying to use that 	     PC to apply standard frame ID unwind techniques is just 	     asking for trouble.  */
comment|/* Use an architecture specific method to extract the prev's 	     dummy ID from the next frame.  Note that this method uses 	     frame_register_unwind to obtain the register values 	     needed to determine the dummy frame's ID.  */
name|prev
operator|->
name|this_id
operator|.
name|value
operator|=
name|gdbarch_unwind_dummy_id
argument_list|(
name|current_gdbarch
argument_list|,
name|this_frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're unwinding a sentinel frame, the PC of which is 	     pointing at a stack dummy.  Fake up the dummy frame's ID 	     using the same sequence as is found a traditional 	     unwinder.  Once all architectures supply the 	     unwind_dummy_id method, this code can go away.  */
name|prev
operator|->
name|this_id
operator|.
name|value
operator|=
name|frame_id_build
argument_list|(
name|deprecated_read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Check that the unwound ID is valid.  */
if|if
condition|(
operator|!
name|frame_id_p
argument_list|(
name|prev
operator|->
name|this_id
operator|.
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // unwound legacy ID invalid }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Check that the new frame isn't inner to (younger, below, 	 next) the old frame.  If that happens the frame unwind is 	 going backwards.  */
comment|/* FIXME: cagney/2003-02-25: Ignore the sentinel frame since 	 that doesn't have a valid frame ID.  Should instead set the 	 sentinel frame's frame ID to a `sentinel'.  Leave it until 	 after the switch to storing the frame ID, instead of the 	 frame base, in the frame object.  */
comment|/* Link it in.  */
name|this_frame
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
comment|/* FIXME: cagney/2002-01-19: This call will go away.  Instead of 	 initializing extra info, all frames will use the frame_cache 	 (passed to the unwind functions) to store additional frame 	 info.  Unfortunately legacy targets can't use 	 legacy_get_prev_frame() to unwind the sentinel frame and, 	 consequently, are forced to take this code path and rely on 	 the below call to DEPRECATED_INIT_EXTRA_FRAME_INFO to 	 initialize the inner-most frame.  */
if|if
condition|(
name|DEPRECATED_INIT_EXTRA_FRAME_INFO_P
argument_list|()
condition|)
block|{
name|DEPRECATED_INIT_EXTRA_FRAME_INFO
argument_list|(
literal|0
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|->
name|type
operator|==
name|NORMAL_FRAME
condition|)
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|code_addr
operator|=
name|get_pc_function_start
argument_list|(
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|code_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" } // legacy innermost frame\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
comment|/* This code only works on normal frames.  A sentinel frame, where      the level is -1, should never reach this code.  */
name|gdb_assert
argument_list|(
name|this_frame
operator|->
name|level
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* On some machines it is possible to call a function without      setting up a stack frame for it.  On these machines, we      define this macro to take two args; a frameinfo pointer      identifying a frame and a variable to set or clear if it is      or isn't leafless.  */
comment|/* Still don't want to worry about this except on the innermost      frame.  This macro will set FROMLEAF if THIS_FRAME is a frameless      function invocation.  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|==
literal|0
condition|)
comment|/* FIXME: 2002-11-09: Frameless functions can occure anywhere in        the frame chain, not just the inner most frame!  The generic,        per-architecture, frame code should handle this and the below        should simply be removed.  */
name|fromleaf
operator|=
operator|(
name|DEPRECATED_FRAMELESS_FUNCTION_INVOCATION_P
argument_list|()
operator|&&
name|DEPRECATED_FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|this_frame
argument_list|)
operator|)
expr_stmt|;
else|else
name|fromleaf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fromleaf
condition|)
comment|/* A frameless inner-most frame.  The `FP' (which isn't an        architecture frame-pointer register!) of the caller is the same        as the callee.  */
comment|/* FIXME: 2002-11-09: There isn't any reason to special case this        edge condition.  Instead the per-architecture code should hande        it locally.  */
comment|/* FIXME: cagney/2003-06-16: This returns the inner most stack        address for the previous frame, that, however, is wrong.  It        should be the inner most stack address for the previous to        previous frame.  This is because it is the previous to previous        frame's innermost stack address that is constant through out        the lifetime of the previous frame (trust me :-).  */
name|address
operator|=
name|get_frame_base
argument_list|(
name|this_frame
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Two macros defined in tm.h specify the machine-dependent          actions to be performed here.           First, get the frame's chain-pointer.           If that is zero, the frame is the outermost frame or a leaf          called by the outermost frame.  This means that if start          calls main without a frame, we'll return 0 (which is fine          anyway).           Nope; there's a problem.  This also returns when the current          routine is a leaf of main.  This is unacceptable.  We move          this to after the ffi test; I'd rather have backtraces from          start go curfluy than have an abort called from main not show          main.  */
if|if
condition|(
name|DEPRECATED_FRAME_CHAIN_P
argument_list|()
condition|)
name|address
operator|=
name|DEPRECATED_FRAME_CHAIN
argument_list|(
name|this_frame
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Someone is part way through coverting an old architecture              to the new frame code.  Implement FRAME_CHAIN the way the              new frame will.  */
comment|/* Find PREV frame's unwinder.  */
name|prev
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|this_frame
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-04-02: Rather than storing the frame's 	     type in the frame, the unwinder's type should be returned 	     directly.  Unfortunately, legacy code, called by 	     legacy_get_prev_frame, explicitly set the frames type 	     using the method deprecated_set_frame_type().  */
name|prev
operator|->
name|type
operator|=
name|prev
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
comment|/* Find PREV frame's ID.  */
name|prev
operator|->
name|unwind
operator|->
name|this_id
argument_list|(
name|this_frame
argument_list|,
operator|&
name|prev
operator|->
name|prologue_cache
argument_list|,
operator|&
name|prev
operator|->
name|this_id
operator|.
name|value
argument_list|)
expr_stmt|;
name|prev
operator|->
name|this_id
operator|.
name|p
operator|=
literal|1
expr_stmt|;
name|address
operator|=
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|stack_addr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|legacy_frame_chain_valid
argument_list|(
name|address
argument_list|,
name|this_frame
argument_list|)
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // legacy frame chain invalid }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|address
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // legacy frame chain NULL }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Link in the already allocated prev frame.  */
name|this_frame
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|deprecated_update_frame_base_hack
argument_list|(
name|prev
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* This change should not be needed, FIXME!  We should determine      whether any targets *need* DEPRECATED_INIT_FRAME_PC to happen      after DEPRECATED_INIT_EXTRA_FRAME_INFO and come up with a simple      way to express what goes on here.       DEPRECATED_INIT_EXTRA_FRAME_INFO is called from two places:      create_new_frame (where the PC is already set up) and here (where      it isn't).  DEPRECATED_INIT_FRAME_PC is only called from here,      always after DEPRECATED_INIT_EXTRA_FRAME_INFO.       The catch is the MIPS, where DEPRECATED_INIT_EXTRA_FRAME_INFO      requires the PC value (which hasn't been set yet).  Some other      machines appear to require DEPRECATED_INIT_EXTRA_FRAME_INFO      before they can do DEPRECATED_INIT_FRAME_PC.  Phoo.       We shouldn't need DEPRECATED_INIT_FRAME_PC_FIRST to add more      complication to an already overcomplicated part of GDB.      gnu@cygnus.com, 15Sep92.       Assuming that some machines need DEPRECATED_INIT_FRAME_PC after      DEPRECATED_INIT_EXTRA_FRAME_INFO, one possible scheme:       SETUP_INNERMOST_FRAME(): Default version is just create_new_frame      (deprecated_read_fp ()), read_pc ()).  Machines with extra frame      info would do that (or the local equivalent) and then set the      extra fields.       SETUP_ARBITRARY_FRAME(argc, argv): Only change here is that      create_new_frame would no longer init extra frame info;      SETUP_ARBITRARY_FRAME would have to do that.       INIT_PREV_FRAME(fromleaf, prev) Replace      DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC.      This should also return a flag saying whether to keep the new      frame, or whether to discard it, because on some machines (e.g.      mips) it is really awkward to have DEPRECATED_FRAME_CHAIN_VALID      called BEFORE DEPRECATED_INIT_EXTRA_FRAME_INFO (there is no good      way to get information deduced in DEPRECATED_FRAME_CHAIN_VALID      into the extra fields of the new frame).  std_frame_pc(fromleaf,      prev)       This is the default setting for INIT_PREV_FRAME.  It just does      what the default DEPRECATED_INIT_FRAME_PC does.  Some machines      will call it from INIT_PREV_FRAME (either at the beginning, the      end, or in the middle).  Some machines won't use it.       kingdon@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */
comment|/* NOTE: cagney/2002-11-09: Just ignore the above!  There is no      reason for things to be this complicated.       The trick is to assume that there is always a frame.  Instead of      special casing the inner-most frame, create fake frame      (containing the hardware registers) that is inner to the      user-visible inner-most frame (...) and then unwind from that.      That way architecture code can use use the standard      frame_XX_unwind() functions and not differentiate between the      inner most and any other case.       Since there is always a frame to unwind from, there is always      somewhere (THIS_FRAME) to store all the info needed to construct      a new (previous) frame without having to first create it.  This      means that the convolution below - needing to carefully order a      frame's initialization - isn't needed.       The irony here though, is that DEPRECATED_FRAME_CHAIN(), at least      for a more up-to-date architecture, always calls      FRAME_SAVED_PC(), and FRAME_SAVED_PC() computes the PC but      without first needing the frame!  Instead of the convolution      below, we could have simply called FRAME_SAVED_PC() and been done      with it!  Note that FRAME_SAVED_PC() is being superseed by      frame_pc_unwind() and that function does have somewhere to cache      that PC value.  */
if|if
condition|(
name|DEPRECATED_INIT_FRAME_PC_FIRST_P
argument_list|()
condition|)
name|deprecated_update_frame_pc_hack
argument_list|(
name|prev
argument_list|,
name|DEPRECATED_INIT_FRAME_PC_FIRST
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_INIT_EXTRA_FRAME_INFO_P
argument_list|()
condition|)
name|DEPRECATED_INIT_EXTRA_FRAME_INFO
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
comment|/* This entry is in the frame queue now, which is good since      FRAME_SAVED_PC may use that queue to figure out its value (see      tm-sparc.h).  We want the pc saved in the inferior frame. */
if|if
condition|(
name|DEPRECATED_INIT_FRAME_PC_P
argument_list|()
condition|)
name|deprecated_update_frame_pc_hack
argument_list|(
name|prev
argument_list|,
name|DEPRECATED_INIT_FRAME_PC
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If ->frame and ->pc are unchanged, we are in the process of      getting ourselves into an infinite backtrace.  Some architectures      check this in DEPRECATED_FRAME_CHAIN or thereabouts, but it seems      like there is no reason this can't be an architecture-independent      check.  */
if|if
condition|(
name|get_frame_base
argument_list|(
name|prev
argument_list|)
operator|==
name|get_frame_base
argument_list|(
name|this_frame
argument_list|)
operator|&&
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
operator|==
name|get_frame_pc
argument_list|(
name|this_frame
argument_list|)
condition|)
block|{
name|this_frame
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // legacy this.id == prev.id }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Initialize the code used to unwind the frame PREV based on the PC      (and probably other architectural information).  The PC lets you      check things like the debug info at that point (dwarf2cfi?) and      use that to decide how the frame should be unwound.       If there isn't a FRAME_CHAIN, the code above will have already      done this.  */
if|if
condition|(
name|prev
operator|->
name|unwind
operator|==
name|NULL
condition|)
name|prev
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|prev
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* If the unwinder provides a frame type, use it.  Otherwize      continue on to that heuristic mess.  */
if|if
condition|(
name|prev
operator|->
name|unwind
operator|->
name|type
operator|!=
name|UNKNOWN_FRAME
condition|)
block|{
name|prev
operator|->
name|type
operator|=
name|prev
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|type
operator|==
name|NORMAL_FRAME
condition|)
comment|/* FIXME: cagney/2003-06-16: would get_frame_pc() be better?  */
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|code_addr
operator|=
name|get_pc_function_start
argument_list|(
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|code_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" } // legacy with unwound type\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
comment|/* NOTE: cagney/2002-11-18: The code segments, found in      create_new_frame and get_prev_frame(), that initializes the      frames type is subtly different.  The latter only updates ->type      when it encounters a SIGTRAMP_FRAME or DUMMY_FRAME.  This stops      get_prev_frame() overriding the frame's type when the INIT code      has previously set it.  This is really somewhat bogus.  The      initialization, as seen in create_new_frame(), should occur      before the INIT function has been called.  */
if|if
condition|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
operator|&&
operator|(
name|DEPRECATED_PC_IN_CALL_DUMMY_P
argument_list|()
condition|?
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|pc_in_dummy_frame
argument_list|(
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|)
condition|)
name|prev
operator|->
name|type
operator|=
name|DUMMY_FRAME
expr_stmt|;
else|else
block|{
comment|/* FIXME: cagney/2002-11-10: This should be moved to before the 	 INIT code above so that the INIT code knows what the frame's 	 type is (in fact, for a [generic] dummy-frame, the type can 	 be set and then the entire initialization can be skipped. 	 Unforunatly, its the INIT code that sets the PC (Hmm, catch 	 22).  */
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_SIGTRAMP
argument_list|(
name|get_frame_pc
argument_list|(
name|prev
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
name|prev
operator|->
name|type
operator|=
name|SIGTRAMP_FRAME
expr_stmt|;
comment|/* FIXME: cagney/2002-11-11: Leave prev->type alone.  Some          architectures are forcing the frame's type in INIT so we          don't want to override it here.  Remember, NORMAL_FRAME == 0,          so it all works (just :-/).  Once this initialization is          moved to the start of this function, all this nastness will          go away.  */
block|}
if|if
condition|(
name|prev
operator|->
name|type
operator|==
name|NORMAL_FRAME
condition|)
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|code_addr
operator|=
name|get_pc_function_start
argument_list|(
name|prev
operator|->
name|this_id
operator|.
name|value
operator|.
name|code_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" } // legacy with confused type\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Return a structure containing various interesting information    about the frame that called THIS_FRAME.  Returns NULL    if there is no such frame.     This function tests some target-independent conditions that should    terminate the frame chain, such as unwinding past main().  It    should not contain any target-dependent tests, such as checking    whether the program-counter is zero.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_prev_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|prev_frame
decl_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ get_prev_frame (this_frame="
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_frame
operator|!=
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%d"
argument_list|,
name|this_frame
operator|->
name|level
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"<NULL>"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
comment|/* Return the inner-most frame, when the caller passes in NULL.  */
comment|/* NOTE: cagney/2002-11-09: Not sure how this would happen.  The      caller should have previously obtained a valid frame using      get_selected_frame() and then called this code - only possibility      I can think of is code behaving badly.       NOTE: cagney/2003-01-10: Talk about code behaving badly.  Check      block_innermost_frame().  It does the sequence: frame = NULL;      while (1) { frame = get_prev_frame (frame); .... }.  Ulgh!  Why      it couldn't be written better, I don't know.       NOTE: cagney/2003-01-11: I suspect what is happening is      block_innermost_frame() is, when the target has no state      (registers, memory, ...), still calling this function.  The      assumption being that this function will return NULL indicating      that a frame isn't possible, rather than checking that the target      has state and then calling get_current_frame() and      get_prev_frame().  This is a guess mind.  */
if|if
condition|(
name|this_frame
operator|==
name|NULL
condition|)
block|{
comment|/* NOTE: cagney/2002-11-09: There was a code segment here that 	 would error out when CURRENT_FRAME was NULL.  The comment 	 that went with it made the claim ...  	 ``This screws value_of_variable, which just wants a nice 	 clean NULL return from block_innermost_frame if there are no 	 frames.  I don't think I've ever seen this message happen 	 otherwise.  And returning NULL here is a perfectly legitimate 	 thing to do.''           Per the above, this code shouldn't even be called with a NULL          THIS_FRAME.  */
return|return
name|current_frame
return|;
block|}
comment|/* There is always a frame.  If this assertion fails, suspect that      something should be calling get_selected_frame() or      get_current_frame().  */
name|gdb_assert
argument_list|(
name|this_frame
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure we pass an address within THIS_FRAME's code block to      inside_main_func.  Otherwise, we might stop unwinding at a      function which has a call instruction as its last instruction if      that function immediately precedes main().  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>=
literal|0
operator|&&
operator|!
name|backtrace_past_main
operator|&&
name|inside_main_func
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|this_frame
argument_list|)
argument_list|)
condition|)
comment|/* Don't unwind past main(), bug always unwind the sentinel frame.        Note, this is done _before_ the frame has been marked as        previously unwound.  That way if the user later decides to        allow unwinds past main(), that just happens.  */
block|{
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> NULL // inside main func }\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>
name|backtrace_limit
condition|)
block|{
name|error
argument_list|(
literal|"Backtrace limit of %d exceeded"
argument_list|,
name|backtrace_limit
argument_list|)
expr_stmt|;
block|}
comment|/* If we're already inside the entry function for the main objfile,      then it isn't valid.  Don't apply this test to a dummy frame -      dummy frame PC's typically land in the entry func.  Don't apply      this test to the sentinel frame.  Sentinel frames should always      be allowed to unwind.  */
comment|/* NOTE: cagney/2003-02-25: Don't enable until someone has found      hard evidence that this is needed.  */
comment|/* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func - wasn't      checking for "main" in the minimal symbols.  With that fixed      asm-source tests now stop in "main" instead of halting the      backtrace in wierd and wonderful ways somewhere inside the entry      file.  Suspect that deprecated_inside_entry_file and      inside_entry_func tests were added to work around that (now      fixed) case.  */
comment|/* NOTE: cagney/2003-07-15: danielj (if I'm reading it right)      suggested having the inside_entry_func test use the      inside_main_func msymbol trick (along with entry_point_address I      guess) to determine the address range of the start function.      That should provide a far better stopper than the current      heuristics.  */
comment|/* NOTE: cagney/2003-07-15: Need to add a "set backtrace      beyond-entry-func" command so that this can be selectively      disabled.  */
if|if
condition|(
literal|0
if|#
directive|if
literal|0
expr|&& backtrace_beyond_entry_func
endif|#
directive|endif
operator|&&
name|this_frame
operator|->
name|type
operator|!=
name|DUMMY_FRAME
operator|&&
name|this_frame
operator|->
name|level
operator|>=
literal|0
operator|&&
name|inside_entry_func
argument_list|(
name|this_frame
argument_list|)
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"// inside entry func }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Assume that the only way to get a zero PC is through something      like a SIGSEGV or a dummy frame, and hence that NORMAL frames      will never unwind a zero PC.  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>
literal|0
operator|&&
name|get_frame_type
argument_list|(
name|this_frame
argument_list|)
operator|==
name|NORMAL_FRAME
operator|&&
name|get_frame_type
argument_list|(
name|get_next_frame
argument_list|(
name|this_frame
argument_list|)
argument_list|)
operator|==
name|NORMAL_FRAME
operator|&&
name|get_frame_pc
argument_list|(
name|this_frame
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|this_frame
operator|->
name|prev
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // zero PC \n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Only try to do the unwind once.  */
if|if
condition|(
name|this_frame
operator|->
name|prev_p
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|this_frame
operator|->
name|prev
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // cached \n"
argument_list|)
expr_stmt|;
block|}
return|return
name|this_frame
operator|->
name|prev
return|;
block|}
name|this_frame
operator|->
name|prev_p
operator|=
literal|1
expr_stmt|;
comment|/* If we're inside the entry file, it isn't valid.  Don't apply this      test to a dummy frame - dummy frame PC's typically land in the      entry file.  Don't apply this test to the sentinel frame.      Sentinel frames should always be allowed to unwind.  */
comment|/* NOTE: drow/2002-12-25: should there be a way to disable this      check?  It assumes a single small entry file, and the way some      debug readers (e.g.  dbxread) figure out which object is the      entry file is somewhat hokey.  */
comment|/* NOTE: cagney/2003-01-10: If there is a way of disabling this test      then it should probably be moved to before the ->prev_p test,      above.  */
comment|/* NOTE: vinschen/2003-04-01: Disabled.  It turns out that the call      to deprecated_inside_entry_file destroys a meaningful backtrace      under some conditions.  E. g. the backtrace tests in the      asm-source testcase are broken for some targets.  In this test      the functions are all implemented as part of one file and the      testcase is not necessarily linked with a start file (depending      on the target).  What happens is, that the first frame is printed      normaly and following frames are treated as being inside the      enttry file then.  This way, only the #0 frame is printed in the      backtrace output.  */
if|if
condition|(
literal|0
operator|&&
name|this_frame
operator|->
name|type
operator|!=
name|DUMMY_FRAME
operator|&&
name|this_frame
operator|->
name|level
operator|>=
literal|0
operator|&&
name|deprecated_inside_entry_file
argument_list|(
name|get_frame_pc
argument_list|(
name|this_frame
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // inside entry file }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* If any of the old frame initialization methods are around, use      the legacy get_prev_frame method.  */
if|if
condition|(
name|legacy_frame_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
name|prev_frame
operator|=
name|legacy_get_prev_frame
argument_list|(
name|this_frame
argument_list|)
expr_stmt|;
return|return
name|prev_frame
return|;
block|}
comment|/* Check that this frame's ID was valid.  If it wasn't, don't try to      unwind to the prev frame.  Be careful to not apply this test to      the sentinel frame.  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>=
literal|0
operator|&&
operator|!
name|frame_id_p
argument_list|(
name|get_frame_id
argument_list|(
name|this_frame
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" // this ID is NULL }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Check that this frame's ID isn't inner to (younger, below, next)      the next frame.  This happens when a frame unwind goes backwards.      Since the sentinel frame doesn't really exist, don't compare the      inner-most against that sentinel.  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>
literal|0
operator|&&
name|frame_id_inner
argument_list|(
name|get_frame_id
argument_list|(
name|this_frame
argument_list|)
argument_list|,
name|get_frame_id
argument_list|(
name|this_frame
operator|->
name|next
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Previous frame inner to this frame (corrupt stack?)"
argument_list|)
expr_stmt|;
comment|/* Check that this and the next frame are not identical.  If they      are, there is most likely a stack cycle.  As with the inner-than      test above, avoid comparing the inner-most and sentinel frames.  */
if|if
condition|(
name|this_frame
operator|->
name|level
operator|>
literal|0
operator|&&
name|frame_id_eq
argument_list|(
name|get_frame_id
argument_list|(
name|this_frame
argument_list|)
argument_list|,
name|get_frame_id
argument_list|(
name|this_frame
operator|->
name|next
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Previous frame identical to this frame (corrupt stack?)"
argument_list|)
expr_stmt|;
comment|/* Allocate the new frame but do not wire it in to the frame chain.      Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along      frame->next to pull some fancy tricks (of course such code is, by      definition, recursive).  Try to prevent it.       There is no reason to worry about memory leaks, should the      remainder of the function fail.  The allocated memory will be      quickly reclaimed when the frame cache is flushed, and the `we've      been here before' check above will stop repeated memory      allocation calls.  */
name|prev_frame
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|frame_info
argument_list|)
expr_stmt|;
name|prev_frame
operator|->
name|level
operator|=
name|this_frame
operator|->
name|level
operator|+
literal|1
expr_stmt|;
comment|/* Don't yet compute ->unwind (and hence ->type).  It is computed      on-demand in get_frame_type, frame_register_unwind, and      get_frame_id.  */
comment|/* Don't yet compute the frame's ID.  It is computed on-demand by      get_frame_id().  */
comment|/* The unwound frame ID is validate at the start of this function,      as part of the logic to decide if that frame should be further      unwound, and not here while the prev frame is being created.      Doing this makes it possible for the user to examine a frame that      has an invalid frame ID.       Some very old VAX code noted: [...]  For the sake of argument,      suppose that the stack is somewhat trashed (which is one reason      that "info frame" exists).  So, return 0 (indicating we don't      know the address of the arglist) if we don't know what frame this      frame calls.  */
comment|/* Link it in.  */
name|this_frame
operator|->
name|prev
operator|=
name|prev_frame
expr_stmt|;
name|prev_frame
operator|->
name|next
operator|=
name|this_frame
expr_stmt|;
if|if
condition|(
name|frame_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|fprint_frame
argument_list|(
name|gdb_stdlog
argument_list|,
name|prev_frame
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|prev_frame
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|frame
operator|->
name|next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|frame_pc_unwind
argument_list|(
name|frame
operator|->
name|next
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an address of that falls within the frame's code block.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_unwind_address_in_block
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
comment|/* A draft address.  */
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|frame_tdep_pc_fixup
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|frame_tdep_pc_fixup
argument_list|(
operator|&
name|pc
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|pc
return|;
comment|/* If THIS frame is not inner most (i.e., NEXT isn't the sentinel),      and NEXT is `normal' (i.e., not a sigtramp, dummy, ....) THIS      frame's PC ends up pointing at the instruction fallowing the      "call".  Adjust that PC value so that it falls on the call      instruction (which, hopefully, falls within THIS frame's code      block.  So far it's proved to be a very good approximation.  See      get_frame_type for why ->type can't be used.  */
if|if
condition|(
name|next_frame
operator|->
name|level
operator|>=
literal|0
operator|&&
name|get_frame_type
argument_list|(
name|next_frame
argument_list|)
operator|==
name|NORMAL_FRAME
condition|)
operator|--
name|pc
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_address_in_block
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
return|return
name|frame_unwind_address_in_block
argument_list|(
name|this_frame
operator|->
name|next
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pc_notcurrent
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
comment|/* If FRAME is not the innermost frame, that normally means that      FRAME->pc points at the return instruction (which is *after* the      call instruction), and we want to get the line containing the      call (because the call is where the user thinks the program is).      However, if the next frame is either a SIGTRAMP_FRAME or a      DUMMY_FRAME, then the next frame will contain a saved interrupt      PC and such a PC indicates the current (rather than next)      instruction/line, consequently, for such cases, want to get the      line containing fi->pc.  */
name|struct
name|frame_info
modifier|*
name|next
init|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|int
name|notcurrent
init|=
operator|(
name|next
operator|!=
name|NULL
operator|&&
name|get_frame_type
argument_list|(
name|next
argument_list|)
operator|==
name|NORMAL_FRAME
operator|)
decl_stmt|;
return|return
name|notcurrent
return|;
block|}
end_function

begin_function
name|void
name|find_frame_sal
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|)
block|{
operator|(
operator|*
name|sal
operator|)
operator|=
name|find_pc_line
argument_list|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
name|pc_notcurrent
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Per "frame.h", return the ``address'' of the frame.  Code should    really be using get_frame_id().  */
end_comment

begin_function
name|CORE_ADDR
name|get_frame_base
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|get_frame_id
argument_list|(
name|fi
argument_list|)
operator|.
name|stack_addr
return|;
block|}
end_function

begin_comment
comment|/* High-level offsets into the frame.  Used by the debug info.  */
end_comment

begin_function
name|CORE_ADDR
name|get_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|!=
name|NORMAL_FRAME
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fi
operator|->
name|base
operator|==
name|NULL
condition|)
name|fi
operator|->
name|base
operator|=
name|frame_base_find_by_frame
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* Sneaky: If the low-level unwind and high-level base code share a      common unwinder, let them share the prologue cache.  */
if|if
condition|(
name|fi
operator|->
name|base
operator|->
name|unwind
operator|==
name|fi
operator|->
name|unwind
condition|)
return|return
name|fi
operator|->
name|base
operator|->
name|this_base
argument_list|(
name|fi
operator|->
name|next
argument_list|,
operator|&
name|fi
operator|->
name|prologue_cache
argument_list|)
return|;
return|return
name|fi
operator|->
name|base
operator|->
name|this_base
argument_list|(
name|fi
operator|->
name|next
argument_list|,
operator|&
name|fi
operator|->
name|base_cache
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_locals_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|!=
name|NORMAL_FRAME
condition|)
return|return
literal|0
return|;
comment|/* If there isn't a frame address method, find it.  */
if|if
condition|(
name|fi
operator|->
name|base
operator|==
name|NULL
condition|)
name|fi
operator|->
name|base
operator|=
name|frame_base_find_by_frame
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* Sneaky: If the low-level unwind and high-level base code share a      common unwinder, let them share the prologue cache.  */
if|if
condition|(
name|fi
operator|->
name|base
operator|->
name|unwind
operator|==
name|fi
operator|->
name|unwind
condition|)
name|cache
operator|=
operator|&
name|fi
operator|->
name|prologue_cache
expr_stmt|;
else|else
name|cache
operator|=
operator|&
name|fi
operator|->
name|base_cache
expr_stmt|;
return|return
name|fi
operator|->
name|base
operator|->
name|this_locals
argument_list|(
name|fi
operator|->
name|next
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_args_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|!=
name|NORMAL_FRAME
condition|)
return|return
literal|0
return|;
comment|/* If there isn't a frame address method, find it.  */
if|if
condition|(
name|fi
operator|->
name|base
operator|==
name|NULL
condition|)
name|fi
operator|->
name|base
operator|=
name|frame_base_find_by_frame
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* Sneaky: If the low-level unwind and high-level base code share a      common unwinder, let them share the prologue cache.  */
if|if
condition|(
name|fi
operator|->
name|base
operator|->
name|unwind
operator|==
name|fi
operator|->
name|unwind
condition|)
name|cache
operator|=
operator|&
name|fi
operator|->
name|prologue_cache
expr_stmt|;
else|else
name|cache
operator|=
operator|&
name|fi
operator|->
name|base_cache
expr_stmt|;
return|return
name|fi
operator|->
name|base
operator|->
name|this_args
argument_list|(
name|fi
operator|->
name|next
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Level of the selected frame: 0 for innermost, 1 for its caller, ...    or -1 for a NULL frame.  */
end_comment

begin_function
name|int
name|frame_relative_level
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|fi
operator|->
name|level
return|;
block|}
end_function

begin_function
name|enum
name|frame_type
name|get_frame_type
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
comment|/* Some targets still don't use [generic] dummy frames.  Catch them      here.  */
if|if
condition|(
operator|!
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
operator|&&
name|deprecated_frame_in_dummy
argument_list|(
name|frame
argument_list|)
condition|)
return|return
name|DUMMY_FRAME
return|;
comment|/* Some legacy code, e.g, mips_init_extra_frame_info() wants      to determine the frame's type prior to it being completely      initialized.  Don't attempt to lazily initialize ->unwind for      legacy code.  It will be initialized in legacy_get_prev_frame().  */
if|if
condition|(
name|frame
operator|->
name|unwind
operator|==
name|NULL
operator|&&
operator|!
name|legacy_frame_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* Initialize the frame's unwinder because it is that which          provides the frame's type.  */
name|frame
operator|->
name|unwind
operator|=
name|frame_unwind_find_by_frame
argument_list|(
name|frame
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-04-02: Rather than storing the frame's 	 type in the frame, the unwinder's type should be returned 	 directly.  Unfortunately, legacy code, called by 	 legacy_get_prev_frame, explicitly set the frames type using 	 the method deprecated_set_frame_type().  */
name|frame
operator|->
name|type
operator|=
name|frame
operator|->
name|unwind
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|type
operator|==
name|UNKNOWN_FRAME
condition|)
return|return
name|NORMAL_FRAME
return|;
else|else
return|return
name|frame
operator|->
name|type
return|;
block|}
end_function

begin_function
name|void
name|deprecated_set_frame_type
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|enum
name|frame_type
name|type
parameter_list|)
block|{
comment|/* Arrrg!  See comment in "frame.h".  */
name|frame
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|frame_extra_info
modifier|*
name|get_frame_extra_info
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|fi
operator|->
name|extra_info
return|;
block|}
end_function

begin_function
name|struct
name|frame_extra_info
modifier|*
name|frame_extra_info_zalloc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|fi
operator|->
name|extra_info
operator|=
name|frame_obstack_zalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|extra_info
return|;
block|}
end_function

begin_function
name|void
name|deprecated_update_frame_pc_hack
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ deprecated_update_frame_pc_hack (frame=%d,pc=0x%s) }\n"
argument_list|,
name|frame
operator|->
name|level
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-03-11: Some architectures (e.g., Arm) are      maintaining a locally allocated frame object.  Since such frame's      are not in the frame chain, it isn't possible to assume that the      frame has a next.  Sigh.  */
if|if
condition|(
name|frame
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* While we're at it, update this frame's cached PC value, found 	 in the next frame.  Oh for the day when "struct frame_info" 	 is opaque and this hack on hack can just go away.  */
name|frame
operator|->
name|next
operator|->
name|prev_pc
operator|.
name|value
operator|=
name|pc
expr_stmt|;
name|frame
operator|->
name|next
operator|->
name|prev_pc
operator|.
name|p
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|deprecated_update_frame_base_hack
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|CORE_ADDR
name|base
parameter_list|)
block|{
if|if
condition|(
name|frame_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"{ deprecated_update_frame_base_hack (frame=%d,base=0x%s) }\n"
argument_list|,
name|frame
operator|->
name|level
argument_list|,
name|paddr_nz
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See comment in "frame.h".  */
name|frame
operator|->
name|this_id
operator|.
name|value
operator|.
name|stack_addr
operator|=
name|base
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|frame_info
modifier|*
name|deprecated_frame_xmalloc_with_cleanup
parameter_list|(
name|long
name|sizeof_saved_regs
parameter_list|,
name|long
name|sizeof_extra_info
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|XMALLOC
argument_list|(
expr|struct
name|frame_info
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|->
name|this_id
operator|.
name|p
operator|=
literal|1
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeof_saved_regs
operator|>
literal|0
condition|)
block|{
name|frame
operator|->
name|saved_regs
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|sizeof_saved_regs
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|frame
operator|->
name|saved_regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizeof_extra_info
operator|>
literal|0
condition|)
block|{
name|frame
operator|->
name|extra_info
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|sizeof_extra_info
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|frame
operator|->
name|extra_info
argument_list|)
expr_stmt|;
block|}
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* Memory access methods.  */
end_comment

begin_function
name|void
name|get_frame_memory
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LONGEST
name|get_frame_memory_signed
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|get_frame_memory_unsigned
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|read_memory_unsigned_integer
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Architecture method.  */
end_comment

begin_function
name|struct
name|gdbarch
modifier|*
name|get_frame_arch
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
return|return
name|current_gdbarch
return|;
block|}
end_function

begin_comment
comment|/* Stack pointer methods.  */
end_comment

begin_function
name|CORE_ADDR
name|get_frame_sp
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
return|return
name|frame_sp_unwind
argument_list|(
name|this_frame
operator|->
name|next
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_sp_unwind
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
comment|/* Normality, an architecture that provides a way of obtaining any      frame inner-most address.  */
if|if
condition|(
name|gdbarch_unwind_sp_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
return|return
name|gdbarch_unwind_sp
argument_list|(
name|current_gdbarch
argument_list|,
name|next_frame
argument_list|)
return|;
comment|/* Things are looking grim.  If it's the inner-most frame and there      is a TARGET_READ_SP then that can be used.  */
if|if
condition|(
name|next_frame
operator|->
name|level
operator|<
literal|0
operator|&&
name|TARGET_READ_SP_P
argument_list|()
condition|)
return|return
name|TARGET_READ_SP
argument_list|()
return|;
comment|/* Now things are really are grim.  Hope that the value returned by      the SP_REGNUM register is meaningful.  */
if|if
condition|(
name|SP_REGNUM
operator|>=
literal|0
condition|)
block|{
name|ULONGEST
name|sp
decl_stmt|;
name|frame_unwind_unsigned_register
argument_list|(
name|next_frame
argument_list|,
name|SP_REGNUM
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Missing unwind SP method"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|legacy_frame_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|current_gdbarch
parameter_list|)
block|{
if|if
condition|(
name|DEPRECATED_INIT_FRAME_PC_P
argument_list|()
operator|||
name|DEPRECATED_INIT_FRAME_PC_FIRST_P
argument_list|()
operator|||
name|DEPRECATED_INIT_EXTRA_FRAME_INFO_P
argument_list|()
operator|||
name|DEPRECATED_FRAME_CHAIN_P
argument_list|()
condition|)
comment|/* No question, it's a legacy frame.  */
return|return
literal|1
return|;
if|if
condition|(
name|gdbarch_unwind_dummy_id_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
comment|/* No question, it's not a legacy frame (provided none of the        deprecated methods checked above are present that is).  */
return|return
literal|0
return|;
if|if
condition|(
name|DEPRECATED_TARGET_READ_FP_P
argument_list|()
operator|||
name|DEPRECATED_FP_REGNUM
operator|>=
literal|0
condition|)
comment|/* Assume it's legacy.  If you're trying to convert a legacy frame        target to the new mechanism, get rid of these.  legacy        get_prev_frame requires these when unwind_frame_id isn't        available.  */
return|return
literal|1
return|;
comment|/* Default to assuming that it's brand new code, and hence not      legacy.  Force it down the non-legacy path so that the new code      uses the new frame mechanism from day one.  Dummy frame's won't      work very well but we can live with that.  */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|set_backtrace_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|show_backtrace_cmdlist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_backtrace_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_list
argument_list|(
name|set_backtrace_cmdlist
argument_list|,
literal|"set backtrace "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_backtrace_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|show_backtrace_cmdlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"backtrace"
argument_list|,
name|class_maintenance
argument_list|,
name|set_backtrace_cmd
argument_list|,
literal|"\ Set backtrace specific variables.\n\ Configure backtrace variables such as the backtrace limit"
argument_list|,
operator|&
name|set_backtrace_cmdlist
argument_list|,
literal|"set backtrace "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"backtrace"
argument_list|,
name|class_maintenance
argument_list|,
name|show_backtrace_cmd
argument_list|,
literal|"\ Show backtrace specific variables\n\ Show backtrace variables such as the backtrace limit"
argument_list|,
operator|&
name|show_backtrace_cmdlist
argument_list|,
literal|"show backtrace "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_setshow_boolean_cmd
argument_list|(
literal|"past-main"
argument_list|,
name|class_obscure
argument_list|,
operator|&
name|backtrace_past_main
argument_list|,
literal|"\ Set whether backtraces should continue past \"main\".\n\ Normally the caller of \"main\" is not of interest, so GDB will terminate\n\ the backtrace at \"main\".  Set this variable if you need to see the rest\n\ of the stack trace."
argument_list|,
literal|"\ Show whether backtraces should continue past \"main\".\n\ Normally the caller of \"main\" is not of interest, so GDB will terminate\n\ the backtrace at \"main\".  Set this variable if you need to see the rest\n\ of the stack trace."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|set_backtrace_cmdlist
argument_list|,
operator|&
name|show_backtrace_cmdlist
argument_list|)
expr_stmt|;
name|add_setshow_uinteger_cmd
argument_list|(
literal|"limit"
argument_list|,
name|class_obscure
argument_list|,
operator|&
name|backtrace_limit
argument_list|,
literal|"\ Set an upper bound on the number of backtrace levels.\n\ No more than the specified number of frames can be displayed or examined.\n\ Zero is unlimited."
argument_list|,
literal|"\ Show the upper bound on the number of backtrace levels."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|set_backtrace_cmdlist
argument_list|,
operator|&
name|show_backtrace_cmdlist
argument_list|)
expr_stmt|;
comment|/* Debug this files internals. */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"frame"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|&
name|frame_debug
argument_list|,
literal|"Set frame debugging.\n\ When non-zero, frame specific internal debugging is enabled."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

