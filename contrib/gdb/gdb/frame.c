begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Cache and manage the values of registers for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for inferior_ptid */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_comment
comment|/* FIND_SAVED_REGISTER ()     Return the address in which frame FRAME's value of register REGNUM    has been saved in memory.  Or return zero if it has not been saved.    If REGNUM specifies the SP, the value we return is actually    the SP value, not an address where it was saved.  */
end_comment

begin_function
name|CORE_ADDR
name|find_saved_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|frame1
init|=
name|NULL
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
comment|/* No regs saved if want current frame */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_REGISTER_WINDOWS
comment|/* We assume that a register in a register window will only be saved      in one place (since the name changes and/or disappears as you go      towards inner frames), so we only call get_frame_saved_regs on      the current frame.  This is directly in contradiction to the      usage below, which assumes that registers used in a frame must be      saved in a lower (more interior) frame.  This change is a result      of working on a register window machine; get_frame_saved_regs      always returns the registers saved within a frame, within the      context (register namespace) of that frame. */
comment|/* However, note that we don't want this to return anything if      nothing is saved (if there's a frame inside of this one).  Also,      callers to this routine asking for the stack pointer want the      stack pointer saved for *this* frame; this is returned from the      next frame.  */
if|if
condition|(
name|REGISTER_IN_WINDOW_P
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
return|return
literal|0
return|;
comment|/* Registers of this frame are active.  */
comment|/* Get the SP from the next frame in; it will be this          current frame.  */
if|if
condition|(
name|regnum
operator|!=
name|SP_REGNUM
condition|)
name|frame1
operator|=
name|frame
expr_stmt|;
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
return|return
name|frame1
operator|->
name|saved_regs
index|[
name|regnum
index|]
return|;
comment|/* ... which might be zero */
block|}
endif|#
directive|endif
comment|/* HAVE_REGISTER_WINDOWS */
comment|/* Note that this next routine assumes that registers used in      frame x will be saved only in the frame that x calls and      frames interior to it.  This is not true on the sparc, but the      above macro takes care of it, so we should be all right. */
while|while
condition|(
literal|1
condition|)
block|{
name|QUIT
expr_stmt|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame1
operator|==
literal|0
operator|||
name|frame1
operator|==
name|frame
condition|)
break|break;
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame1
operator|->
name|saved_regs
index|[
name|regnum
index|]
condition|)
name|addr
operator|=
name|frame1
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* DEFAULT_GET_SAVED_REGISTER ()     Find register number REGNUM relative to FRAME and put its (raw,    target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the    variable was optimized out (and thus can't be fetched).  Set *LVAL    to lval_memory, lval_register, or not_lval, depending on whether    the value was fetched from memory, from a register, or in a strange    and non-modifiable way (e.g. a frame pointer which was calculated    rather than fetched).  Set *ADDRP to the address, either in memory    on as a REGISTER_BYTE offset into the registers array.     Note that this implementation never sets *LVAL to not_lval.  But    it can be replaced by defining GET_SAVED_REGISTER and supplying    your own.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
specifier|static
name|void
name|default_get_saved_register
parameter_list|(
name|char
modifier|*
name|raw_buffer
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lval
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
comment|/* Normal systems don't optimize out things with register numbers.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
block|{
comment|/* Put it back in target format.  */
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
name|addr
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GET_SAVED_REGISTER
argument_list|)
end_if

begin_define
define|#
directive|define
name|GET_SAVED_REGISTER
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lval
parameter_list|)
define|\
value|default_get_saved_register(raw_buffer, optimized, addrp, frame, regnum, lval)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|get_saved_register
parameter_list|(
name|char
modifier|*
name|raw_buffer
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lval
parameter_list|)
block|{
name|GET_SAVED_REGISTER
argument_list|(
name|raw_buffer
argument_list|,
name|optimized
argument_list|,
name|addrp
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* READ_RELATIVE_REGISTER_RAW_BYTES_FOR_FRAME     Copy the bytes of register REGNUM, relative to the input stack frame,    into our memory at MYADDR, in target byte order.    The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).     Returns 1 if could not be read, 0 if could.  */
end_comment

begin_comment
comment|/* FIXME: This function increases the confusion between FP_REGNUM    and the virtual/pseudo-frame pointer.  */
end_comment

begin_function
specifier|static
name|int
name|read_relative_register_raw_bytes_for_frame
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|optim
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|FP_REGNUM
operator|&&
name|frame
condition|)
block|{
comment|/* Put it back in target format. */
name|store_address
argument_list|(
name|myaddr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|get_saved_register
argument_list|(
name|myaddr
argument_list|,
operator|&
name|optim
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_cached
argument_list|(
name|regnum
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* register value not available */
return|return
name|optim
return|;
block|}
end_function

begin_comment
comment|/* READ_RELATIVE_REGISTER_RAW_BYTES     Copy the bytes of register REGNUM, relative to the current stack    frame, into our memory at MYADDR, in target byte order.      The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).     Returns 1 if could not be read, 0 if could.  */
end_comment

begin_function
name|int
name|read_relative_register_raw_bytes
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|)
block|{
return|return
name|read_relative_register_raw_bytes_for_frame
argument_list|(
name|regnum
argument_list|,
name|myaddr
argument_list|,
name|selected_frame
argument_list|)
return|;
block|}
end_function

end_unit

