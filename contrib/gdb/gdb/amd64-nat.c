begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for AMD64.     Copyright 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"amd64-tdep.h"
end_include

begin_comment
comment|/* The following bits of code help with implementing debugging 32-bit    code natively on AMD64.  The idea is to define two mappings between    the register number as used by GDB and the register set used by the    host to represent the general-purpose registers; one for 32-bit    code and one for 64-bit code.  The mappings are specified by the    follwing variables and consist of an array of offsets within the    register set indexed by register number, and the number of    registers supported by the mapping.  We don't need mappings for the    floating-point and SSE registers, since the difference between    64-bit and 32-bit variants are negligable.  The difference in the    number of SSE registers is already handled by the target code.  */
end_comment

begin_comment
comment|/* General-purpose register mapping for native 32-bit code.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|amd64_native_gregset32_reg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|amd64_native_gregset32_num_regs
init|=
name|I386_NUM_GREGS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* General-purpose register mapping for native 64-bit code.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|amd64_native_gregset64_reg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|amd64_native_gregset64_num_regs
init|=
name|AMD64_NUM_GREGS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the offset of REGNUM within the appropriate native    general-purpose register set.  */
end_comment

begin_function
specifier|static
name|int
name|amd64_native_gregset_reg_offset
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|int
modifier|*
name|reg_offset
init|=
name|amd64_native_gregset64_reg_offset
decl_stmt|;
name|int
name|num_regs
init|=
name|amd64_native_gregset64_num_regs
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|32
condition|)
block|{
name|reg_offset
operator|=
name|amd64_native_gregset32_reg_offset
expr_stmt|;
name|num_regs
operator|=
name|amd64_native_gregset32_num_regs
expr_stmt|;
block|}
if|if
condition|(
name|num_regs
operator|>
name|NUM_REGS
condition|)
name|num_regs
operator|=
name|NUM_REGS
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
name|num_regs
operator|&&
name|regnum
operator|<
name|NUM_REGS
condition|)
return|return
name|reg_offset
index|[
name|regnum
index|]
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return whether the native general-purpose register set supplies    register REGNUM.  */
end_comment

begin_function
name|int
name|amd64_native_gregset_supplies_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
operator|(
name|amd64_native_gregset_reg_offset
argument_list|(
name|regnum
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Supply register REGNUM, whose contents are store in BUF, to    REGCACHE.  If REGNUM is -1, supply all appropriate registers.  */
end_comment

begin_function
name|void
name|amd64_supply_native_gregset
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_regcache_arch
argument_list|(
name|regcache
argument_list|)
decl_stmt|;
name|int
name|num_regs
init|=
name|amd64_native_gregset64_num_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|32
condition|)
name|num_regs
operator|=
name|amd64_native_gregset32_num_regs
expr_stmt|;
if|if
condition|(
name|num_regs
operator|>
name|NUM_REGS
condition|)
name|num_regs
operator|=
name|NUM_REGS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
name|int
name|offset
init|=
name|amd64_native_gregset_reg_offset
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Collect register REGNUM from REGCACHE and store its contents in    GREGS.  If REGNUM is -1, collect and store all appropriate    registers.  */
end_comment

begin_function
name|void
name|amd64_collect_native_gregset
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|gregs
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_regcache_arch
argument_list|(
name|regcache
argument_list|)
decl_stmt|;
name|int
name|num_regs
init|=
name|amd64_native_gregset64_num_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|32
condition|)
block|{
name|num_regs
operator|=
name|amd64_native_gregset32_num_regs
expr_stmt|;
comment|/* Make sure %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp, %esp and          %eip get zero-extended to 64 bits.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|I386_EIP_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
name|memset
argument_list|(
name|regs
operator|+
name|amd64_native_gregset_reg_offset
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Ditto for %cs, %ss, %ds, %es, %fs, and %gs.  */
for|for
control|(
name|i
operator|=
name|I386_CS_REGNUM
init|;
name|i
operator|<=
name|I386_GS_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
name|memset
argument_list|(
name|regs
operator|+
name|amd64_native_gregset_reg_offset
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_regs
operator|>
name|NUM_REGS
condition|)
name|num_regs
operator|=
name|NUM_REGS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
name|int
name|offset
init|=
name|amd64_native_gregset_reg_offset
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

