begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Concatenate variable number of strings.    Copyright (C) 1991, 1994 Free Software Foundation, Inc.    Written by Fred Fish @ Cygnus Support  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  NAME  	concat -- concatenate a variable number of strings  SYNOPSIS  	#include<varargs.h>  	char *concat (s1, s2, s3, ..., NULL)  DESCRIPTION  	Concatenate a variable number of strings and return the result 	in freshly malloc'd memory.  	Returns NULL if insufficient memory is available.  The argument 	list is terminated by the first NULL pointer encountered.  Pointers 	to empty strings are ignored.  NOTES  	This function uses xmalloc() which is expected to be a front end 	function to malloc() that deals with low memory situations.  In 	typical use, if malloc() returns NULL then xmalloc() diverts to an 	error handler routine which never returns, and thus xmalloc will 	never return a NULL pointer.  If the client application wishes to 	deal with low memory situations itself, it should supply an xmalloc 	that just directly invokes malloc and blindly returns whatever 	malloc returns. */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_function_decl
specifier|extern
name|size_t
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|strlen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NULLP
value|(char *)0
end_define

begin_comment
comment|/* VARARGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|concat
argument_list|(
specifier|const
name|char
operator|*
name|first
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|char
modifier|*
name|concat
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|char
modifier|*
name|newstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|va_list
name|args
decl_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|first
decl_stmt|;
endif|#
directive|endif
comment|/* First compute the size of the result and get sufficient memory. */
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|first
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|first
operator|==
name|NULLP
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|length
operator|=
name|strlen
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULLP
condition|)
block|{
name|length
operator|+=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now copy the individual pieces to the result string. */
if|if
condition|(
name|newstr
operator|!=
name|NULLP
condition|)
block|{
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|first
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
name|newstr
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULLP
condition|)
block|{
name|arg
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
operator|*
name|end
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULLP
condition|)
block|{
while|while
condition|(
operator|*
name|arg
condition|)
block|{
operator|*
name|end
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|end
operator|=
literal|'\000'
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|newstr
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_comment
comment|/* Simple little test driver. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\"\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"a\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"ab\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abc\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcd\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"ab"
argument_list|,
literal|"cd"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcde\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"ab"
argument_list|,
literal|"c"
argument_list|,
literal|"de"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcdef\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|""
argument_list|,
literal|"a"
argument_list|,
literal|""
argument_list|,
literal|"bcd"
argument_list|,
literal|"ef"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

