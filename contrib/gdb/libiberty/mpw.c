begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MPW-Unix compatibility library.    Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This should only be compiled and linked under MPW. */
end_comment

begin_include
include|#
directive|include
file|"mpw.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MW_HEADERS
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<Types.h>
end_include

begin_include
include|#
directive|include
file|<Files.h>
end_include

begin_include
include|#
directive|include
file|<Timer.h>
end_include

begin_comment
comment|/* Initialize to 0 at first, then set to errno_max() later.  */
end_comment

begin_decl_stmt
name|int
name|sys_nerr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug flag for pathname hacking.  Set this to one and rebuild. */
end_comment

begin_decl_stmt
name|int
name|DebugPI
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mpwify_filename
parameter_list|(
name|char
modifier|*
name|unixname
parameter_list|,
name|char
modifier|*
name|macname
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|in_middle
decl_stmt|,
name|terminate
init|=
literal|0
decl_stmt|;
comment|/* (should truncate 255 chars from end of name, not beginning) */
if|if
condition|(
name|strlen
argument_list|(
name|unixname
argument_list|)
operator|>
literal|255
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pathname \"%s\" is too long for Macs, truncating\n"
argument_list|,
name|unixname
argument_list|)
expr_stmt|;
name|terminate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Abs Unix path to abs Mac path. */
if|if
condition|(
operator|*
name|unixname
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|unixname
argument_list|,
literal|"/tmp/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A temporary name, make a more Mac-flavored tmpname. */
comment|/* A better choice would be {Boot}Trash:foo, but that would 	     require being able to identify the boot disk's and trashcan's 	     name.  Another option would be to have an env var, so user 	     can point it at a ramdisk. */
name|strncpy
argument_list|(
name|macname
argument_list|,
name|unixname
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminate
condition|)
name|macname
index|[
literal|255
index|]
operator|=
literal|'\0'
expr_stmt|;
name|macname
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|macname
index|[
literal|4
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume that the leading component is a valid disk name. */
name|strncpy
argument_list|(
name|macname
argument_list|,
name|unixname
operator|+
literal|1
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If this is a "Unix-only" pathname, assume relative. */
if|if
condition|(
name|strchr
argument_list|(
name|unixname
argument_list|,
literal|'/'
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|unixname
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|macname
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|strncpy
argument_list|(
name|macname
operator|+
literal|1
argument_list|,
name|unixname
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise copy it verbatim. */
comment|/* ... but if of the form ":/foo", lose the extra colon; 	     the slash will be made into a colon shortly. */
if|if
condition|(
name|unixname
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|unixname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|++
name|unixname
expr_stmt|;
name|strncpy
argument_list|(
name|macname
argument_list|,
name|unixname
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|terminate
condition|)
name|macname
index|[
literal|255
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macname
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|macname
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|macname
index|[
name|i
index|]
operator|=
literal|':'
expr_stmt|;
block|}
name|in_middle
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macname
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
comment|/* We're in the middle of the name when a char is not a colon. */
if|if
condition|(
name|macname
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
name|in_middle
operator|=
literal|1
expr_stmt|;
comment|/* Copy chars verbatim, *unless* the char is the first of a pair 	 of colons in the middle of a pathname. */
if|if
condition|(
operator|!
operator|(
name|in_middle
operator|&&
name|macname
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|macname
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
name|macname
index|[
name|j
operator|++
index|]
operator|=
name|macname
index|[
name|i
index|]
expr_stmt|;
block|}
name|macname
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If we have a trailing ":.", make it into a ":". */
if|if
condition|(
name|j
operator|>=
literal|2
operator|&&
name|macname
index|[
name|j
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|macname
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|macname
index|[
name|j
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|DebugPI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# Made \"%s\"\n"
argument_list|,
name|unixname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# into \"%s\"\n"
argument_list|,
name|macname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* MPW-flavored basename finder. */
end_comment

begin_function
name|char
modifier|*
name|mpw_basename
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|base
init|=
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|++
operator|==
literal|':'
condition|)
block|{
name|base
operator|=
name|name
expr_stmt|;
block|}
block|}
return|return
name|base
return|;
block|}
end_function

begin_comment
comment|/* Mixed MPW/Unix basename finder.  This can be led astray by    filenames with slashes in them and come up with a basename that    either corresponds to no file or (worse) to some other file, so    should only be tried if other methods of finding a file via a    basename have failed.  */
end_comment

begin_function
name|char
modifier|*
name|mpw_mixed_basename
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|base
init|=
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|||
operator|*
name|name
operator|==
literal|':'
condition|)
block|{
name|base
operator|=
name|name
operator|+
literal|1
expr_stmt|;
block|}
operator|++
name|name
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
end_function

begin_comment
comment|/* This function is fopen() modified to create files that are type TEXT    or 'BIN ', and always of type 'MPS '.  */
end_comment

begin_function
name|FILE
modifier|*
name|mpw_fopen
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
undef|#
directive|undef
name|fopen
name|int
name|errnum
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|tmpname
index|[
literal|256
index|]
decl_stmt|;
name|mpwify_filename
argument_list|(
name|name
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|tmpname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|errno
expr_stmt|;
comment|/* If writing, need to set type and creator usefully. */
if|if
condition|(
name|strchr
argument_list|(
name|mode
argument_list|,
literal|'w'
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pname
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|tmpname
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|OSErr
name|e
decl_stmt|;
name|struct
name|FInfo
name|fi
decl_stmt|;
name|pname
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pname
operator|+
literal|1
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|e
operator|=
name|GetFInfo
argument_list|(
operator|(
name|ConstStr255Param
operator|)
name|pname
argument_list|,
literal|0
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
comment|/* should do spiffier error handling */
if|if
condition|(
name|e
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GetFInfo returns %d\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|mode
argument_list|,
literal|'b'
argument_list|)
condition|)
block|{
name|fi
operator|.
name|fdType
operator|=
operator|(
name|OSType
operator|)
literal|'BIN '
expr_stmt|;
block|}
else|else
block|{
name|fi
operator|.
name|fdType
operator|=
operator|(
name|OSType
operator|)
literal|'TEXT'
expr_stmt|;
block|}
name|fi
operator|.
name|fdCreator
operator|=
operator|(
name|OSType
operator|)
literal|'MPS '
expr_stmt|;
name|e
operator|=
name|SetFInfo
argument_list|(
operator|(
name|ConstStr255Param
operator|)
name|pname
argument_list|,
literal|0
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SetFInfo returns %d\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errno
operator|=
name|errnum
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* This is a version of fseek() modified to fill the file with zeros    if seeking past the end of it.  */
end_comment

begin_define
define|#
directive|define
name|ZEROBLKSIZE
value|4096
end_define

begin_decl_stmt
name|char
name|zeros
index|[
name|ZEROBLKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mpw_fseek
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
undef|#
directive|undef
name|fseek
name|int
name|cursize
decl_stmt|,
name|numleft
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|whence
operator|==
name|SEEK_SET
condition|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|cursize
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|cursize
condition|)
block|{
name|numleft
operator|=
name|offset
operator|-
name|cursize
expr_stmt|;
while|while
condition|(
name|numleft
operator|>
name|ZEROBLKSIZE
condition|)
block|{
comment|/* This might fail, should check for that. */
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|zeros
argument_list|,
literal|1
argument_list|,
name|ZEROBLKSIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|numleft
operator|-=
name|ZEROBLKSIZE
expr_stmt|;
block|}
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|zeros
argument_list|,
literal|1
argument_list|,
name|numleft
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fseek
argument_list|(
name|fp
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mpw_fread
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|nitems
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
undef|#
directive|undef
name|fread
name|int
name|rslt
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|fread
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|nitems
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|rslt
return|;
block|}
end_function

begin_function
name|int
name|mpw_fwrite
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|nitems
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
undef|#
directive|undef
name|fwrite
name|int
name|rslt
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|fwrite
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|nitems
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|rslt
return|;
block|}
end_function

begin_function
name|int
name|link
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"link not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fork
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fork not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vfork
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vfork not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pipe
parameter_list|(
name|int
modifier|*
name|fd
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pipe not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MW_HEADERS
end_ifndef

begin_function
name|int
name|execvp
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execvp not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|execv
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execv not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|kill
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kill not available!\n"
argument_list|)
expr_stmt|;
name|mpw_abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wait
parameter_list|(
name|int
modifier|*
name|status
parameter_list|)
block|{
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MW_HEADERS
end_ifndef

begin_function
name|int
name|sleep
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
name|unsigned
name|long
name|start_time
decl_stmt|,
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|start_time
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|>
name|start_time
operator|+
name|seconds
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|putenv
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
comment|/* The GCC driver calls this to do things for collect2, but we      don't care about collect2. */
block|}
end_function

begin_function
name|int
name|chmod
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* Pretend it was all OK. */
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MW_HEADERS
end_ifndef

begin_function
name|int
name|getuid
parameter_list|()
block|{
comment|/* One value is as good as another... */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|getgid
parameter_list|()
block|{
comment|/* One value is as good as another... */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Instead of coredumping, which is not a normal Mac facility, we    drop into Macsbug.  If we then "g" from Macsbug, the program will    exit cleanly. */
end_comment

begin_function
name|void
name|mpw_abort
parameter_list|()
block|{
comment|/* Make sure no output still buffered up, then zap into MacsBug. */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"## Abort! ##\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MPW_SADE
name|SysError
argument_list|(
literal|8005
argument_list|)
expr_stmt|;
else|#
directive|else
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* "g" in MacsBug will then cause a regular error exit. */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Imitation getrusage based on the ANSI clock() function. */
end_comment

begin_function
name|int
name|getrusage
parameter_list|(
name|int
name|who
parameter_list|,
name|struct
name|rusage
modifier|*
name|rusage
parameter_list|)
block|{
name|int
name|clk
init|=
name|clock
argument_list|()
decl_stmt|;
if|#
directive|if
literal|0
block|rusage->ru_utime.tv_sec = clk / CLOCKS_PER_SEC;   rusage->ru_utime.tv_usec = ((clk * 1000) / CLOCKS_PER_SEC) * 1000;   rusage->ru_stime.tv_sec = 0;   rusage->ru_stime.tv_usec = 0;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|sbrk
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MW_HEADERS
end_ifndef

begin_function
name|int
name|isatty
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is inherited from Timothy Murray's Posix library. */
end_comment

begin_include
include|#
directive|include
file|"utime.h"
end_include

begin_function
name|int
name|utime
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|utimbuf
modifier|*
name|times
parameter_list|)
block|{
name|CInfoPBRec
name|cipbr
decl_stmt|;
name|HFileInfo
modifier|*
name|fpb
init|=
operator|(
name|HFileInfo
operator|*
operator|)
operator|&
name|cipbr
decl_stmt|;
name|DirInfo
modifier|*
name|dpb
init|=
operator|(
name|DirInfo
operator|*
operator|)
operator|&
name|cipbr
decl_stmt|;
name|unsigned
name|char
name|pname
index|[
literal|256
index|]
decl_stmt|;
name|short
name|err
decl_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|c2pstr
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|dpb
operator|->
name|ioDrDirID
operator|=
literal|0L
expr_stmt|;
name|fpb
operator|->
name|ioNamePtr
operator|=
name|pname
expr_stmt|;
name|fpb
operator|->
name|ioVRefNum
operator|=
literal|0
expr_stmt|;
name|fpb
operator|->
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|fpb
operator|->
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|PBGetCatInfo
argument_list|(
operator|&
name|cipbr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|noErr
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dpb
operator|->
name|ioDrDirID
operator|=
literal|0L
expr_stmt|;
name|fpb
operator|->
name|ioFlMdDat
operator|=
name|times
operator|->
name|modtime
expr_stmt|;
name|fpb
operator|->
name|ioFlCrDat
operator|=
name|times
operator|->
name|actime
expr_stmt|;
name|err
operator|=
name|PBSetCatInfo
argument_list|(
operator|&
name|cipbr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|noErr
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mkdir
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|rmdir
parameter_list|()
block|{
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|chown
argument_list|()
end_macro

begin_block
block|{
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|myenviron
index|[]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
init|=
name|myenviron
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MW_HEADERS
end_ifndef

begin_comment
comment|/* Minimal 'stat' emulation: tells directories from files and    gives length and mtime.     Derived from code written by Guido van Rossum, CWI, Amsterdam    and placed by him in the public domain.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|__uid
decl_stmt|,
name|__gid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__uid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__gid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bits in ioFlAttrib: */
end_comment

begin_define
define|#
directive|define
name|LOCKBIT
value|(1<<0)
end_define

begin_comment
comment|/* File locked */
end_comment

begin_define
define|#
directive|define
name|DIRBIT
value|(1<<4)
end_define

begin_comment
comment|/* It's a directory */
end_comment

begin_comment
comment|/* Macified "stat" in which filename is given relative to a directory,    specified by long DirID.  */
end_comment

begin_function
specifier|static
name|int
name|_stat
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|long
name|dirid
parameter_list|,
name|struct
name|stat
modifier|*
name|buf
parameter_list|)
block|{
name|CInfoPBRec
name|cipbr
decl_stmt|;
name|HFileInfo
modifier|*
name|fpb
init|=
operator|(
name|HFileInfo
operator|*
operator|)
operator|&
name|cipbr
decl_stmt|;
name|DirInfo
modifier|*
name|dpb
init|=
operator|(
name|DirInfo
operator|*
operator|)
operator|&
name|cipbr
decl_stmt|;
name|Str255
name|pname
decl_stmt|;
name|short
name|err
decl_stmt|;
comment|/* Make a temp copy of the name and pascalize. */
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|c2pstr
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|cipbr
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|=
name|dirid
expr_stmt|;
name|cipbr
operator|.
name|hFileInfo
operator|.
name|ioNamePtr
operator|=
name|pname
expr_stmt|;
name|cipbr
operator|.
name|hFileInfo
operator|.
name|ioVRefNum
operator|=
literal|0
expr_stmt|;
name|cipbr
operator|.
name|hFileInfo
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|cipbr
operator|.
name|hFileInfo
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|PBGetCatInfo
argument_list|(
operator|&
name|cipbr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|noErr
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Mac files are readable if they can be accessed at all. */
name|buf
operator|->
name|st_mode
operator|=
literal|0444
expr_stmt|;
comment|/* Mark unlocked files as writeable. */
if|if
condition|(
operator|!
operator|(
name|fpb
operator|->
name|ioFlAttrib
operator|&
name|LOCKBIT
operator|)
condition|)
name|buf
operator|->
name|st_mode
operator||=
literal|0222
expr_stmt|;
if|if
condition|(
name|fpb
operator|->
name|ioFlAttrib
operator|&
name|DIRBIT
condition|)
block|{
comment|/* Mark directories as "executable". */
name|buf
operator|->
name|st_mode
operator||=
literal|0111
operator||
name|S_IFDIR
expr_stmt|;
name|buf
operator|->
name|st_size
operator|=
name|dpb
operator|->
name|ioDrNmFls
expr_stmt|;
name|buf
operator|->
name|st_rsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
comment|/* Mark apps as "executable". */
if|if
condition|(
name|fpb
operator|->
name|ioFlFndrInfo
operator|.
name|fdType
operator|==
literal|'APPL'
condition|)
name|buf
operator|->
name|st_mode
operator||=
literal|0111
expr_stmt|;
comment|/* Fill in the sizes of data and resource forks. */
name|buf
operator|->
name|st_size
operator|=
name|fpb
operator|->
name|ioFlLgLen
expr_stmt|;
name|buf
operator|->
name|st_rsize
operator|=
name|fpb
operator|->
name|ioFlRLgLen
expr_stmt|;
block|}
comment|/* Fill in various times. */
name|buf
operator|->
name|st_atime
operator|=
name|fpb
operator|->
name|ioFlCrDat
expr_stmt|;
name|buf
operator|->
name|st_mtime
operator|=
name|fpb
operator|->
name|ioFlMdDat
expr_stmt|;
name|buf
operator|->
name|st_ctime
operator|=
name|fpb
operator|->
name|ioFlCrDat
expr_stmt|;
comment|/* Set up an imitation inode number. */
name|buf
operator|->
name|st_ino
operator|=
operator|(
name|unsigned
name|short
operator|)
name|fpb
operator|->
name|ioDirID
expr_stmt|;
comment|/* Set up an imitation device. */
name|GetVRefNum
argument_list|(
name|buf
operator|->
name|st_ino
argument_list|,
operator|&
name|buf
operator|->
name|st_dev
argument_list|)
expr_stmt|;
name|buf
operator|->
name|st_uid
operator|=
name|__uid
expr_stmt|;
name|buf
operator|->
name|st_gid
operator|=
name|__gid
expr_stmt|;
comment|/*  buf->st_FlFndrInfo = fpb->ioFlFndrInfo;  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* stat() sets up an empty dirid. */
end_comment

begin_function
name|int
name|stat
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|rslt
decl_stmt|,
name|errnum
decl_stmt|;
name|char
name|tmpname
index|[
literal|256
index|]
decl_stmt|;
name|mpwify_filename
argument_list|(
name|path
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugPI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# stat (%s, %x)"
argument_list|,
name|tmpname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|_stat
argument_list|(
name|tmpname
argument_list|,
literal|0L
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|DebugPI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> %d"
argument_list|,
name|rslt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (errno is %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rslt
operator|!=
literal|0
condition|)
name|errno
operator|=
name|errnum
expr_stmt|;
return|return
name|rslt
return|;
block|}
end_function

begin_function
name|int
name|fstat
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|buf
parameter_list|)
block|{
name|FCBPBRec
name|fcb
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Str255
name|pathname
decl_stmt|;
name|long
name|dirid
init|=
literal|0L
decl_stmt|,
name|temp
decl_stmt|;
name|long
name|rslt
decl_stmt|,
name|errnum
decl_stmt|;
name|short
name|err
decl_stmt|;
if|if
condition|(
name|DebugPI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# fstat (%d, %x)"
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pathname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FIOFNAME
comment|/* Use an MPW-specific ioctl to get the pathname associated with      the file descriptor.  */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOFNAME
argument_list|,
operator|(
name|long
operator|*
operator|)
name|pathname
argument_list|)
expr_stmt|;
else|#
directive|else
name|you
name|lose
endif|#
directive|endif
if|if
condition|(
name|DebugPI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (name is %s)"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|dirid
operator|=
literal|0L
comment|/* fcb.ioFCBParID */
expr_stmt|;
name|rslt
operator|=
name|_stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pathname
argument_list|,
name|dirid
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|DebugPI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> %d"
argument_list|,
name|rslt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (errno is %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rslt
operator|!=
literal|0
condition|)
name|errno
operator|=
name|errnum
expr_stmt|;
return|return
name|rslt
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* n USE_MW_HEADERS */
end_comment

begin_macro
name|chdir
argument_list|()
end_macro

begin_block
block|{
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getcwd
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* This should probably be more elaborate for MPW. */
end_comment

begin_function
name|char
modifier|*
name|getpwd
parameter_list|()
block|{
return|return
literal|":"
return|;
block|}
end_function

begin_function
name|int
name|mpw_open
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|arg2
parameter_list|,
name|int
name|arg3
parameter_list|)
block|{
undef|#
directive|undef
name|open
name|int
name|fd
decl_stmt|,
name|errnum
init|=
literal|0
decl_stmt|;
name|char
name|tmpname
index|[
literal|256
index|]
decl_stmt|;
name|mpwify_filename
argument_list|(
name|filename
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|DebugPI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# open (%s, %d, %d)"
argument_list|,
name|tmpname
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (errno is %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|errno
operator|=
name|errnum
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_function
name|int
name|mpw_access
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|)
block|{
undef|#
directive|undef
name|access
name|int
name|rslt
decl_stmt|,
name|errnum
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|tmpname
index|[
literal|256
index|]
decl_stmt|;
name|mpwify_filename
argument_list|(
name|filename
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|R_OK
operator|||
name|cmd
operator|&
name|X_OK
condition|)
block|{
name|rslt
operator|=
name|stat
argument_list|(
name|tmpname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|rslt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|004
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|&
name|R_OK
operator|)
operator|)
operator|||
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|002
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|&
name|W_OK
operator|)
operator|)
operator|||
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|001
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|&
name|X_OK
operator|)
operator|)
condition|)
block|{
name|rslt
operator|=
operator|-
literal|1
expr_stmt|;
name|errnum
operator|=
name|EACCES
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DebugPI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# mpw_access (%s, %d)"
argument_list|,
name|tmpname
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> %d"
argument_list|,
name|rslt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (errno is %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rslt
operator|!=
literal|0
condition|)
name|errno
operator|=
name|errnum
expr_stmt|;
return|return
name|rslt
return|;
block|}
end_function

begin_comment
comment|/* The MPW library creat() has no mode argument. */
end_comment

begin_function
name|int
name|mpw_creat
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
comment|/* mode_t */
name|int
name|mode
parameter_list|)
block|{
undef|#
directive|undef
name|creat
ifdef|#
directive|ifdef
name|USE_MW_HEADERS
return|return
name|creat
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
return|;
else|#
directive|else
return|return
name|creat
argument_list|(
name|path
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is a hack to get control in an MPW tool before it crashes the    machine.  */
end_comment

begin_macro
name|mpw_special_init
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"DEBUG"
argument_list|)
condition|)
name|DebugStr
argument_list|(
literal|"\pat beginning of program"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|current_umask
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|umask
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|oldmask
init|=
name|current_umask
decl_stmt|;
name|current_umask
operator|=
name|mask
expr_stmt|;
return|return
name|oldmask
return|;
block|}
end_function

begin_comment
comment|/* Cursor-spinning stuff that includes metering of spin rate and delays.  */
end_comment

begin_comment
comment|/* Nonzero when cursor spinning has been set up properly.  */
end_comment

begin_decl_stmt
name|int
name|cursor_inited
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if spin should be measured and excessive delays reported.  */
end_comment

begin_decl_stmt
name|int
name|measure_spin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if spin histogram and rate data should be written out.  */
end_comment

begin_decl_stmt
name|int
name|dump_spin_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|warning_threshold
init|=
literal|400000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bucket_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bucket_power
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|numbuckets
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|delay_counts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|overflow_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|current_progress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UnsignedWide
name|last_microseconds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_spin_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_spin_line
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|warn_if_spin_delay
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|long
name|diff
decl_stmt|,
name|ix
decl_stmt|;
name|UnsignedWide
name|now
decl_stmt|;
name|Microseconds
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|diff
operator|=
name|now
operator|.
name|lo
operator|-
name|last_microseconds
operator|.
name|lo
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|warning_threshold
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# %s: %ld.%06ld sec delay getting from %s:%d to %s:%d\n"
argument_list|,
operator|(
name|current_progress
condition|?
name|current_progress
else|:
literal|""
operator|)
argument_list|,
name|diff
operator|/
literal|1000000
argument_list|,
name|diff
operator|%
literal|1000000
argument_list|,
name|last_spin_file
argument_list|,
name|last_spin_line
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_spin_data
condition|)
block|{
if|if
condition|(
name|diff
operator|>=
literal|0
condition|)
block|{
name|ix
operator|=
name|diff
operator|>>
name|bucket_power
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
literal|0
operator|&&
name|ix
operator|<
name|numbuckets
operator|&&
name|delay_counts
operator|!=
name|NULL
condition|)
operator|++
name|delay_counts
index|[
name|ix
index|]
expr_stmt|;
else|else
operator|++
name|overflow_count
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"raw diff is %ld (?)\n"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|record_for_spin_delay
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|Microseconds
argument_list|(
operator|&
name|last_microseconds
argument_list|)
expr_stmt|;
name|last_spin_file
operator|=
name|file
expr_stmt|;
name|last_spin_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpw_start_progress
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|n
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|measure
decl_stmt|,
modifier|*
name|threshold
decl_stmt|;
if|if
condition|(
operator|!
name|cursor_inited
condition|)
block|{
name|InitCursorCtl
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|cursor_inited
operator|=
literal|1
expr_stmt|;
name|record_for_spin_delay
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|measure
operator|=
name|getenv
argument_list|(
literal|"MEASURE_SPIN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|measure
operator|!=
name|NULL
operator|&&
name|measure
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|measure_spin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|measure
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|dump_spin_data
operator|=
literal|1
expr_stmt|;
block|}
name|threshold
operator|=
name|getenv
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|"SPIN_WARN_THRESHOLD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
operator|!=
name|NULL
operator|&&
name|threshold
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|warning_threshold
operator|=
name|atol
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_spin_data
condition|)
block|{
if|if
condition|(
name|delay_counts
operator|==
name|NULL
condition|)
name|delay_counts
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|numbuckets
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbuckets
condition|;
operator|++
name|i
control|)
name|delay_counts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|overflow_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|current_progress
operator|=
name|str
expr_stmt|;
name|sys_nerr
operator|=
name|errno_max
argument_list|()
expr_stmt|;
name|mpw_special_init
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpw_progress
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|SpinCursor
argument_list|(
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpw_progress_measured
parameter_list|(
name|int
name|n
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|measure_spin
condition|)
name|warn_if_spin_delay
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|SpinCursor
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|measure_spin
condition|)
name|record_for_spin_delay
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpw_end_progress
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|long
name|i
decl_stmt|,
name|delay
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0
decl_stmt|,
name|avgdelay
decl_stmt|,
name|spinrate
decl_stmt|;
name|long
name|curpower
init|=
literal|0
decl_stmt|,
name|curgroup
init|=
literal|0
decl_stmt|;
comment|/* Warn if it's been a while since the last spin.  */
if|if
condition|(
name|measure_spin
condition|)
name|warn_if_spin_delay
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Dump all the nonzero delay counts and an approximation of the delay.  */
if|if
condition|(
name|dump_spin_data
operator|&&
name|delay_counts
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbuckets
condition|;
operator|++
name|i
control|)
block|{
name|delay
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|bucket_size
expr_stmt|;
name|sum
operator|+=
name|delay_counts
index|[
name|i
index|]
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|count
operator|+=
name|delay_counts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|delay
operator|<=
operator|(
literal|1
operator|<<
name|curpower
operator|)
condition|)
block|{
name|curgroup
operator|+=
name|delay_counts
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|curgroup
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# %s: %d delays between %ld.%06ld and %ld.%06ld sec\n"
argument_list|,
operator|(
name|str
condition|?
name|str
else|:
literal|""
operator|)
argument_list|,
name|curgroup
argument_list|,
operator|(
literal|1
operator|<<
name|curpower
operator|)
operator|/
literal|1000000
argument_list|,
operator|(
literal|1
operator|<<
name|curpower
operator|)
operator|%
literal|1000000
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|curpower
operator|+
literal|1
operator|)
operator|)
operator|/
literal|1000000
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|curpower
operator|+
literal|1
operator|)
operator|)
operator|%
literal|1000000
argument_list|)
expr_stmt|;
operator|++
name|curpower
expr_stmt|;
name|curgroup
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|avgdelay
operator|=
operator|(
name|sum
operator|*
name|bucket_size
operator|)
operator|/
name|count
expr_stmt|;
name|spinrate
operator|=
literal|1000000
operator|/
name|avgdelay
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# %s: Average spin rate is %d times/sec\n"
argument_list|,
operator|(
name|str
condition|?
name|str
else|:
literal|""
operator|)
argument_list|,
name|spinrate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PROGRESS_TEST
end_ifdef

begin_comment
comment|/* Test program.  */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|x
init|=
literal|1.0
decl_stmt|,
name|y
init|=
literal|2.4
decl_stmt|;
name|long
name|start
init|=
name|Microseconds
argument_list|()
decl_stmt|,
name|tm
decl_stmt|;
name|FIXME
name|START_PROGRESS
argument_list|(
literal|"hi"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|i
operator|*
literal|100
operator|)
condition|;
operator|++
name|j
control|)
block|{
name|x
operator|+=
operator|(
name|x
operator|*
name|y
operator|)
operator|/
name|j
expr_stmt|;
block|}
block|}
name|END_PROGRESS
argument_list|(
literal|"hi"
argument_list|)
expr_stmt|;
name|tm
operator|=
name|Microseconds
argument_list|()
operator|-
name|start
expr_stmt|;
name|printf
argument_list|(
literal|"Total time is %d.%d secs\n"
argument_list|,
name|tm
operator|/
literal|1000000
argument_list|,
name|tm
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MW_HEADERS
end_ifdef

begin_comment
comment|/* Empty definitions for Metrowerks' SIOUX console library. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CONSOLE__
end_ifndef

begin_include
include|#
directive|include
file|<console.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|short
name|InstallConsole
parameter_list|(
name|short
name|fd
parameter_list|)
block|{
pragma|#
directive|pragma
name|unused
name|(
name|fd
name|)
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|RemoveConsole
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|long
name|WriteCharsToConsole
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|n
parameter_list|)
block|{
pragma|#
directive|pragma
name|unused
name|(
name|buf
name|,
name|n
name|)
return|return
literal|0
return|;
block|}
end_function

begin_function
name|long
name|ReadCharsFromConsole
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|n
parameter_list|)
block|{
pragma|#
directive|pragma
name|unused
name|(
name|buf
name|,
name|n
name|)
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|extern
name|char
modifier|*
name|__ttyname
parameter_list|(
name|long
name|fd
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|__devicename
init|=
literal|"null device"
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<=
literal|2
condition|)
return|return
operator|(
name|__devicename
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

