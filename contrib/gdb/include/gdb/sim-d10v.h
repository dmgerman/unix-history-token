begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file defines the interface between the d10v simulator and gdb.     Copyright 1999, 2002 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIM_D10V_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIM_D10V_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
comment|// }
endif|#
directive|endif
comment|/* GDB interprets addresses as:     0x00xxxxxx: Physical unified memory segment     (Unified memory)    0x01xxxxxx: Physical instruction memory segment (On-chip insn memory)    0x02xxxxxx: Physical data memory segment        (On-chip data memory)    0x10xxxxxx: Logical data address segment        (DMAP translated memory)    0x11xxxxxx: Logical instruction address segment (IMAP translated memory)     The remote d10v board interprets addresses as:     0x00xxxxxx: Physical unified memory segment     (Unified memory)    0x01xxxxxx: Physical instruction memory segment (On-chip insn memory)    0x02xxxxxx: Physical data memory segment        (On-chip data memory)     The following translate a virtual DMAP/IMAP offset into a physical    memory segment assigning the translated address to PHYS.  Since a    memory access may cross a page boundrary the number of bytes for    which the translation is applicable (or 0 for an invalid virtual    offset) is returned. */
enum|enum
block|{
name|SIM_D10V_MEMORY_UNIFIED
init|=
literal|0x00000000
block|,
name|SIM_D10V_MEMORY_INSN
init|=
literal|0x01000000
block|,
name|SIM_D10V_MEMORY_DATA
init|=
literal|0x02000000
block|,
name|SIM_D10V_MEMORY_DMAP
init|=
literal|0x10000000
block|,
name|SIM_D10V_MEMORY_IMAP
init|=
literal|0x11000000
block|}
enum|;
specifier|extern
name|unsigned
name|long
name|sim_d10v_translate_dmap_addr
argument_list|(
name|unsigned
name|long
name|offset
argument_list|,
name|int
name|nr_bytes
argument_list|,
name|unsigned
name|long
operator|*
name|phys
argument_list|,
name|void
operator|*
name|regcache
argument_list|,
name|unsigned
name|long
argument_list|(
argument|*dmap_register
argument_list|)
operator|(
name|void
operator|*
name|regcache
operator|,
name|int
name|reg_nr
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|unsigned
name|long
name|sim_d10v_translate_imap_addr
argument_list|(
name|unsigned
name|long
name|offset
argument_list|,
name|int
name|nr_bytes
argument_list|,
name|unsigned
name|long
operator|*
name|phys
argument_list|,
name|void
operator|*
name|regcache
argument_list|,
name|unsigned
name|long
argument_list|(
argument|*imap_register
argument_list|)
operator|(
name|void
operator|*
name|regcache
operator|,
name|int
name|reg_nr
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|unsigned
name|long
name|sim_d10v_translate_addr
argument_list|(
name|unsigned
name|long
name|vaddr
argument_list|,
name|int
name|nr_bytes
argument_list|,
name|unsigned
name|long
operator|*
name|phys
argument_list|,
name|void
operator|*
name|regcache
argument_list|,
name|unsigned
name|long
argument_list|(
argument|*dmap_register
argument_list|)
operator|(
name|void
operator|*
name|regcache
operator|,
name|int
name|reg_nr
operator|)
argument_list|,
name|unsigned
name|long
argument_list|(
argument|*imap_register
argument_list|)
operator|(
name|void
operator|*
name|regcache
operator|,
name|int
name|reg_nr
operator|)
argument_list|)
decl_stmt|;
comment|/* The simulator makes use of the following register information. */
enum|enum
name|sim_d10v_regs
block|{
name|SIM_D10V_R0_REGNUM
block|,
name|SIM_D10V_R1_REGNUM
block|,
name|SIM_D10V_R2_REGNUM
block|,
name|SIM_D10V_R3_REGNUM
block|,
name|SIM_D10V_R4_REGNUM
block|,
name|SIM_D10V_R5_REGNUM
block|,
name|SIM_D10V_R6_REGNUM
block|,
name|SIM_D10V_R7_REGNUM
block|,
name|SIM_D10V_R8_REGNUM
block|,
name|SIM_D10V_R9_REGNUM
block|,
name|SIM_D10V_R10_REGNUM
block|,
name|SIM_D10V_R11_REGNUM
block|,
name|SIM_D10V_R12_REGNUM
block|,
name|SIM_D10V_R13_REGNUM
block|,
name|SIM_D10V_R14_REGNUM
block|,
name|SIM_D10V_R15_REGNUM
block|,
name|SIM_D10V_CR0_REGNUM
block|,
name|SIM_D10V_CR1_REGNUM
block|,
name|SIM_D10V_CR2_REGNUM
block|,
name|SIM_D10V_CR3_REGNUM
block|,
name|SIM_D10V_CR4_REGNUM
block|,
name|SIM_D10V_CR5_REGNUM
block|,
name|SIM_D10V_CR6_REGNUM
block|,
name|SIM_D10V_CR7_REGNUM
block|,
name|SIM_D10V_CR8_REGNUM
block|,
name|SIM_D10V_CR9_REGNUM
block|,
name|SIM_D10V_CR10_REGNUM
block|,
name|SIM_D10V_CR11_REGNUM
block|,
name|SIM_D10V_CR12_REGNUM
block|,
name|SIM_D10V_CR13_REGNUM
block|,
name|SIM_D10V_CR14_REGNUM
block|,
name|SIM_D10V_CR15_REGNUM
block|,
name|SIM_D10V_A0_REGNUM
block|,
name|SIM_D10V_A1_REGNUM
block|,
name|SIM_D10V_SPI_REGNUM
block|,
name|SIM_D10V_SPU_REGNUM
block|,
name|SIM_D10V_IMAP0_REGNUM
block|,
name|SIM_D10V_IMAP1_REGNUM
block|,
name|SIM_D10V_DMAP0_REGNUM
block|,
name|SIM_D10V_DMAP1_REGNUM
block|,
name|SIM_D10V_DMAP2_REGNUM
block|,
name|SIM_D10V_DMAP3_REGNUM
block|,
name|SIM_D10V_TS2_DMAP_REGNUM
block|}
enum|;
enum|enum
block|{
name|SIM_D10V_NR_R_REGS
init|=
literal|16
block|,
name|SIM_D10V_NR_A_REGS
init|=
literal|2
block|,
name|SIM_D10V_NR_IMAP_REGS
init|=
literal|2
block|,
name|SIM_D10V_NR_DMAP_REGS
init|=
literal|4
block|,
name|SIM_D10V_NR_CR_REGS
init|=
literal|16
block|}
enum|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

