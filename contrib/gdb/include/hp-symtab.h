begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions and structures for reading debug symbols from the    native HP C compiler.     Written by the Center for Software Science at the University of Utah    and by Cygnus Support.     Copyright 1994 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HP_SYMTAB_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|HP_SYMTAB_INCLUDED
end_define

begin_comment
comment|/* General information:     This header file defines and describes only the basic data structures    necessary to read debug symbols produced by the HP C compiler using the    SOM object file format.  Definitions and structures used by other compilers    for other languages or object file formats may be missing.    (For a full description of the debug format, ftp hpux-symtab.h from    jaguar.cs.utah.edu:/dist).      Debug symbols are contained entirely within an unloadable space called    $DEBUG$.  $DEBUG$ contains several subspaces which group related    debug symbols.     $GNTT$ contains information for global variables, types and contants.     $LNTT$ contains information for procedures (including nesting), scoping    information, local variables, types, and constants.     $SLT$ contains source line information so that code addresses may be    mapped to source lines.     $VT$ contains various strings and constants for named objects (variables,    typedefs, functions, etc).  Strings are stored as null-terminated character    lists.  Constants always begin on word boundaries.  The first byte of    the VT must be zero (a null string).     $XT$ is not currently used by GDB.     Many structures within the subspaces point to other structures within    the same subspace, or to structures within a different subspace.  These    pointers are represented as a structure index from the beginning of    the appropriate subspace.  */
end_comment

begin_comment
comment|/* Used to describe where a constant is stored.  */
end_comment

begin_enum
enum|enum
name|location_type
block|{
name|LOCATION_IMMEDIATE
block|,
name|LOCATION_PTR
block|,
name|LOCATION_VT
block|, }
enum|;
end_enum

begin_comment
comment|/* Languages supported by this debug format.  Within the data structures    this type is limited to 4 bits for a maximum of 16 languages.  */
end_comment

begin_enum
enum|enum
name|hp_language
block|{
name|HP_LANGUAGE_UNKNOWN
block|,
name|HP_LANGUAGE_C
block|,
name|HP_LANGUAGE_F77
block|,
name|HP_LANGUAGE_PASCAL
block|,
name|HP_LANGUAGE_COBOL
block|,
name|HP_LANGUAGE_BASIC
block|,
name|HP_LANGUAGE_ADA
block|,
name|HP_LANGUAGE_CPLUSPLUS
block|, }
enum|;
end_enum

begin_comment
comment|/* Basic data types available in this debug format.  Within the data    structures this type is limited to 5 bits for a maximum of 32 basic    data types.  */
end_comment

begin_enum
enum|enum
name|hp_type
block|{
name|HP_TYPE_UNDEFINED
block|,
name|HP_TYPE_BOOLEAN
block|,
name|HP_TYPE_CHAR
block|,
name|HP_TYPE_INT
block|,
name|HP_TYPE_UNSIGNED_INT
block|,
name|HP_TYPE_REAL
block|,
name|HP_TYPE_COMPLEX
block|,
name|HP_TYPE_STRING200
block|,
name|HP_TYPE_LONGSTRING200
block|,
name|HP_TYPE_TEXT
block|,
name|HP_TYPE_FLABEL
block|,
name|HP_TYPE_FTN_STRING_SPEC
block|,
name|HP_TYPE_MOD_STRING_SPEC
block|,
name|HP_TYPE_PACKED_DECIMAL
block|,
name|HP_TYPE_REAL_3000
block|,
name|HP_TYPE_MOD_STRING_3000
block|,
name|HP_TYPE_ANYPOINTER
block|,
name|HP_TYPE_GLOBAL_ANYPOINTER
block|,
name|HP_TYPE_LOCAL_ANYPOINTER
block|,
name|HP_TYPE_COMPLEXS3000
block|,
name|HP_TYPE_FTN_STRING_S300_COMPAT
block|,
name|HP_TYPE_FTN_STRING_VAX_COMPAT
block|,
name|HP_TYPE_BOOLEAN_S300_COMPAT
block|,
name|HP_TYPE_BOOLEAN_VAX_COMPAT
block|,
name|HP_TYPE_WIDE_CHAR
block|,
name|HP_TYPE_LONG
block|,
name|HP_TYPE_UNSIGNED_LONG
block|,
name|HP_TYPE_DOUBLE
block|,
name|HP_TYPE_TEMPLATE_ARG
block|, }
enum|;
end_enum

begin_comment
comment|/* An immediate name and type table entry.     extension and immediate will always be one.    global will always be zero.    hp_type is the basic type this entry describes.    bitlength is the length in bits for the basic type.  */
end_comment

begin_struct
struct|struct
name|dnttp_immediate
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|immediate
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|type
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|bitlength
range|:
literal|24
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A nonimmediate name and type table entry.     extension will always be one.    immediate will always be zero.    if global is zero, this entry points into the LNTT    if global is one, this entry points into the GNTT    index is the index within the GNTT or LNTT for this entry.  */
end_comment

begin_struct
struct|struct
name|dnttp_nonimmediate
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|immediate
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|index
range|:
literal|29
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A pointer to an entry in the GNTT and LNTT tables.  It has two    forms depending on the type being described.     The immediate form is used for simple entries and is one    word.     The nonimmediate form is used for complex entries and contains    an index into the LNTT or GNTT which describes the entire type.     If a dnttpointer is -1, then it is a NIL entry.  */
end_comment

begin_define
define|#
directive|define
name|DNTTNIL
value|(-1)
end_define

begin_typedef
typedef|typedef
union|union
name|dnttpointer
block|{
name|struct
name|dnttp_immediate
name|dntti
decl_stmt|;
name|struct
name|dnttp_nonimmediate
name|dnttp
decl_stmt|;
name|int
name|word
decl_stmt|;
block|}
name|dnttpointer
typedef|;
end_typedef

begin_comment
comment|/* An index into the source line table.  As with dnttpointers, a sltpointer    of -1 indicates a NIL entry.  */
end_comment

begin_define
define|#
directive|define
name|SLTNIL
value|(-1)
end_define

begin_typedef
typedef|typedef
name|int
name|sltpointer
typedef|;
end_typedef

begin_comment
comment|/* Unsigned byte offset into the VT.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
name|vtpointer
typedef|;
end_typedef

begin_comment
comment|/* A DNTT entry (used within the GNTT and LNTT).     DNTT entries are variable sized objects, but are always a multiple    of 3 words (we call each group of 3 words a "block").     The first bit in each block is an extension bit.  This bit is zero    for the first block of a DNTT entry.  If the entry requires more    than one block, then this bit is set to one in all blocks after    the first one.  */
end_comment

begin_comment
comment|/* Each DNTT entry describes a particular debug symbol (beginning of    a source file, a function, variables, structures, etc.     The type of the DNTT entry is stored in the "kind" field within the    DNTT entry itself.  */
end_comment

begin_enum
enum|enum
name|dntt_entry_type
block|{
name|DNTT_TYPE_NIL
init|=
operator|-
literal|1
block|,
name|DNTT_TYPE_SRCFILE
block|,
name|DNTT_TYPE_MODULE
block|,
name|DNTT_TYPE_FUNCTION
block|,
name|DNTT_TYPE_ENTRY
block|,
name|DNTT_TYPE_BEGIN
block|,
name|DNTT_TYPE_END
block|,
name|DNTT_TYPE_IMPORT
block|,
name|DNTT_TYPE_LABEL
block|,
name|DNTT_TYPE_FPARAM
block|,
name|DNTT_TYPE_SVAR
block|,
name|DNTT_TYPE_DVAR
block|,
name|DNTT_TYPE_HOLE1
block|,
name|DNTT_TYPE_CONST
block|,
name|DNTT_TYPE_TYPEDEF
block|,
name|DNTT_TYPE_TAGDEF
block|,
name|DNTT_TYPE_POINTER
block|,
name|DNTT_TYPE_ENUM
block|,
name|DNTT_TYPE_MEMENUM
block|,
name|DNTT_TYPE_SET
block|,
name|DNTT_TYPE_SUBRANGE
block|,
name|DNTT_TYPE_ARRAY
block|,
name|DNTT_TYPE_STRUCT
block|,
name|DNTT_TYPE_UNION
block|,
name|DNTT_TYPE_FIELD
block|,
name|DNTT_TYPE_VARIANT
block|,
name|DNTT_TYPE_FILE
block|,
name|DNTT_TYPE_FUNCTYPE
block|,
name|DNTT_TYPE_WITH
block|,
name|DNTT_TYPE_COMMON
block|,
name|DNTT_TYPE_COBSTRUCT
block|,
name|DNTT_TYPE_XREF
block|,
name|DNTT_TYPE_SA
block|,
name|DNTT_TYPE_MACRO
block|,
name|DNTT_TYPE_BLOCKDATA
block|,
name|DNTT_TYPE_CLASS_SCOPE
block|,
name|DNTT_TYPE_REFERENCE
block|,
name|DNTT_TYPE_PTRMEM
block|,
name|DNTT_TYPE_PTRMEMFUNC
block|,
name|DNTT_TYPE_CLASS
block|,
name|DNTT_TYPE_GENFIELD
block|,
name|DNTT_TYPE_VFUNC
block|,
name|DNTT_TYPE_MEMACCESS
block|,
name|DNTT_TYPE_INHERITANCE
block|,
name|DNTT_TYPE_FRIEND_CLASS
block|,
name|DNTT_TYPE_FRIEND_FUNC
block|,
name|DNTT_TYPE_MODIFIER
block|,
name|DNTT_TYPE_OBJECT_ID
block|,
name|DNTT_TYPE_MEMFUNC
block|,
name|DNTT_TYPE_TEMPLATE
block|,
name|DNTT_TYPE_TEMPLATE_ARG
block|,
name|DNTT_TYPE_FUNC_TEMPLATE
block|,
name|DNTT_TYPE_LINK
block|,
name|DNTT_TYPE_MAX
block|, }
enum|;
end_enum

begin_comment
comment|/* DNTT_TYPE_SRCFILE:     One DNTT_TYPE_SRCFILE symbol is output for the start of each source    file and at the begin and end of an included file.  A DNTT_TYPE_SRCFILE    entry is also output before each DNTT_TYPE_FUNC symbol so that debuggers    can determine what file a function was defined in.     LANGUAGE describes the source file's language.     NAME points to an VT entry providing the source file's name.     Note the name used for DNTT_TYPE_SRCFILE entries are exactly as seen    by the compiler (ie they may be relative or absolute).  C include files    via<> inclusion must use absolute paths.     ADDRESS points to an SLT entry from which line number and code locations    may be determined.  */
end_comment

begin_struct
struct|struct
name|dntt_type_srcfile
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|language
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|17
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|sltpointer
name|address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_MODULE:     A DNTT_TYPE_MODULE symbol is emitted for the start of a pascal    module or C source file.     Each DNTT_TYPE_MODULE must have an associated DNTT_TYPE_END symbol.     NAME points to a VT entry providing the module's name.  Note C    source files are considered nameless modules.     ALIAS point to a VT entry providing a secondary name.     ADDRESS points to an SLT entry from which line number and code locations    may be determined.  */
end_comment

begin_struct
struct|struct
name|dntt_type_module
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|21
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|vtpointer
name|alias
decl_stmt|;
name|dnttpointer
name|unused2
decl_stmt|;
name|sltpointer
name|address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_FUNCTION:     A DNTT_TYPE_FUNCTION symbol is emitted for each function definition;    a DNTT_TYPE_ENTRY symbols is used for secondary entry points.  Both    symbols used the dntt_type_function structure.     Each DNTT_TYPE_FUNCTION must have a matching DNTT_TYPE_END.     GLOBAL is nonzero if the function has global scope.     LANGUAGE describes the function's source language.     OPT_LEVEL describes the optimization level the function was compiled    with.     VARARGS is nonzero if the function uses varargs.     NAME points to a VT entry providing the function's name.     ALIAS points to a VT entry providing a secondary name for the function.     FIRSTPARAM points to a LNTT entry which describes the parameter list.     ADDRESS points to an SLT entry from which line number and code locations    may be determined.     ENTRYADDR is the memory address corresponding the the function's entry point     RETVAL points to a LNTT entry describing the function's return value.     LOWADDR is the lowest memory address associated with this function.     HIADDR is the highest memory address associated with this function.  */
end_comment

begin_struct
struct|struct
name|dntt_type_function
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|language
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|nest_level
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|opt_level
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|varargs
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|lang_info
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|inlined
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|localalloc
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|expansion
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|1
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|vtpointer
name|alias
decl_stmt|;
name|dnttpointer
name|firstparam
decl_stmt|;
name|sltpointer
name|address
decl_stmt|;
name|CORE_ADDR
name|entryaddr
decl_stmt|;
name|dnttpointer
name|retval
decl_stmt|;
name|CORE_ADDR
name|lowaddr
decl_stmt|;
name|CORE_ADDR
name|hiaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_BEGIN:     A DNTT_TYPE_BEGIN symbol is emitted to begin a new nested scope.    Every DNTT_TYPE_BEGIN symbol must have a matching DNTT_TYPE_END symbol.     CLASSFLAG is nonzero if this is the beginning of a c++ class definition.     ADDRESS points to an SLT entry from which line number and code locations    may be determined.  */
end_comment

begin_struct
struct|struct
name|dntt_type_begin
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|classflag
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|20
decl_stmt|;
name|sltpointer
name|address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_END:     A DNTT_TYPE_END symbol is emitted when closing a scope started by    a DNTT_TYPE_MODULE, DNTT_TYPE_FUNCTION, and DNTT_TYPE_BEGIN symbols.     ENDKIND describes what type of scope the DNTT_TYPE_END is closing    (DNTT_TYPE_MODULE, DNTT_TYPE_BEGIN, etc).     CLASSFLAG is nonzero if this is the end of a c++ class definition.     ADDRESS points to an SLT entry from which line number and code locations    may be determined.     BEGINSCOPE points to the LNTT entry which opened the scope.  */
end_comment

begin_struct
struct|struct
name|dntt_type_end
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|endkind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|classflag
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|10
decl_stmt|;
name|sltpointer
name|address
decl_stmt|;
name|dnttpointer
name|beginscope
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_IMPORT is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_LABEL is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_FPARAM:     A DNTT_TYPE_FPARAM symbol is emitted for a function argument.  When    chained together the symbols represent an argument list for a function.     REGPARAM is nonzero if this parameter was passed in a register.     INDIRECT is nonzero if this parameter is a pointer to the parameter    (pass by reference or pass by value for large items).     LONGADDR is nonzero if the parameter is a 64bit pointer.     NAME is a pointer into the VT for the parameter's name.     LOCATION describes where the parameter is stored.  Depending on the    parameter type LOCATION could be a register number, or an offset    from the stack pointer.     TYPE points to a NTT entry describing the type of this parameter.     NEXTPARAM points to the LNTT entry describing the next parameter.  */
end_comment

begin_struct
struct|struct
name|dntt_type_fparam
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|regparam
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|indirect
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|longaddr
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|copyparam
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|dflt
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|16
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|int
name|location
decl_stmt|;
name|dnttpointer
name|type
decl_stmt|;
name|dnttpointer
name|nextparam
decl_stmt|;
name|int
name|misc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_SVAR:     A DNTT_TYPE_SVAR is emitted to describe a variable in static storage.     GLOBAL is nonzero if the variable has global scope.     INDIRECT is nonzero if the variable is a pointer to an object.     LONGADDR is nonzero if the variable is in long pointer space.     STATICMEM is nonzero if the variable is a member of a class.     A_UNION is nonzero if the variable is an anonymous union member.     NAME is a pointer into the VT for the variable's name.     LOCATION provides the memory address for the variable.     TYPE is a pointer into either the GNTT or LNTT which describes    the type of this variable.  */
end_comment

begin_struct
struct|struct
name|dntt_type_svar
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|indirect
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|longaddr
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|staticmem
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|a_union
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|16
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|CORE_ADDR
name|location
decl_stmt|;
name|dnttpointer
name|type
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|displacement
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_DVAR:     A DNTT_TYPE_DVAR is emitted to describe automatic variables and variables    held in registers.     GLOBAL is nonzero if the variable has global scope.     INDIRECT is nonzero if the variable is a pointer to an object.     REGVAR is nonzero if the variable is in a register.     A_UNION is nonzero if the variable is an anonymous union member.     NAME is a pointer into the VT for the variable's name.     LOCATION provides the memory address or register number for the variable.     TYPE is a pointer into either the GNTT or LNTT which describes    the type of this variable.  */
end_comment

begin_struct
struct|struct
name|dntt_type_dvar
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|indirect
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|regvar
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|a_union
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|17
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|int
name|location
decl_stmt|;
name|dnttpointer
name|type
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_CONST:     A DNTT_TYPE_CONST symbol is emitted for program constants.     GLOBAL is nonzero if the constant has global scope.     INDIRECT is nonzero if the constant is a pointer to an object.     LOCATION_TYPE describes where to find the constant's value    (in the VT, memory, or embedded in an instruction).     CLASSMEM is nonzero if the constant is a member of a class.     NAME is a pointer into the VT for the constant's name.     LOCATION provides the memory address, register number or pointer    into the VT for the constant's value.     TYPE is a pointer into either the GNTT or LNTT which describes    the type of this variable.  */
end_comment

begin_struct
struct|struct
name|dntt_type_const
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|indirect
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
range|:
literal|3
decl_stmt|;
name|unsigned
name|int
name|classmem
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|15
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|CORE_ADDR
name|location
decl_stmt|;
name|dnttpointer
name|type
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|displacement
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_TYPEDEF and DNTT_TYPE_TAGDEF:     The same structure is used to describe typedefs and tagdefs.     DNTT_TYPE_TYPEDEFS are associated with C "typedefs".     DNTT_TYPE_TAGDEFs are associated with C "struct", "union", and "enum"    tags, which may have the same name as a typedef in the same scope.     GLOBAL is nonzero if the typedef/tagdef has global scope.     TYPEINFO is used to determine if full type information is available    for a tag.  (usually 1, but can be zero for opaque types in C).     NAME is a pointer into the VT for the constant's name.     TYPE points to the underlying type for the typedef/tagdef in the    GNTT or LNTT.  */
end_comment

begin_struct
struct|struct
name|dntt_type_type
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|typeinfo
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|19
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|dnttpointer
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_POINTER:     Used to describe a pointer to an underlying type.     POINTSTO is a pointer into the GNTT or LNTT for the type which this    pointer points to.     BITLENGTH is the length of the pointer (not the underlying type). */
end_comment

begin_struct
struct|struct
name|dntt_type_pointer
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|21
decl_stmt|;
name|dnttpointer
name|pointsto
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_ENUM:     Used to describe enumerated types.     FIRSTMEM is a pointer to a DNTT_TYPE_MEMENUM in the GNTT/LNTT which    describes the first member (and contains a pointer to the chain of    members).     BITLENGTH is the number of bits used to hold the values of the enum's    members.  */
end_comment

begin_struct
struct|struct
name|dntt_type_enum
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|21
decl_stmt|;
name|dnttpointer
name|firstmem
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_MEMENUM     Used to describe members of an enumerated type.     CLASSMEM is nonzero if this member is part of a class.     NAME points into the VT for the name of this member.     VALUE is the value of this enumeration member.     NEXTMEM points to the next DNTT_TYPE_MEMENUM in the chain.  */
end_comment

begin_struct
struct|struct
name|dntt_type_memenum
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|classmem
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|20
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
name|dnttpointer
name|nextmem
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_SET     DECLARATION describes the bitpacking of the set.     SUBTYPE points to a DNTT entry describing the type of the members.     BITLENGTH is the size of the set.  */
end_comment

begin_struct
struct|struct
name|dntt_type_set
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|declaration
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|19
decl_stmt|;
name|dnttpointer
name|subtype
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_SUBRANGE     DYN_LOW describes the lower bound of the subrange:       00 for a constant lower bound (found in LOWBOUND).       01 for a dynamic lower bound with the lower bound found in the the      memory address pointed to by LOWBOUND.       10 for a dynamic lower bound described by an variable found in the      DNTT/LNTT (LOWBOUND would be a pointer into the DNTT/LNTT).     DYN_HIGH is similar to DYN_LOW, except it describes the upper bound.     SUBTYPE points to the type of the subrange.     BITLENGTH is the length in bits needed to describe the subrange's    values.  */
end_comment

begin_struct
struct|struct
name|dntt_type_subrange
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|dyn_low
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|dyn_high
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|17
decl_stmt|;
name|int
name|lowbound
decl_stmt|;
name|int
name|highbound
decl_stmt|;
name|dnttpointer
name|subtype
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_ARRAY     DECLARATION describes the bit packing used in the array.     ARRAYISBYTES is nonzero if the field in arraylength describes the    length in bytes rather than in bits.  A value of zero is used to    describe an array with size 2**32.     ELEMISBYTES is nonzero if the length if each element in the array    is describes in bytes rather than bits.  A value of zero is used    to an element with size 2**32.     ELEMORDER is nonzero if the elements are indexed in increasing order.     JUSTIFIED if the elements are left justified to index zero.     ARRAYLENGTH is the length of the array.     INDEXTYPE is a DNTT pointer to the type used to index the array.     ELEMTYPE is a DNTT pointer to the type for the array elements.     ELEMLENGTH is the length of each element in the array (including    any padding).     Multi-dimensional arrays are represented by ELEMTYPE pointing to    another DNTT_TYPE_ARRAY.  */
end_comment

begin_struct
struct|struct
name|dntt_type_array
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|declaration
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|dyn_low
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|dyn_high
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|arrayisbytes
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|elemisbytes
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|elemorder
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|justified
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|11
decl_stmt|;
name|unsigned
name|int
name|arraylength
decl_stmt|;
name|dnttpointer
name|indextype
decl_stmt|;
name|dnttpointer
name|elemtype
decl_stmt|;
name|unsigned
name|int
name|elemlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_STRUCT     DNTT_TYPE_STRUCT is used to describe a C structure.     DECLARATION describes the bitpacking used.     FIRSTFIELD is a DNTT pointer to the first field of the structure    (each field contains a pointer to the next field, walk the list    to access all fields of the structure).     VARTAGFIELD and VARLIST are used for Pascal variant records.     BITLENGTH is the size of the structure in bits.  */
end_comment

begin_struct
struct|struct
name|dntt_type_struct
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|declaration
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|19
decl_stmt|;
name|dnttpointer
name|firstfield
decl_stmt|;
name|dnttpointer
name|vartagfield
decl_stmt|;
name|dnttpointer
name|varlist
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_UNION     DNTT_TYPE_UNION is used to describe a C union.     FIRSTFIELD is a DNTT pointer to the beginning of the field chain.     BITLENGTH is the size of the union in bits.  */
end_comment

begin_struct
struct|struct
name|dntt_type_union
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|21
decl_stmt|;
name|dnttpointer
name|firstfield
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_FIELD     DNTT_TYPE_FIELD describes one field in a structure or union.     VISIBILITY is used to describe the visibility of the field    (for c++.  public = 0, protected = 1, private = 2).     A_UNION is nonzero if this field is a member of an anonymous union.     STATICMEM is nonzero if this field is a static member of a template.     NAME is a pointer into the VT for the name of the field.     BITOFFSET gives the offset of this field in bits from the beginning    of the structure or union this field is a member of.     TYPE is a DNTT pointer to the type describing this field.     BITLENGTH is the size of the entry in bits.     NEXTFIELD is a DNTT pointer to the next field in the chain.  */
end_comment

begin_struct
struct|struct
name|dntt_type_field
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|visibility
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|a_union
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|staticmem
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|17
decl_stmt|;
name|vtpointer
name|name
decl_stmt|;
name|unsigned
name|int
name|bitoffset
decl_stmt|;
name|dnttpointer
name|type
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
name|dnttpointer
name|nextfield
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_VARIANT is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_FILE is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_COMMON is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_LINK is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_FFUNC_LINK is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_TEMPLATE is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_FUNCTYPE     VARARGS is nonzero if this function uses varargs.     FIRSTPARAM is a DNTT pointer to the first entry in the parameter    chain.     RETVAL is a DNTT pointer to the type of the return value.  */
end_comment

begin_struct
struct|struct
name|dntt_type_functype
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|varargs
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|info
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|16
decl_stmt|;
name|unsigned
name|int
name|bitlength
decl_stmt|;
name|dnttpointer
name|firstparam
decl_stmt|;
name|dnttpointer
name|retval
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* DNTT_TYPE_WITH is unued by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_COBSTRUCT is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_MODIFIER is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_GENFIELD is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_MEMACCESS is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_VFUNC is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_CLASS_SCOPE is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_FRIEND_CLASS is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_FRIEND_FUNC is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_CLASS unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_TEMPLATE unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_TEMPL_ARG is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_PTRMEM not used by GDB */
end_comment

begin_comment
comment|/* DNTT_TYPE_INHERITANCE is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_OBJECT_ID is unused by GDB. */
end_comment

begin_comment
comment|/* DNTT_TYPE_XREF is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_SA is unused by GDB.  */
end_comment

begin_comment
comment|/* DNTT_TYPE_GENERIC and DNTT_TYPE_BLOCK are convience structures    so we can examine a DNTT entry in a generic fashion.  */
end_comment

begin_struct
struct|struct
name|dntt_type_generic
block|{
name|unsigned
name|int
name|word
index|[
literal|9
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dntt_type_block
block|{
name|unsigned
name|int
name|extension
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|kind
range|:
literal|10
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|21
decl_stmt|;
name|unsigned
name|int
name|word
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One entry in a DNTT (either the LNTT or GNTT).  */
end_comment

begin_union
union|union
name|dnttentry
block|{
name|struct
name|dntt_type_srcfile
name|dsfile
decl_stmt|;
name|struct
name|dntt_type_module
name|dmodule
decl_stmt|;
name|struct
name|dntt_type_function
name|dfunc
decl_stmt|;
name|struct
name|dntt_type_function
name|dentry
decl_stmt|;
name|struct
name|dntt_type_begin
name|dbegin
decl_stmt|;
name|struct
name|dntt_type_end
name|dend
decl_stmt|;
name|struct
name|dntt_type_fparam
name|dfparam
decl_stmt|;
name|struct
name|dntt_type_svar
name|dsvar
decl_stmt|;
name|struct
name|dntt_type_dvar
name|ddvar
decl_stmt|;
name|struct
name|dntt_type_const
name|dconst
decl_stmt|;
name|struct
name|dntt_type_type
name|dtype
decl_stmt|;
name|struct
name|dntt_type_type
name|dtag
decl_stmt|;
name|struct
name|dntt_type_pointer
name|dptr
decl_stmt|;
name|struct
name|dntt_type_enum
name|denum
decl_stmt|;
name|struct
name|dntt_type_memenum
name|dmember
decl_stmt|;
name|struct
name|dntt_type_set
name|dset
decl_stmt|;
name|struct
name|dntt_type_subrange
name|dsubr
decl_stmt|;
name|struct
name|dntt_type_array
name|darray
decl_stmt|;
name|struct
name|dntt_type_struct
name|dstruct
decl_stmt|;
name|struct
name|dntt_type_union
name|dunion
decl_stmt|;
name|struct
name|dntt_type_field
name|dfield
decl_stmt|;
name|struct
name|dntt_type_functype
name|dfunctype
decl_stmt|;
name|struct
name|dntt_type_generic
name|dgeneric
decl_stmt|;
name|struct
name|dntt_type_block
name|dblock
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* Source line entry types.  */
end_comment

begin_enum
enum|enum
name|slttype
block|{
name|SLT_NORMAL
block|,
name|SLT_SRCFILE
block|,
name|SLT_MODULE
block|,
name|SLT_FUNCTION
block|,
name|SLT_ENTRY
block|,
name|SLT_BEGIN
block|,
name|SLT_END
block|,
name|SLT_WITH
block|,
name|SLT_EXIT
block|,
name|SLT_ASSIST
block|,
name|SLT_MARKER
block|, }
enum|;
end_enum

begin_comment
comment|/* A normal source line entry.  Simply provides a mapping of a source    line number to a code address.     SLTDESC will always be SLT_NORMAL or SLT_EXIT.  */
end_comment

begin_struct
struct|struct
name|slt_normal
block|{
name|unsigned
name|int
name|sltdesc
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|line
range|:
literal|28
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A special source line entry.  Provides a mapping of a declaration    to a line number.  These entries point back into the DNTT which    references them.  */
end_comment

begin_struct
struct|struct
name|slt_special
block|{
name|unsigned
name|int
name|sltdesc
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|line
range|:
literal|28
decl_stmt|;
name|dnttpointer
name|backptr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to describe nesting.     For nested languages, an slt_assist entry must follow each SLT_FUNC    entry in the SLT.  The address field will point forward to the    first slt_normal entry within the function's scope.  */
end_comment

begin_struct
struct|struct
name|slt_assist
block|{
name|unsigned
name|int
name|sltdesc
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|unused
range|:
literal|28
decl_stmt|;
name|sltpointer
name|address
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|slt_generic
block|{
name|unsigned
name|int
name|word
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|sltentry
block|{
name|struct
name|slt_normal
name|snorm
decl_stmt|;
name|struct
name|slt_special
name|sspec
decl_stmt|;
name|struct
name|slt_assist
name|sasst
decl_stmt|;
name|struct
name|slt_generic
name|sgeneric
decl_stmt|;
block|}
union|;
end_union

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HP_SYMTAB_INCLUDED */
end_comment

end_unit

