begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* NLM (NetWare Loadable Module) executable support for BFD.    Copyright (C) 1993 Free Software Foundation, Inc.     Written by Fred Fish @ Cygnus Support, using ELF support as the    template.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For strrchr and friends */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libnlm.h"
end_include

begin_comment
comment|/* The functions in this file do not use the names they appear to use.    This file is actually compiled multiple times, once for each size    of NLM target we are using.  At each size we use a different name,    constructed by the macro nlmNAME.  For example, the function which    is named nlm_symbol_type below is actually named nlm32_symbol_type    in the final executable.  */
end_comment

begin_define
define|#
directive|define
name|Nlm_External_Fixed_Header
value|NlmNAME(External_Fixed_Header)
end_define

begin_define
define|#
directive|define
name|Nlm_External_Version_Header
value|NlmNAME(External_Version_Header)
end_define

begin_define
define|#
directive|define
name|Nlm_External_Copyright_Header
value|NlmNAME(External_Copyright_Header)
end_define

begin_define
define|#
directive|define
name|Nlm_External_Extended_Header
value|NlmNAME(External_Extended_Header)
end_define

begin_define
define|#
directive|define
name|Nlm_External_Custom_Header
value|NlmNAME(External_Custom_Header)
end_define

begin_define
define|#
directive|define
name|Nlm_External_Cygnus_Ext_Header
value|NlmNAME(External_Cygnus_Ext_Header)
end_define

begin_define
define|#
directive|define
name|nlm_symbol_type
value|nlmNAME(symbol_type)
end_define

begin_define
define|#
directive|define
name|nlm_get_symtab_upper_bound
value|nlmNAME(get_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|nlm_get_symtab
value|nlmNAME(get_symtab)
end_define

begin_define
define|#
directive|define
name|nlm_make_empty_symbol
value|nlmNAME(make_empty_symbol)
end_define

begin_define
define|#
directive|define
name|nlm_print_symbol
value|nlmNAME(print_symbol)
end_define

begin_define
define|#
directive|define
name|nlm_get_symbol_info
value|nlmNAME(get_symbol_info)
end_define

begin_define
define|#
directive|define
name|nlm_get_reloc_upper_bound
value|nlmNAME(get_reloc_upper_bound)
end_define

begin_define
define|#
directive|define
name|nlm_canonicalize_reloc
value|nlmNAME(canonicalize_reloc)
end_define

begin_define
define|#
directive|define
name|nlm_object_p
value|nlmNAME(object_p)
end_define

begin_define
define|#
directive|define
name|nlm_set_section_contents
value|nlmNAME(set_section_contents)
end_define

begin_define
define|#
directive|define
name|nlm_write_object_contents
value|nlmNAME(write_object_contents)
end_define

begin_define
define|#
directive|define
name|nlm_swap_fixed_header_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|(nlm_swap_fixed_header_in_func(abfd))(abfd,src,dst)
end_define

begin_define
define|#
directive|define
name|nlm_swap_fixed_header_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|(nlm_swap_fixed_header_out_func(abfd))(abfd,src,dst)
end_define

begin_comment
comment|/* Forward declarations of static functions */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|add_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_swap_variable_header_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_swap_variable_header_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|find_nonzero
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_swap_auxiliary_headers_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_swap_auxiliary_headers_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_slurp_reloc_fixups
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlm_external_reloc_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should perhaps use put_offset, put_word, etc.  For now, the two versions    can be handled by explicitly specifying 32 bits or "the long type".  */
end_comment

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|put_word
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|get_word
value|bfd_h_get_64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|put_word
value|bfd_h_put_32
end_define

begin_define
define|#
directive|define
name|get_word
value|bfd_h_get_32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|bfd_target
modifier|*
name|nlm_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|nlm_obj_tdata
modifier|*
name|preserved_tdata
init|=
name|nlm_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
argument_list|(
argument|*backend_object_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
name|PTR
name|x_fxdhdr
init|=
name|NULL
decl_stmt|;
name|Nlm_Internal_Fixed_Header
modifier|*
name|i_fxdhdrp
decl_stmt|;
name|struct
name|nlm_obj_tdata
modifier|*
name|new_tdata
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|signature
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* Some NLM formats have a prefix before the standard NLM fixed      header.  */
name|backend_object_p
operator|=
name|nlm_backend_object_p_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|backend_object_p
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|backend_object_p
call|)
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* Read in the fixed length portion of the NLM header in external format.  */
name|x_fxdhdr
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_fxdhdr
operator|==
name|NULL
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|x_fxdhdr
argument_list|,
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
goto|goto
name|got_wrong_format_error
goto|;
else|else
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Allocate an instance of the nlm_obj_tdata structure and hook it up to      the tdata pointer in the bfd.  */
name|new_tdata
operator|=
operator|(
operator|(
expr|struct
name|nlm_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_obj_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|==
name|NULL
condition|)
goto|goto
name|got_no_match
goto|;
name|nlm_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|new_tdata
expr_stmt|;
name|i_fxdhdrp
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|nlm_swap_fixed_header_in
argument_list|(
name|abfd
argument_list|,
name|x_fxdhdr
argument_list|,
name|i_fxdhdrp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x_fxdhdr
argument_list|)
expr_stmt|;
name|x_fxdhdr
operator|=
name|NULL
expr_stmt|;
comment|/* Check to see if we have an NLM file for this backend by matching      the NLM signature. */
name|signature
operator|=
name|nlm_signature
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
name|NULL
operator|&&
operator|*
name|signature
operator|!=
literal|'\0'
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|i_fxdhdrp
operator|->
name|signature
argument_list|,
name|signature
argument_list|,
name|NLM_SIGNATURE_SIZE
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* There's no supported way to discover the endianess of an NLM, so test for      a sane version number after doing byte swapping appropriate for this      XVEC.  (Hack alert!) */
if|if
condition|(
name|i_fxdhdrp
operator|->
name|version
operator|>
literal|0xFFFF
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* There's no supported way to check for 32 bit versus 64 bit addresses,      so ignore this distinction for now.  (FIXME) */
comment|/* Swap in the rest of the required header.  */
if|if
condition|(
operator|!
name|nlm_swap_variable_header_in
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
goto|goto
name|got_wrong_format_error
goto|;
else|else
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Add the sections supplied by all NLM's, and then read in the      auxiliary headers.  Reading the auxiliary headers may create      additional sections described in the cygnus_ext header.      From this point on we assume that we have an NLM, and do not      treat errors as indicating the wrong format.  */
if|if
condition|(
operator|!
name|add_bfd_section
argument_list|(
name|abfd
argument_list|,
name|NLM_CODE_NAME
argument_list|,
name|i_fxdhdrp
operator|->
name|codeImageOffset
argument_list|,
name|i_fxdhdrp
operator|->
name|codeImageSize
argument_list|,
operator|(
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
argument_list|)
operator|||
operator|!
name|add_bfd_section
argument_list|(
name|abfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|,
name|i_fxdhdrp
operator|->
name|dataImageOffset
argument_list|,
name|i_fxdhdrp
operator|->
name|dataImageSize
argument_list|,
operator|(
name|SEC_DATA
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
argument_list|)
operator|||
operator|!
name|add_bfd_section
argument_list|(
name|abfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|i_fxdhdrp
operator|->
name|uninitializedDataSize
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
operator|!
name|nlm_swap_auxiliary_headers_in
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfRelocationFixups
operator|!=
literal|0
operator|||
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfExternalReferences
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfPublics
operator|!=
literal|0
operator|||
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfDebugRecords
operator|!=
literal|0
operator|||
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfExternalReferences
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
name|arch
operator|=
name|nlm_architecture
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeStartOffset
expr_stmt|;
return|return
operator|(
name|abfd
operator|->
name|xvec
operator|)
return|;
name|got_wrong_format_error
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|got_no_match
label|:
name|nlm_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|preserved_tdata
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_fxdhdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|x_fxdhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a section to the bfd. */
end_comment

begin_function
specifier|static
name|boolean
name|add_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
name|newsect
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
comment|/* NLM's are relocatable. */
name|newsect
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|offset
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
name|bfd_log2
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read and swap in the variable length header.  All the fields must    exist in the NLM, and must exist in the order they are read here. */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_swap_variable_header_in
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|char
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
comment|/* Read the description length and text members. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionText
argument_list|,
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
operator|+
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Read and convert the stackSize field. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stackSize
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
comment|/* Read and convert the reserved field. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
comment|/* Read the oldThreadName field.  This field is a fixed length string. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Read the screen name length and text members. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenName
argument_list|,
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
operator|+
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Read the thread name length and text members. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadName
argument_list|,
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
operator|+
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Swap and write out the variable length header.  All the fields must    exist in the NLM, and must exist in this order.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_swap_variable_header_out
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|char
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
comment|/* Write the description length and text members. */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionText
argument_list|,
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
operator|+
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Convert and write the stackSize field. */
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stackSize
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Convert and write the reserved field. */
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Write the oldThreadName field.  This field is a fixed length string. */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Write the screen name length and text members. */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenName
argument_list|,
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
operator|+
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Write the thread name length and text members. */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadName
argument_list|,
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
operator|+
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read and swap in the contents of all the auxiliary headers.  Because of    the braindead design, we have to do strcmps on strings of indeterminate    length to figure out what each auxiliary header is.  Even worse, we have    no way of knowing how many auxiliary headers there are or where the end    of the auxiliary headers are, except by finding something that doesn't    look like a known auxiliary header.  This means that the first new type    of auxiliary header added will break all existing tools that don't    recognize it. */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_swap_auxiliary_headers_in
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|tempstr
index|[
literal|16
index|]
decl_stmt|;
name|long
name|position
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|position
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|tempstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tempstr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tempstr
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|position
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|tempstr
argument_list|,
literal|"VeRsIoN#"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Nlm_External_Version_Header
name|thdr
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|memcpy
argument_list|(
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stamp
argument_list|,
name|thdr
operator|.
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|majorVersion
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|majorVersion
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|minorVersion
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|minorVersion
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|revision
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|revision
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|year
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|year
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|month
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|month
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|day
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|day
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|tempstr
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Nlm_External_Extended_Header
name|thdr
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|memcpy
argument_list|(
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stamp
argument_list|,
name|thdr
operator|.
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|languageID
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|languageID
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|messageFileOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|messageFileOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|messageFileLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|messageFileLength
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|messageCount
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|messageCount
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|helpFileOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|helpFileOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|helpFileLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|helpFileLength
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|RPCDataOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|RPCDataOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|RPCDataLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|RPCDataLength
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedCodeOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedCodeOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedCodeLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedCodeLength
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDataOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDataOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDataLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDataLength
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedRelocationFixupOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedRelocationFixupOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedRelocationFixupCount
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedRelocationFixupCount
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedExternalReferenceOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedExternalReferenceOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedExternalReferenceCount
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedExternalReferenceCount
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedPublicsOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedPublicsOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedPublicsCount
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedPublicsCount
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDebugRecordOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDebugRecordOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDebugRecordCount
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDebugRecordCount
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|SharedInitializationOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedInitializationOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|SharedExitProcedureOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|SharedExitProcedureOffset
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|productID
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|productID
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved0
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved0
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved1
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved1
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved2
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved2
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved3
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved3
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved4
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved4
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved5
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|tempstr
argument_list|,
literal|"CoPyRiGhT="
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stamp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stamp
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
operator|(
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
operator|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* The copyright message is a variable length string. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessage
argument_list|,
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
operator|(
name|bfd_size_type
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
operator|+
literal|1
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|tempstr
argument_list|,
literal|"CuStHeAd"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Nlm_External_Custom_Header
name|thdr
decl_stmt|;
name|bfd_size_type
name|hdrLength
decl_stmt|;
name|file_ptr
name|dataOffset
decl_stmt|;
name|bfd_size_type
name|dataLength
decl_stmt|;
name|char
name|dataStamp
index|[
literal|8
index|]
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
comment|/* Read the stamp ("CuStHeAd").  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|thdr
operator|.
name|stamp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Read the length of this custom header.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|thdr
operator|.
name|length
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|length
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|length
argument_list|)
condition|)
return|return
name|false
return|;
name|hdrLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* Read further fields if we have them.  */
if|if
condition|(
name|hdrLength
operator|<
name|NLM_TARGET_LONG_SIZE
condition|)
name|dataOffset
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|thdr
operator|.
name|dataOffset
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataOffset
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataOffset
argument_list|)
condition|)
return|return
name|false
return|;
name|dataOffset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|dataOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdrLength
operator|<
literal|2
operator|*
name|NLM_TARGET_LONG_SIZE
condition|)
name|dataLength
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|thdr
operator|.
name|dataLength
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataLength
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataLength
argument_list|)
condition|)
return|return
name|false
return|;
name|dataLength
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|dataLength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdrLength
operator|<
literal|2
operator|*
name|NLM_TARGET_LONG_SIZE
operator|+
literal|8
condition|)
name|memset
argument_list|(
name|dataStamp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dataStamp
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|dataStamp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dataStamp
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dataStamp
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Read the rest of the header, if any.  */
if|if
condition|(
name|hdrLength
operator|<=
literal|2
operator|*
name|NLM_TARGET_LONG_SIZE
operator|+
literal|8
condition|)
block|{
name|hdr
operator|=
name|NULL
expr_stmt|;
name|hdrLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hdrLength
operator|-=
literal|2
operator|*
name|NLM_TARGET_LONG_SIZE
operator|+
literal|8
expr_stmt|;
name|hdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|hdrLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|hdr
argument_list|,
literal|1
argument_list|,
name|hdrLength
argument_list|,
name|abfd
argument_list|)
operator|!=
name|hdrLength
condition|)
return|return
name|false
return|;
block|}
comment|/* If we have found a Cygnus header, process it.  Otherwise, 	     just save the associated data without trying to interpret 	     it.  */
if|if
condition|(
name|strncmp
argument_list|(
name|dataStamp
argument_list|,
literal|"CyGnUsEx"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|file_ptr
name|pos
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdrLength
operator|==
literal|0
operator|&&
name|hdr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|dataOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|dataLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|dataLength
argument_list|,
name|abfd
argument_list|)
operator|!=
name|dataLength
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"CyGnUsEx"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|offset
operator|=
name|dataOffset
expr_stmt|;
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|length
operator|=
name|dataLength
expr_stmt|;
comment|/* This data this header points to provides a list of 		 the sections which were in the original object file 		 which was converted to become an NLM.  We locate 		 those sections and add them to the BFD.  Note that 		 this is likely to create a second .text, .data and 		 .bss section; retrieving the sections by name will 		 get the actual NLM sections, which is what we want to 		 happen.  The sections from the original file, which 		 may be subsets of the NLM section, can only be found 		 using bfd_map_over_sections.  */
name|p
operator|=
name|contents
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|dataLength
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pend
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|asection
modifier|*
name|newsec
decl_stmt|;
comment|/* The format of this information is 		     null terminated section name 		     zeroes to adjust to 4 byte boundary 		     4 byte section data file pointer 		     4 byte section size 		     */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|l
operator|=
operator|(
name|l
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
name|filepos
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|newsec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|newsec
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|filepos
operator|!=
literal|0
condition|)
block|{
name|newsec
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|stamp
argument_list|,
name|thdr
operator|.
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdrLength
operator|=
name|hdrLength
expr_stmt|;
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataOffset
operator|=
name|dataOffset
expr_stmt|;
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataLength
operator|=
name|dataLength
expr_stmt|;
name|memcpy
argument_list|(
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataStamp
argument_list|,
name|dataStamp
argument_list|,
sizeof|sizeof
argument_list|(
name|dataStamp
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdr
operator|=
name|hdr
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether there is a non-zero byte in a memory block.  */
end_comment

begin_function
specifier|static
name|boolean
name|find_nonzero
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|PTR
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|buf
decl_stmt|;
while|while
condition|(
name|size
operator|--
operator|!=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Swap out the contents of the auxiliary headers.  We create those    auxiliary headers which have been set non-zero.  We do not require    the caller to set up the stamp fields.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_swap_auxiliary_headers_out
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Write out the version header if there is one.  */
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Version_Header
argument_list|)
argument_list|)
condition|)
block|{
name|Nlm_External_Version_Header
name|thdr
decl_stmt|;
name|memcpy
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|,
literal|"VeRsIoN#"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|majorVersion
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|majorVersion
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|minorVersion
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|minorVersion
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|revision
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|revision
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|year
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|year
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|month
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|month
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|day
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the extended header if there is one.  */
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Extended_Header
argument_list|)
argument_list|)
condition|)
block|{
name|Nlm_External_Extended_Header
name|thdr
decl_stmt|;
name|memcpy
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|languageID
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|languageID
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|messageFileOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|messageFileOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|messageFileLength
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|messageFileLength
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|messageCount
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|messageCount
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|helpFileOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|helpFileOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|helpFileLength
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|helpFileLength
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|RPCDataOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|RPCDataOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|RPCDataLength
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|RPCDataLength
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedCodeOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedCodeOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedCodeLength
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedCodeLength
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDataOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDataOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDataLength
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDataLength
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedRelocationFixupOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedRelocationFixupOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedRelocationFixupCount
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedRelocationFixupCount
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedExternalReferenceOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedExternalReferenceOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedExternalReferenceCount
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedExternalReferenceCount
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedPublicsOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedPublicsOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedPublicsCount
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedPublicsCount
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDebugRecordOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDebugRecordOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|sharedDebugRecordCount
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedDebugRecordCount
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|SharedInitializationOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|sharedInitializationOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|SharedExitProcedureOffset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|SharedExitProcedureOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|productID
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|productID
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved0
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved0
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved1
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved1
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved2
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved2
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved3
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved3
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved4
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved4
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|reserved5
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|reserved5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the copyright header if there is one.  */
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Copyright_Header
argument_list|)
argument_list|)
condition|)
block|{
name|Nlm_External_Copyright_Header
name|thdr
decl_stmt|;
name|memcpy
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|,
literal|"CoPyRiGhT="
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|thdr
operator|.
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|)
condition|)
return|return
name|false
return|;
name|thdr
operator|.
name|copyrightMessageLength
index|[
literal|0
index|]
operator|=
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|thdr
operator|.
name|copyrightMessageLength
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
comment|/* The copyright message is a variable length string. */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessage
argument_list|,
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
operator|(
name|bfd_size_type
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
operator|+
literal|1
operator|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the custom header if there is one.   */
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Custom_Header
argument_list|)
argument_list|)
condition|)
block|{
name|Nlm_External_Custom_Header
name|thdr
decl_stmt|;
name|boolean
name|ds
decl_stmt|;
name|bfd_size_type
name|hdrLength
decl_stmt|;
name|ds
operator|=
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataStamp
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataStamp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|,
literal|"CuStHeAd"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|hdrLength
operator|=
operator|(
literal|2
operator|*
name|NLM_TARGET_LONG_SIZE
operator|+
operator|(
name|ds
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdrLength
operator|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|hdrLength
argument_list|,
name|thdr
operator|.
name|length
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataOffset
argument_list|,
name|thdr
operator|.
name|dataOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataLength
argument_list|,
name|thdr
operator|.
name|dataLength
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ds
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdrLength
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataStamp
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataStamp
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|thdr
operator|.
name|dataStamp
argument_list|,
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataStamp
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
operator|.
name|dataStamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdr
argument_list|,
literal|1
argument_list|,
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdrLength
argument_list|,
name|abfd
argument_list|)
operator|!=
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdrLength
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Write out the Cygnus debugging header if there is one.  */
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Cygnus_Ext_Header
argument_list|)
argument_list|)
condition|)
block|{
name|Nlm_External_Custom_Header
name|thdr
decl_stmt|;
name|memcpy
argument_list|(
name|thdr
operator|.
name|stamp
argument_list|,
literal|"CuStHeAd"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|2
operator|*
name|NLM_TARGET_LONG_SIZE
operator|+
literal|8
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|length
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|offset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|dataOffset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|length
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|thdr
operator|.
name|dataLength
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|thdr
operator|.
name|dataStamp
argument_list|,
literal|"CyGnUsEx"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|thdr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We read the NLM's public symbols and use it to generate a bfd symbol    table (hey, it's better than nothing) on a one-for-one basis.  Thus    use the number of public symbols as the number of bfd symbols we will    have once we actually get around to reading them in.     Return the number of bytes required to hold the symtab vector, based on    the count plus 1, since we will NULL terminate the vector allocated based    on this size. */
end_comment

begin_function
name|long
name|nlm_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Nlm_Internal_Fixed_Header
modifier|*
name|i_fxdhdrp
decl_stmt|;
comment|/* Nlm file header, internal form */
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
init|=
literal|0
decl_stmt|;
name|i_fxdhdrp
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symcount
operator|=
operator|(
name|i_fxdhdrp
operator|->
name|numberOfPublics
operator|+
name|i_fxdhdrp
operator|->
name|numberOfDebugRecords
operator|+
name|i_fxdhdrp
operator|->
name|numberOfExternalReferences
operator|)
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|symtab_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Note that bfd_get_symcount is guaranteed to be zero if slurping the    symbol table fails. */
end_comment

begin_function
name|long
name|nlm_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|nlm_symbol_type
modifier|*
name|symbase
decl_stmt|;
name|bfd_size_type
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nlm_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
operator|-
literal|1
return|;
name|symbase
operator|=
name|nlm_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
operator|*
name|alocation
operator|++
operator|=
operator|&
name|symbase
operator|->
name|symbol
expr_stmt|;
name|symbase
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
operator|*
name|alocation
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an NLM symbol.  There is nothing special to do here.  */
end_comment

begin_function
name|asymbol
modifier|*
name|nlm_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|nlm_symbol_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|nlm_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Get symbol information.  */
end_comment

begin_function
name|void
name|nlm_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print symbol information.  */
end_comment

begin_function
name|void
name|nlm_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
case|case
name|bfd_print_symbol_more
case|:
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Slurp in nlm symbol table.     In the external (in-file) form, NLM export records are variable length,    with the following form:  	1 byte		length of the symbol name (N) 	N bytes		the symbol name 	4 bytes		the symbol offset from start of it's section     We also read in the debugging symbols and import records.  Import    records are treated as undefined symbols.  As we read the import    records we also read in the associated reloc information, which is    attached to the symbol.     The bfd symbols are copied to SYMPTRS.     When we return, the bfd symcount is either zero or contains the correct    number of symbols. */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Nlm_Internal_Fixed_Header
modifier|*
name|i_fxdhdrp
decl_stmt|;
comment|/* Nlm file header, internal form */
name|bfd_size_type
name|totsymcount
decl_stmt|;
comment|/* Number of NLM symbols */
name|bfd_size_type
name|symcount
decl_stmt|;
comment|/* Counter of NLM symbols */
name|nlm_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Pointer to current bfd symbol */
name|unsigned
name|char
name|symlength
decl_stmt|;
comment|/* Symbol length read into here */
name|unsigned
name|char
name|symtype
decl_stmt|;
comment|/* Type of debugging symbol */
name|bfd_byte
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
comment|/* Symbol offsets read into here */
name|boolean
argument_list|(
argument|*read_import_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlm_symbol_type
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*set_public_section_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlm_symbol_type
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlm_get_symbols
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Read each raw NLM symbol, using the information to create a canonical bfd      symbol table entry.       Note that we allocate the initial bfd canonical symbol buffer based on a      one-to-one mapping of the NLM symbols to canonical symbols.  We actually      use all the NLM symbols, so there will be no space left over at the end.      When we have all the symbols, we build the caller's pointer vector. */
name|abfd
operator|->
name|symcount
operator|=
literal|0
expr_stmt|;
name|i_fxdhdrp
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|totsymcount
operator|=
operator|(
name|i_fxdhdrp
operator|->
name|numberOfPublics
operator|+
name|i_fxdhdrp
operator|->
name|numberOfDebugRecords
operator|+
name|i_fxdhdrp
operator|->
name|numberOfExternalReferences
operator|)
expr_stmt|;
if|if
condition|(
name|totsymcount
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_fxdhdrp
operator|->
name|publicsOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|sym
operator|=
operator|(
operator|(
name|nlm_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|totsymcount
operator|*
sizeof|sizeof
argument_list|(
name|nlm_symbol_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
return|return
name|false
return|;
name|nlm_set_symbols
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
comment|/* We use the bfd's symcount directly as the control count, so that early      termination of the loop leaves the symcount correct for the symbols that      were read. */
name|set_public_section_func
operator|=
name|nlm_set_public_section_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|i_fxdhdrp
operator|->
name|numberOfPublics
expr_stmt|;
while|while
condition|(
name|abfd
operator|->
name|symcount
operator|<
name|symcount
condition|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|symlength
argument_list|,
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symlength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|->
name|symbol
operator|.
name|name
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
name|symlength
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symlength
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Cast away const.  */
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|sym
operator|->
name|symbol
operator|.
name|name
operator|)
operator|)
index|[
name|symlength
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_public_section_func
condition|)
block|{
comment|/* Most backends can use the code below, but unfortunately 	     some use a different scheme.  */
if|if
condition|(
call|(
modifier|*
name|set_public_section_func
call|)
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&
name|NLM_HIBIT
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&=
operator|~
name|NLM_HIBIT
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_CODE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
block|}
block|}
name|sym
operator|->
name|rcnt
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|sym
operator|++
expr_stmt|;
block|}
comment|/* Read the debugging records.  */
if|if
condition|(
name|i_fxdhdrp
operator|->
name|numberOfDebugRecords
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_fxdhdrp
operator|->
name|debugInfoOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|symcount
operator|+=
name|i_fxdhdrp
operator|->
name|numberOfDebugRecords
expr_stmt|;
while|while
condition|(
name|abfd
operator|->
name|symcount
operator|<
name|symcount
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|symtype
argument_list|,
sizeof|sizeof
argument_list|(
name|symtype
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|symtype
argument_list|)
operator|)
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|symlength
argument_list|,
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symlength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|->
name|symbol
operator|.
name|name
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
name|symlength
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symlength
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Cast away const.  */
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|sym
operator|->
name|symbol
operator|.
name|name
operator|)
operator|)
index|[
name|symlength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtype
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symtype
operator|==
literal|1
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_CODE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|sym
operator|->
name|rcnt
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|sym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Read in the import records.  We can only do this if we know how      to read relocs for this target.  */
name|read_import_func
operator|=
name|nlm_read_import_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_import_func
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_fxdhdrp
operator|->
name|externalReferencesOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|symcount
operator|+=
name|i_fxdhdrp
operator|->
name|numberOfExternalReferences
expr_stmt|;
while|while
condition|(
name|abfd
operator|->
name|symcount
operator|<
name|symcount
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|read_import_func
call|)
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|sym
operator|++
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the relocs for an NLM file.  There are two types of relocs.    Imports are relocs against symbols defined in other NLM files.  We    treat these as relocs against global symbols.  Relocation fixups    are internal relocs.     The actual format used to store the relocs is machine specific.  */
end_comment

begin_comment
comment|/* Read in the relocation fixup information.  This is stored in    nlm_relocation_fixups, an array of arelent structures, and    nlm_relocation_fixup_secs, an array of section pointers.  The    section pointers are needed because the relocs are not sorted by    section.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_slurp_reloc_fixups
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*read_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlm_symbol_type
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|arelent
modifier|*
name|rels
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
if|if
condition|(
name|nlm_relocation_fixups
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
name|read_func
operator|=
name|nlm_read_reloc_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_func
operator|==
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|relocationFixupOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|count
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfRelocationFixups
expr_stmt|;
name|rels
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|secs
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rels
operator|==
name|NULL
operator|||
name|secs
operator|==
name|NULL
operator|)
operator|&&
name|count
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|nlm_relocation_fixups
argument_list|(
name|abfd
argument_list|)
operator|=
name|rels
expr_stmt|;
name|nlm_relocation_fixup_secs
argument_list|(
name|abfd
argument_list|)
operator|=
name|secs
expr_stmt|;
comment|/* We have to read piece by piece, because we don't know how large      the machine specific reloc information is.  */
while|while
condition|(
name|count
operator|--
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|read_func
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|nlm_symbol_type
operator|*
operator|)
name|NULL
argument_list|,
name|secs
argument_list|,
name|rels
argument_list|)
operator|==
name|false
condition|)
block|{
name|nlm_relocation_fixups
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|nlm_relocation_fixup_secs
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
name|secs
expr_stmt|;
operator|++
name|rels
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get the number of relocs.  This really just returns an upper bound,    since it does not attempt to distinguish them based on the section.    That will be handled when they are actually read.  */
end_comment

begin_function
name|long
name|nlm_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|nlm_symbol_type
modifier|*
name|syms
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|unsigned
name|int
name|ret
decl_stmt|;
comment|/* If we don't know how to read relocs, just return 0.  */
if|if
condition|(
name|nlm_read_reloc_func
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Make sure we have either the code or the data section.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|syms
operator|=
name|nlm_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nlm_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
operator|-
literal|1
return|;
name|syms
operator|=
name|nlm_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfRelocationFixups
expr_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|!=
literal|0
condition|)
block|{
name|ret
operator|+=
name|syms
operator|->
name|rcnt
expr_stmt|;
operator|++
name|syms
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the relocs themselves.  */
end_comment

begin_function
name|long
name|nlm_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|rels
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|ret
decl_stmt|;
comment|/* Get the relocation fixups.  */
name|rels
operator|=
name|nlm_relocation_fixups
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nlm_slurp_reloc_fixups
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
operator|-
literal|1
return|;
name|rels
operator|=
name|nlm_relocation_fixups
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|secs
operator|=
name|nlm_relocation_fixup_secs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfRelocationFixups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|rels
operator|++
operator|,
name|secs
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|secs
operator|==
name|sec
condition|)
block|{
operator|*
name|relptr
operator|++
operator|=
name|rels
expr_stmt|;
operator|++
name|ret
expr_stmt|;
block|}
block|}
comment|/* Get the import symbols.  */
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|symbols
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
operator|*
name|symbols
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|sym
argument_list|)
operator|==
name|bfd_target_nlm_flavour
condition|)
block|{
name|nlm_symbol_type
modifier|*
name|nlm_sym
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|;
name|nlm_sym
operator|=
operator|(
name|nlm_symbol_type
operator|*
operator|)
name|sym
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlm_sym
operator|->
name|rcnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nlm_sym
operator|->
name|relocs
index|[
name|j
index|]
operator|.
name|section
operator|==
name|sec
condition|)
block|{
operator|*
name|relptr
operator|=
operator|&
name|nlm_sym
operator|->
name|relocs
index|[
name|j
index|]
operator|.
name|reloc
expr_stmt|;
operator|(
operator|*
name|relptr
operator|)
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
expr_stmt|;
operator|++
name|relptr
expr_stmt|;
operator|++
name|ret
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the section file positions for an NLM file.  All variable    length data in the file headers must be set before this function is    called.  If the variable length data is changed later, the    resulting object file will be incorrect.  Unfortunately, there is    no way to check this.     This routine also sets the Size and Offset fields in the fixed    header.     It also looks over the symbols and moves any common symbols into    the .bss section; NLM has no way to represent a common symbol.    This approach means that either the symbols must already have been    set at this point, or there must be no common symbols.  We need to    move the symbols at this point so that mangle_relocs can see the    final values.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|sofar
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|text
decl_stmt|,
name|data
decl_stmt|,
name|bss
decl_stmt|;
name|bfd_vma
name|text_low
decl_stmt|,
name|data_low
decl_stmt|;
name|unsigned
name|int
name|text_align
decl_stmt|,
name|data_align
decl_stmt|,
name|other_align
decl_stmt|;
name|file_ptr
name|text_ptr
decl_stmt|,
name|data_ptr
decl_stmt|,
name|other_ptr
decl_stmt|;
name|asection
modifier|*
name|bss_sec
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|true
condition|)
return|return
name|true
return|;
comment|/* Make sure we have a section to hold uninitialized data.  */
name|bss_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss_sec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|add_bfd_section
argument_list|(
name|abfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|0
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|false
return|;
name|bss_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
block|}
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
comment|/* The fixed header.  */
name|sofar
operator|=
name|nlm_optional_prefix_size
argument_list|(
name|abfd
argument_list|)
operator|+
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* The variable header.  */
name|sofar
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
argument_list|)
operator|+
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|descriptionLength
operator|+
literal|1
operator|+
name|NLM_TARGET_LONG_SIZE
comment|/* stackSize */
operator|+
name|NLM_TARGET_LONG_SIZE
comment|/* reserved */
operator|+
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|oldThreadName
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
argument_list|)
operator|+
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|screenNameLength
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
argument_list|)
operator|+
name|nlm_variable_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|threadNameLength
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* The auxiliary headers.  */
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_version_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Version_Header
argument_list|)
argument_list|)
condition|)
name|sofar
operator|+=
sizeof|sizeof
argument_list|(
name|Nlm_External_Version_Header
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_extended_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Extended_Header
argument_list|)
argument_list|)
condition|)
name|sofar
operator|+=
sizeof|sizeof
argument_list|(
name|Nlm_External_Extended_Header
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Copyright_Header
argument_list|)
argument_list|)
condition|)
name|sofar
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|Nlm_External_Copyright_Header
argument_list|)
operator|+
name|nlm_copyright_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyrightMessageLength
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Custom_Header
argument_list|)
argument_list|)
condition|)
name|sofar
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|Nlm_External_Custom_Header
argument_list|)
operator|+
name|nlm_custom_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|hdrLength
operator|)
expr_stmt|;
if|if
condition|(
name|find_nonzero
argument_list|(
operator|(
name|PTR
operator|)
name|nlm_cygnus_ext_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Nlm_Internal_Cygnus_Ext_Header
argument_list|)
argument_list|)
condition|)
name|sofar
operator|+=
sizeof|sizeof
argument_list|(
name|Nlm_External_Custom_Header
argument_list|)
expr_stmt|;
comment|/* Compute the section file positions in two passes.  First get the      sizes of the text and data sections, and then set the file      positions.  This code aligns the sections in the file using the      same alignment restrictions that apply to the sections in memory;      this may not be necessary.  */
name|text
operator|=
literal|0
expr_stmt|;
name|text_low
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|text_align
operator|=
literal|0
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
name|data_low
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|data_align
operator|=
literal|0
expr_stmt|;
name|bss
operator|=
literal|0
expr_stmt|;
name|other_align
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|flagword
name|f
decl_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|,
literal|1
operator|<<
name|sec
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|f
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|SEC_CODE
condition|)
block|{
name|text
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|<
name|text_low
condition|)
name|text_low
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
name|text_align
condition|)
name|text_align
operator|=
name|sec
operator|->
name|alignment_power
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&
name|SEC_DATA
condition|)
block|{
name|data
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|<
name|data_low
condition|)
name|data_low
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
name|data_align
condition|)
name|data_align
operator|=
name|sec
operator|->
name|alignment_power
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
name|other_align
condition|)
name|other_align
operator|=
name|sec
operator|->
name|alignment_power
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&
name|SEC_ALLOC
condition|)
name|bss
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
name|nlm_set_text_low
argument_list|(
name|abfd
argument_list|,
name|text_low
argument_list|)
expr_stmt|;
name|nlm_set_data_low
argument_list|(
name|abfd
argument_list|,
name|data_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlm_no_uninitialized_data
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* This NetWare format does not use uninitialized data.  We must 	 increase the size of the data section.  We will never wind up 	 writing those file locations, so they will remain zero.  */
name|data
operator|+=
name|bss
expr_stmt|;
name|bss
operator|=
literal|0
expr_stmt|;
block|}
name|text_ptr
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|text_align
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
name|BFD_ALIGN
argument_list|(
name|text_ptr
operator|+
name|text
argument_list|,
literal|1
operator|<<
name|data_align
argument_list|)
expr_stmt|;
name|other_ptr
operator|=
name|BFD_ALIGN
argument_list|(
name|data_ptr
operator|+
name|data
argument_list|,
literal|1
operator|<<
name|other_align
argument_list|)
expr_stmt|;
comment|/* Fill in some fields in the header for which we now have the      information.  */
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeImageOffset
operator|=
name|text_ptr
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeImageSize
operator|=
name|text
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataImageOffset
operator|=
name|data_ptr
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataImageSize
operator|=
name|data
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|uninitializedDataSize
operator|=
name|bss
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|flagword
name|f
decl_stmt|;
name|f
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|SEC_CODE
condition|)
block|{
name|sec
operator|->
name|filepos
operator|=
name|text_ptr
expr_stmt|;
name|text_ptr
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&
name|SEC_DATA
condition|)
block|{
name|sec
operator|->
name|filepos
operator|=
name|data_ptr
expr_stmt|;
name|data_ptr
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|sec
operator|->
name|filepos
operator|=
name|other_ptr
expr_stmt|;
name|other_ptr
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|relocationFixupOffset
operator|=
name|other_ptr
expr_stmt|;
comment|/* Move all common symbols into the .bss section.  */
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_ptr_ptr
operator|!=
name|NULL
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
name|bfd_vma
name|add
decl_stmt|;
name|sym_end
operator|=
name|sym_ptr_ptr
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|sym
operator|=
operator|*
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Put the common symbol in the .bss section, and increase 	     the size of the .bss section by the size of the common 	     symbol (which is the old value of the symbol).  */
name|sym
operator|->
name|section
operator|=
name|bss_sec
expr_stmt|;
name|size
operator|=
name|sym
operator|->
name|value
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|bss_sec
operator|->
name|_raw_size
operator|+
name|add
expr_stmt|;
name|add
operator|+=
name|size
expr_stmt|;
name|add
operator|=
name|BFD_ALIGN
argument_list|(
name|add
argument_list|,
literal|1
operator|<<
name|bss_sec
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nlm_no_uninitialized_data
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* We could handle this case, but so far it hasn't been 		 necessary.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|uninitializedDataSize
operator|+=
name|add
expr_stmt|;
name|bss_sec
operator|->
name|_raw_size
operator|+=
name|add
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the contents of a section.  To do this we need to know where    the section is going to be located in the output file.  That means    that the sizes of all the sections must be set, and all the    variable size header information must be known.  */
end_comment

begin_function
name|boolean
name|nlm_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
operator|&&
name|nlm_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* i386 NetWare has a very restricted set of relocs.  In order for      objcopy to work, the NLM i386 backend needs a chance to rework      the section contents so that its set of relocs will work.  If all      the relocs are already acceptable, this will not do anything.  */
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
name|boolean
argument_list|(
argument|*mangle_relocs_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|,
name|bfd_size_type
operator|)
argument_list|)
expr_stmt|;
name|mangle_relocs_func
operator|=
name|nlm_mangle_relocs_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mangle_relocs_func
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|mangle_relocs_func
call|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
operator|(
name|bfd_vma
operator|)
name|offset
argument_list|,
name|count
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We need to sort a list of relocs associated with sections when we    write out the external relocs.  */
end_comment

begin_function
specifier|static
name|int
name|nlm_external_reloc_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|;
specifier|const
name|void
modifier|*
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|reloc_and_sec
modifier|*
name|r1
init|=
operator|(
specifier|const
expr|struct
name|reloc_and_sec
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|reloc_and_sec
modifier|*
name|r2
init|=
operator|(
specifier|const
expr|struct
name|reloc_and_sec
operator|*
operator|)
name|p2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|strcmp
argument_list|(
operator|(
operator|*
name|r1
operator|->
name|rel
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|r2
operator|->
name|rel
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
return|;
comment|/* We sort by address within symbol to make the sort more stable and      increase the chances that different hosts will generate bit for      bit equivalent results.  */
return|return
call|(
name|int
call|)
argument_list|(
name|r1
operator|->
name|rel
operator|->
name|address
operator|-
name|r2
operator|->
name|rel
operator|->
name|address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out an NLM file.  We write out the information in this order:      fixed header      variable header      auxiliary headers      code sections      data sections      other sections (custom data, messages, help, shared NLM, RPC,      		     module dependencies)      relocation fixups      external references (imports)      public symbols (exports)      debugging records    This is similar to the order used by the NetWare tools; the    difference is that NetWare puts the sections other than code, data    and custom data at the end of the NLM.  It is convenient for us to    know where the sections are going to be before worrying about the    size of the other information.     By the time this function is called, all the section data should    have been output using set_section_contents.  Note that custom    data, the message file, the help file, the shared NLM file, the RPC    data, and the module dependencies are all considered to be    sections; the caller is responsible for filling in the offset and    length fields in the NLM headers.  The relocation fixups and    imports are both obtained from the list of relocs attached to each    section.  The exports and debugging records are obtained from the    list of outsymbols.  */
end_comment

begin_function
name|boolean
name|nlm_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|boolean
argument_list|(
argument|*write_import_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd_size_type
name|external_reloc_count
decl_stmt|,
name|internal_reloc_count
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|reloc_and_sec
modifier|*
name|external_relocs
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
name|file_ptr
name|last
decl_stmt|;
name|boolean
argument_list|(
argument|*write_prefix_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
name|unsigned
name|char
modifier|*
name|fixed_header
init|=
name|NULL
decl_stmt|;
name|fixed_header
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fixed_header
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
operator|&&
name|nlm_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
comment|/* Write out the variable length headers.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|nlm_optional_prefix_size
argument_list|(
name|abfd
argument_list|)
operator|+
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|nlm_swap_variable_header_out
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
operator|||
name|nlm_swap_auxiliary_headers_out
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* A weak check on whether the section file positions were      reasonable.  */
if|if
condition|(
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|>
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeImageOffset
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Advance to the relocs.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|relocationFixupOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* The format of the relocation entries is dependent upon the      particular target.  We use an external routine to write the reloc      out.  */
name|write_import_func
operator|=
name|nlm_write_import_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Write out the internal relocation fixups.  While we're looping      over the relocs, we also count the external relocs, which is      needed when they are written out below.  */
name|internal_reloc_count
operator|=
literal|0
expr_stmt|;
name|external_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|rel_ptr_ptr
decl_stmt|,
modifier|*
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* We can only represent relocs within a code or data 	 section.  We ignore them for a debugging section.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* We need to know how to write out imports */
if|if
condition|(
name|write_import_func
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|rel_ptr_ptr
operator|=
name|sec
operator|->
name|orelocation
expr_stmt|;
name|rel_end
operator|=
name|rel_ptr_ptr
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel_ptr_ptr
operator|<
name|rel_end
condition|;
name|rel_ptr_ptr
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|rel
operator|=
operator|*
name|rel_ptr_ptr
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|internal_reloc_count
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|write_import_func
call|)
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
operator|++
name|external_reloc_count
expr_stmt|;
block|}
block|}
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfRelocationFixups
operator|=
name|internal_reloc_count
expr_stmt|;
comment|/* Write out the imports (relocs against external symbols).  These      are output as a symbol name followed by all the relocs for that      symbol, so we must first gather together all the relocs against      external symbols and sort them.  */
name|external_relocs
operator|=
operator|(
expr|struct
name|reloc_and_sec
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|external_reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_and_sec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
operator|(
expr|struct
name|reloc_and_sec
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|rel_ptr_ptr
decl_stmt|,
modifier|*
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|rel_ptr_ptr
operator|=
name|sec
operator|->
name|orelocation
expr_stmt|;
name|rel_end
operator|=
name|rel_ptr_ptr
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel_ptr_ptr
operator|<
name|rel_end
condition|;
name|rel_ptr_ptr
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|rel
operator|=
operator|*
name|rel_ptr_ptr
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
continue|continue;
name|external_relocs
index|[
name|i
index|]
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|external_relocs
index|[
name|i
index|]
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|i
operator|==
name|external_reloc_count
argument_list|)
expr_stmt|;
comment|/* Sort the external relocs by name.  */
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|external_relocs
argument_list|,
operator|(
name|size_t
operator|)
name|external_reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_and_sec
argument_list|)
argument_list|,
name|nlm_external_reloc_compare
argument_list|)
expr_stmt|;
comment|/* Write out the external relocs.  */
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|externalReferencesOffset
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|external_reloc_count
condition|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|,
name|cnt
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|rel
operator|=
name|external_relocs
index|[
name|i
index|]
operator|.
name|rel
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
operator|(
name|j
operator|<
name|external_reloc_count
operator|&&
operator|*
name|external_relocs
index|[
name|j
index|]
operator|.
name|rel
operator|->
name|sym_ptr_ptr
operator|==
name|sym
operator|)
condition|;
name|j
operator|++
control|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|nlm_write_external_func
argument_list|(
name|abfd
argument_list|)
operator|)
operator|(
name|abfd
operator|,
name|cnt
operator|,
name|sym
operator|,
operator|&
name|external_relocs
index|[
name|i
index|]
operator|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
name|i
operator|+=
name|cnt
expr_stmt|;
block|}
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfExternalReferences
operator|=
name|c
expr_stmt|;
comment|/* Write out the public symbols (exports).  */
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_ptr_ptr
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_vma
argument_list|(
argument|*get_public_offset_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*write_export_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
expr_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|publicsOffset
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|get_public_offset_func
operator|=
name|nlm_get_public_offset_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|write_export_func
operator|=
name|nlm_write_export_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|sym_end
operator|=
name|sym_ptr_ptr
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_byte
name|len
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_byte
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
name|sym
operator|=
operator|*
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator|)
operator|)
operator|==
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
continue|continue;
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|get_public_offset_func
condition|)
block|{
comment|/* Most backends can use the code below, but 		 unfortunately some use a different scheme.  */
name|offset
operator|=
call|(
modifier|*
name|get_public_offset_func
call|)
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sym
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|offset
operator|-=
name|nlm_get_text_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|offset
operator||=
name|NLM_HIBIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
comment|/* SEC_ALLOC is for the .bss section.  */
name|offset
operator|-=
name|nlm_get_data_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle an exported symbol that is not in 		     the code or data segment.  */
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|write_export_func
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|write_export_func
call|)
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
name|offset
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_write
argument_list|(
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
operator|)
operator|||
name|bfd_write
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|error_return
goto|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfPublics
operator|=
name|c
expr_stmt|;
comment|/* Write out the debugging records.  The NLM conversion program 	 wants to be able to inhibit this, so as a special hack if 	 debugInfoOffset is set to -1 we don't write any debugging 	 information.  This can not be handled by fiddling with the 	 symbol table, because exported symbols appear in both the 	 exported symbol list and the debugging information.  */
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|debugInfoOffset
operator|==
operator|(
name|file_ptr
operator|)
operator|-
literal|1
condition|)
block|{
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|debugInfoOffset
operator|=
literal|0
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfDebugRecords
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|debugInfoOffset
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_end
operator|=
name|sym_ptr_ptr
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_byte
name|type
decl_stmt|,
name|len
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_byte
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
name|sym
operator|=
operator|*
name|sym_ptr_ptr
expr_stmt|;
comment|/* The NLM notion of a debugging symbol is actually what 		 BFD calls a local or global symbol.  What BFD calls a 		 debugging symbol NLM does not understand at all.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_LOCAL
operator||
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
continue|continue;
operator|++
name|c
expr_stmt|;
name|offset
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sym
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|offset
operator|-=
name|nlm_get_text_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|type
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
comment|/* SEC_ALLOC is for the .bss section.  */
name|offset
operator|-=
name|nlm_get_data_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|type
operator|=
literal|2
expr_stmt|;
comment|/* The type is 0 for data, 1 for code, 2 for absolute.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|len
operator|=
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_write
argument_list|(
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
operator|)
operator|||
name|bfd_write
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|error_return
goto|;
block|}
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|numberOfDebugRecords
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* NLMLINK fills in offset values even if there is no data, so we do      the same.  */
name|last
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeImageOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeImageOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataImageOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataImageOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|customDataOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|customDataOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|moduleDependencyOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|moduleDependencyOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|relocationFixupOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|relocationFixupOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|externalReferencesOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|externalReferencesOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|publicsOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|publicsOffset
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|debugInfoOffset
operator|==
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|debugInfoOffset
operator|=
name|last
expr_stmt|;
comment|/* At this point everything has been written out except the fixed      header.  */
name|memcpy
argument_list|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|signature
argument_list|,
name|nlm_signature
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|NLM_SIGNATURE_SIZE
argument_list|)
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|version
operator|=
name|NLM_HEADER_VERSION
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|codeStartOffset
operator|=
operator|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|-
name|nlm_get_text_low
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
comment|/* We have no convenient way for the caller to pass in the exit      procedure or the check unload procedure, so the caller must set      the values in the header to the values of the symbols.  */
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|exitProcedureOffset
operator|-=
name|nlm_get_text_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|checkUnloadProcedureOffset
operator|!=
literal|0
condition|)
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|checkUnloadProcedureOffset
operator|-=
name|nlm_get_text_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|write_prefix_func
operator|=
name|nlm_write_prefix_func
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_prefix_func
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|write_prefix_func
call|)
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|==
name|nlm_optional_prefix_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_swap_fixed_header_out
argument_list|(
name|abfd
argument_list|,
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|fixed_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|fixed_header
argument_list|,
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|nlm_fixed_header_size
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|fixed_header
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fixed_header
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|fixed_header
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fixed_header
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

end_unit

