begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bfd back-end for HP PA-RISC SOM objects.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.     Contributed by the Center for Software Science at the    University of Utah (pa-gdb-bugs@cs.utah.edu).     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HOST_HPPAHPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|HOST_HPPABSD
argument_list|)
operator|||
name|defined
argument_list|(
name|HOST_HPPAOSF
argument_list|)
end_if

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"som.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Magic not defined in standard HP-UX header files until 8.0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_PA_RISC1_0
end_ifndef

begin_define
define|#
directive|define
name|CPU_PA_RISC1_0
value|0x20B
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_PA_RISC1_0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_PA_RISC1_1
end_ifndef

begin_define
define|#
directive|define
name|CPU_PA_RISC1_1
value|0x210
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_PA_RISC1_1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC1_0_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC1_0_ID
value|CPU_PA_RISC1_0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC1_0_ID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC1_1_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC1_1_ID
value|CPU_PA_RISC1_1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC1_1_ID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC_MAXID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC_MAXID
value|0x2FF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC_MAXID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC_ID
parameter_list|(
name|__m_num
parameter_list|)
define|\
value|(((__m_num) == _PA_RISC1_0_ID) ||	\      ((__m_num)>= _PA_RISC1_1_ID&& (__m_num)<= _PA_RISC_MAXID))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC_ID */
end_comment

begin_comment
comment|/* HIUX in it's infinite stupidity changed the names for several "well    known" constants.  Work around such braindamage.  Try the HPUX version    first, then the HIUX version, and finally provide a default.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_AUX_ID
end_ifdef

begin_define
define|#
directive|define
name|EXEC_AUX_ID
value|HPUX_AUX_ID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXEC_AUX_ID
argument_list|)
operator|&&
name|defined
argument_list|(
name|HIUX_AUX_ID
argument_list|)
end_if

begin_define
define|#
directive|define
name|EXEC_AUX_ID
value|HIUX_AUX_ID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXEC_AUX_ID
end_ifndef

begin_define
define|#
directive|define
name|EXEC_AUX_ID
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size (in chars) of the temporary buffers used during fixup and string    table writes.   */
end_comment

begin_define
define|#
directive|define
name|SOM_TMP_BUFSIZE
value|8192
end_define

begin_comment
comment|/* Size of the hash table in archives.  */
end_comment

begin_define
define|#
directive|define
name|SOM_LST_HASH_SIZE
value|31
end_define

begin_comment
comment|/* Max number of SOMs to be found in an archive.  */
end_comment

begin_define
define|#
directive|define
name|SOM_LST_MODULE_LIMIT
value|1024
end_define

begin_comment
comment|/* Generic alignment macro.  */
end_comment

begin_define
define|#
directive|define
name|SOM_ALIGN
parameter_list|(
name|val
parameter_list|,
name|alignment
parameter_list|)
define|\
value|(((val) + (alignment) - 1)& ~((alignment) - 1))
end_define

begin_comment
comment|/* SOM allows any one of the four previous relocations to be reused    with a "R_PREV_FIXUP" relocation entry.  Since R_PREV_FIXUP    relocations are always a single byte, using a R_PREV_FIXUP instead    of some multi-byte relocation makes object files smaller.      Note one side effect of using a R_PREV_FIXUP is the relocation that    is being repeated moves to the front of the queue.  */
end_comment

begin_struct
struct|struct
name|reloc_queue
block|{
name|unsigned
name|char
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
name|reloc_queue
index|[
literal|4
index|]
struct|;
end_struct

begin_comment
comment|/* This fully describes the symbol types which may be attached to    an EXPORT or IMPORT directive.  Only SOM uses this formation    (ELF has no need for it).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SYMBOL_TYPE_UNKNOWN
block|,
name|SYMBOL_TYPE_ABSOLUTE
block|,
name|SYMBOL_TYPE_CODE
block|,
name|SYMBOL_TYPE_DATA
block|,
name|SYMBOL_TYPE_ENTRY
block|,
name|SYMBOL_TYPE_MILLICODE
block|,
name|SYMBOL_TYPE_PLABEL
block|,
name|SYMBOL_TYPE_PRI_PROG
block|,
name|SYMBOL_TYPE_SEC_PROG
block|, }
name|pa_symbol_type
typedef|;
end_typedef

begin_struct
struct|struct
name|section_to_type
block|{
name|char
modifier|*
name|section
decl_stmt|;
name|char
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Assorted symbol information that needs to be derived from the BFD symbol    and/or the BFD backend private symbol data.  */
end_comment

begin_struct
struct|struct
name|som_misc_symbol_info
block|{
name|unsigned
name|int
name|symbol_type
decl_stmt|;
name|unsigned
name|int
name|symbol_scope
decl_stmt|;
name|unsigned
name|int
name|arg_reloc
decl_stmt|;
name|unsigned
name|int
name|symbol_info
decl_stmt|;
name|unsigned
name|int
name|symbol_value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|som_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|som_object_setup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|header
operator|*
operator|,
expr|struct
name|som_exec_auxhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|setup_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|header
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|som_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_slurp_string_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|som_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|som_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|som_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|som_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|som_set_reloc_info
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|arelent
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|som_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|som_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_copy_private_symbol_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_copy_private_section_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|som_bfd_merge_private_bfd_data
value|_bfd_generic_bfd_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|som_bfd_set_private_flags
value|_bfd_generic_bfd_set_private_flags
end_define

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_is_local_label
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|bfd_section_from_som_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|symbol_dictionary_record
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log2
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|hppa_som_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_initialize_reloc_queue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_reloc_queue_insert
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_reloc_queue_fix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|reloc_queue
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|som_reloc_queue_find
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|try_prev_fixup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_skip
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_addend
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_call
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|arelent
operator|*
operator|,
name|int
operator|,
expr|struct
name|reloc_queue
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|som_count_spaces
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|som_count_subspaces
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_syms
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_subspaces
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|som_compute_checksum
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_prep_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|som_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_finish_writing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_build_and_write_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_prep_for_fixups
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_write_fixups
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_write_space_strings
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_write_symbol_strings
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_begin_writing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|som_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|som_section_type
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|som_decode_symclass
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_count_ar_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|lst_header
operator|*
operator|,
name|symindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_fill_in_ar_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|lst_header
operator|*
operator|,
name|carsym
operator|*
operator|*
name|syms
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_bfd_derive_misc_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
expr|struct
name|som_misc_symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_prep_for_ar_write
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|som_bfd_ar_symbol_hash
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_ar_write_symbol_stuff
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|lst_header
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|normalize
name|PARAMS
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_is_space
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_is_subspace
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_is_container
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_free_cached_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|som_bfd_link_split_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map SOM section names to POSIX/BSD single-character symbol types.     This table includes all the standard subspaces as defined in the     current "PRO ABI for PA-RISC Systems", $UNWIND$ which for     some reason was left out, and sections specific to embedded stabs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|section_to_type
name|stt
index|[]
init|=
block|{
block|{
literal|"$TEXT$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$SHLIB_INFO$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$MILLICODE$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$LIT$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$CODE$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$UNWIND_START$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$UNWIND$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$PRIVATE$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$PLT$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$SHLIB_DATA$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$DATA$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$SHORTDATA$"
block|,
literal|'g'
block|}
block|,
block|{
literal|"$DLT$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$GLOBAL$"
block|,
literal|'g'
block|}
block|,
block|{
literal|"$SHORTBSS$"
block|,
literal|'s'
block|}
block|,
block|{
literal|"$BSS$"
block|,
literal|'b'
block|}
block|,
block|{
literal|"$GDB_STRINGS$"
block|,
literal|'N'
block|}
block|,
block|{
literal|"$GDB_SYMBOLS$"
block|,
literal|'N'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* About the relocation formatting table...     There are 256 entries in the table, one for each possible    relocation opcode available in SOM.  We index the table by    the relocation opcode.  The names and operations are those    defined by a.out_800 (4).     Right now this table is only used to count and perform minimal    processing on relocation streams so that they can be internalized    into BFD and symbolically printed by utilities.  To make actual use     of them would be much more difficult, BFD's concept of relocations    is far too simple to handle SOM relocations.  The basic assumption    that a relocation can be completely processed independent of other    relocations before an object file is written is invalid for SOM.     The SOM relocations are meant to be processed as a stream, they    specify copying of data from the input section to the output section    while possibly modifying the data in some manner.  They also can     specify that a variable number of zeros or uninitialized data be    inserted on in the output segment at the current offset.  Some    relocations specify that some previous relocation be re-applied at    the current location in the input/output sections.  And finally a number    of relocations have effects on other sections (R_ENTRY, R_EXIT,    R_UNWIND_AUX and a variety of others).  There isn't even enough room    in the BFD relocation data structure to store enough information to    perform all the relocations.     Each entry in the table has three fields.      The first entry is an index into this "class" of relocations.  This    index can then be used as a variable within the relocation itself.     The second field is a format string which actually controls processing    of the relocation.  It uses a simple postfix machine to do calculations    based on variables/constants found in the string and the relocation    stream.       The third field specifys whether or not this relocation may use     a constant (V) from the previous R_DATA_OVERRIDE rather than a constant    stored in the instruction.     Variables:         L = input space byte count    D = index into class of relocations    M = output space byte count    N = statement number (unused?)    O = stack operation    R = parameter relocation bits    S = symbol index    T = first 32 bits of stack unwind information    U = second 32 bits of stack unwind information    V = a literal constant (usually used in the next relocation)    P = a previous relocation       Lower case letters (starting with 'b') refer to following     bytes in the relocation stream.  'b' is the next 1 byte,    c is the next 2 bytes, d is the next 3 bytes, etc...      This is the variable part of the relocation entries that    makes our life a living hell.     numerical constants are also used in the format string.  Note    the constants are represented in decimal.      '+', "*" and "=" represents the obvious postfix operators.    '<' represents a left shift.      Stack Operations:     Parameter Relocation Bits:     Unwind Entries:          Previous Relocations:  The index field represents which in the queue    of 4 previous fixups should be re-applied.     Literal Constants:  These are generally used to represent addend    parts of relocations when these constants are not stored in the    fields of the instructions themselves.  For example the instruction    addil foo-$global$-0x1234 would use an override for "0x1234" rather    than storing it into the addil itself.  */
end_comment

begin_struct
struct|struct
name|fixup_format
block|{
name|int
name|D
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fixup_format
name|som_fixup_formats
index|[
literal|256
index|]
init|=
block|{
comment|/* R_NO_RELOCATION */
literal|0
block|,
literal|"LD1+4*="
block|,
comment|/* 0x00 */
literal|1
block|,
literal|"LD1+4*="
block|,
comment|/* 0x01 */
literal|2
block|,
literal|"LD1+4*="
block|,
comment|/* 0x02 */
literal|3
block|,
literal|"LD1+4*="
block|,
comment|/* 0x03 */
literal|4
block|,
literal|"LD1+4*="
block|,
comment|/* 0x04 */
literal|5
block|,
literal|"LD1+4*="
block|,
comment|/* 0x05 */
literal|6
block|,
literal|"LD1+4*="
block|,
comment|/* 0x06 */
literal|7
block|,
literal|"LD1+4*="
block|,
comment|/* 0x07 */
literal|8
block|,
literal|"LD1+4*="
block|,
comment|/* 0x08 */
literal|9
block|,
literal|"LD1+4*="
block|,
comment|/* 0x09 */
literal|10
block|,
literal|"LD1+4*="
block|,
comment|/* 0x0a */
literal|11
block|,
literal|"LD1+4*="
block|,
comment|/* 0x0b */
literal|12
block|,
literal|"LD1+4*="
block|,
comment|/* 0x0c */
literal|13
block|,
literal|"LD1+4*="
block|,
comment|/* 0x0d */
literal|14
block|,
literal|"LD1+4*="
block|,
comment|/* 0x0e */
literal|15
block|,
literal|"LD1+4*="
block|,
comment|/* 0x0f */
literal|16
block|,
literal|"LD1+4*="
block|,
comment|/* 0x10 */
literal|17
block|,
literal|"LD1+4*="
block|,
comment|/* 0x11 */
literal|18
block|,
literal|"LD1+4*="
block|,
comment|/* 0x12 */
literal|19
block|,
literal|"LD1+4*="
block|,
comment|/* 0x13 */
literal|20
block|,
literal|"LD1+4*="
block|,
comment|/* 0x14 */
literal|21
block|,
literal|"LD1+4*="
block|,
comment|/* 0x15 */
literal|22
block|,
literal|"LD1+4*="
block|,
comment|/* 0x16 */
literal|23
block|,
literal|"LD1+4*="
block|,
comment|/* 0x17 */
literal|0
block|,
literal|"LD8<b+1+4*="
block|,
comment|/* 0x18 */
literal|1
block|,
literal|"LD8<b+1+4*="
block|,
comment|/* 0x19 */
literal|2
block|,
literal|"LD8<b+1+4*="
block|,
comment|/* 0x1a */
literal|3
block|,
literal|"LD8<b+1+4*="
block|,
comment|/* 0x1b */
literal|0
block|,
literal|"LD16<c+1+4*="
block|,
comment|/* 0x1c */
literal|1
block|,
literal|"LD16<c+1+4*="
block|,
comment|/* 0x1d */
literal|2
block|,
literal|"LD16<c+1+4*="
block|,
comment|/* 0x1e */
literal|0
block|,
literal|"Ld1+="
block|,
comment|/* 0x1f */
comment|/* R_ZEROES */
literal|0
block|,
literal|"Lb1+4*="
block|,
comment|/* 0x20 */
literal|1
block|,
literal|"Ld1+="
block|,
comment|/* 0x21 */
comment|/* R_UNINIT */
literal|0
block|,
literal|"Lb1+4*="
block|,
comment|/* 0x22 */
literal|1
block|,
literal|"Ld1+="
block|,
comment|/* 0x23 */
comment|/* R_RELOCATION */
literal|0
block|,
literal|"L4="
block|,
comment|/* 0x24 */
comment|/* R_DATA_ONE_SYMBOL */
literal|0
block|,
literal|"L4=Sb="
block|,
comment|/* 0x25 */
literal|1
block|,
literal|"L4=Sd="
block|,
comment|/* 0x26 */
comment|/* R_DATA_PLEBEL */
literal|0
block|,
literal|"L4=Sb="
block|,
comment|/* 0x27 */
literal|1
block|,
literal|"L4=Sd="
block|,
comment|/* 0x28 */
comment|/* R_SPACE_REF */
literal|0
block|,
literal|"L4="
block|,
comment|/* 0x29 */
comment|/* R_REPEATED_INIT */
literal|0
block|,
literal|"L4=Mb1+4*="
block|,
comment|/* 0x2a */
literal|1
block|,
literal|"Lb4*=Mb1+L*="
block|,
comment|/* 0x2b */
literal|2
block|,
literal|"Lb4*=Md1+4*="
block|,
comment|/* 0x2c */
literal|3
block|,
literal|"Ld1+=Me1+="
block|,
comment|/* 0x2d */
comment|/* R_SHORT_PCREL_MODE */
literal|0
block|,
literal|""
block|,
comment|/* 0x2e */
comment|/* R_LONG_PCREL_MODE */
literal|0
block|,
literal|""
block|,
comment|/* 0x2f */
comment|/* R_PCREL_CALL */
literal|0
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x30 */
literal|1
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x31 */
literal|2
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x32 */
literal|3
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x33 */
literal|4
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x34 */
literal|5
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x35 */
literal|6
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x36 */
literal|7
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x37 */
literal|8
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x38 */
literal|9
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x39 */
literal|0
block|,
literal|"L4=RD8<b+=Sb="
block|,
comment|/* 0x3a */
literal|1
block|,
literal|"L4=RD8<b+=Sb="
block|,
comment|/* 0x3b */
literal|0
block|,
literal|"L4=RD8<b+=Sd="
block|,
comment|/* 0x3c */
literal|1
block|,
literal|"L4=RD8<b+=Sd="
block|,
comment|/* 0x3d */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0x3e */
literal|0
block|,
literal|""
block|,
comment|/* 0x3f */
comment|/* R_ABS_CALL */
literal|0
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x40 */
literal|1
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x41 */
literal|2
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x42 */
literal|3
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x43 */
literal|4
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x44 */
literal|5
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x45 */
literal|6
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x46 */
literal|7
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x47 */
literal|8
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x48 */
literal|9
block|,
literal|"L4=RD=Sb="
block|,
comment|/* 0x49 */
literal|0
block|,
literal|"L4=RD8<b+=Sb="
block|,
comment|/* 0x4a */
literal|1
block|,
literal|"L4=RD8<b+=Sb="
block|,
comment|/* 0x4b */
literal|0
block|,
literal|"L4=RD8<b+=Sd="
block|,
comment|/* 0x4c */
literal|1
block|,
literal|"L4=RD8<b+=Sd="
block|,
comment|/* 0x4d */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0x4e */
literal|0
block|,
literal|""
block|,
comment|/* 0x4f */
comment|/* R_DP_RELATIVE */
literal|0
block|,
literal|"L4=SD="
block|,
comment|/* 0x50 */
literal|1
block|,
literal|"L4=SD="
block|,
comment|/* 0x51 */
literal|2
block|,
literal|"L4=SD="
block|,
comment|/* 0x52 */
literal|3
block|,
literal|"L4=SD="
block|,
comment|/* 0x53 */
literal|4
block|,
literal|"L4=SD="
block|,
comment|/* 0x54 */
literal|5
block|,
literal|"L4=SD="
block|,
comment|/* 0x55 */
literal|6
block|,
literal|"L4=SD="
block|,
comment|/* 0x56 */
literal|7
block|,
literal|"L4=SD="
block|,
comment|/* 0x57 */
literal|8
block|,
literal|"L4=SD="
block|,
comment|/* 0x58 */
literal|9
block|,
literal|"L4=SD="
block|,
comment|/* 0x59 */
literal|10
block|,
literal|"L4=SD="
block|,
comment|/* 0x5a */
literal|11
block|,
literal|"L4=SD="
block|,
comment|/* 0x5b */
literal|12
block|,
literal|"L4=SD="
block|,
comment|/* 0x5c */
literal|13
block|,
literal|"L4=SD="
block|,
comment|/* 0x5d */
literal|14
block|,
literal|"L4=SD="
block|,
comment|/* 0x5e */
literal|15
block|,
literal|"L4=SD="
block|,
comment|/* 0x5f */
literal|16
block|,
literal|"L4=SD="
block|,
comment|/* 0x60 */
literal|17
block|,
literal|"L4=SD="
block|,
comment|/* 0x61 */
literal|18
block|,
literal|"L4=SD="
block|,
comment|/* 0x62 */
literal|19
block|,
literal|"L4=SD="
block|,
comment|/* 0x63 */
literal|20
block|,
literal|"L4=SD="
block|,
comment|/* 0x64 */
literal|21
block|,
literal|"L4=SD="
block|,
comment|/* 0x65 */
literal|22
block|,
literal|"L4=SD="
block|,
comment|/* 0x66 */
literal|23
block|,
literal|"L4=SD="
block|,
comment|/* 0x67 */
literal|24
block|,
literal|"L4=SD="
block|,
comment|/* 0x68 */
literal|25
block|,
literal|"L4=SD="
block|,
comment|/* 0x69 */
literal|26
block|,
literal|"L4=SD="
block|,
comment|/* 0x6a */
literal|27
block|,
literal|"L4=SD="
block|,
comment|/* 0x6b */
literal|28
block|,
literal|"L4=SD="
block|,
comment|/* 0x6c */
literal|29
block|,
literal|"L4=SD="
block|,
comment|/* 0x6d */
literal|30
block|,
literal|"L4=SD="
block|,
comment|/* 0x6e */
literal|31
block|,
literal|"L4=SD="
block|,
comment|/* 0x6f */
literal|32
block|,
literal|"L4=Sb="
block|,
comment|/* 0x70 */
literal|33
block|,
literal|"L4=Sd="
block|,
comment|/* 0x71 */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0x72 */
literal|0
block|,
literal|""
block|,
comment|/* 0x73 */
literal|0
block|,
literal|""
block|,
comment|/* 0x74 */
literal|0
block|,
literal|""
block|,
comment|/* 0x75 */
literal|0
block|,
literal|""
block|,
comment|/* 0x76 */
literal|0
block|,
literal|""
block|,
comment|/* 0x77 */
comment|/* R_DLT_REL */
literal|0
block|,
literal|"L4=Sb="
block|,
comment|/* 0x78 */
literal|1
block|,
literal|"L4=Sd="
block|,
comment|/* 0x79 */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0x7a */
literal|0
block|,
literal|""
block|,
comment|/* 0x7b */
literal|0
block|,
literal|""
block|,
comment|/* 0x7c */
literal|0
block|,
literal|""
block|,
comment|/* 0x7d */
literal|0
block|,
literal|""
block|,
comment|/* 0x7e */
literal|0
block|,
literal|""
block|,
comment|/* 0x7f */
comment|/* R_CODE_ONE_SYMBOL */
literal|0
block|,
literal|"L4=SD="
block|,
comment|/* 0x80 */
literal|1
block|,
literal|"L4=SD="
block|,
comment|/* 0x81 */
literal|2
block|,
literal|"L4=SD="
block|,
comment|/* 0x82 */
literal|3
block|,
literal|"L4=SD="
block|,
comment|/* 0x83 */
literal|4
block|,
literal|"L4=SD="
block|,
comment|/* 0x84 */
literal|5
block|,
literal|"L4=SD="
block|,
comment|/* 0x85 */
literal|6
block|,
literal|"L4=SD="
block|,
comment|/* 0x86 */
literal|7
block|,
literal|"L4=SD="
block|,
comment|/* 0x87 */
literal|8
block|,
literal|"L4=SD="
block|,
comment|/* 0x88 */
literal|9
block|,
literal|"L4=SD="
block|,
comment|/* 0x89 */
literal|10
block|,
literal|"L4=SD="
block|,
comment|/* 0x8q */
literal|11
block|,
literal|"L4=SD="
block|,
comment|/* 0x8b */
literal|12
block|,
literal|"L4=SD="
block|,
comment|/* 0x8c */
literal|13
block|,
literal|"L4=SD="
block|,
comment|/* 0x8d */
literal|14
block|,
literal|"L4=SD="
block|,
comment|/* 0x8e */
literal|15
block|,
literal|"L4=SD="
block|,
comment|/* 0x8f */
literal|16
block|,
literal|"L4=SD="
block|,
comment|/* 0x90 */
literal|17
block|,
literal|"L4=SD="
block|,
comment|/* 0x91 */
literal|18
block|,
literal|"L4=SD="
block|,
comment|/* 0x92 */
literal|19
block|,
literal|"L4=SD="
block|,
comment|/* 0x93 */
literal|20
block|,
literal|"L4=SD="
block|,
comment|/* 0x94 */
literal|21
block|,
literal|"L4=SD="
block|,
comment|/* 0x95 */
literal|22
block|,
literal|"L4=SD="
block|,
comment|/* 0x96 */
literal|23
block|,
literal|"L4=SD="
block|,
comment|/* 0x97 */
literal|24
block|,
literal|"L4=SD="
block|,
comment|/* 0x98 */
literal|25
block|,
literal|"L4=SD="
block|,
comment|/* 0x99 */
literal|26
block|,
literal|"L4=SD="
block|,
comment|/* 0x9a */
literal|27
block|,
literal|"L4=SD="
block|,
comment|/* 0x9b */
literal|28
block|,
literal|"L4=SD="
block|,
comment|/* 0x9c */
literal|29
block|,
literal|"L4=SD="
block|,
comment|/* 0x9d */
literal|30
block|,
literal|"L4=SD="
block|,
comment|/* 0x9e */
literal|31
block|,
literal|"L4=SD="
block|,
comment|/* 0x9f */
literal|32
block|,
literal|"L4=Sb="
block|,
comment|/* 0xa0 */
literal|33
block|,
literal|"L4=Sd="
block|,
comment|/* 0xa1 */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0xa2 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa3 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa4 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa5 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa6 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa7 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa8 */
literal|0
block|,
literal|""
block|,
comment|/* 0xa9 */
literal|0
block|,
literal|""
block|,
comment|/* 0xaa */
literal|0
block|,
literal|""
block|,
comment|/* 0xab */
literal|0
block|,
literal|""
block|,
comment|/* 0xac */
literal|0
block|,
literal|""
block|,
comment|/* 0xad */
comment|/* R_MILLI_REL */
literal|0
block|,
literal|"L4=Sb="
block|,
comment|/* 0xae */
literal|1
block|,
literal|"L4=Sd="
block|,
comment|/* 0xaf */
comment|/* R_CODE_PLABEL */
literal|0
block|,
literal|"L4=Sb="
block|,
comment|/* 0xb0 */
literal|1
block|,
literal|"L4=Sd="
block|,
comment|/* 0xb1 */
comment|/* R_BREAKPOINT */
literal|0
block|,
literal|"L4="
block|,
comment|/* 0xb2 */
comment|/* R_ENTRY */
literal|0
block|,
literal|"Te=Ue="
block|,
comment|/* 0xb3 */
literal|1
block|,
literal|"Uf="
block|,
comment|/* 0xb4 */
comment|/* R_ALT_ENTRY */
literal|0
block|,
literal|""
block|,
comment|/* 0xb5 */
comment|/* R_EXIT */
literal|0
block|,
literal|""
block|,
comment|/* 0xb6 */
comment|/* R_BEGIN_TRY */
literal|0
block|,
literal|""
block|,
comment|/* 0xb7 */
comment|/* R_END_TRY */
literal|0
block|,
literal|"R0="
block|,
comment|/* 0xb8 */
literal|1
block|,
literal|"Rb4*="
block|,
comment|/* 0xb9 */
literal|2
block|,
literal|"Rd4*="
block|,
comment|/* 0xba */
comment|/* R_BEGIN_BRTAB */
literal|0
block|,
literal|""
block|,
comment|/* 0xbb */
comment|/* R_END_BRTAB */
literal|0
block|,
literal|""
block|,
comment|/* 0xbc */
comment|/* R_STATEMENT */
literal|0
block|,
literal|"Nb="
block|,
comment|/* 0xbd */
literal|1
block|,
literal|"Nc="
block|,
comment|/* 0xbe */
literal|2
block|,
literal|"Nd="
block|,
comment|/* 0xbf */
comment|/* R_DATA_EXPR */
literal|0
block|,
literal|"L4="
block|,
comment|/* 0xc0 */
comment|/* R_CODE_EXPR */
literal|0
block|,
literal|"L4="
block|,
comment|/* 0xc1 */
comment|/* R_FSEL */
literal|0
block|,
literal|""
block|,
comment|/* 0xc2 */
comment|/* R_LSEL */
literal|0
block|,
literal|""
block|,
comment|/* 0xc3 */
comment|/* R_RSEL */
literal|0
block|,
literal|""
block|,
comment|/* 0xc4 */
comment|/* R_N_MODE */
literal|0
block|,
literal|""
block|,
comment|/* 0xc5 */
comment|/* R_S_MODE */
literal|0
block|,
literal|""
block|,
comment|/* 0xc6 */
comment|/* R_D_MODE */
literal|0
block|,
literal|""
block|,
comment|/* 0xc7 */
comment|/* R_R_MODE */
literal|0
block|,
literal|""
block|,
comment|/* 0xc8 */
comment|/* R_DATA_OVERRIDE */
literal|0
block|,
literal|"V0="
block|,
comment|/* 0xc9 */
literal|1
block|,
literal|"Vb="
block|,
comment|/* 0xca */
literal|2
block|,
literal|"Vc="
block|,
comment|/* 0xcb */
literal|3
block|,
literal|"Vd="
block|,
comment|/* 0xcc */
literal|4
block|,
literal|"Ve="
block|,
comment|/* 0xcd */
comment|/* R_TRANSLATED */
literal|0
block|,
literal|""
block|,
comment|/* 0xce */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0xcf */
comment|/* R_COMP1 */
literal|0
block|,
literal|"Ob="
block|,
comment|/* 0xd0 */
comment|/* R_COMP2 */
literal|0
block|,
literal|"Ob=Sd="
block|,
comment|/* 0xd1 */
comment|/* R_COMP3 */
literal|0
block|,
literal|"Ob=Ve="
block|,
comment|/* 0xd2 */
comment|/* R_PREV_FIXUP */
literal|0
block|,
literal|"P"
block|,
comment|/* 0xd3 */
literal|1
block|,
literal|"P"
block|,
comment|/* 0xd4 */
literal|2
block|,
literal|"P"
block|,
comment|/* 0xd5 */
literal|3
block|,
literal|"P"
block|,
comment|/* 0xd6 */
comment|/* R_SEC_STMT */
literal|0
block|,
literal|""
block|,
comment|/* 0xd7 */
comment|/* R_N0SEL */
literal|0
block|,
literal|""
block|,
comment|/* 0xd8 */
comment|/* R_N1SEL */
literal|0
block|,
literal|""
block|,
comment|/* 0xd9 */
comment|/* R_LINETAB */
literal|0
block|,
literal|""
block|,
comment|/* 0xda */
comment|/* R_LINETAB_ESC */
literal|0
block|,
literal|""
block|,
comment|/* 0xdb */
comment|/* R_LTP_OVERRIDE */
literal|0
block|,
literal|""
block|,
comment|/* 0xdc */
comment|/* R_COMMENT */
literal|0
block|,
literal|""
block|,
comment|/* 0xdd */
comment|/* R_RESERVED */
literal|0
block|,
literal|""
block|,
comment|/* 0xde */
literal|0
block|,
literal|""
block|,
comment|/* 0xdf */
literal|0
block|,
literal|""
block|,
comment|/* 0xe0 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe1 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe2 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe3 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe4 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe5 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe6 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe7 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe8 */
literal|0
block|,
literal|""
block|,
comment|/* 0xe9 */
literal|0
block|,
literal|""
block|,
comment|/* 0xea */
literal|0
block|,
literal|""
block|,
comment|/* 0xeb */
literal|0
block|,
literal|""
block|,
comment|/* 0xec */
literal|0
block|,
literal|""
block|,
comment|/* 0xed */
literal|0
block|,
literal|""
block|,
comment|/* 0xee */
literal|0
block|,
literal|""
block|,
comment|/* 0xef */
literal|0
block|,
literal|""
block|,
comment|/* 0xf0 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf1 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf2 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf3 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf4 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf5 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf6 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf7 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf8 */
literal|0
block|,
literal|""
block|,
comment|/* 0xf9 */
literal|0
block|,
literal|""
block|,
comment|/* 0xfa */
literal|0
block|,
literal|""
block|,
comment|/* 0xfb */
literal|0
block|,
literal|""
block|,
comment|/* 0xfc */
literal|0
block|,
literal|""
block|,
comment|/* 0xfd */
literal|0
block|,
literal|""
block|,
comment|/* 0xfe */
literal|0
block|,
literal|""
block|,
comment|/* 0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|comp1_opcodes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x40
block|,
literal|0x41
block|,
literal|0x42
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x4a
block|,
literal|0x4b
block|,
literal|0x60
block|,
literal|0x80
block|,
literal|0xa0
block|,
literal|0xc0
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|comp2_opcodes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0x82
block|,
literal|0xc0
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|comp3_opcodes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x02
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These apparently are not in older versions of hpux reloc.h (hpux7).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R_DLT_REL
end_ifndef

begin_define
define|#
directive|define
name|R_DLT_REL
value|0x78
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_AUX_UNWIND
end_ifndef

begin_define
define|#
directive|define
name|R_AUX_UNWIND
value|0xcf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_SEC_STMT
end_ifndef

begin_define
define|#
directive|define
name|R_SEC_STMT
value|0xd7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* And these first appeared in hpux10.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R_SHORT_PCREL_MODE
end_ifndef

begin_define
define|#
directive|define
name|R_SHORT_PCREL_MODE
value|0x3e
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LONG_PCREL_MODE
end_ifndef

begin_define
define|#
directive|define
name|R_LONG_PCREL_MODE
value|0x3f
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_N0SEL
end_ifndef

begin_define
define|#
directive|define
name|R_N0SEL
value|0xd8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_N1SEL
end_ifndef

begin_define
define|#
directive|define
name|R_N1SEL
value|0xd9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LINETAB
end_ifndef

begin_define
define|#
directive|define
name|R_LINETAB
value|0xda
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LINETAB_ESC
end_ifndef

begin_define
define|#
directive|define
name|R_LINETAB_ESC
value|0xdb
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LTP_OVERRIDE
end_ifndef

begin_define
define|#
directive|define
name|R_LTP_OVERRIDE
value|0xdc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_COMMENT
end_ifndef

begin_define
define|#
directive|define
name|R_COMMENT
value|0xdd
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|som_hppa_howto_table
index|[]
init|=
block|{
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_NO_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_NO_RELOCATION"
block|}
block|,
block|{
name|R_ZEROES
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ZEROES"
block|}
block|,
block|{
name|R_ZEROES
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ZEROES"
block|}
block|,
block|{
name|R_UNINIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_UNINIT"
block|}
block|,
block|{
name|R_UNINIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_UNINIT"
block|}
block|,
block|{
name|R_RELOCATION
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RELOCATION"
block|}
block|,
block|{
name|R_DATA_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_ONE_SYMBOL"
block|}
block|,
block|{
name|R_DATA_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_ONE_SYMBOL"
block|}
block|,
block|{
name|R_DATA_PLABEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_PLABEL"
block|}
block|,
block|{
name|R_DATA_PLABEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_PLABEL"
block|}
block|,
block|{
name|R_SPACE_REF
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_SPACE_REF"
block|}
block|,
block|{
name|R_REPEATED_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"REPEATED_INIT"
block|}
block|,
block|{
name|R_REPEATED_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"REPEATED_INIT"
block|}
block|,
block|{
name|R_REPEATED_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"REPEATED_INIT"
block|}
block|,
block|{
name|R_REPEATED_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"REPEATED_INIT"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_PCREL_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PCREL_CALL"
block|}
block|,
block|{
name|R_SHORT_PCREL_MODE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_SHORT_PCREL_MODE"
block|}
block|,
block|{
name|R_LONG_PCREL_MODE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_LONG_PCREL_MODE"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_ABS_CALL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ABS_CALL"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_DP_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DP_RELATIVE"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_DLT_REL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DLT_REL"
block|}
block|,
block|{
name|R_DLT_REL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DLT_REL"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_CODE_ONE_SYMBOL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_ONE_SYMBOL"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_MILLI_REL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_MILLI_REL"
block|}
block|,
block|{
name|R_MILLI_REL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_MILLI_REL"
block|}
block|,
block|{
name|R_CODE_PLABEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_PLABEL"
block|}
block|,
block|{
name|R_CODE_PLABEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_PLABEL"
block|}
block|,
block|{
name|R_BREAKPOINT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_BREAKPOINT"
block|}
block|,
block|{
name|R_ENTRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ENTRY"
block|}
block|,
block|{
name|R_ENTRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ENTRY"
block|}
block|,
block|{
name|R_ALT_ENTRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_ALT_ENTRY"
block|}
block|,
block|{
name|R_EXIT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_EXIT"
block|}
block|,
block|{
name|R_BEGIN_TRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_BEGIN_TRY"
block|}
block|,
block|{
name|R_END_TRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_END_TRY"
block|}
block|,
block|{
name|R_END_TRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_END_TRY"
block|}
block|,
block|{
name|R_END_TRY
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_END_TRY"
block|}
block|,
block|{
name|R_BEGIN_BRTAB
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_BEGIN_BRTAB"
block|}
block|,
block|{
name|R_END_BRTAB
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_END_BRTAB"
block|}
block|,
block|{
name|R_STATEMENT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_STATEMENT"
block|}
block|,
block|{
name|R_STATEMENT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_STATEMENT"
block|}
block|,
block|{
name|R_STATEMENT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_STATEMENT"
block|}
block|,
block|{
name|R_DATA_EXPR
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_EXPR"
block|}
block|,
block|{
name|R_CODE_EXPR
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_CODE_EXPR"
block|}
block|,
block|{
name|R_FSEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_FSEL"
block|}
block|,
block|{
name|R_LSEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_LSEL"
block|}
block|,
block|{
name|R_RSEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RSEL"
block|}
block|,
block|{
name|R_N_MODE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_N_MODE"
block|}
block|,
block|{
name|R_S_MODE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_S_MODE"
block|}
block|,
block|{
name|R_D_MODE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_D_MODE"
block|}
block|,
block|{
name|R_R_MODE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_R_MODE"
block|}
block|,
block|{
name|R_DATA_OVERRIDE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_OVERRIDE"
block|}
block|,
block|{
name|R_DATA_OVERRIDE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_OVERRIDE"
block|}
block|,
block|{
name|R_DATA_OVERRIDE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_OVERRIDE"
block|}
block|,
block|{
name|R_DATA_OVERRIDE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_OVERRIDE"
block|}
block|,
block|{
name|R_DATA_OVERRIDE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_DATA_OVERRIDE"
block|}
block|,
block|{
name|R_TRANSLATED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_TRANSLATED"
block|}
block|,
block|{
name|R_AUX_UNWIND
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_AUX_UNWIND"
block|}
block|,
block|{
name|R_COMP1
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_COMP1"
block|}
block|,
block|{
name|R_COMP2
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_COMP2"
block|}
block|,
block|{
name|R_COMP3
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_COMP3"
block|}
block|,
block|{
name|R_PREV_FIXUP
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PREV_FIXUP"
block|}
block|,
block|{
name|R_PREV_FIXUP
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PREV_FIXUP"
block|}
block|,
block|{
name|R_PREV_FIXUP
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PREV_FIXUP"
block|}
block|,
block|{
name|R_PREV_FIXUP
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_PREV_FIXUP"
block|}
block|,
block|{
name|R_SEC_STMT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_SEC_STMT"
block|}
block|,
block|{
name|R_N0SEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_N0SEL"
block|}
block|,
block|{
name|R_N1SEL
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_N1SEL"
block|}
block|,
block|{
name|R_LINETAB
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_LINETAB"
block|}
block|,
block|{
name|R_LINETAB_ESC
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_LINETAB_ESC"
block|}
block|,
block|{
name|R_LTP_OVERRIDE
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_LTP_OVERRIDE"
block|}
block|,
block|{
name|R_COMMENT
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_COMMENT"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|,
block|{
name|R_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
literal|0
block|,
name|hppa_som_reloc
block|,
literal|"R_RESERVED"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the SOM relocation queue.  By definition the queue holds    the last four multibyte fixups.  */
end_comment

begin_function
specifier|static
name|void
name|som_initialize_reloc_queue
parameter_list|(
name|queue
parameter_list|)
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a new relocation into the relocation queue.  */
end_comment

begin_function
specifier|static
name|void
name|som_reloc_queue_insert
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|,
name|queue
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|p
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When an entry in the relocation queue is reused, the entry moves    to the front of the queue.  */
end_comment

begin_function
specifier|static
name|void
name|som_reloc_queue_fix
parameter_list|(
name|queue
parameter_list|,
name|index
parameter_list|)
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tmp1
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
decl_stmt|;
name|unsigned
name|int
name|tmp2
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
decl_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|tmp1
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|tmp2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|==
literal|2
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tmp1
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
decl_stmt|;
name|unsigned
name|int
name|tmp2
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
decl_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|tmp1
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|tmp2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|==
literal|3
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tmp1
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
decl_stmt|;
name|unsigned
name|int
name|tmp2
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
decl_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|3
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|tmp1
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|tmp2
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search for a particular relocation in the relocation queue.  */
end_comment

begin_function
specifier|static
name|int
name|som_reloc_queue_find
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|,
name|queue
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
if|if
condition|(
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|0
index|]
operator|.
name|size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|1
index|]
operator|.
name|size
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|2
index|]
operator|.
name|size
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|3
index|]
operator|.
name|size
condition|)
return|return
literal|3
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|try_prev_fixup
parameter_list|(
name|abfd
parameter_list|,
name|subspace_reloc_sizep
parameter_list|,
name|p
parameter_list|,
name|size
parameter_list|,
name|queue
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
modifier|*
name|subspace_reloc_sizep
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
name|int
name|queue_index
init|=
name|som_reloc_queue_find
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue_index
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Found this in a previous fixup.  Undo the fixup we 	 just built and use R_PREV_FIXUP instead.  We saved  	 a total of size - 1 bytes in the fixup stream.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_PREV_FIXUP
operator|+
name|queue_index
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
literal|1
expr_stmt|;
name|som_reloc_queue_fix
argument_list|(
name|queue
argument_list|,
name|queue_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|som_reloc_queue_insert
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|queue
argument_list|)
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
name|size
expr_stmt|;
name|p
operator|+=
name|size
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Emit the proper R_NO_RELOCATION fixups to map the next SKIP    bytes without any relocation.  Update the size of the subspace    relocation stream via SUBSPACE_RELOC_SIZE_P; also return the     current pointer into the relocation stream.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_skip
parameter_list|(
name|abfd
parameter_list|,
name|skip
parameter_list|,
name|p
parameter_list|,
name|subspace_reloc_sizep
parameter_list|,
name|queue
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|skip
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
decl_stmt|;
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
comment|/* Use a 4 byte R_NO_RELOCATION entry with a maximal value      then R_PREV_FIXUPs to get the difference down to a      reasonable size.  */
if|if
condition|(
name|skip
operator|>=
literal|0x1000000
condition|)
block|{
name|skip
operator|-=
literal|0x1000000
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|31
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xffff
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|skip
operator|>=
literal|0x1000000
condition|)
block|{
name|skip
operator|-=
literal|0x1000000
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_PREV_FIXUP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
literal|1
expr_stmt|;
comment|/* No need to adjust queue here since we are repeating the 	     most recent fixup.  */
block|}
block|}
comment|/* The difference must be less than 0x1000000.  Use one       more R_NO_RELOCATION entry to get to the right difference.  */
if|if
condition|(
operator|(
name|skip
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
name|skip
operator|<=
literal|0xc0000
operator|&&
name|skip
operator|>
literal|0
condition|)
block|{
comment|/* Difference can be handled in a simple single-byte 	 R_NO_RELOCATION entry.  */
if|if
condition|(
name|skip
operator|<=
literal|0x60
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Handle it with a two byte R_NO_RELOCATION entry.  */
elseif|else
if|if
condition|(
name|skip
operator|<=
literal|0x1000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|24
operator|+
operator|(
operator|(
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
operator|)
operator|>>
literal|8
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
comment|/* Handle it with a three byte R_NO_RELOCATION entry.  */
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|28
operator|+
operator|(
operator|(
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
operator|)
operator|>>
literal|16
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ugh.  Punt and use a 4 byte entry.  */
elseif|else
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|31
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|skip
operator|-
literal|1
operator|)
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|skip
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Emit the proper R_DATA_OVERRIDE fixups to handle a nonzero addend    from a BFD relocation.  Update the size of the subspace relocation    stream via SUBSPACE_RELOC_SIZE_P; also return the current pointer    into the relocation stream.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_addend
parameter_list|(
name|abfd
parameter_list|,
name|addend
parameter_list|,
name|p
parameter_list|,
name|subspace_reloc_sizep
parameter_list|,
name|queue
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|addend
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
decl_stmt|;
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|addend
argument_list|)
operator|+
literal|0x80
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|addend
argument_list|)
operator|+
literal|0x8000
operator|<
literal|0x10000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|addend
argument_list|)
operator|+
literal|0x800000
operator|<
literal|0x1000000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|3
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|addend
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|4
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|5
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Handle a single function call relocation.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_call
parameter_list|(
name|abfd
parameter_list|,
name|p
parameter_list|,
name|subspace_reloc_sizep
parameter_list|,
name|bfd_reloc
parameter_list|,
name|sym_num
parameter_list|,
name|queue
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
decl_stmt|;
name|arelent
modifier|*
name|bfd_reloc
decl_stmt|;
name|int
name|sym_num
decl_stmt|;
name|struct
name|reloc_queue
modifier|*
name|queue
decl_stmt|;
block|{
name|int
name|arg_bits
init|=
name|HPPA_R_ARG_RELOC
argument_list|(
name|bfd_reloc
operator|->
name|addend
argument_list|)
decl_stmt|;
name|int
name|rtn_bits
init|=
name|arg_bits
operator|&
literal|0x3
decl_stmt|;
name|int
name|type
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
comment|/* You'll never believe all this is necessary to handle relocations      for function calls.  Having to compute and pack the argument      relocation bits is the real nightmare.            If you're interested in how this works, just forget it.  You really      do not want to know about this braindamage.  */
comment|/* First see if this can be done with a "simple" relocation.  Simple      relocations have a symbol number< 0x100 and have simple encodings      of argument relocations.  */
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
switch|switch
condition|(
name|arg_bits
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
case|:
name|type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
case|:
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
case|:
name|type
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|1
case|:
name|type
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
comment|/* Not one of the easy encodings.  This will have to be 	     handled by the more complex code below.  */
name|type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Account for the return value too.  */
if|if
condition|(
name|rtn_bits
condition|)
name|type
operator|+=
literal|5
expr_stmt|;
comment|/* Emit a 2 byte relocation.  Then see if it can be handled 	     with a relocation which is already in the relocation queue.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this could not be handled with a simple relocation, then do a hard      one.  Hard relocations occur if the symbol number was too high or if      the encoding of argument relocation bits is too complex.  */
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Don't ask about these magic sequences.  I took them straight 	 from gas-1.36 which took them from the a.out man page.  */
name|type
operator|=
name|rtn_bits
expr_stmt|;
if|if
condition|(
operator|(
name|arg_bits
operator|>>
literal|6
operator|&
literal|0xf
operator|)
operator|==
literal|0xe
condition|)
name|type
operator|+=
literal|9
operator|*
literal|40
expr_stmt|;
else|else
name|type
operator|+=
operator|(
literal|3
operator|*
operator|(
name|arg_bits
operator|>>
literal|8
operator|&
literal|3
operator|)
operator|+
operator|(
name|arg_bits
operator|>>
literal|6
operator|&
literal|3
operator|)
operator|)
operator|*
literal|40
expr_stmt|;
if|if
condition|(
operator|(
name|arg_bits
operator|>>
literal|2
operator|&
literal|0xf
operator|)
operator|==
literal|0xe
condition|)
name|type
operator|+=
literal|9
operator|*
literal|4
expr_stmt|;
else|else
name|type
operator|+=
operator|(
literal|3
operator|*
operator|(
name|arg_bits
operator|>>
literal|4
operator|&
literal|3
operator|)
operator|+
operator|(
name|arg_bits
operator|>>
literal|2
operator|&
literal|3
operator|)
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Output the first two bytes of the relocation.  These describe 	 the length of the relocation and encoding style.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|10
operator|+
literal|2
operator|*
operator|(
name|sym_num
operator|>=
literal|0x100
operator|)
operator|+
operator|(
name|type
operator|>=
literal|0x100
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now output the symbol index and see if this bizarre relocation 	 just happened to be in the relocation queue.  */
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|5
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned.     Abort -1 if X is not a power or two or is zero.  */
end_comment

begin_function
specifier|static
name|int
name|log2
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|;
block|{
name|int
name|log
init|=
literal|0
decl_stmt|;
comment|/* Test for 0 or a power of 2.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|x
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|log
operator|++
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|hppa_som_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Given a generic HPPA relocation type, the instruction format,    and a field selector, return one or more appropriate SOM relocations.  */
end_comment

begin_function
name|int
modifier|*
modifier|*
name|hppa_som_gen_reloc_type
parameter_list|(
name|abfd
parameter_list|,
name|base_type
parameter_list|,
name|format
parameter_list|,
name|field
parameter_list|,
name|sym_diff
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|base_type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|hppa_reloc_field_selector_type_alt
name|field
decl_stmt|;
name|int
name|sym_diff
decl_stmt|;
block|{
name|int
modifier|*
name|final_type
decl_stmt|,
modifier|*
modifier|*
name|final_types
decl_stmt|;
name|final_types
operator|=
operator|(
name|int
operator|*
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
literal|6
argument_list|)
expr_stmt|;
name|final_type
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
operator|||
operator|!
name|final_type
condition|)
return|return
name|NULL
return|;
comment|/* The field selector may require additional relocations to be       generated.  It's impossible to know at this moment if additional      relocations will be needed, so we make them.  The code to actually      write the relocation/fixup stream is responsible for removing      any redundant relocations.  */
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
case|case
name|e_psel
case|:
case|case
name|e_lpsel
case|:
case|case
name|e_rpsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_tsel
case|:
case|case
name|e_ltsel
case|:
case|case
name|e_rtsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_tsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_FSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_ltsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LSEL
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_RSEL
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_lssel
case|:
case|case
name|e_rssel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_S_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_lsel
case|:
case|case
name|e_rsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_N_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_ldsel
case|:
case|case
name|e_rdsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_D_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_lrsel
case|:
case|case
name|e_rrsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_R_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_nsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_N1SEL
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_nlsel
case|:
case|case
name|e_nlrsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_N0SEL
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|1
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_nlsel
condition|)
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_N_MODE
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_R_MODE
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|R_HPPA
case|:
comment|/* The difference of two symbols needs *very* special handling.  */
if|if
condition|(
name|sym_diff
condition|)
block|{
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|3
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
operator|||
operator|!
name|final_types
index|[
literal|1
index|]
operator|||
operator|!
name|final_types
index|[
literal|2
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_fsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_FSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_rsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_RSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_lsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LSEL
expr_stmt|;
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|2
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|3
index|]
operator|=
name|R_COMP1
expr_stmt|;
name|final_types
index|[
literal|4
index|]
operator|=
name|final_type
expr_stmt|;
operator|*
name|final_types
index|[
literal|4
index|]
operator|=
name|R_CODE_EXPR
expr_stmt|;
name|final_types
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* PLABELs get their own relocation type.  */
elseif|else
if|if
condition|(
name|field
operator|==
name|e_psel
operator|||
name|field
operator|==
name|e_lpsel
operator|||
name|field
operator|==
name|e_rpsel
condition|)
block|{
comment|/* A PLABEL relocation that has a size of 32 bits must 	     be a R_DATA_PLABEL.  All others are R_CODE_PLABELs.  */
if|if
condition|(
name|format
operator|==
literal|32
condition|)
operator|*
name|final_type
operator|=
name|R_DATA_PLABEL
expr_stmt|;
else|else
operator|*
name|final_type
operator|=
name|R_CODE_PLABEL
expr_stmt|;
block|}
comment|/* PIC stuff.  */
elseif|else
if|if
condition|(
name|field
operator|==
name|e_tsel
operator|||
name|field
operator|==
name|e_ltsel
operator|||
name|field
operator|==
name|e_rtsel
condition|)
operator|*
name|final_type
operator|=
name|R_DLT_REL
expr_stmt|;
comment|/* A relocation in the data space is always a full 32bits.  */
elseif|else
if|if
condition|(
name|format
operator|==
literal|32
condition|)
operator|*
name|final_type
operator|=
name|R_DATA_ONE_SYMBOL
expr_stmt|;
break|break;
case|case
name|R_HPPA_GOTOFF
case|:
comment|/* More PLABEL special cases.  */
if|if
condition|(
name|field
operator|==
name|e_psel
operator|||
name|field
operator|==
name|e_lpsel
operator|||
name|field
operator|==
name|e_rpsel
condition|)
operator|*
name|final_type
operator|=
name|R_DATA_PLABEL
expr_stmt|;
break|break;
case|case
name|R_HPPA_COMPLEX
case|:
comment|/* The difference of two symbols needs *very* special handling.  */
if|if
condition|(
name|sym_diff
condition|)
block|{
name|final_types
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|3
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
operator|||
operator|!
name|final_types
index|[
literal|1
index|]
operator|||
operator|!
name|final_types
index|[
literal|2
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_fsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_FSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_rsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_RSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_lsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LSEL
expr_stmt|;
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|2
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|3
index|]
operator|=
name|R_COMP1
expr_stmt|;
name|final_types
index|[
literal|4
index|]
operator|=
name|final_type
expr_stmt|;
operator|*
name|final_types
index|[
literal|4
index|]
operator|=
name|R_CODE_EXPR
expr_stmt|;
name|final_types
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
break|break;
case|case
name|R_HPPA_NONE
case|:
case|case
name|R_HPPA_ABS_CALL
case|:
case|case
name|R_HPPA_PCREL_CALL
case|:
comment|/* Right now we can default all these.  */
break|break;
block|}
return|return
name|final_types
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the correct entry in the PA SOM relocation    howto table.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|som_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|<
operator|(
name|int
operator|)
name|R_NO_RELOCATION
operator|+
literal|255
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|som_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
return|return
operator|&
name|som_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
return|;
block|}
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform some initialization for an object.  Save results of this    initialization in the BFD.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|som_object_setup
parameter_list|(
name|abfd
parameter_list|,
name|file_hdrp
parameter_list|,
name|aux_hdrp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|header
modifier|*
name|file_hdrp
decl_stmt|;
name|struct
name|som_exec_auxhdr
modifier|*
name|aux_hdrp
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* som_mkobject will set bfd_error if som_mkobject fails.  */
if|if
condition|(
name|som_mkobject
argument_list|(
name|abfd
argument_list|)
operator|!=
name|true
condition|)
return|return
literal|0
return|;
comment|/* Set BFD flags based on what information is available in the SOM.  */
name|abfd
operator|->
name|flags
operator|=
name|NO_FLAGS
expr_stmt|;
if|if
condition|(
name|file_hdrp
operator|->
name|symbol_total
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
switch|switch
condition|(
name|file_hdrp
operator|->
name|a_magic
condition|)
block|{
case|case
name|DEMAND_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
operator|(
name|D_PAGED
operator||
name|WP_TEXT
operator||
name|EXEC_P
operator|)
expr_stmt|;
break|break;
case|case
name|SHARE_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
operator|(
name|WP_TEXT
operator||
name|EXEC_P
operator|)
expr_stmt|;
break|break;
case|case
name|EXEC_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
operator|(
name|EXEC_P
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SHL_MAGIC
case|case
name|SHL_MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DL_MAGIC
case|case
name|DL_MAGIC
case|:
endif|#
directive|endif
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Allocate space to hold the saved exec header information.  */
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|som_exec_data
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* The braindamaged OSF1 linker switched exec_flags and exec_entry!       We used to identify OSF1 binaries based on NEW_VERSION_ID, but      apparently the latest HPUX linker is using NEW_VERSION_ID now.       It's about time, OSF has used the new id since at least 1992;      HPUX didn't start till nearly 1995!.           The new approach examines the entry field.  If it's zero or not 4      byte aligned then it's not a proper code address and we guess it's      really the executable flags.  */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|aux_hdrp
operator|->
name|exec_entry
operator|>=
name|section
operator|->
name|vma
operator|&&
name|aux_hdrp
operator|->
name|exec_entry
operator|<
name|section
operator|->
name|vma
operator|+
name|section
operator|->
name|_cooked_size
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|aux_hdrp
operator|->
name|exec_entry
operator|==
literal|0
operator|||
operator|(
name|aux_hdrp
operator|->
name|exec_entry
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
operator|!
name|found
condition|)
block|{
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|aux_hdrp
operator|->
name|exec_flags
expr_stmt|;
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_flags
operator|=
name|aux_hdrp
operator|->
name|exec_entry
expr_stmt|;
block|}
else|else
block|{
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|aux_hdrp
operator|->
name|exec_entry
expr_stmt|;
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_flags
operator|=
name|aux_hdrp
operator|->
name|exec_flags
expr_stmt|;
block|}
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
name|pa10
argument_list|)
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_total
expr_stmt|;
comment|/* Initialize the saved symbol table and string table to NULL.        Save important offsets and sizes from the SOM header into      the BFD.  */
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|som_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_som_sorted_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_strings_size
expr_stmt|;
name|obj_som_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_location
expr_stmt|;
name|obj_som_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_strings_location
expr_stmt|;
name|obj_som_reloc_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|fixup_request_location
expr_stmt|;
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|file_hdrp
operator|->
name|system_id
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Convert all of the space and subspace info into BFD sections.  Each space    contains a number of subspaces, which in turn describe the mapping between    regions of the exec file, and the address space that the program runs in.    BFD sections which correspond to spaces will overlap the sections for the    associated subspaces.  */
end_comment

begin_function
specifier|static
name|boolean
name|setup_sections
parameter_list|(
name|abfd
parameter_list|,
name|file_hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|header
modifier|*
name|file_hdr
decl_stmt|;
block|{
name|char
modifier|*
name|space_strings
decl_stmt|;
name|unsigned
name|int
name|space_index
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|total_subspaces
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
modifier|*
name|subspace_sections
decl_stmt|,
modifier|*
name|section
decl_stmt|;
comment|/* First, read in space names */
name|space_strings
operator|=
name|bfd_malloc
argument_list|(
name|file_hdr
operator|->
name|space_strings_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space_strings
operator|&&
name|file_hdr
operator|->
name|space_strings_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_hdr
operator|->
name|space_strings_location
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
name|space_strings
argument_list|,
literal|1
argument_list|,
name|file_hdr
operator|->
name|space_strings_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|file_hdr
operator|->
name|space_strings_size
condition|)
goto|goto
name|error_return
goto|;
comment|/* Loop over all of the space dictionaries, building up sections */
for|for
control|(
name|space_index
operator|=
literal|0
init|;
name|space_index
operator|<
name|file_hdr
operator|->
name|space_total
condition|;
name|space_index
operator|++
control|)
block|{
name|struct
name|space_dictionary_record
name|space
decl_stmt|;
name|struct
name|subspace_dictionary_record
name|subspace
decl_stmt|,
name|save_subspace
decl_stmt|;
name|int
name|subspace_index
decl_stmt|;
name|asection
modifier|*
name|space_asect
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
comment|/* Read the space dictionary element */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_hdr
operator|->
name|space_location
operator|+
name|space_index
operator|*
sizeof|sizeof
name|space
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|space
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|space
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|space
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the space name string */
name|space
operator|.
name|name
operator|.
name|n_name
operator|=
name|space
operator|.
name|name
operator|.
name|n_strx
operator|+
name|space_strings
expr_stmt|;
comment|/* Make a section out of it */
name|newname
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|space
operator|.
name|name
operator|.
name|n_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newname
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|space
operator|.
name|name
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|space_asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space_asect
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|space
operator|.
name|is_loadable
operator|==
literal|0
condition|)
name|space_asect
operator|->
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
comment|/* Set up all the attributes for the space.  */
if|if
condition|(
name|bfd_som_set_section_attributes
argument_list|(
name|space_asect
argument_list|,
name|space
operator|.
name|is_defined
argument_list|,
name|space
operator|.
name|is_private
argument_list|,
name|space
operator|.
name|sort_key
argument_list|,
name|space
operator|.
name|space_number
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
comment|/* If the space has no subspaces, then we're done.  */
if|if
condition|(
name|space
operator|.
name|subspace_quantity
operator|==
literal|0
condition|)
continue|continue;
comment|/* Now, read in the first subspace for this space */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_hdr
operator|->
name|subspace_location
operator|+
name|space
operator|.
name|subspace_index
operator|*
sizeof|sizeof
name|subspace
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|subspace
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|subspace
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|subspace
condition|)
goto|goto
name|error_return
goto|;
comment|/* Seek back to the start of the subspaces for loop below */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_hdr
operator|->
name|subspace_location
operator|+
name|space
operator|.
name|subspace_index
operator|*
sizeof|sizeof
name|subspace
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the start address and file loc from the first subspace record */
name|space_asect
operator|->
name|vma
operator|=
name|subspace
operator|.
name|subspace_start
expr_stmt|;
name|space_asect
operator|->
name|filepos
operator|=
name|subspace
operator|.
name|file_loc_init_value
expr_stmt|;
name|space_asect
operator|->
name|alignment_power
operator|=
name|log2
argument_list|(
name|subspace
operator|.
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|space_asect
operator|->
name|alignment_power
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
comment|/* Initialize save_subspace so we can reliably determine if this 	 loop placed any useful values into it.  */
name|memset
argument_list|(
operator|&
name|save_subspace
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over the rest of the subspaces, building up more sections */
for|for
control|(
name|subspace_index
operator|=
literal|0
init|;
name|subspace_index
operator|<
name|space
operator|.
name|subspace_quantity
condition|;
name|subspace_index
operator|++
control|)
block|{
name|asection
modifier|*
name|subspace_asect
decl_stmt|;
comment|/* Read in the next subspace */
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|subspace
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|subspace
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|subspace
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the subspace name string */
name|subspace
operator|.
name|name
operator|.
name|n_name
operator|=
name|subspace
operator|.
name|name
operator|.
name|n_strx
operator|+
name|space_strings
expr_stmt|;
name|newname
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|subspace
operator|.
name|name
operator|.
name|n_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newname
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|subspace
operator|.
name|name
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* Make a section out of this subspace */
name|subspace_asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subspace_asect
condition|)
goto|goto
name|error_return
goto|;
comment|/* Store private information about the section.  */
if|if
condition|(
name|bfd_som_set_subsection_attributes
argument_list|(
name|subspace_asect
argument_list|,
name|space_asect
argument_list|,
name|subspace
operator|.
name|access_control_bits
argument_list|,
name|subspace
operator|.
name|sort_key
argument_list|,
name|subspace
operator|.
name|quadrant
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
comment|/* Keep an easy mapping between subspaces and sections.  	     Note we do not necessarily read the subspaces in the 	     same order in which they appear in the object file.  	     So to make the target index come out correctly, we 	     store the location of the subspace header in target 	     index, then sort using the location of the subspace 	     header as the key.  Then we can assign correct 	     subspace indices.  */
name|total_subspaces
operator|++
expr_stmt|;
name|subspace_asect
operator|->
name|target_index
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
expr_stmt|;
comment|/* Set SEC_READONLY and SEC_CODE/SEC_DATA as specified 	     by the access_control_bits in the subspace header.  */
switch|switch
condition|(
name|subspace
operator|.
name|access_control_bits
operator|>>
literal|4
condition|)
block|{
comment|/* Readonly data.  */
case|case
literal|0x0
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_READONLY
expr_stmt|;
break|break;
comment|/* Normal data.  */
case|case
literal|0x1
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
comment|/* Readonly code and the gateways. 	       Gateways have other attributes which do not map 	       into anything BFD knows about.  */
case|case
literal|0x2
case|:
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_CODE
operator||
name|SEC_READONLY
expr_stmt|;
break|break;
comment|/* dynamic (writable) code.  */
case|case
literal|0x3
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subspace
operator|.
name|dup_common
operator|||
name|subspace
operator|.
name|is_common
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|subspace
operator|.
name|subspace_length
operator|>
literal|0
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|subspace
operator|.
name|is_loadable
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
else|else
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
if|if
condition|(
name|subspace
operator|.
name|code_only
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
comment|/* Both file_loc_init_value and initialization_length will 	     be zero for a BSS like subspace.  */
if|if
condition|(
name|subspace
operator|.
name|file_loc_init_value
operator|==
literal|0
operator|&&
name|subspace
operator|.
name|initialization_length
operator|==
literal|0
condition|)
name|subspace_asect
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
comment|/* This subspace has relocations. 	     The fixup_request_quantity is a byte count for the number of 	     entries in the relocation stream; it is not the actual number 	     of relocations in the subspace.  */
if|if
condition|(
name|subspace
operator|.
name|fixup_request_quantity
operator|!=
literal|0
condition|)
block|{
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|subspace_asect
operator|->
name|rel_filepos
operator|=
name|subspace
operator|.
name|fixup_request_index
expr_stmt|;
name|som_section_data
argument_list|(
name|subspace_asect
argument_list|)
operator|->
name|reloc_size
operator|=
name|subspace
operator|.
name|fixup_request_quantity
expr_stmt|;
comment|/* We can not determine this yet.  When we read in the  		 relocation table the correct value will be filled in.  */
name|subspace_asect
operator|->
name|reloc_count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Update save_subspace if appropriate.  */
if|if
condition|(
name|subspace
operator|.
name|file_loc_init_value
operator|>
name|save_subspace
operator|.
name|file_loc_init_value
condition|)
name|save_subspace
operator|=
name|subspace
expr_stmt|;
name|subspace_asect
operator|->
name|vma
operator|=
name|subspace
operator|.
name|subspace_start
expr_stmt|;
name|subspace_asect
operator|->
name|_cooked_size
operator|=
name|subspace
operator|.
name|subspace_length
expr_stmt|;
name|subspace_asect
operator|->
name|_raw_size
operator|=
name|subspace
operator|.
name|subspace_length
expr_stmt|;
name|subspace_asect
operator|->
name|filepos
operator|=
name|subspace
operator|.
name|file_loc_init_value
expr_stmt|;
name|subspace_asect
operator|->
name|alignment_power
operator|=
name|log2
argument_list|(
name|subspace
operator|.
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_asect
operator|->
name|alignment_power
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Yow! there is no subspace within the space which actually           has initialized information in it; this should never happen          as far as I know.  */
if|if
condition|(
operator|!
name|save_subspace
operator|.
name|file_loc_init_value
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the sizes for the space section based upon the info in the          last subspace of the space.  */
name|space_asect
operator|->
name|_cooked_size
operator|=
name|save_subspace
operator|.
name|subspace_start
operator|-
name|space_asect
operator|->
name|vma
operator|+
name|save_subspace
operator|.
name|subspace_length
expr_stmt|;
name|space_asect
operator|->
name|_raw_size
operator|=
name|save_subspace
operator|.
name|file_loc_init_value
operator|-
name|space_asect
operator|->
name|filepos
operator|+
name|save_subspace
operator|.
name|initialization_length
expr_stmt|;
block|}
comment|/* Now that we've read in all the subspace records, we need to assign      a target index to each subspace.  */
name|subspace_sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|total_subspaces
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
name|subspace_sections
index|[
name|i
index|]
operator|=
name|section
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|qsort
argument_list|(
name|subspace_sections
argument_list|,
name|total_subspaces
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|compare_subspaces
argument_list|)
expr_stmt|;
comment|/* subspace_sections is now sorted in the order in which the subspaces      appear in the object file.  Assign an index to each one now.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_subspaces
condition|;
name|i
operator|++
control|)
name|subspace_sections
index|[
name|i
index|]
operator|->
name|target_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|space_strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|subspace_sections
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|space_strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|subspace_sections
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read in a SOM object and make it into a BFD.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|som_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|header
name|file_hdr
decl_stmt|;
name|struct
name|som_exec_auxhdr
name|aux_hdr
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|file_hdr
argument_list|,
literal|1
argument_list|,
name|FILE_HDR_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|FILE_HDR_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|_PA_RISC_ID
argument_list|(
name|file_hdr
operator|.
name|system_id
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|file_hdr
operator|.
name|a_magic
condition|)
block|{
case|case
name|RELOC_MAGIC
case|:
case|case
name|EXEC_MAGIC
case|:
case|case
name|SHARE_MAGIC
case|:
case|case
name|DEMAND_MAGIC
case|:
ifdef|#
directive|ifdef
name|DL_MAGIC
case|case
name|DL_MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHL_MAGIC
case|case
name|SHL_MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXECLIBMAGIC
case|case
name|EXECLIBMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHARED_MAGIC_CNX
case|case
name|SHARED_MAGIC_CNX
case|:
endif|#
directive|endif
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|file_hdr
operator|.
name|version_id
operator|!=
name|VERSION_ID
operator|&&
name|file_hdr
operator|.
name|version_id
operator|!=
name|NEW_VERSION_ID
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If the aux_header_size field in the file header is zero, then this      object is an incomplete executable (a .o file).  Do not try to read      a non-existant auxiliary header.  */
name|memset
argument_list|(
operator|&
name|aux_hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|.
name|aux_header_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|aux_hdr
argument_list|,
literal|1
argument_list|,
name|AUX_HDR_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|AUX_HDR_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|setup_sections
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_hdr
argument_list|)
condition|)
block|{
comment|/* setup_sections does not bubble up a bfd error code.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This appears to be a valid SOM object.  Do some initialization.  */
return|return
name|som_object_setup
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_hdr
argument_list|,
operator|&
name|aux_hdr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a SOM object.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Allocate memory to hold backend information.  */
name|abfd
operator|->
name|tdata
operator|.
name|som_data
operator|=
operator|(
expr|struct
name|som_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|som_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Initialize some information in the file header.  This routine makes    not attempt at doing the right thing for a full executable; it    is only meant to handle relocatable objects.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_prep_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|header
modifier|*
name|file_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Make and attach a file header to the BFD.  */
name|file_hdr
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdr
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
comment|/* Make and attach an exec header to the BFD.  */
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|som_exec_auxhdr
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
condition|)
name|file_hdr
operator|->
name|a_magic
operator|=
name|DEMAND_MAGIC
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
condition|)
name|file_hdr
operator|->
name|a_magic
operator|=
name|SHARE_MAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|SHL_MAGIC
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
condition|)
name|file_hdr
operator|->
name|a_magic
operator|=
name|SHL_MAGIC
expr_stmt|;
endif|#
directive|endif
else|else
name|file_hdr
operator|->
name|a_magic
operator|=
name|EXEC_MAGIC
expr_stmt|;
block|}
else|else
name|file_hdr
operator|->
name|a_magic
operator|=
name|RELOC_MAGIC
expr_stmt|;
comment|/* Only new format SOM is supported.  */
name|file_hdr
operator|->
name|version_id
operator|=
name|NEW_VERSION_ID
expr_stmt|;
comment|/* These fields are optional, and embedding timestamps is not always      a wise thing to do, it makes comparing objects during a multi-stage      bootstrap difficult.  */
name|file_hdr
operator|->
name|file_time
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|file_time
operator|.
name|nanosecs
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|entry_space
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|entry_subspace
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|presumed_dp
operator|=
literal|0
expr_stmt|;
comment|/* Now iterate over the sections translating information from      BFD sections to SOM spaces/subspaces.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
comment|/* Ignore anything which has not been marked as a space or 	 subspace.  */
if|if
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
block|{
comment|/* Allocate space for the space dictionary.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|=
operator|(
expr|struct
name|space_dictionary_record
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Set space attributes.  Note most attributes of SOM spaces 	     are set based on the subspaces it contains.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|loader_fix_index
operator|=
operator|-
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|init_pointer_index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set more attributes that were stuffed away in private data.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|sort_key
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_defined
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_defined
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_private
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_private
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|space_number
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|space_number
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate space for the subspace dictionary.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|=
operator|(
expr|struct
name|subspace_dictionary_record
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Set subspace attributes.  Basic stuff is done here, additional 	     attributes are filled in later as more information becomes 	     available.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_IS_COMMON
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|dup_common
operator|=
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_common
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_loadable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|code_only
operator|=
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|subspace_start
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|subspace_length
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|initialization_length
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|alignment
operator|=
literal|1
operator|<<
name|section
operator|->
name|alignment_power
expr_stmt|;
comment|/* Set more attributes that were stuffed away in private data.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|sort_key
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|access_control_bits
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|access_control_bits
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|quadrant
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|quadrant
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given section is a SOM space, false otherwise.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_is_space
parameter_list|(
name|section
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
block|{
comment|/* If no copy data is available, then it's neither a space nor a      subspace.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* If the containing space isn't the same as the given section,      then this isn't a space.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|!=
name|section
operator|&&
operator|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
operator|!=
name|section
operator|)
condition|)
return|return
name|false
return|;
comment|/* OK.  Must be a space.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given section is a SOM subspace, false otherwise.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_is_subspace
parameter_list|(
name|section
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
block|{
comment|/* If no copy data is available, then it's neither a space nor a      subspace.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* If the containing space is the same as the given section,      then this isn't a subspace.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|==
name|section
operator|||
operator|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
operator|==
name|section
operator|)
condition|)
return|return
name|false
return|;
comment|/* OK.  Must be a subspace.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given space containins the given subspace.  It    is safe to assume space really is a space, and subspace really    is a subspace.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_is_container
parameter_list|(
name|space
parameter_list|,
name|subspace
parameter_list|)
name|asection
modifier|*
name|space
decl_stmt|,
decl|*
name|subspace
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|som_section_data
argument_list|(
name|subspace
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|==
name|space
operator|||
operator|(
name|som_section_data
argument_list|(
name|subspace
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
operator|==
name|space
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Count and return the number of spaces attached to the given BFD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|som_count_spaces
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
name|count
operator|+=
name|som_is_space
argument_list|(
name|section
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Count the number of subspaces attached to the given BFD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|som_count_subspaces
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
name|count
operator|+=
name|som_is_subspace
argument_list|(
name|section
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return -1, 0, 1 indicating the relative ordering of sym1 and sym2.     We desire symbols to be ordered starting with the symbol with the    highest relocation count down to the symbol with the lowest relocation    count.  Doing so compacts the relocation stream.  */
end_comment

begin_function
specifier|static
name|int
name|compare_syms
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|sym1
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym2
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
comment|/* Get relocation count for each symbol.  Note that the count      is stored in the udata pointer for section symbols!  */
if|if
condition|(
operator|(
operator|*
name|sym1
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|count1
operator|=
operator|(
operator|*
name|sym1
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|count1
operator|=
name|som_symbol_data
argument_list|(
operator|*
name|sym1
argument_list|)
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sym2
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|count2
operator|=
operator|(
operator|*
name|sym2
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|count2
operator|=
name|som_symbol_data
argument_list|(
operator|*
name|sym2
argument_list|)
operator|->
name|reloc_count
expr_stmt|;
comment|/* Return the appropriate value.  */
if|if
condition|(
name|count1
operator|<
name|count2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|count1
operator|>
name|count2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return -1, 0, 1 indicating the relative ordering of subspace1    and subspace.  */
end_comment

begin_function
specifier|static
name|int
name|compare_subspaces
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|subspace1
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|asection
modifier|*
modifier|*
name|subspace2
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|subspace1
operator|)
operator|->
name|target_index
operator|<
operator|(
operator|*
name|subspace2
operator|)
operator|->
name|target_index
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|subspace2
operator|)
operator|->
name|target_index
operator|<
operator|(
operator|*
name|subspace1
operator|)
operator|->
name|target_index
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform various work in preparation for emitting the fixup stream.  */
end_comment

begin_function
specifier|static
name|void
name|som_prep_for_fixups
parameter_list|(
name|abfd
parameter_list|,
name|syms
parameter_list|,
name|num_syms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|long
name|num_syms
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sorted_syms
decl_stmt|;
comment|/* Most SOM relocations involving a symbol have a length which is      dependent on the index of the symbol.  So symbols which are      used often in relocations should have a small index.  */
comment|/* First initialize the counters for each symbol.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
comment|/* Handle a section symbol; these have no pointers back to the 	 SOM symbol info.  So we just use the udata field to hold the 	 relocation count.  */
if|if
condition|(
name|som_symbol_data
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
operator|||
name|syms
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
name|syms
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
name|syms
index|[
name|i
index|]
operator|->
name|udata
operator|.
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|som_symbol_data
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now that the counters are initialized, make a weighted count      of how often a given symbol is used in a relocation.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Does this section have any relocations?  */
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|<=
literal|0
condition|)
continue|continue;
comment|/* Walk through each relocation for this section.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|reloc
init|=
name|section
operator|->
name|orelocation
index|[
name|i
index|]
decl_stmt|;
name|int
name|scale
decl_stmt|;
comment|/* A relocation against a symbol in the *ABS* section really 	     does not have a symbol.  Likewise if the symbol isn't associated 	     with any section.  */
if|if
condition|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|==
name|NULL
operator|||
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* Scaling to encourage symbols involved in R_DP_RELATIVE  	     and R_CODE_ONE_SYMBOL relocations to come first.  These 	     two relocations have single byte versions if the symbol 	     index is very small.  */
if|if
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_DP_RELATIVE
operator|||
name|reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_CODE_ONE_SYMBOL
condition|)
name|scale
operator|=
literal|2
expr_stmt|;
else|else
name|scale
operator|=
literal|1
expr_stmt|;
comment|/* Handle section symbols by storing the count in the udata 	     field.  It will not be used and the count is very important 	     for these symbols.  */
if|if
condition|(
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
operator|=
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
operator|+
name|scale
expr_stmt|;
continue|continue;
block|}
comment|/* A normal symbol.  Increment the count.  */
name|som_symbol_data
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
operator|->
name|reloc_count
operator|+=
name|scale
expr_stmt|;
block|}
block|}
comment|/* Sort a copy of the symbol table, rather than the canonical      output symbol table.  */
name|sorted_syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|num_syms
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sorted_syms
argument_list|,
name|syms
argument_list|,
name|num_syms
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sorted_syms
argument_list|,
name|num_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|,
name|compare_syms
argument_list|)
expr_stmt|;
name|obj_som_sorted_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|sorted_syms
expr_stmt|;
comment|/* Compute the symbol indexes, they will be needed by the relocation      code.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
comment|/* A section symbol.  Again, there is no pointer to backend symbol 	 information, so we reuse the udata field again.  */
if|if
condition|(
name|sorted_syms
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sorted_syms
index|[
name|i
index|]
operator|->
name|udata
operator|.
name|i
operator|=
name|i
expr_stmt|;
else|else
name|som_symbol_data
argument_list|(
name|sorted_syms
index|[
name|i
index|]
argument_list|)
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|som_write_fixups
parameter_list|(
name|abfd
parameter_list|,
name|current_offset
parameter_list|,
name|total_reloc_sizep
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|current_offset
decl_stmt|;
name|unsigned
name|int
modifier|*
name|total_reloc_sizep
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Chunk of memory that we can use as buffer space, then throw      away.  */
name|unsigned
name|char
name|tmp_space
index|[
name|SOM_TMP_BUFSIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|total_reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|subspace_reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_spaces
init|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_total
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|memset
argument_list|(
name|tmp_space
argument_list|,
literal|0
argument_list|,
name|SOM_TMP_BUFSIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_space
expr_stmt|;
comment|/* All the fixups for a particular subspace are emitted in a single      stream.  All the subspaces for a particular space are emitted      as a single stream.       So, to get all the locations correct one must iterate through all the      spaces, for each space iterate through its subspaces and output a      fixups stream.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Now iterate through each of its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
name|int
name|reloc_offset
decl_stmt|,
name|current_rounding_mode
decl_stmt|;
comment|/* Find a subspace of this space.  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
condition|)
continue|continue;
comment|/* If this subspace does not have real data, then we are 	     finised with it.  */
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|fixup_request_index
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* This subspace has some relocations.  Put the relocation stream 	     index into the subspace record.  */
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|fixup_request_index
operator|=
name|total_reloc_size
expr_stmt|;
comment|/* To make life easier start over with a clean slate for  	     each subspace.  Seek to the start of the relocation stream 	     for this subspace in preparation for writing out its fixup 	     stream.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
operator|+
name|total_reloc_size
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Buffer space has already been allocated.  Just perform some 	     initialization here.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
name|subspace_reloc_size
operator|=
literal|0
expr_stmt|;
name|reloc_offset
operator|=
literal|0
expr_stmt|;
name|som_initialize_reloc_queue
argument_list|(
name|reloc_queue
argument_list|)
expr_stmt|;
name|current_rounding_mode
operator|=
name|R_N_MODE
expr_stmt|;
comment|/* Translate each BFD relocation into one or more SOM  	     relocations.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|subsection
operator|->
name|reloc_count
condition|;
name|j
operator|++
control|)
block|{
name|arelent
modifier|*
name|bfd_reloc
init|=
name|subsection
operator|->
name|orelocation
index|[
name|j
index|]
decl_stmt|;
name|unsigned
name|int
name|skip
decl_stmt|;
name|int
name|sym_num
decl_stmt|;
comment|/* Get the symbol number.  Remember it's stored in a  		 special place for section symbols.  */
if|if
condition|(
operator|(
operator|*
name|bfd_reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sym_num
operator|=
operator|(
operator|*
name|bfd_reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|sym_num
operator|=
name|som_symbol_data
argument_list|(
operator|*
name|bfd_reloc
operator|->
name|sym_ptr_ptr
argument_list|)
operator|->
name|index
expr_stmt|;
comment|/* If there is not enough room for the next couple relocations, 		 then dump the current buffer contents now.  Also reinitialize 		 the relocation queue.   		 No single BFD relocation could ever translate into more 		 than 100 bytes of SOM relocations (20bytes is probably the 		 upper limit, but leave lots of space for growth).  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|100
operator|>
name|SOM_TMP_BUFSIZE
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|tmp_space
argument_list|,
name|p
operator|-
name|tmp_space
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|p
operator|-
name|tmp_space
condition|)
return|return
name|false
return|;
name|p
operator|=
name|tmp_space
expr_stmt|;
name|som_initialize_reloc_queue
argument_list|(
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
comment|/* Emit R_NO_RELOCATION fixups to map any bytes which were 		 skipped.  */
name|skip
operator|=
name|bfd_reloc
operator|->
name|address
operator|-
name|reloc_offset
expr_stmt|;
name|p
operator|=
name|som_reloc_skip
argument_list|(
name|abfd
argument_list|,
name|skip
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
comment|/* Update reloc_offset for the next iteration.  		 Many relocations do not consume input bytes.  They 		 are markers, or set state necessary to perform some 		 later relocation.  */
switch|switch
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
comment|/* This only needs to handle relocations that may be 		   made by hppa_som_gen_reloc.  */
case|case
name|R_ENTRY
case|:
case|case
name|R_ALT_ENTRY
case|:
case|case
name|R_EXIT
case|:
case|case
name|R_N_MODE
case|:
case|case
name|R_S_MODE
case|:
case|case
name|R_D_MODE
case|:
case|case
name|R_R_MODE
case|:
case|case
name|R_FSEL
case|:
case|case
name|R_LSEL
case|:
case|case
name|R_RSEL
case|:
case|case
name|R_COMP1
case|:
case|case
name|R_COMP2
case|:
case|case
name|R_BEGIN_BRTAB
case|:
case|case
name|R_END_BRTAB
case|:
case|case
name|R_N0SEL
case|:
case|case
name|R_N1SEL
case|:
name|reloc_offset
operator|=
name|bfd_reloc
operator|->
name|address
expr_stmt|;
break|break;
default|default:
name|reloc_offset
operator|=
name|bfd_reloc
operator|->
name|address
operator|+
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Now the actual relocation we care about.  */
switch|switch
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_PCREL_CALL
case|:
case|case
name|R_ABS_CALL
case|:
name|p
operator|=
name|som_reloc_call
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|bfd_reloc
argument_list|,
name|sym_num
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_CODE_ONE_SYMBOL
case|:
case|case
name|R_DP_RELATIVE
case|:
comment|/* Account for any addend.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|addend
condition|)
name|p
operator|=
name|som_reloc_addend
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_num
operator|<
literal|0x20
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
name|sym_num
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|32
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_num
operator|<
literal|0x10000000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|33
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_DATA_ONE_SYMBOL
case|:
case|case
name|R_DATA_PLABEL
case|:
case|case
name|R_CODE_PLABEL
case|:
case|case
name|R_DLT_REL
case|:
comment|/* Account for any addend using R_DATA_OVERRIDE.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|!=
name|R_DATA_ONE_SYMBOL
operator|&&
name|bfd_reloc
operator|->
name|addend
condition|)
name|p
operator|=
name|som_reloc_addend
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_num
operator|<
literal|0x10000000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_ENTRY
case|:
block|{
name|int
name|tmp
decl_stmt|;
name|arelent
modifier|*
name|tmp_reloc
init|=
name|NULL
decl_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_ENTRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* R_ENTRY relocations have 64 bits of associated 		       data.  Unfortunately the addend field of a bfd 		       relocation is only 32 bits.  So, we split up 		       the 64bit unwind information and store part in 		       the R_ENTRY relocation, and the rest in the R_EXIT 		       relocation.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Find the next R_EXIT relocation.  */
for|for
control|(
name|tmp
operator|=
name|j
init|;
name|tmp
operator|<
name|subsection
operator|->
name|reloc_count
condition|;
name|tmp
operator|++
control|)
block|{
name|tmp_reloc
operator|=
name|subsection
operator|->
name|orelocation
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|tmp_reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_EXIT
condition|)
break|break;
block|}
if|if
condition|(
name|tmp
operator|==
name|subsection
operator|->
name|reloc_count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|tmp_reloc
operator|->
name|addend
argument_list|,
name|p
operator|+
literal|5
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|9
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_N_MODE
case|:
case|case
name|R_S_MODE
case|:
case|case
name|R_D_MODE
case|:
case|case
name|R_R_MODE
case|:
comment|/* If this relocation requests the current rounding 		     mode, then it is redundant.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|!=
name|current_rounding_mode
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|current_rounding_mode
operator|=
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
expr_stmt|;
block|}
break|break;
case|case
name|R_EXIT
case|:
case|case
name|R_ALT_ENTRY
case|:
case|case
name|R_FSEL
case|:
case|case
name|R_LSEL
case|:
case|case
name|R_RSEL
case|:
case|case
name|R_BEGIN_BRTAB
case|:
case|case
name|R_END_BRTAB
case|:
case|case
name|R_N0SEL
case|:
case|case
name|R_N1SEL
case|:
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_COMP1
case|:
comment|/* The only time we generate R_COMP1, R_COMP2 and  		     R_CODE_EXPR relocs is for the difference of two 		     symbols.  Hence we can cheat here.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x44
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_COMP2
case|:
comment|/* The only time we generate R_COMP1, R_COMP2 and  		     R_CODE_EXPR relocs is for the difference of two 		     symbols.  Hence we can cheat here.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x80
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|5
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_CODE_EXPR
case|:
comment|/* The only time we generate R_COMP1, R_COMP2 and  		     R_CODE_EXPR relocs is for the difference of two 		     symbols.  Hence we can cheat here.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
comment|/* Put a "R_RESERVED" relocation in the stream if 		   we hit something we do not understand.  The linker 		   will complain loudly if this ever happens.  */
default|default:
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Last BFD relocation for a subspace has been processed. 	     Map the rest of the subspace with R_NO_RELOCATION fixups.  */
name|p
operator|=
name|som_reloc_skip
argument_list|(
name|abfd
argument_list|,
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|subsection
argument_list|)
operator|-
name|reloc_offset
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
comment|/* Scribble out the relocations.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|tmp_space
argument_list|,
name|p
operator|-
name|tmp_space
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|p
operator|-
name|tmp_space
condition|)
return|return
name|false
return|;
name|p
operator|=
name|tmp_space
expr_stmt|;
name|total_reloc_size
operator|+=
name|subspace_reloc_size
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|fixup_request_quantity
operator|=
name|subspace_reloc_size
expr_stmt|;
block|}
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|total_reloc_sizep
operator|=
name|total_reloc_size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out the space/subspace string table.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_write_space_strings
parameter_list|(
name|abfd
parameter_list|,
name|current_offset
parameter_list|,
name|string_sizep
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|current_offset
decl_stmt|;
name|unsigned
name|int
modifier|*
name|string_sizep
decl_stmt|;
block|{
comment|/* Chunk of memory that we can use as buffer space, then throw      away.  */
name|unsigned
name|char
name|tmp_space
index|[
name|SOM_TMP_BUFSIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|strings_size
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|memset
argument_list|(
name|tmp_space
argument_list|,
literal|0
argument_list|,
name|SOM_TMP_BUFSIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_space
expr_stmt|;
comment|/* Seek to the start of the space strings in preparation for writing      them out.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Walk through all the spaces and subspaces (order is not important)      building up and writing string table entries for their names.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|int
name|length
decl_stmt|;
comment|/* Only work with space/subspaces; avoid any other sections 	 which might have been made (.text for example).  */
if|if
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
comment|/* Get the length of the space/subspace name.  */
name|length
operator|=
name|strlen
argument_list|(
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If there is not enough room for the next entry, then dump the 	 current buffer contents now.  Each entry will take 4 bytes to 	 hold the string length + the string itself + null terminator.  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|5
operator|+
name|length
operator|>
name|SOM_TMP_BUFSIZE
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|p
operator|-
name|tmp_space
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|p
operator|-
name|tmp_space
condition|)
return|return
name|false
return|;
comment|/* Reset to beginning of the buffer space.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
block|}
comment|/* First element in a string table entry is the length of the 	 string.  Alignment issues are already handled.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|strings_size
operator|+=
literal|4
expr_stmt|;
comment|/* Record the index in the space/subspace records.  */
if|if
condition|(
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|name
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
else|else
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|name
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
comment|/* Next comes the string itself + a null terminator.  */
name|strcpy
argument_list|(
name|p
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
name|strings_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
comment|/* Always align up to the next word boundary.  */
while|while
condition|(
name|strings_size
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|strings_size
operator|++
expr_stmt|;
block|}
block|}
comment|/* Done with the space/subspace strings.  Write out any information      contained in a partial block.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|p
operator|-
name|tmp_space
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|p
operator|-
name|tmp_space
condition|)
return|return
name|false
return|;
operator|*
name|string_sizep
operator|=
name|strings_size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out the symbol string table.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_write_symbol_strings
parameter_list|(
name|abfd
parameter_list|,
name|current_offset
parameter_list|,
name|syms
parameter_list|,
name|num_syms
parameter_list|,
name|string_sizep
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|current_offset
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|num_syms
decl_stmt|;
name|unsigned
name|int
modifier|*
name|string_sizep
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Chunk of memory that we can use as buffer space, then throw      away.  */
name|unsigned
name|char
name|tmp_space
index|[
name|SOM_TMP_BUFSIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|strings_size
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|tmp_space
argument_list|,
literal|0
argument_list|,
name|SOM_TMP_BUFSIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_space
expr_stmt|;
comment|/* Seek to the start of the space strings in preparation for writing      them out.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* If there is not enough room for the next entry, then dump the 	 current buffer contents now.  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|5
operator|+
name|length
operator|>
name|SOM_TMP_BUFSIZE
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|p
operator|-
name|tmp_space
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|p
operator|-
name|tmp_space
condition|)
return|return
name|false
return|;
comment|/* Reset to beginning of the buffer space.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
block|}
comment|/* First element in a string table entry is the length of the 	 string.  This must always be 4 byte aligned.  This is also 	 an appropriate time to fill in the string index field in the 	 symbol table entry.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strings_size
operator|+=
literal|4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Next comes the string itself + a null terminator.  */
name|strcpy
argument_list|(
name|p
argument_list|,
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|som_symbol_data
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|->
name|stringtab_offset
operator|=
name|strings_size
expr_stmt|;
name|p
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
name|strings_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
comment|/* Always align up to the next word boundary.  */
while|while
condition|(
name|strings_size
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strings_size
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/* Scribble out any partial block.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|p
operator|-
name|tmp_space
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|p
operator|-
name|tmp_space
condition|)
return|return
name|false
return|;
operator|*
name|string_sizep
operator|=
name|strings_size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Compute variable information to be placed in the SOM headers,     space/subspace dictionaries, relocation streams, etc.  Begin    writing parts of the object file.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_begin_writing
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|long
name|current_offset
init|=
literal|0
decl_stmt|;
name|int
name|strings_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|total_reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|num_spaces
decl_stmt|,
name|num_subspaces
decl_stmt|,
name|i
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|total_subspaces
init|=
literal|0
decl_stmt|;
name|struct
name|som_exec_auxhdr
modifier|*
name|exec_header
init|=
name|NULL
decl_stmt|;
comment|/* The file header will always be first in an object file,       everything else can be in random locations.  To keep things      "simple" BFD will lay out the object file in the manner suggested      by the PRO ABI for PA-RISC Systems.  */
comment|/* Before any output can really begin offsets for all the major      portions of the object file must be computed.  So, starting      with the initial file header compute (and sometimes write)      each portion of the object file.  */
comment|/* Make room for the file header, it's contents are not complete      yet, so it can not be written at this time.  */
name|current_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
expr_stmt|;
comment|/* Any auxiliary headers will follow the file header.  Right now      we support only the copyright and version headers.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
comment|/* Parts of the exec header will be filled in later, so 	 delay writing the header itself.  Fill in the defaults, 	 and write it later.  */
name|current_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
expr_stmt|;
name|exec_header
operator|=
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|som_auxhdr
operator|.
name|type
operator|=
name|EXEC_AUX_ID
expr_stmt|;
name|exec_header
operator|->
name|som_auxhdr
operator|.
name|length
operator|=
literal|40
expr_stmt|;
block|}
if|if
condition|(
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Write the aux_id structure and the string length.  */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
comment|/* Write the version string.  */
name|len
operator|=
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_string
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Write the aux_id structure and the string length.  */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
comment|/* Write the copyright string.  */
name|len
operator|=
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyright
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
comment|/* Next comes the initialization pointers; we have no initialization      pointers, so current offset does not change.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|init_array_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|init_array_total
operator|=
literal|0
expr_stmt|;
comment|/* Next are the space records.  These are fixed length records.       Count the number of spaces to determine how much room is needed      in the object file for the space records.       The names of the spaces are stored in a separate string table,      and the index for each space into the string table is computed      below.  Therefore, it is not possible to write the space headers      at this time.  */
name|num_spaces
operator|=
name|som_count_spaces
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_total
operator|=
name|num_spaces
expr_stmt|;
name|current_offset
operator|+=
name|num_spaces
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
expr_stmt|;
comment|/* Next are the subspace records.  These are fixed length records.       Count the number of subspaes to determine how much room is needed      in the object file for the subspace records.       A variety if fields in the subspace record are still unknown at      this time (index into string table, fixup stream location/size, etc).  */
name|num_subspaces
operator|=
name|som_count_subspaces
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|subspace_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|subspace_total
operator|=
name|num_subspaces
expr_stmt|;
name|current_offset
operator|+=
name|num_subspaces
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
expr_stmt|;
comment|/* Next is the string table for the space/subspace names.  We will      build and write the string table on the fly.  At the same time      we will fill in the space/subspace name index fields.  */
comment|/* The string table needs to be aligned on a word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
comment|/* Mark the offset of the space/subspace string table in the       file header.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_strings_location
operator|=
name|current_offset
expr_stmt|;
comment|/* Scribble out the space strings.  */
if|if
condition|(
name|som_write_space_strings
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
operator|&
name|strings_size
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Record total string table size in the header and update the      current offset.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_strings_size
operator|=
name|strings_size
expr_stmt|;
name|current_offset
operator|+=
name|strings_size
expr_stmt|;
comment|/* Next is the compiler records.  We do not use these.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|compiler_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|compiler_total
operator|=
literal|0
expr_stmt|;
comment|/* Now compute the file positions for the loadable subspaces, taking      care to make sure everything stays properly aligned.  */
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
name|int
name|first_subspace
decl_stmt|;
name|unsigned
name|int
name|subspace_offset
init|=
literal|0
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
name|first_subspace
operator|=
literal|1
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this is the first subspace in the space, and we are 	     building an executable, then take care to make sure all 	     the alignments are correct and update the exec header.  */
if|if
condition|(
name|first_subspace
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
condition|)
block|{
comment|/* Demand paged executables have each space aligned to a 		 page boundary.  Sharable executables (write-protected 		 text) have just the private (aka data& bss) space aligned 		 to a page boundary.  Ugh.  Not true for HPUX.  		 The HPUX kernel requires the text to always be page aligned 		 within the file regardless of the executable's type.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|D_PAGED
operator||
name|DYNAMIC
operator|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|||
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
operator|)
operator|&&
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_DATA
operator|)
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
comment|/* Update the exec header.  */
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
operator|&&
name|exec_header
operator|->
name|exec_tfile
operator|==
literal|0
condition|)
block|{
name|exec_header
operator|->
name|exec_tmem
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|exec_header
operator|->
name|exec_tfile
operator|=
name|current_offset
expr_stmt|;
block|}
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_DATA
operator|&&
name|exec_header
operator|->
name|exec_dfile
operator|==
literal|0
condition|)
block|{
name|exec_header
operator|->
name|exec_dmem
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|exec_header
operator|->
name|exec_dfile
operator|=
name|current_offset
expr_stmt|;
block|}
comment|/* Keep track of exactly where we are within a particular 		 space.  This is necessary as the braindamaged HPUX 		 loader will create holes between subspaces *and*  		 subspace alignments are *NOT* preserved.  What a crock.  */
name|subspace_offset
operator|=
name|subsection
operator|->
name|vma
expr_stmt|;
comment|/* Only do this for the first subspace within each space.  */
name|first_subspace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
comment|/* The braindamaged HPUX loader may have created a hole 		 between two subspaces.  It is *not* sufficient to use 		 the alignment specifications within the subspaces to 		 account for these holes -- I've run into at least one 		 case where the loader left one code subspace unaligned 		 in a final executable.  		 To combat this we keep a current offset within each space, 		 and use the subspace vma fields to detect and preserve 		 holes.  What a crock!  		 ps.  This is not necessary for unloadable space/subspaces.  */
name|current_offset
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|exec_header
operator|->
name|exec_tsize
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
else|else
name|exec_header
operator|->
name|exec_dsize
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
name|subspace_offset
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
block|}
name|subsection
operator|->
name|target_index
operator|=
name|total_subspaces
operator|++
expr_stmt|;
comment|/* This is real data to be loaded from the file.  */
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
comment|/* Update the size of the code& data.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|&&
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|exec_header
operator|->
name|exec_tsize
operator|+=
name|subsection
operator|->
name|_cooked_size
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|&&
name|subsection
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
name|exec_header
operator|->
name|exec_dsize
operator|+=
name|subsection
operator|->
name|_cooked_size
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
name|current_offset
expr_stmt|;
name|subsection
operator|->
name|filepos
operator|=
name|current_offset
expr_stmt|;
name|current_offset
operator|+=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|subsection
argument_list|)
expr_stmt|;
name|subspace_offset
operator|+=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|subsection
argument_list|)
expr_stmt|;
block|}
comment|/* Looks like uninitialized data.  */
else|else
block|{
comment|/* Update the size of the bss section.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|exec_header
operator|->
name|exec_bsize
operator|+=
name|subsection
operator|->
name|_cooked_size
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
literal|0
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|initialization_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* Finally compute the file positions for unloadable subspaces.      If building an executable, start the unloadable stuff on its      own page.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|unloadable_sp_location
operator|=
name|current_offset
expr_stmt|;
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|subsection
operator|->
name|target_index
operator|=
name|total_subspaces
operator|++
expr_stmt|;
comment|/* This is real data to be loaded from the file.  */
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
name|current_offset
expr_stmt|;
name|subsection
operator|->
name|filepos
operator|=
name|current_offset
expr_stmt|;
name|current_offset
operator|+=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|subsection
argument_list|)
expr_stmt|;
block|}
comment|/* Looks like uninitialized data.  */
else|else
block|{
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
literal|0
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|initialization_length
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|subsection
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* If building an executable, then make sure to seek to and write      one byte at the end of the file to make sure any necessary      zeros are filled in.  Ugh.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
literal|""
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|unloadable_sp_size
operator|=
name|current_offset
operator|-
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|unloadable_sp_location
expr_stmt|;
comment|/* Loader fixups are not supported in any way shape or form.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|loader_fixup_location
operator|=
literal|0
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|loader_fixup_total
operator|=
literal|0
expr_stmt|;
comment|/* Done.  Store the total size of the SOM so far.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
operator|=
name|current_offset
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finally, scribble out the various headers to the disk.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_finish_writing
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|num_spaces
init|=
name|som_count_spaces
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_syms
decl_stmt|,
name|strings_size
decl_stmt|;
name|int
name|subspace_index
init|=
literal|0
decl_stmt|;
name|file_ptr
name|location
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|long
name|current_offset
decl_stmt|;
name|unsigned
name|int
name|total_reloc_size
decl_stmt|;
comment|/* Next is the symbol table.  These are fixed length records.       Count the number of symbols to determine how much room is needed      in the object file for the symbol table.       The names of the symbols are stored in a separate string table,      and the index for each symbol name into the string table is computed      below.  Therefore, it is not possible to write the symbol table      at this time.        These used to be output before the subspace contents, but they      were moved here to work around a stupid bug in the hpux linker      (fixed in hpux10).  */
name|current_offset
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
expr_stmt|;
comment|/* Make sure we're on a word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|num_syms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_total
operator|=
name|num_syms
expr_stmt|;
name|current_offset
operator|+=
name|num_syms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
expr_stmt|;
comment|/* Next are the symbol strings.      Align them to a word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_strings_location
operator|=
name|current_offset
expr_stmt|;
comment|/* Scribble out the symbol strings.  */
if|if
condition|(
name|som_write_symbol_strings
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
name|syms
argument_list|,
name|num_syms
argument_list|,
operator|&
name|strings_size
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Record total string table size in header and update the      current offset.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_strings_size
operator|=
name|strings_size
expr_stmt|;
name|current_offset
operator|+=
name|strings_size
expr_stmt|;
comment|/* Do prep work before handling fixups.  */
name|som_prep_for_fixups
argument_list|(
name|abfd
argument_list|,
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At the end of the file is the fixup stream which starts on a      word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|fixup_request_location
operator|=
name|current_offset
expr_stmt|;
comment|/* Write the fixups and update fields in subspace headers which      relate to the fixup stream.  */
if|if
condition|(
name|som_write_fixups
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
operator|&
name|total_reloc_size
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Record the total size of the fixup stream in the file header.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|fixup_request_total
operator|=
name|total_reloc_size
expr_stmt|;
comment|/* Done.  Store the total size of the SOM.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
operator|=
name|current_offset
operator|+
name|total_reloc_size
expr_stmt|;
comment|/* Now that the symbol table information is complete, build and      write the symbol table.  */
if|if
condition|(
name|som_build_and_write_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Subspaces are written first so that we can set up information      about them in their containing spaces as the subspace is written.  */
comment|/* Seek to the start of the subspace dictionary records.  */
name|location
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|subspace_location
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
comment|/* Now for each loadable space write out records for its subspaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
comment|/* Skip any section which does not correspond to a space 	     or subspace.  Or does not have SEC_ALLOC set (and therefore 	     has no real bits on the disk).  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this is the first subspace for this space, then save 	     the index of the subspace in its containing space.  Also 	     set "is_loadable" in the containing space.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_loadable
operator|=
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_index
operator|=
name|subspace_index
expr_stmt|;
block|}
comment|/* Increment the number of subspaces seen and the number of 	     subspaces contained within the current space.  */
name|subspace_index
operator|++
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|++
expr_stmt|;
comment|/* Mark the index of the current space within the subspace's 	     dictionary record.  */
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|space_index
operator|=
name|i
expr_stmt|;
comment|/* Dump the current subspace header.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* Now repeat the process for unloadable subspaces.  */
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
comment|/* Now for each space write out records for its subspaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
comment|/* Skip any section which does not correspond to a space or 	     subspace, or which SEC_ALLOC set (and therefore handled 	     in the loadable spaces/subspaces code above).  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If this is the first subspace for this space, then save 	     the index of the subspace in its containing space.  Clear 	     "is_loadable".  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_loadable
operator|=
literal|0
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_index
operator|=
name|subspace_index
expr_stmt|;
block|}
comment|/* Increment the number of subspaces seen and the number of 	     subspaces contained within the current space.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|++
expr_stmt|;
name|subspace_index
operator|++
expr_stmt|;
comment|/* Mark the index of the current space within the subspace's 	     dictionary record.  */
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|space_index
operator|=
name|i
expr_stmt|;
comment|/* Dump this subspace header.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* All the subspace dictiondary records are written, and all the      fields are set up in the space dictionary records.       Seek to the right location and start writing the space      dictionary records.  */
name|location
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_location
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Dump its header  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* Setting of the system_id has to happen very late now that copying of      BFD private data happens *after* section contents are set.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|pa11
condition|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|CPU_PA_RISC1_1
expr_stmt|;
else|else
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|CPU_PA_RISC1_0
expr_stmt|;
comment|/* Compute the checksum for the file header just before writing      the header to disk.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|checksum
operator|=
name|som_compute_checksum
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Only thing left to do is write out the file header.  It is always      at location zero.  Seek there and write it.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now write the exec header.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
name|long
name|tmp
decl_stmt|;
name|struct
name|som_exec_auxhdr
modifier|*
name|exec_header
decl_stmt|;
name|exec_header
operator|=
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|exec_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|exec_flags
operator|=
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_flags
expr_stmt|;
comment|/* Oh joys.  Ram some of the BSS data into the DATA section 	 to be compatable with how the hp linker makes objects 	 (saves memory space).  */
name|tmp
operator|=
name|exec_header
operator|->
name|exec_dsize
expr_stmt|;
name|tmp
operator|=
name|SOM_ALIGN
argument_list|(
name|tmp
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|exec_bsize
operator|-=
operator|(
name|tmp
operator|-
name|exec_header
operator|->
name|exec_dsize
operator|)
expr_stmt|;
if|if
condition|(
name|exec_header
operator|->
name|exec_bsize
operator|<
literal|0
condition|)
name|exec_header
operator|->
name|exec_bsize
operator|=
literal|0
expr_stmt|;
name|exec_header
operator|->
name|exec_dsize
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_location
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|exec_header
argument_list|,
name|AUX_HDR_SIZE
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|AUX_HDR_SIZE
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Compute and return the checksum for a SOM file header.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|som_compute_checksum
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|long
name|checksum
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|checksum
operator|^=
operator|*
operator|(
name|buffer
operator|+
name|i
operator|)
expr_stmt|;
return|return
name|checksum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|som_bfd_derive_misc_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|som_misc_symbol_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* Initialize.  */
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_misc_symbol_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The HP SOM linker requires detailed type information about      all symbols (including undefined symbols!).  Unfortunately,      the type specified in an import/export statement does not      always match what the linker wants.  Severe braindamage.  */
comment|/* Section symbols will not have a SOM symbol type assigned to      them yet.  Assign all section symbols type ST_DATA.  */
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_DATA
expr_stmt|;
else|else
block|{
comment|/* Common symbols must have scope SS_UNSAT and type 	 ST_STORAGE or the linker will choke.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
name|info
operator|->
name|symbol_scope
operator|=
name|SS_UNSAT
expr_stmt|;
name|info
operator|->
name|symbol_type
operator|=
name|ST_STORAGE
expr_stmt|;
block|}
comment|/* It is possible to have a symbol without an associated 	 type.  This happens if the user imported the symbol 	 without a type and the symbol was never defined 	 locally.  If BSF_FUNCTION is set for this symbol, then 	 assign it type ST_CODE (the HP linker requires undefined 	 external functions to have type ST_CODE rather than ST_ENTRY).  */
elseif|else
if|if
condition|(
operator|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
operator|||
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_CODE
operator|)
operator|&&
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_CODE
expr_stmt|;
comment|/* Handle function symbols which were defined in this file. 	 They should have type ST_ENTRY.  Also retrieve the argument 	 relocation bits from the SOM backend information.  */
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_ENTRY
operator|||
operator|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_CODE
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|)
operator|||
operator|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|)
condition|)
block|{
name|info
operator|->
name|symbol_type
operator|=
name|ST_ENTRY
expr_stmt|;
name|info
operator|->
name|arg_reloc
operator|=
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
expr_stmt|;
block|}
comment|/* If the type is unknown at this point, it should be ST_DATA or 	 ST_CODE (function/ST_ENTRY symbols were handled  as special 	 cases above). */
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_CODE
expr_stmt|;
else|else
name|info
operator|->
name|symbol_type
operator|=
name|ST_DATA
expr_stmt|;
block|}
comment|/* From now on it's a very simple mapping.  */
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_ABSOLUTE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_ABSOLUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_CODE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_DATA
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_MILLICODE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_MILLICODE
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_PLABEL
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_PLABEL
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_PRI_PROG
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_PRI_PROG
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_SEC_PROG
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_SEC_PROG
expr_stmt|;
block|}
comment|/* Now handle the symbol's scope.  Exported data which is not      in the common section has scope SS_UNIVERSAL.  Note scope      of common symbols was handled earlier!  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|info
operator|->
name|symbol_scope
operator|=
name|SS_UNSAT
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_EXPORT
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|info
operator|->
name|symbol_scope
operator|=
name|SS_UNIVERSAL
expr_stmt|;
comment|/* Anything else which is not in the common section has scope      SS_LOCAL.  */
elseif|else
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|info
operator|->
name|symbol_scope
operator|=
name|SS_LOCAL
expr_stmt|;
comment|/* Now set the symbol_info field.  It has no real meaning      for undefined or common symbols, but the HP linker will      choke if it's not set to some "reasonable" value.  We      use zero as a reasonable value.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|info
operator|->
name|symbol_info
operator|=
literal|0
expr_stmt|;
comment|/* For all other symbols, the symbol_info field contains the       subspace index of the space this symbol is contained in.  */
else|else
name|info
operator|->
name|symbol_info
operator|=
name|sym
operator|->
name|section
operator|->
name|target_index
expr_stmt|;
comment|/* Set the symbol's value.  */
name|info
operator|->
name|symbol_value
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build and write, in one big chunk, the entire symbol table for    this BFD.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_build_and_write_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|num_syms
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|symtab_location
init|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_location
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|bfd_syms
init|=
name|obj_som_sorted_syms
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|som_symtab
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|symtab_size
decl_stmt|;
comment|/* Compute total symbol table size and allocate a chunk of memory      to hold the symbol table as we build it.  */
name|symtab_size
operator|=
name|num_syms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
expr_stmt|;
name|som_symtab
operator|=
operator|(
expr|struct
name|symbol_dictionary_record
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_symtab
operator|==
name|NULL
operator|&&
name|symtab_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|memset
argument_list|(
name|som_symtab
argument_list|,
literal|0
argument_list|,
name|symtab_size
argument_list|)
expr_stmt|;
comment|/* Walk over each symbol.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|som_misc_symbol_info
name|info
decl_stmt|;
comment|/* This is really an index into the symbol strings table.   	 By the time we get here, the index has already been  	 computed and stored into the name field in the BFD symbol.  */
name|som_symtab
index|[
name|i
index|]
operator|.
name|name
operator|.
name|n_strx
operator|=
name|som_symbol_data
argument_list|(
name|bfd_syms
index|[
name|i
index|]
argument_list|)
operator|->
name|stringtab_offset
expr_stmt|;
comment|/* Derive SOM information from the BFD symbol.  */
name|som_bfd_derive_misc_symbol_info
argument_list|(
name|abfd
argument_list|,
name|bfd_syms
index|[
name|i
index|]
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Now use it.  */
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_type
operator|=
name|info
operator|.
name|symbol_type
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_scope
operator|=
name|info
operator|.
name|symbol_scope
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|arg_reloc
operator|=
name|info
operator|.
name|arg_reloc
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_info
operator|=
name|info
operator|.
name|symbol_info
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_value
operator|=
name|info
operator|.
name|symbol_value
expr_stmt|;
block|}
comment|/* Everything is ready, seek to the right location and      scribble out the symbol table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|som_symtab
argument_list|,
name|symtab_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symtab_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|som_symtab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_symtab
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|som_symtab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_symtab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Write an object in SOM format.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
comment|/* Set up fixed parts of the file, space, and subspace headers. 	 Notify the world that output has begun.  */
name|som_prep_headers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
comment|/* Start writing the object file.  This include all the string 	 tables, fixup streams, and other portions of the object file.  */
name|som_begin_writing
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|som_finish_writing
argument_list|(
name|abfd
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read and save the string table associated with the given BFD.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_slurp_string_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|stringtab
decl_stmt|;
comment|/* Use the saved version if its available.  */
if|if
condition|(
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
comment|/* I don't think this can currently happen, and I'm not sure it should      really be an error, but it's better than getting unpredictable results      from the host's malloc when passed a size of zero.  */
if|if
condition|(
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Allocate and read in the string table.  */
name|stringtab
operator|=
name|bfd_malloc
argument_list|(
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringtab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|stringtab
argument_list|,
literal|0
argument_list|,
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|stringtab
argument_list|,
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Save our results and return success. */
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|stringtab
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of data (in bytes) required to hold the symbol    table for this object.  */
end_comment

begin_function
specifier|static
name|long
name|som_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|som_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert from a SOM subspace index to a BFD section.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|bfd_section_from_som_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|symbol
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* The meaning of the symbol_info field changes for functions      within executables.  So only use the quick symbol_info mapping for      incomplete objects and non-function symbols in executables.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_ENTRY
operator|&&
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_PRI_PROG
operator|&&
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_SEC_PROG
operator|&&
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_MILLICODE
operator|)
condition|)
block|{
name|unsigned
name|int
name|index
init|=
name|symbol
operator|->
name|symbol_info
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|section
operator|->
name|target_index
operator|==
name|index
operator|&&
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|section
return|;
comment|/* Could be a symbol from an external library (such as an OMOS 	 shared library).  Don't abort.  */
return|return
name|bfd_abs_section_ptr
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|value
init|=
name|symbol
operator|->
name|symbol_value
decl_stmt|;
comment|/* For executables we will have to use the symbol's address and 	 find out what section would contain that address.   Yuk.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|value
operator|>=
name|section
operator|->
name|vma
operator|&&
name|value
operator|<=
name|section
operator|->
name|vma
operator|+
name|section
operator|->
name|_cooked_size
operator|&&
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|section
return|;
block|}
comment|/* Could be a symbol from an external library (such as an OMOS 	 shared library).  Don't abort.  */
return|return
name|bfd_abs_section_ptr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read and save the symbol table associated with the given BFD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|som_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|symsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|endbufp
decl_stmt|;
name|som_symbol_type
modifier|*
name|sym
decl_stmt|,
modifier|*
name|symbase
decl_stmt|;
comment|/* Return saved value if it exists.  */
if|if
condition|(
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|successful_return
goto|;
comment|/* Special case.  This is *not* an error.  */
if|if
condition|(
name|symbol_count
operator|==
literal|0
condition|)
goto|goto
name|successful_return
goto|;
if|if
condition|(
operator|!
name|som_slurp_string_table
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|stringtab
operator|=
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symbase
operator|=
operator|(
operator|(
name|som_symbol_type
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symbol_count
operator|*
sizeof|sizeof
argument_list|(
name|som_symbol_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symbase
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memset
argument_list|(
name|symbase
argument_list|,
literal|0
argument_list|,
name|symbol_count
operator|*
sizeof|sizeof
argument_list|(
name|som_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the external SOM representation.  */
name|buf
operator|=
name|bfd_malloc
argument_list|(
name|symbol_count
operator|*
name|symsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|&&
name|symbol_count
operator|*
name|symsize
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
name|buf
argument_list|,
name|symbol_count
operator|*
name|symsize
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symbol_count
operator|*
name|symsize
condition|)
goto|goto
name|error_return
goto|;
comment|/* Iterate over all the symbols and internalize them.  */
name|endbufp
operator|=
name|buf
operator|+
name|symbol_count
expr_stmt|;
for|for
control|(
name|bufp
operator|=
name|buf
operator|,
name|sym
operator|=
name|symbase
init|;
name|bufp
operator|<
name|endbufp
condition|;
operator|++
name|bufp
control|)
block|{
comment|/* I don't think we care about these.  */
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_SYM_EXT
operator|||
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_ARG_EXT
condition|)
continue|continue;
comment|/* Set some private data we care about.  */
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_NULL
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_UNKNOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_ABSOLUTE
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_ABSOLUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_DATA
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_CODE
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_PRI_PROG
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_PRI_PROG
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_SEC_PROG
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_SEC_PROG
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_ENTRY
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_ENTRY
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_MILLICODE
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_MILLICODE
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_PLABEL
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_PLABEL
expr_stmt|;
else|else
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_UNKNOWN
expr_stmt|;
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
operator|=
name|bufp
operator|->
name|arg_reloc
expr_stmt|;
comment|/* Some reasonable defaults.  */
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|bufp
operator|->
name|symbol_value
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_ENTRY
case|:
case|case
name|ST_MILLICODE
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&=
operator|~
literal|0x3
expr_stmt|;
break|break;
case|case
name|ST_STUB
case|:
case|case
name|ST_CODE
case|:
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&=
operator|~
literal|0x3
expr_stmt|;
comment|/* If the symbol's scope is ST_UNSAT, then these are 	     undefined function symbols.  */
if|if
condition|(
name|bufp
operator|->
name|symbol_scope
operator|==
name|SS_UNSAT
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
default|default:
break|break;
block|}
comment|/* Handle scoping and section information.  */
switch|switch
condition|(
name|bufp
operator|->
name|symbol_scope
condition|)
block|{
comment|/* symbol_info field is undefined for SS_EXTERNAL and SS_UNSAT symbols, 	   so the section associated with this symbol can't be known.  */
case|case
name|SS_EXTERNAL
case|:
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
operator|(
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator|)
expr_stmt|;
break|break;
case|case
name|SS_UNSAT
case|:
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|SS_UNIVERSAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
operator|(
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_section_from_som_symbol
argument_list|(
name|abfd
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* SS_GLOBAL and SS_LOCAL are two names for the same thing. 	   Sound dumb?  It is.  */
block|case SS_GLOBAL:
endif|#
directive|endif
case|case
name|SS_LOCAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_section_from_som_symbol
argument_list|(
name|abfd
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
comment|/* Mark section symbols and symbols used by the debugger. 	 Note $START$ is a magic code symbol, NOT a section symbol.  */
if|if
condition|(
name|sym
operator|->
name|symbol
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|sym
operator|->
name|symbol
operator|.
name|name
index|[
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|&&
operator|!
name|strcmp
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
argument_list|)
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
literal|"L$0\002"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
literal|"L$0\001"
argument_list|,
literal|4
argument_list|)
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* Note increment at bottom of loop, since we skip some symbols          we can not include it as part of the for statement.  */
name|sym
operator|++
expr_stmt|;
block|}
comment|/* Save our results and return success.  */
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|symbase
expr_stmt|;
name|successful_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a SOM symbol table.  Return the number of entries    in the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|som_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|location
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|som_symbol_type
modifier|*
name|symbase
decl_stmt|;
if|if
condition|(
operator|!
name|som_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symbase
operator|=
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|location
operator|++
operator|,
name|symbase
operator|++
control|)
operator|*
name|location
operator|=
operator|&
name|symbase
operator|->
name|symbol
expr_stmt|;
comment|/* Final null pointer.  */
operator|*
name|location
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a SOM symbol.  There is nothing special to do here.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|som_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|som_symbol_type
modifier|*
name|new
init|=
operator|(
name|som_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|som_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Print symbol information.  */
end_comment

begin_function
specifier|static
name|void
name|som_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"som "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
decl_stmt|;
name|section_name
operator|=
name|symbol
operator|->
name|section
condition|?
name|symbol
operator|->
name|section
operator|->
name|name
else|:
literal|"(*none*)"
expr_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\t%s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|som_bfd_is_local_label
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
return|return
operator|(
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|sym
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Count or process variable-length SOM fixup records.     To avoid code duplication we use this code both to compute the number    of relocations requested by a stream, and to internalize the stream.     When computing the number of relocations requested by a stream the    variables rptr, section, and symbols have no meaning.     Return the number of relocations requested by the fixup stream.  When    not just counting      This needs at least two or three more passes to get it cleaned up.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|som_set_reloc_info
parameter_list|(
name|fixup
parameter_list|,
name|end
parameter_list|,
name|internal_relocs
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|just_count
parameter_list|)
name|unsigned
name|char
modifier|*
name|fixup
decl_stmt|;
name|unsigned
name|int
name|end
decl_stmt|;
name|arelent
modifier|*
name|internal_relocs
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|boolean
name|just_count
decl_stmt|;
block|{
name|unsigned
name|int
name|op
decl_stmt|,
name|varname
decl_stmt|,
name|deallocate_contents
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end_fixups
init|=
operator|&
name|fixup
index|[
name|end
index|]
decl_stmt|;
specifier|const
name|struct
name|fixup_format
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|save_fixup
decl_stmt|;
name|int
name|variables
index|[
literal|26
index|]
decl_stmt|,
name|stack
index|[
literal|20
index|]
decl_stmt|,
name|c
decl_stmt|,
name|v
decl_stmt|,
name|count
decl_stmt|,
name|prev_fixup
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
name|saved_unwind_bits
decl_stmt|;
specifier|const
name|int
modifier|*
name|subop
decl_stmt|;
name|arelent
modifier|*
name|rptr
init|=
name|internal_relocs
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|var
parameter_list|(
name|c
parameter_list|)
value|variables[(c) - 'A']
define|#
directive|define
name|push
parameter_list|(
name|v
parameter_list|)
value|(*sp++ = (v))
define|#
directive|define
name|pop
parameter_list|()
value|(*--sp)
define|#
directive|define
name|emptystack
parameter_list|()
value|(sp == stack)
name|som_initialize_reloc_queue
argument_list|(
name|reloc_queue
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|variables
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|variables
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|prev_fixup
operator|=
literal|0
expr_stmt|;
name|saved_unwind_bits
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
while|while
condition|(
name|fixup
operator|<
name|end_fixups
condition|)
block|{
comment|/* Save pointer to the start of this fixup.  We'll use 	 it later to determine if it is necessary to put this fixup 	 on the queue.  */
name|save_fixup
operator|=
name|fixup
expr_stmt|;
comment|/* Get the fixup code and its associated format.  */
name|op
operator|=
operator|*
name|fixup
operator|++
expr_stmt|;
name|fp
operator|=
operator|&
name|som_fixup_formats
index|[
name|op
index|]
expr_stmt|;
comment|/* Handle a request for a previous fixup.  */
if|if
condition|(
operator|*
name|fp
operator|->
name|format
operator|==
literal|'P'
condition|)
block|{
comment|/* Get pointer to the beginning of the prev fixup, move 	     the repeated fixup to the head of the queue.  */
name|fixup
operator|=
name|reloc_queue
index|[
name|fp
operator|->
name|D
index|]
operator|.
name|reloc
expr_stmt|;
name|som_reloc_queue_fix
argument_list|(
name|reloc_queue
argument_list|,
name|fp
operator|->
name|D
argument_list|)
expr_stmt|;
name|prev_fixup
operator|=
literal|1
expr_stmt|;
comment|/* Get the fixup code and its associated format.  */
name|op
operator|=
operator|*
name|fixup
operator|++
expr_stmt|;
name|fp
operator|=
operator|&
name|som_fixup_formats
index|[
name|op
index|]
expr_stmt|;
block|}
comment|/* If this fixup will be passed to BFD, set some reasonable defaults.  */
if|if
condition|(
operator|!
name|just_count
operator|&&
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_NO_RELOCATION
operator|&&
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_DATA_OVERRIDE
condition|)
block|{
name|rptr
operator|->
name|address
operator|=
name|offset
expr_stmt|;
name|rptr
operator|->
name|howto
operator|=
operator|&
name|som_hppa_howto_table
index|[
name|op
index|]
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
comment|/* Set default input length to 0.  Get the opcode class index 	 into D.  */
name|var
argument_list|(
literal|'L'
argument_list|)
operator|=
literal|0
expr_stmt|;
name|var
argument_list|(
literal|'D'
argument_list|)
operator|=
name|fp
operator|->
name|D
expr_stmt|;
name|var
argument_list|(
literal|'U'
argument_list|)
operator|=
name|saved_unwind_bits
expr_stmt|;
comment|/* Get the opcode format.  */
name|cp
operator|=
name|fp
operator|->
name|format
expr_stmt|;
comment|/* Process the format string.  Parsing happens in two phases, 	 parse RHS, then assign to LHS.  Repeat until no more  	 characters in the format string.  */
while|while
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* The variable this pass is going to compute a value for.  */
name|varname
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* Start processing RHS.  Continue until a NULL or '=' is found.  */
do|do
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* If this is a variable, push it on the stack.  */
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|push
argument_list|(
name|var
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a lower case letter, then it represents 		 additional data from the fixup stream to be pushed onto 		 the stack.  */
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|bits
init|=
operator|(
name|c
operator|-
literal|'a'
operator|)
operator|*
literal|8
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|c
operator|>
literal|'a'
condition|;
operator|--
name|c
control|)
name|v
operator|=
operator|(
name|v
operator|<<
literal|8
operator|)
operator||
operator|*
name|fixup
operator|++
expr_stmt|;
if|if
condition|(
name|varname
operator|==
literal|'V'
condition|)
name|v
operator|=
name|sign_extend
argument_list|(
name|v
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* A decimal constant.  Push it on the stack.  */
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|v
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|v
operator|=
operator|(
name|v
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* An operator.  Pop two two values from the stack and 		   use them as operands to the given operation.  Push 		   the result of the operation back on the stack.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|+=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|*=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
operator|<<
name|v
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'='
condition|)
do|;
comment|/* Move over the equal operator.  */
name|cp
operator|++
expr_stmt|;
comment|/* Pop the RHS off the stack.  */
name|c
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* Perform the assignment.  */
name|var
argument_list|(
name|varname
argument_list|)
operator|=
name|c
expr_stmt|;
comment|/* Handle side effects. and special 'O' stack cases.  */
switch|switch
condition|(
name|varname
condition|)
block|{
comment|/* Consume some bytes from the input space.  */
case|case
literal|'L'
case|:
name|offset
operator|+=
name|c
expr_stmt|;
break|break;
comment|/* A symbol to use in the relocation.  Make a note 	       of this if we are not just counting.  */
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|just_count
condition|)
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|symbols
index|[
name|c
index|]
expr_stmt|;
break|break;
comment|/* Argument relocation bits for a function call.  */
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|just_count
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
name|var
argument_list|(
literal|'R'
argument_list|)
decl_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_PCREL_CALL
operator|&&
name|R_PCREL_CALL
operator|+
literal|10
operator|>
name|op
operator|)
operator|||
operator|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_ABS_CALL
operator|&&
name|R_ABS_CALL
operator|+
literal|10
operator|>
name|op
operator|)
condition|)
block|{
comment|/* Simple encoding.  */
if|if
condition|(
name|tmp
operator|>
literal|4
condition|)
block|{
name|tmp
operator|-=
literal|5
expr_stmt|;
name|rptr
operator|->
name|addend
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|==
literal|4
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|3
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|2
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|1
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* First part is easy -- low order two bits are 			 directly copied, then shifted away.  */
name|rptr
operator|->
name|addend
operator|=
name|tmp
operator|&
literal|0x3
expr_stmt|;
name|tmp
operator|>>=
literal|2
expr_stmt|;
comment|/* Diving the result by 10 gives us the second 			 part.  If it is 9, then the first two words 			 are a double precision paramater, else it is 			 3 * the first arg bits + the 2nd arg bits.  */
name|tmp1
operator|=
name|tmp
operator|/
literal|10
expr_stmt|;
name|tmp
operator|-=
name|tmp1
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|tmp1
operator|==
literal|9
condition|)
name|rptr
operator|->
name|addend
operator|+=
operator|(
literal|0xe
operator|<<
literal|6
operator|)
expr_stmt|;
else|else
block|{
comment|/* Get the two pieces.  */
name|tmp2
operator|=
name|tmp1
operator|/
literal|3
expr_stmt|;
name|tmp1
operator|-=
name|tmp2
operator|*
literal|3
expr_stmt|;
comment|/* Put them in the addend.  */
name|rptr
operator|->
name|addend
operator|+=
operator|(
name|tmp2
operator|<<
literal|8
operator|)
operator|+
operator|(
name|tmp1
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
comment|/* What's left is the third part.  It's unpacked 			 just like the second.  */
if|if
condition|(
name|tmp
operator|==
literal|9
condition|)
name|rptr
operator|->
name|addend
operator|+=
operator|(
literal|0xe
operator|<<
literal|2
operator|)
expr_stmt|;
else|else
block|{
name|tmp2
operator|=
name|tmp
operator|/
literal|3
expr_stmt|;
name|tmp
operator|-=
name|tmp2
operator|*
literal|3
expr_stmt|;
name|rptr
operator|->
name|addend
operator|+=
operator|(
name|tmp2
operator|<<
literal|4
operator|)
operator|+
operator|(
name|tmp
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
block|}
name|rptr
operator|->
name|addend
operator|=
name|HPPA_R_ADDEND
argument_list|(
name|rptr
operator|->
name|addend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle the linker expression stack.  */
case|case
literal|'O'
case|:
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|R_COMP1
case|:
name|subop
operator|=
name|comp1_opcodes
expr_stmt|;
break|break;
case|case
name|R_COMP2
case|:
name|subop
operator|=
name|comp2_opcodes
expr_stmt|;
break|break;
case|case
name|R_COMP3
case|:
name|subop
operator|=
name|comp3_opcodes
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|subop
operator|<=
operator|(
name|unsigned
name|char
operator|)
name|c
condition|)
operator|++
name|subop
expr_stmt|;
operator|--
name|subop
expr_stmt|;
break|break;
comment|/* The lower 32unwind bits must be persistent.  */
case|case
literal|'U'
case|:
name|saved_unwind_bits
operator|=
name|var
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we used a previous fixup, clean up after it.  */
if|if
condition|(
name|prev_fixup
condition|)
block|{
name|fixup
operator|=
name|save_fixup
operator|+
literal|1
expr_stmt|;
name|prev_fixup
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Queue it.  */
elseif|else
if|if
condition|(
name|fixup
operator|>
name|save_fixup
operator|+
literal|1
condition|)
name|som_reloc_queue_insert
argument_list|(
name|save_fixup
argument_list|,
name|fixup
operator|-
name|save_fixup
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
comment|/* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION  	 fixups to BFD.  */
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_DATA_OVERRIDE
operator|&&
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_NO_RELOCATION
condition|)
block|{
comment|/* Done with a single reloction. Loop back to the top.  */
if|if
condition|(
operator|!
name|just_count
condition|)
block|{
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_ENTRY
condition|)
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_EXIT
condition|)
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_PCREL_CALL
operator|||
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_ABS_CALL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_DATA_ONE_SYMBOL
condition|)
block|{
name|unsigned
name|addend
init|=
name|var
argument_list|(
literal|'V'
argument_list|)
decl_stmt|;
comment|/* Try what was specified in R_DATA_OVERRIDE first 		     (if anything).  Then the hard way using the 		     section contents.  */
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|addend
operator|==
literal|0
operator|&&
operator|!
name|section
operator|->
name|contents
condition|)
block|{
comment|/* Got to read the damn contents first.  We don't 		         bother saving the contents (yet).  Add it one 			 day if the need arises.  */
name|section
operator|->
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|deallocate_contents
operator|=
literal|1
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|,
name|section
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rptr
operator|->
name|addend
operator|==
literal|0
condition|)
name|rptr
operator|->
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|section
operator|->
name|owner
argument_list|,
operator|(
name|section
operator|->
name|contents
operator|+
name|offset
operator|-
name|var
argument_list|(
literal|'L'
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|rptr
operator|++
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
comment|/* Now that we've handled a "full" relocation, reset 	     some state.  */
name|memset
argument_list|(
name|variables
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|variables
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deallocate_contents
condition|)
name|free
argument_list|(
name|section
operator|->
name|contents
argument_list|)
expr_stmt|;
return|return
name|count
return|;
undef|#
directive|undef
name|var
undef|#
directive|undef
name|push
undef|#
directive|undef
name|pop
undef|#
directive|undef
name|emptystack
block|}
end_function

begin_comment
comment|/* Read in the relocs (aka fixups in SOM terms) for a section.      som_get_reloc_upper_bound calls this routine with JUST_COUNT     set to true to indicate it only needs a count of the number    of actual relocations.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|just_count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|boolean
name|just_count
decl_stmt|;
block|{
name|char
modifier|*
name|external_relocs
decl_stmt|;
name|unsigned
name|int
name|fixup_stream_size
decl_stmt|;
name|arelent
modifier|*
name|internal_relocs
decl_stmt|;
name|unsigned
name|int
name|num_relocs
decl_stmt|;
name|fixup_stream_size
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_size
expr_stmt|;
comment|/* If there were no relocations, then there is nothing to do.  */
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If reloc_count is -1, then the relocation stream has not been       parsed.  We must do so now to know how many relocations exist.  */
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|==
operator|-
literal|1
condition|)
block|{
name|external_relocs
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|fixup_stream_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Read in the external forms. */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_reloc_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|section
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|external_relocs
argument_list|,
literal|1
argument_list|,
name|fixup_stream_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|fixup_stream_size
condition|)
return|return
name|false
return|;
comment|/* Let callers know how many relocations found. 	 also save the relocation stream as we will 	 need it again.  */
name|section
operator|->
name|reloc_count
operator|=
name|som_set_reloc_info
argument_list|(
name|external_relocs
argument_list|,
name|fixup_stream_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_stream
operator|=
name|external_relocs
expr_stmt|;
block|}
comment|/* If the caller only wanted a count, then return now.  */
if|if
condition|(
name|just_count
condition|)
return|return
name|true
return|;
name|num_relocs
operator|=
name|section
operator|->
name|reloc_count
expr_stmt|;
name|external_relocs
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_stream
expr_stmt|;
comment|/* Return saved information about the relocations if it is available.  */
if|if
condition|(
name|section
operator|->
name|relocation
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|)
return|return
name|true
return|;
name|internal_relocs
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|num_relocs
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Process and internalize the relocations.  */
name|som_set_reloc_info
argument_list|(
name|external_relocs
argument_list|,
name|fixup_stream_size
argument_list|,
name|internal_relocs
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* We're done with the external relocations.  Free them.  */
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
comment|/* Save our results and return success.  */
name|section
operator|->
name|relocation
operator|=
name|internal_relocs
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes required to store the relocation    information associated with the given section.  */
end_comment

begin_function
specifier|static
name|long
name|som_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
comment|/* If section has relocations, then read in the relocation stream      and parse it to determine how many relocations exist.  */
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
if|if
condition|(
operator|!
name|som_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
comment|/* There are no relocations.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert relocations from SOM (external) form into BFD internal    form.  Return the number of relocations.  */
end_comment

begin_function
specifier|static
name|long
name|som_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|som_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|false
argument_list|)
operator|==
name|false
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|section
operator|->
name|reloc_count
expr_stmt|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|som_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hook to set up object file dependent section information.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|newsect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|newsect
decl_stmt|;
block|{
name|newsect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|3
expr_stmt|;
comment|/* We allow more than three sections internally */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input symbol    to the output symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_copy_private_symbol_data
parameter_list|(
name|ibfd
parameter_list|,
name|isymbol
parameter_list|,
name|obfd
parameter_list|,
name|osymbol
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asymbol
modifier|*
name|isymbol
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asymbol
modifier|*
name|osymbol
decl_stmt|;
block|{
name|struct
name|som_symbol
modifier|*
name|input_symbol
init|=
operator|(
expr|struct
name|som_symbol
operator|*
operator|)
name|isymbol
decl_stmt|;
name|struct
name|som_symbol
modifier|*
name|output_symbol
init|=
operator|(
expr|struct
name|som_symbol
operator|*
operator|)
name|osymbol
decl_stmt|;
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
return|return
name|false
return|;
comment|/* The only private information we need to copy is the argument relocation      bits.  */
name|output_symbol
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
operator|=
name|input_symbol
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input section    to the output section.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_copy_private_section_data
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|obfd
parameter_list|,
name|osection
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|isection
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asection
modifier|*
name|osection
decl_stmt|;
block|{
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
operator|(
operator|!
name|som_is_space
argument_list|(
name|isection
argument_list|)
operator|&&
operator|!
name|som_is_subspace
argument_list|(
name|isection
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|=
operator|(
expr|struct
name|som_copyable_section_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
argument_list|,
name|som_section_data
argument_list|(
name|isection
argument_list|)
operator|->
name|copy_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reparent if necessary.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|->
name|container
condition|)
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|=
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input bfd    to the output bfd.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
return|return
name|true
return|;
comment|/* Allocate some memory to hold the data we need.  */
name|obj_som_exec_data
argument_list|(
name|obfd
argument_list|)
operator|=
operator|(
expr|struct
name|som_exec_data
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_som_exec_data
argument_list|(
name|obfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Now copy the data.  */
name|memcpy
argument_list|(
name|obj_som_exec_data
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|obj_som_exec_data
argument_list|(
name|ibfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Set backend info for sections which can not be described    in the BFD data structures.  */
end_comment

begin_function
name|boolean
name|bfd_som_set_section_attributes
parameter_list|(
name|section
parameter_list|,
name|defined
parameter_list|,
name|private
parameter_list|,
name|sort_key
parameter_list|,
name|spnum
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|int
name|defined
decl_stmt|;
name|int
name|private
decl_stmt|;
name|unsigned
name|int
name|sort_key
decl_stmt|;
name|int
name|spnum
decl_stmt|;
block|{
comment|/* Allocate memory to hold the magic information.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|=
operator|(
expr|struct
name|som_copyable_section_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|section
operator|->
name|owner
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
operator|=
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_defined
operator|=
name|defined
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_private
operator|=
name|private
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|=
name|section
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|space_number
operator|=
name|spnum
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set backend info for subsections which can not be described     in the BFD data structures.  */
end_comment

begin_function
name|boolean
name|bfd_som_set_subsection_attributes
parameter_list|(
name|section
parameter_list|,
name|container
parameter_list|,
name|access
parameter_list|,
name|sort_key
parameter_list|,
name|quadrant
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
name|container
decl_stmt|;
name|int
name|access
decl_stmt|;
name|unsigned
name|int
name|sort_key
decl_stmt|;
name|int
name|quadrant
decl_stmt|;
block|{
comment|/* Allocate memory to hold the magic information.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|=
operator|(
expr|struct
name|som_copyable_section_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|section
operator|->
name|owner
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
operator|=
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|access_control_bits
operator|=
name|access
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|quadrant
operator|=
name|quadrant
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|=
name|container
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the full SOM symbol type.  SOM needs far more symbol information    than any other object file format I'm aware of.  It is mandatory    to be able to know if a symbol is an entry point, millicode, data,    code, absolute, storage request, or procedure label.  If you get    the symbol type wrong your program will not link.  */
end_comment

begin_function
name|void
name|bfd_som_set_symbol_type
parameter_list|(
name|symbol
parameter_list|,
name|type
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
block|{
name|som_symbol_data
argument_list|(
name|symbol
argument_list|)
operator|->
name|som_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach an auxiliary header to the BFD backend so that it may be    written into the object file.  */
end_comment

begin_function
name|boolean
name|bfd_som_attach_aux_hdr
parameter_list|(
name|abfd
parameter_list|,
name|type
parameter_list|,
name|string
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|VERSION_AUX_ID
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|user_string_aux_hdr
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|+
name|len
operator|+
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|type
operator|=
name|VERSION_AUX_ID
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|=
name|len
operator|+
name|pad
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|string_length
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_string
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|COPYRIGHT_AUX_ID
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|copyright_aux_hdr
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|+
name|len
operator|+
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|type
operator|=
name|COPYRIGHT_AUX_ID
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|=
name|len
operator|+
name|pad
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|string_length
operator|=
name|len
expr_stmt|;
name|strcpy
argument_list|(
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyright
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|som_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|section
operator|->
name|_raw_size
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|som_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
comment|/* Set up fixed parts of the file, space, and subspace headers. 	 Notify the world that output has begun.  */
name|som_prep_headers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
comment|/* Start writing the object file.  This include all the string 	 tables, fixup streams, and other portions of the object file.  */
name|som_begin_writing
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Only write subspaces which have "real" contents (eg. the contents      are not generated at run time by the OS).  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
operator|||
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|true
return|;
comment|/* Seek to the proper offset within the object file and write the      data.  */
name|offset
operator|+=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|som_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
comment|/* Allow any architecture to be supported by the SOM backend */
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|som_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|som_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
decl_stmt|;
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"som_sizeof_headers unimplemented"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the single-character symbol type corresponding to    SOM section S, or '?' for an unknown SOM section.  */
end_comment

begin_function
specifier|static
name|char
name|som_section_type
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|const
name|struct
name|section_to_type
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|stt
index|[
literal|0
index|]
init|;
name|t
operator|->
name|section
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|section
argument_list|)
condition|)
return|return
name|t
operator|->
name|type
return|;
return|return
literal|'?'
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|som_decode_symclass
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'C'
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'U'
return|;
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'I'
return|;
if|if
condition|(
operator|!
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
operator|)
condition|)
return|return
literal|'?'
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|||
operator|(
name|som_symbol_data
argument_list|(
name|symbol
argument_list|)
operator|!=
name|NULL
operator|&&
name|som_symbol_data
argument_list|(
name|symbol
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_ABSOLUTE
operator|)
condition|)
name|c
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
condition|)
name|c
operator|=
name|som_section_type
argument_list|(
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
return|return
literal|'?'
return|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Return information about SOM symbol SYMBOL in RET.  */
end_comment

begin_function
specifier|static
name|void
name|som_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|ret
operator|->
name|type
operator|=
name|som_decode_symclass
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|type
operator|!=
literal|'U'
condition|)
name|ret
operator|->
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
expr_stmt|;
else|else
name|ret
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of symbols in the archive symbol table.  Necessary    so that we can allocate space for all the carsyms at once.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_count_ar_symbols
parameter_list|(
name|abfd
parameter_list|,
name|lst_header
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|lst_header
modifier|*
name|lst_header
decl_stmt|;
name|symindex
modifier|*
name|count
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
name|file_ptr
name|lst_filepos
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
decl_stmt|;
name|hash_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|lst_header
operator|->
name|hash_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|==
name|NULL
operator|&&
name|lst_header
operator|->
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Don't forget to initialize the counter!  */
operator|*
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Read in the hash table.  The has table is an array of 32bit file offsets      which point to the hash chains.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|hash_table
argument_list|,
name|lst_header
operator|->
name|hash_size
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
name|lst_header
operator|->
name|hash_size
operator|*
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk each chain counting the number of symbols found on that particular      chain.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lst_header
operator|->
name|hash_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|lst_symbol_record
name|lst_symbol
decl_stmt|;
comment|/* An empty chain has zero as it's file offset.  */
if|if
condition|(
name|hash_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Seek to the first symbol in this hash chain.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|hash_table
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in this symbol and update the counter.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lst_symbol
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
comment|/* Now iterate through the rest of the symbols on this chain.  */
while|while
condition|(
name|lst_symbol
operator|.
name|next_entry
condition|)
block|{
comment|/* Seek to the next symbol.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_symbol
operator|.
name|next_entry
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read the symbol in and update the counter.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lst_symbol
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Fill in the canonical archive symbols (SYMS) from the archive described    by ABFD and LST_HEADER.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_fill_in_ar_symbols
parameter_list|(
name|abfd
parameter_list|,
name|lst_header
parameter_list|,
name|syms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|lst_header
modifier|*
name|lst_header
decl_stmt|;
name|carsym
modifier|*
modifier|*
name|syms
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|carsym
modifier|*
name|set
init|=
name|syms
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
name|struct
name|som_entry
modifier|*
name|som_dict
init|=
name|NULL
decl_stmt|;
name|file_ptr
name|lst_filepos
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
decl_stmt|;
name|hash_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|lst_header
operator|->
name|hash_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|==
name|NULL
operator|&&
name|lst_header
operator|->
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|som_dict
operator|=
operator|(
expr|struct
name|som_entry
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|lst_header
operator|->
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|==
name|NULL
operator|&&
name|lst_header
operator|->
name|module_count
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in the hash table.  The has table is an array of 32bit file offsets      which point to the hash chains.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|hash_table
argument_list|,
name|lst_header
operator|->
name|hash_size
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
name|lst_header
operator|->
name|hash_size
operator|*
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Seek to and read in the SOM dictionary.  We will need this to fill      in the carsym's filepos field.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_header
operator|->
name|dir_loc
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|som_dict
argument_list|,
name|lst_header
operator|->
name|module_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|lst_header
operator|->
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk each chain filling in the carsyms as we go along.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lst_header
operator|->
name|hash_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|lst_symbol_record
name|lst_symbol
decl_stmt|;
comment|/* An empty chain has zero as it's file offset.  */
if|if
condition|(
name|hash_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Seek to and read the first symbol on the chain.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|hash_table
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lst_symbol
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Get the name of the symbol, first get the length which is stored 	 as a 32bit integer just before the symbol.  	 One might ask why we don't just read in the entire string table 	 and index into it.  Well, according to the SOM ABI the string 	 index can point *anywhere* in the archive to save space, so just 	 using the string table would not be safe.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_header
operator|->
name|string_loc
operator|+
name|lst_symbol
operator|.
name|name
operator|.
name|n_strx
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Allocate space for the name and null terminate it too.  */
name|set
operator|->
name|name
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|name
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
name|set
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|error_return
goto|;
name|set
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Fill in the file offset.  Note that the "location" field points 	 to the SOM itself, not the ar_hdr in front of it.  */
name|set
operator|->
name|file_offset
operator|=
name|som_dict
index|[
name|lst_symbol
operator|.
name|som_index
index|]
operator|.
name|location
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* Go to the next symbol.  */
name|set
operator|++
expr_stmt|;
comment|/* Iterate through the rest of the chain.  */
while|while
condition|(
name|lst_symbol
operator|.
name|next_entry
condition|)
block|{
comment|/* Seek to the next symbol and read it in.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_symbol
operator|.
name|next_entry
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lst_symbol
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Seek to the name length& string and read them in.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_header
operator|->
name|string_loc
operator|+
name|lst_symbol
operator|.
name|name
operator|.
name|n_strx
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Allocate space for the name and null terminate it too.  */
name|set
operator|->
name|name
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|name
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
name|set
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|error_return
goto|;
name|set
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Fill in the file offset.  Note that the "location" field points 	     to the SOM itself, not the ar_hdr in front of it.  */
name|set
operator|->
name|file_offset
operator|=
name|som_dict
index|[
name|lst_symbol
operator|.
name|som_index
index|]
operator|.
name|location
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* Go on to the next symbol.  */
name|set
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we haven't died by now, then we successfully read the entire       archive symbol table.  */
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read in the LST from the archive.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|lst_header
name|lst_header
decl_stmt|;
name|struct
name|ar_hdr
name|ar_header
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
decl_stmt|;
comment|/* Special cases.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* For archives without .o files there is no symbol table.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Read in and sanity check the archive header.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|ar_header
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ar_header
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* How big is the archive symbol table entry?  */
name|errno
operator|=
literal|0
expr_stmt|;
name|parsed_size
operator|=
name|strtol
argument_list|(
name|ar_header
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Save off the file offset of the first real user data.  */
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|+
name|parsed_size
expr_stmt|;
comment|/* Read in the library symbol table.  We'll make heavy use of this      in just a minute.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lst_header
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Sanity check.  */
if|if
condition|(
name|lst_header
operator|.
name|a_magic
operator|!=
name|LIBMAGIC
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Count the number of symbols in the library symbol table.  */
if|if
condition|(
name|som_bfd_count_ar_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|lst_header
argument_list|,
operator|&
name|ardata
operator|->
name|symdef_count
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Get back to the start of the library symbol table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ardata
operator|->
name|first_file_filepos
operator|-
name|parsed_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Initializae the cache and allocate space for the library symbols.  */
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|ardata
operator|->
name|symdef_count
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ardata
operator|->
name|symdefs
condition|)
return|return
name|false
return|;
comment|/* Now fill in the canonical archive symbols.  */
if|if
condition|(
name|som_bfd_fill_in_ar_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|lst_header
argument_list|,
operator|&
name|ardata
operator|->
name|symdefs
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Seek back to the "first" file in the archive.  Note the "first"      file may be the extended name table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ardata
operator|->
name|first_file_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Notify the generic archive code that we have a symbol map.  */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Begin preparing to write a SOM library symbol table.     As part of the prep work we need to determine the number of symbols    and the size of the associated string section.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_prep_for_ar_write
parameter_list|(
name|abfd
parameter_list|,
name|num_syms
parameter_list|,
name|stringsize
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
modifier|*
name|num_syms
decl_stmt|,
decl|*
name|stringsize
decl_stmt|;
end_function

begin_block
block|{
name|bfd
modifier|*
name|curr_bfd
init|=
name|abfd
operator|->
name|archive_head
decl_stmt|;
comment|/* Some initialization.  */
operator|*
name|num_syms
operator|=
literal|0
expr_stmt|;
operator|*
name|stringsize
operator|=
literal|0
expr_stmt|;
comment|/* Iterate over each BFD within this archive.  */
while|while
condition|(
name|curr_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|curr_count
decl_stmt|,
name|i
decl_stmt|;
name|som_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Don't bother for non-SOM objects.  */
if|if
condition|(
name|curr_bfd
operator|->
name|format
operator|!=
name|bfd_object
operator|||
name|curr_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
block|{
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure the symbol table has been read, then snag a pointer 	 to it.  It's a little slimey to grab the symbols via obj_som_symtab, 	 but doing so avoids allocating lots of extra memory.  */
if|if
condition|(
name|som_slurp_symbol_table
argument_list|(
name|curr_bfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|sym
operator|=
name|obj_som_symtab
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
name|curr_count
operator|=
name|bfd_get_symcount
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
comment|/* Examine each symbol to determine if it belongs in the 	 library symbol table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
name|struct
name|som_misc_symbol_info
name|info
decl_stmt|;
comment|/* Derive SOM information from the BFD symbol.  */
name|som_bfd_derive_misc_symbol_info
argument_list|(
name|curr_bfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Should we include this symbol?  */
if|if
condition|(
name|info
operator|.
name|symbol_type
operator|==
name|ST_NULL
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_SYM_EXT
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_ARG_EXT
condition|)
continue|continue;
comment|/* Only global symbols and unsatisfied commons.  */
if|if
condition|(
name|info
operator|.
name|symbol_scope
operator|!=
name|SS_UNIVERSAL
operator|&&
name|info
operator|.
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
continue|continue;
comment|/* Do no include undefined symbols.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
continue|continue;
comment|/* Bump the various counters, being careful to honor 	     alignment considerations in the string table.  */
operator|(
operator|*
name|num_syms
operator|)
operator|++
expr_stmt|;
operator|*
name|stringsize
operator|=
operator|*
name|stringsize
operator|+
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|+
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|stringsize
operator|%
literal|4
condition|)
operator|(
operator|*
name|stringsize
operator|)
operator|++
expr_stmt|;
block|}
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|next
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Hash a symbol name based on the hashing algorithm presented in the    SOM ABI.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|som_bfd_ar_symbol_hash
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|symbol
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* Names with length 1 are special.  */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
literal|0x1000100
operator||
operator|(
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
name|symbol
operator|->
name|name
index|[
literal|0
index|]
return|;
return|return
operator|(
operator|(
name|len
operator|&
literal|0x7f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|symbol
operator|->
name|name
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|symbol
operator|->
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|symbol
operator|->
name|name
index|[
name|len
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|CONST
name|char
modifier|*
name|normalize
parameter_list|(
name|file
parameter_list|)
name|CONST
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|filename
operator|++
expr_stmt|;
else|else
name|filename
operator|=
name|file
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Do the bulk of the work required to write the SOM library    symbol table.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_ar_write_symbol_stuff
parameter_list|(
name|abfd
parameter_list|,
name|nsyms
parameter_list|,
name|string_size
parameter_list|,
name|lst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|nsyms
decl_stmt|,
name|string_size
decl_stmt|;
name|struct
name|lst_header
name|lst
decl_stmt|;
block|{
name|file_ptr
name|lst_filepos
decl_stmt|;
name|char
modifier|*
name|strings
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|lst_symbol_record
modifier|*
name|lst_syms
init|=
name|NULL
decl_stmt|,
modifier|*
name|curr_lst_sym
decl_stmt|;
name|bfd
modifier|*
name|curr_bfd
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
name|struct
name|som_entry
modifier|*
name|som_dict
init|=
name|NULL
decl_stmt|;
name|struct
name|lst_symbol_record
modifier|*
modifier|*
name|last_hash_entry
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|curr_som_offset
decl_stmt|,
name|som_index
decl_stmt|,
name|extended_name_length
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|maxname
init|=
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
decl_stmt|;
name|hash_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|lst
operator|.
name|hash_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|==
name|NULL
operator|&&
name|lst
operator|.
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|som_dict
operator|=
operator|(
expr|struct
name|som_entry
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|==
name|NULL
operator|&&
name|lst
operator|.
name|module_count
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|last_hash_entry
operator|=
operator|(
operator|(
expr|struct
name|lst_symbol_record
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|lst
operator|.
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|last_hash_entry
operator|==
name|NULL
operator|&&
name|lst
operator|.
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Lots of fields are file positions relative to the start      of the lst record.  So save its location.  */
name|lst_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
comment|/* Some initialization.  */
name|memset
argument_list|(
name|hash_table
argument_list|,
literal|0
argument_list|,
literal|4
operator|*
name|lst
operator|.
name|hash_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|som_dict
argument_list|,
literal|0
argument_list|,
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|last_hash_entry
argument_list|,
literal|0
argument_list|,
name|lst
operator|.
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Symbols have som_index fields, so we have to keep track of the      index of each SOM in the archive.       The SOM dictionary has (among other things) the absolute file      position for the SOM which a particular dictionary entry      describes.  We have to compute that information as we iterate      through the SOMs/symbols.  */
name|som_index
operator|=
literal|0
expr_stmt|;
name|curr_som_offset
operator|=
literal|8
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|lst
operator|.
name|file_end
expr_stmt|;
comment|/* Yow!  We have to know the size of the extended name table      too.  */
for|for
control|(
name|curr_bfd
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|curr_bfd
operator|!=
name|NULL
condition|;
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|next
control|)
block|{
name|CONST
name|char
modifier|*
name|normal
init|=
name|normalize
argument_list|(
name|curr_bfd
operator|->
name|filename
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|thislen
decl_stmt|;
if|if
condition|(
operator|!
name|normal
condition|)
return|return
name|false
return|;
name|thislen
operator|=
name|strlen
argument_list|(
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
name|extended_name_length
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Make room for the archive header and the contents of the      extended string table.  */
if|if
condition|(
name|extended_name_length
condition|)
name|curr_som_offset
operator|+=
name|extended_name_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* Make sure we're properly aligned.  */
name|curr_som_offset
operator|=
operator|(
name|curr_som_offset
operator|+
literal|0x1
operator|)
operator|&
operator|~
literal|0x1
expr_stmt|;
comment|/* FIXME should be done with buffers just like everything else... */
name|lst_syms
operator|=
name|bfd_malloc
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lst_syms
operator|==
name|NULL
operator|&&
name|nsyms
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|strings
operator|=
name|bfd_malloc
argument_list|(
name|string_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
operator|&&
name|string_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|strings
expr_stmt|;
name|curr_lst_sym
operator|=
name|lst_syms
expr_stmt|;
name|curr_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
while|while
condition|(
name|curr_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|curr_count
decl_stmt|,
name|i
decl_stmt|;
name|som_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Don't bother for non-SOM objects.  */
if|if
condition|(
name|curr_bfd
operator|->
name|format
operator|!=
name|bfd_object
operator|||
name|curr_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
block|{
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure the symbol table has been read, then snag a pointer 	 to it.  It's a little slimey to grab the symbols via obj_som_symtab, 	 but doing so avoids allocating lots of extra memory.  */
if|if
condition|(
name|som_slurp_symbol_table
argument_list|(
name|curr_bfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
name|sym
operator|=
name|obj_som_symtab
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
name|curr_count
operator|=
name|bfd_get_symcount
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
name|struct
name|som_misc_symbol_info
name|info
decl_stmt|;
comment|/* Derive SOM information from the BFD symbol.  */
name|som_bfd_derive_misc_symbol_info
argument_list|(
name|curr_bfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Should we include this symbol?  */
if|if
condition|(
name|info
operator|.
name|symbol_type
operator|==
name|ST_NULL
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_SYM_EXT
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_ARG_EXT
condition|)
continue|continue;
comment|/* Only global symbols and unsatisfied commons.  */
if|if
condition|(
name|info
operator|.
name|symbol_scope
operator|!=
name|SS_UNIVERSAL
operator|&&
name|info
operator|.
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
continue|continue;
comment|/* Do no include undefined symbols.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
continue|continue;
comment|/* If this is the first symbol from this SOM, then update 	     the SOM dictionary too.  */
if|if
condition|(
name|som_dict
index|[
name|som_index
index|]
operator|.
name|location
operator|==
literal|0
condition|)
block|{
name|som_dict
index|[
name|som_index
index|]
operator|.
name|location
operator|=
name|curr_som_offset
expr_stmt|;
name|som_dict
index|[
name|som_index
index|]
operator|.
name|length
operator|=
name|arelt_size
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the lst symbol record.  */
name|curr_lst_sym
operator|->
name|hidden
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|secondary_def
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_type
operator|=
name|info
operator|.
name|symbol_type
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_scope
operator|=
name|info
operator|.
name|symbol_scope
expr_stmt|;
name|curr_lst_sym
operator|->
name|check_level
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|must_qualify
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|initially_frozen
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|memory_resident
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|is_common
operator|=
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|section
argument_list|)
expr_stmt|;
name|curr_lst_sym
operator|->
name|dup_common
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|xleast
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|arg_reloc
operator|=
name|info
operator|.
name|arg_reloc
expr_stmt|;
name|curr_lst_sym
operator|->
name|name
operator|.
name|n_strx
operator|=
name|p
operator|-
name|strings
operator|+
literal|4
expr_stmt|;
name|curr_lst_sym
operator|->
name|qualifier_name
operator|.
name|n_strx
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_info
operator|=
name|info
operator|.
name|symbol_info
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_value
operator|=
name|info
operator|.
name|symbol_value
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_descriptor
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|som_index
operator|=
name|som_index
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_key
operator|=
name|som_bfd_ar_symbol_hash
argument_list|(
operator|&
name|sym
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|curr_lst_sym
operator|->
name|next_entry
operator|=
literal|0
expr_stmt|;
comment|/* Insert into the hash table.  */
if|if
condition|(
name|hash_table
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
condition|)
block|{
name|struct
name|lst_symbol_record
modifier|*
name|tmp
decl_stmt|;
comment|/* There is already something at the head of this hash chain, 		 so tack this symbol onto the end of the chain.  */
name|tmp
operator|=
name|last_hash_entry
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
expr_stmt|;
name|tmp
operator|->
name|next_entry
operator|=
operator|(
name|curr_lst_sym
operator|-
name|lst_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
operator|+
name|lst
operator|.
name|hash_size
operator|*
literal|4
operator|+
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First entry in this hash chain.  */
name|hash_table
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
operator|=
operator|(
name|curr_lst_sym
operator|-
name|lst_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
operator|+
name|lst
operator|.
name|hash_size
operator|*
literal|4
operator|+
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
block|}
comment|/* Keep track of the last symbol we added to this chain so we can 	     easily update its next_entry pointer.  */
name|last_hash_entry
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
operator|=
name|curr_lst_sym
expr_stmt|;
comment|/* Update the string table.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|int
operator|)
name|p
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Head to the next symbol.  */
name|curr_lst_sym
operator|++
expr_stmt|;
block|}
comment|/* Keep track of where each SOM will finally reside; then look 	 at the next BFD.  */
name|curr_som_offset
operator|+=
name|arelt_size
argument_list|(
name|curr_bfd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* A particular object in the archive may have an odd length; the 	 linker requires objects begin on an even boundary.  So round 	 up the current offset as necessary.  */
name|curr_som_offset
operator|=
operator|(
name|curr_som_offset
operator|+
literal|0x1
operator|)
operator|&
operator|~
literal|0x1
expr_stmt|;
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|next
expr_stmt|;
name|som_index
operator|++
expr_stmt|;
block|}
comment|/* Now scribble out the hash table.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|hash_table
argument_list|,
name|lst
operator|.
name|hash_size
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
name|lst
operator|.
name|hash_size
operator|*
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Then the SOM dictionary.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|som_dict
argument_list|,
name|lst
operator|.
name|module_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The library symbols.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|lst_syms
argument_list|,
name|nsyms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* And finally the strings.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|strings
argument_list|,
name|string_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|string_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_hash_entry
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_hash_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|lst_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lst_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_hash_entry
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_hash_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|lst_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lst_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* SOM almost uses the SVR4 style extended name support, but not    quite.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_construct_extended_name_table
parameter_list|(
name|abfd
parameter_list|,
name|tabloc
parameter_list|,
name|tablen
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|tabloc
decl_stmt|;
name|bfd_size_type
modifier|*
name|tablen
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
block|{
operator|*
name|name
operator|=
literal|"//"
expr_stmt|;
return|return
name|_bfd_construct_extended_name_table
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|,
name|tabloc
argument_list|,
name|tablen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the LST for the archive.     You'll never believe this is really how armaps are handled in SOM...  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|som_write_armap
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|bfd
modifier|*
name|curr_bfd
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|lst_size
decl_stmt|,
name|nsyms
decl_stmt|,
name|stringsize
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|lst_header
name|lst
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
comment|/* We'll use this for the archive's date and mode later.  */
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Fudge factor.  */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_timestamp
operator|=
name|statbuf
operator|.
name|st_mtime
operator|+
literal|60
expr_stmt|;
comment|/* Account for the lst header first.  */
name|lst_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
comment|/* Start building the LST header.  */
comment|/* FIXME:  Do we need to examine each element to determine the      largest id number?  */
name|lst
operator|.
name|system_id
operator|=
name|CPU_PA_RISC1_0
expr_stmt|;
name|lst
operator|.
name|a_magic
operator|=
name|LIBMAGIC
expr_stmt|;
name|lst
operator|.
name|version_id
operator|=
name|VERSION_ID
expr_stmt|;
name|lst
operator|.
name|file_time
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|file_time
operator|.
name|nanosecs
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|hash_loc
operator|=
name|lst_size
expr_stmt|;
name|lst
operator|.
name|hash_size
operator|=
name|SOM_LST_HASH_SIZE
expr_stmt|;
comment|/* Hash table is a SOM_LST_HASH_SIZE 32bit offsets.  */
name|lst_size
operator|+=
literal|4
operator|*
name|SOM_LST_HASH_SIZE
expr_stmt|;
comment|/* We need to count the number of SOMs in this archive.  */
name|curr_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|lst
operator|.
name|module_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curr_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Only true SOM objects count.  */
if|if
condition|(
name|curr_bfd
operator|->
name|format
operator|==
name|bfd_object
operator|&&
name|curr_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_som_flavour
condition|)
name|lst
operator|.
name|module_count
operator|++
expr_stmt|;
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|next
expr_stmt|;
block|}
name|lst
operator|.
name|module_limit
operator|=
name|lst
operator|.
name|module_count
expr_stmt|;
name|lst
operator|.
name|dir_loc
operator|=
name|lst_size
expr_stmt|;
name|lst_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
operator|*
name|lst
operator|.
name|module_count
expr_stmt|;
comment|/* We don't support import/export tables, auxiliary headers,      or free lists yet.  Make the linker work a little harder      to make our life easier.  */
name|lst
operator|.
name|export_loc
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|export_count
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|import_loc
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|aux_loc
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|aux_size
operator|=
literal|0
expr_stmt|;
comment|/* Count how many symbols we will have on the hash chains and the      size of the associated string table.  */
if|if
condition|(
name|som_bfd_prep_for_ar_write
argument_list|(
name|abfd
argument_list|,
operator|&
name|nsyms
argument_list|,
operator|&
name|stringsize
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|lst_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
operator|*
name|nsyms
expr_stmt|;
comment|/* For the string table.  One day we might actually use this info      to avoid small seeks/reads when reading archives.  */
name|lst
operator|.
name|string_loc
operator|=
name|lst_size
expr_stmt|;
name|lst
operator|.
name|string_size
operator|=
name|stringsize
expr_stmt|;
name|lst_size
operator|+=
name|stringsize
expr_stmt|;
comment|/* SOM ABI says this must be zero.  */
name|lst
operator|.
name|free_list
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|file_end
operator|=
name|lst_size
expr_stmt|;
comment|/* Compute the checksum.  Must happen after the entire lst header      has filled in.  */
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|lst
expr_stmt|;
name|lst
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|lst
operator|.
name|checksum
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|"/               "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_timestamp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_uid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_gid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_mode
argument_list|,
literal|"%-8o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|statbuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|lst_size
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\012'
expr_stmt|;
comment|/* Turn any nulls into spaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* Scribble out the ar header.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now scribble out the lst header.  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lst
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Build and write the armap.  */
if|if
condition|(
name|som_bfd_ar_write_symbol_stuff
argument_list|(
name|abfd
argument_list|,
name|nsyms
argument_list|,
name|stringsize
argument_list|,
name|lst
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* Done.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Free all information we have cached for this BFD.  We can always    read it again later if we need it.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_free_cached_info
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
return|return
name|true
return|;
define|#
directive|define
name|FREE
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) { free (x); x = NULL; }
comment|/* Free the native string and symbol tables.  */
name|FREE
argument_list|(
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* Free the native relocations.  */
name|o
operator|->
name|reloc_count
operator|=
operator|-
literal|1
expr_stmt|;
name|FREE
argument_list|(
name|som_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|reloc_stream
argument_list|)
expr_stmt|;
comment|/* Free the generic relocations.  */
name|FREE
argument_list|(
name|o
operator|->
name|relocation
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|FREE
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* End of miscellaneous support functions. */
end_comment

begin_comment
comment|/* Linker support functions.  */
end_comment

begin_function
specifier|static
name|boolean
name|som_bfd_link_split_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
return|return
operator|(
name|som_is_subspace
argument_list|(
name|sec
argument_list|)
operator|&&
name|sec
operator|->
name|_raw_size
operator|>
literal|240000
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|som_close_and_cleanup
value|som_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|som_read_ar_hdr
value|_bfd_generic_read_ar_hdr
end_define

begin_define
define|#
directive|define
name|som_openr_next_archived_file
value|bfd_generic_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|som_get_elt_at_index
value|_bfd_generic_get_elt_at_index
end_define

begin_define
define|#
directive|define
name|som_generic_stat_arch_elt
value|bfd_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|som_truncate_arname
value|bfd_bsd_truncate_arname
end_define

begin_define
define|#
directive|define
name|som_slurp_extended_name_table
value|_bfd_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|som_update_armap_timestamp
value|bfd_true
end_define

begin_define
define|#
directive|define
name|som_bfd_print_private_bfd_data
value|_bfd_generic_bfd_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|som_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|som_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|som_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|som_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|som_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|som_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|som_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|som_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|som_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|som_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|som_vec
init|=
block|{
literal|"som"
block|,
comment|/* name */
name|bfd_target_som_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator||
name|DYNAMIC
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
comment|/* leading_symbol_char: is the first char of a user symbol    predictable, and if so what is it */
literal|0
block|,
literal|'/'
block|,
comment|/* ar_pad_char */
literal|14
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|som_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|som_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|som_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
undef|#
directive|undef
name|som
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HOST_HPPAHPUX || HOST_HPPABSD || HOST_HPPAOSF */
end_comment

end_unit

