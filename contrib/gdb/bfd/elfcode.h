begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.     Written by Fred Fish @ Cygnus Support, from information published    in "UNIX System V Release 4, Programmers Guide: ANSI C and    Programming Support Tools".  Sufficient support for gdb.     Rewritten by Mark Eichin @ Cygnus Support, from information    published in "System V Application Binary Interface", chapters 4    and 5, as well as the various "Processor Supplement" documents    derived from it. Added support for assembler and other object file    utilities.  Further work done by Ken Raeburn (Cygnus Support), Michael    Meissner (Open Software Foundation), and Peter Hoogenboom (University    of Utah) to finish and extend this.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Problems and other issues to resolve.     (1)	BFD expects there to be some fixed number of "sections" in         the object file.  I.E. there is a "section_count" variable in the 	bfd structure which contains the number of sections.  However, ELF 	supports multiple "views" of a file.  In particular, with current 	implementations, executable files typically have two tables, a 	program header table and a section header table, both of which 	partition the executable.  	In ELF-speak, the "linking view" of the file uses the section header 	table to access "sections" within the file, and the "execution view" 	uses the program header table to access "segments" within the file. 	"Segments" typically may contain all the data from one or more 	"sections".  	Note that the section header table is optional in ELF executables, 	but it is this information that is most useful to gdb.  If the 	section header table is missing, then gdb should probably try 	to make do with the program header table.  (FIXME)     (2)  The code in this file is compiled twice, once in 32-bit mode and 	once in 64-bit mode.  More of it should be made size-independent 	and moved into elf.c.     (3)	ELF section symbols are handled rather sloppily now.  This should 	be cleaned up, and ELF section symbols reconciled with BFD section 	symbols.     (4)  We need a published spec for 64-bit ELF.  We've got some stuff here 	that we're using for SPARC V9 64-bit chips, but don't assume that 	it's cast in stone.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For strrchr and friends */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_comment
comment|/* Renaming structures, typedefs, macros and functions to be size-specific.  */
end_comment

begin_define
define|#
directive|define
name|Elf_External_Ehdr
value|NAME(Elf,External_Ehdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Sym
value|NAME(Elf,External_Sym)
end_define

begin_define
define|#
directive|define
name|Elf_External_Shdr
value|NAME(Elf,External_Shdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Phdr
value|NAME(Elf,External_Phdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Rel
value|NAME(Elf,External_Rel)
end_define

begin_define
define|#
directive|define
name|Elf_External_Rela
value|NAME(Elf,External_Rela)
end_define

begin_define
define|#
directive|define
name|Elf_External_Dyn
value|NAME(Elf,External_Dyn)
end_define

begin_define
define|#
directive|define
name|elf_core_file_failing_command
value|NAME(bfd_elf,core_file_failing_command)
end_define

begin_define
define|#
directive|define
name|elf_core_file_failing_signal
value|NAME(bfd_elf,core_file_failing_signal)
end_define

begin_define
define|#
directive|define
name|elf_core_file_matches_executable_p
define|\
value|NAME(bfd_elf,core_file_matches_executable_p)
end_define

begin_define
define|#
directive|define
name|elf_object_p
value|NAME(bfd_elf,object_p)
end_define

begin_define
define|#
directive|define
name|elf_core_file_p
value|NAME(bfd_elf,core_file_p)
end_define

begin_define
define|#
directive|define
name|elf_get_symtab_upper_bound
value|NAME(bfd_elf,get_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_get_dynamic_symtab_upper_bound
define|\
value|NAME(bfd_elf,get_dynamic_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloc_in
value|NAME(bfd_elf,swap_reloc_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloca_in
value|NAME(bfd_elf,swap_reloca_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloc_out
value|NAME(bfd_elf,swap_reloc_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloca_out
value|NAME(bfd_elf,swap_reloca_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_symbol_in
value|NAME(bfd_elf,swap_symbol_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_symbol_out
value|NAME(bfd_elf,swap_symbol_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_phdr_in
value|NAME(bfd_elf,swap_phdr_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_phdr_out
value|NAME(bfd_elf,swap_phdr_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_dyn_in
value|NAME(bfd_elf,swap_dyn_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_dyn_out
value|NAME(bfd_elf,swap_dyn_out)
end_define

begin_define
define|#
directive|define
name|elf_get_reloc_upper_bound
value|NAME(bfd_elf,get_reloc_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_reloc
value|NAME(bfd_elf,canonicalize_reloc)
end_define

begin_define
define|#
directive|define
name|elf_get_symtab
value|NAME(bfd_elf,get_symtab)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_dynamic_symtab
define|\
value|NAME(bfd_elf,canonicalize_dynamic_symtab)
end_define

begin_define
define|#
directive|define
name|elf_make_empty_symbol
value|NAME(bfd_elf,make_empty_symbol)
end_define

begin_define
define|#
directive|define
name|elf_get_symbol_info
value|NAME(bfd_elf,get_symbol_info)
end_define

begin_define
define|#
directive|define
name|elf_get_lineno
value|NAME(bfd_elf,get_lineno)
end_define

begin_define
define|#
directive|define
name|elf_set_arch_mach
value|NAME(bfd_elf,set_arch_mach)
end_define

begin_define
define|#
directive|define
name|elf_find_nearest_line
value|NAME(bfd_elf,find_nearest_line)
end_define

begin_define
define|#
directive|define
name|elf_sizeof_headers
value|NAME(bfd_elf,sizeof_headers)
end_define

begin_define
define|#
directive|define
name|elf_set_section_contents
value|NAME(bfd_elf,set_section_contents)
end_define

begin_define
define|#
directive|define
name|elf_no_info_to_howto
value|NAME(bfd_elf,no_info_to_howto)
end_define

begin_define
define|#
directive|define
name|elf_no_info_to_howto_rel
value|NAME(bfd_elf,no_info_to_howto_rel)
end_define

begin_define
define|#
directive|define
name|elf_find_section
value|NAME(bfd_elf,find_section)
end_define

begin_define
define|#
directive|define
name|elf_bfd_link_add_symbols
value|NAME(bfd_elf,bfd_link_add_symbols)
end_define

begin_define
define|#
directive|define
name|elf_add_dynamic_entry
value|NAME(bfd_elf,add_dynamic_entry)
end_define

begin_define
define|#
directive|define
name|elf_link_create_dynamic_sections
define|\
value|NAME(bfd_elf,link_create_dynamic_sections)
end_define

begin_define
define|#
directive|define
name|elf_link_record_dynamic_symbol
value|_bfd_elf_link_record_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_bfd_final_link
value|NAME(bfd_elf,bfd_final_link)
end_define

begin_define
define|#
directive|define
name|elf_create_pointer_linker_section
value|NAME(bfd_elf,create_pointer_linker_section)
end_define

begin_define
define|#
directive|define
name|elf_finish_pointer_linker_section
value|NAME(bfd_elf,finish_pointer_linker_section)
end_define

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|ELF64_R_INFO(X,Y)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELFCLASS
value|ELFCLASS64
end_define

begin_define
define|#
directive|define
name|FILE_ALIGN
value|8
end_define

begin_define
define|#
directive|define
name|LOG_FILE_ALIGN
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|ELF32_R_INFO(X,Y)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELFCLASS
value|ELFCLASS32
end_define

begin_define
define|#
directive|define
name|FILE_ALIGN
value|4
end_define

begin_define
define|#
directive|define
name|LOG_FILE_ALIGN
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations of static functions */
end_comment

begin_define
define|#
directive|define
name|elf_stringtab_init
value|_bfd_elf_stringtab_init
end_define

begin_decl_stmt
specifier|extern
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_elf_stringtab_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|section_from_elf_index
value|bfd_section_from_elf_index
end_define

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_section_from_phdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|elf_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_bfd_elf_symbol_from_bfd_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|validate_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
name|shindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|elf_debug_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_debug_file
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Ehdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|elf_symbol_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Structure swapping routines */
end_comment

begin_comment
comment|/* Should perhaps use put_offset, put_word, etc.  For now, the two versions    can be handled by explicitly specifying 32 bits or "the long type".  */
end_comment

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|put_word
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|get_word
value|bfd_h_get_64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|put_word
value|bfd_h_put_32
end_define

begin_define
define|#
directive|define
name|get_word
value|bfd_h_get_32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate an ELF symbol in external format into an ELF symbol in internal    format. */
end_comment

begin_function
name|void
name|elf_swap_symbol_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|st_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_value
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_size
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_info
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_shndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF symbol in internal format into an ELF symbol in external    format. */
end_comment

begin_function
name|void
name|elf_swap_symbol_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|cdst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|src
decl_stmt|;
name|PTR
name|cdst
decl_stmt|;
block|{
name|Elf_External_Sym
modifier|*
name|dst
init|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|cdst
decl_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_name
argument_list|,
name|dst
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_value
argument_list|,
name|dst
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_size
argument_list|,
name|dst
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_info
argument_list|,
name|dst
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_other
argument_list|,
name|dst
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_shndx
argument_list|,
name|dst
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF file header in external format into an ELF file header in    internal format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_ehdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Ehdr
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|dst
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_type
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_machine
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_version
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_entry
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phoff
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shoff
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_ehsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phentsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shentsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shstrndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF file header in internal format into an ELF file header in    external format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_ehdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|src
decl_stmt|;
name|Elf_External_Ehdr
modifier|*
name|dst
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_type
argument_list|,
name|dst
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_machine
argument_list|,
name|dst
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_version
argument_list|,
name|dst
operator|->
name|e_version
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|,
name|dst
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phoff
argument_list|,
name|dst
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shoff
argument_list|,
name|dst
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_flags
argument_list|,
name|dst
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_ehsize
argument_list|,
name|dst
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phentsize
argument_list|,
name|dst
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phnum
argument_list|,
name|dst
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shentsize
argument_list|,
name|dst
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shnum
argument_list|,
name|dst
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shstrndx
argument_list|,
name|dst
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF section header table entry in external format into an    ELF section header table entry in internal format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_shdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Shdr
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|sh_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_flags
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addr
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_size
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_link
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addralign
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_entsize
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|bfd_section
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF section header table entry in internal format into an    ELF section header table entry in external format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_shdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|src
decl_stmt|;
name|Elf_External_Shdr
modifier|*
name|dst
decl_stmt|;
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_name
argument_list|,
name|dst
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_type
argument_list|,
name|dst
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_flags
argument_list|,
name|dst
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addr
argument_list|,
name|dst
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_offset
argument_list|,
name|dst
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_size
argument_list|,
name|dst
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_link
argument_list|,
name|dst
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_info
argument_list|,
name|dst
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addralign
argument_list|,
name|dst
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_entsize
argument_list|,
name|dst
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF program header table entry in external format into an    ELF program header table entry in internal format. */
end_comment

begin_function
name|void
name|elf_swap_phdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Phdr
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|p_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_vaddr
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_paddr
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_filesz
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_memsz
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_align
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_swap_phdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|src
decl_stmt|;
name|Elf_External_Phdr
modifier|*
name|dst
decl_stmt|;
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_type
argument_list|,
name|dst
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_offset
argument_list|,
name|dst
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_vaddr
argument_list|,
name|dst
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_paddr
argument_list|,
name|dst
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_filesz
argument_list|,
name|dst
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_memsz
argument_list|,
name|dst
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_flags
argument_list|,
name|dst
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_align
argument_list|,
name|dst
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF reloc from external format to internal format. */
end_comment

begin_function
name|INLINE
name|void
name|elf_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|r_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_reloca_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|r_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_addend
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF reloc from internal format to external format. */
end_comment

begin_function
name|INLINE
name|void
name|elf_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|src
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_reloca_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|src
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|,
name|dst
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_dyn_in
parameter_list|(
name|abfd
parameter_list|,
name|p
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|p
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|Elf_External_Dyn
modifier|*
name|src
init|=
operator|(
specifier|const
name|Elf_External_Dyn
operator|*
operator|)
name|p
decl_stmt|;
name|dst
operator|->
name|d_tag
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|dst
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_dyn_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Dyn
modifier|*
name|src
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dst
decl_stmt|;
block|{
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_tag
argument_list|,
name|dst
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|dst
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file reading */
end_comment

begin_comment
comment|/* Begin processing a given object.     First we validate the file by reading in the ELF header and checking    the magic number.  */
end_comment

begin_function
specifier|static
name|INLINE
name|boolean
name|elf_file_p
parameter_list|(
name|x_ehdrp
parameter_list|)
name|Elf_External_Ehdr
modifier|*
name|x_ehdrp
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|==
name|ELFMAG0
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|==
name|ELFMAG1
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|==
name|ELFMAG2
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|==
name|ELFMAG3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the file associated with ABFD matches the target vector    that ABFD points to.     Note that we may be called several times with the same ABFD, but different    target vectors, most of which will not match.  We have to avoid leaving    any side effects in ABFD, or any data it points to (like tdata), if the    file does not match the target vector.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
name|x_shdr
decl_stmt|;
comment|/* Section header table entry, external form */
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|NULL
decl_stmt|;
comment|/* Section header table, internal form */
name|unsigned
name|int
name|shindex
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
comment|/* Internal copy of section header stringtab */
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|preserved_tdata
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|new_tdata
init|=
name|NULL
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
goto|goto
name|got_wrong_format_error
goto|;
else|else
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      section header table (FIXME: See comments re sections at top of this      file). */
if|if
condition|(
operator|(
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|==
name|false
operator|)
operator|||
operator|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|)
operator|||
operator|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
operator|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Check that file's byte order matches xvec's */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
operator|!
name|bfd_header_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd.  */
name|new_tdata
operator|=
operator|(
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|==
name|NULL
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|new_tdata
expr_stmt|;
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If there is no section header table, we're hosed. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shoff
operator|==
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* As a simple sanity check, verify that the what BFD thinks is the      size of each section header table entry actually matches the size      recorded in the file. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt1
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt1
operator|)
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt2
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt2
operator|)
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|got_wrong_format_error
goto|;
block|}
block|}
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
elseif|else
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phnum
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|ebd
operator|->
name|arch
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
comment|/* Remember the entry point specified in the ELF file header. */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
comment|/* Allocate space for a copy of the section header table in      internal form, seek to the section header table in the file,      read it in, and convert it to internal form.  */
name|i_shdrp
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
argument_list|)
operator|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|i_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_shdrp
operator|||
operator|!
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
for|for
control|(
name|shindex
operator|=
literal|0
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_shdr
argument_list|,
sizeof|sizeof
name|x_shdr
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_swap_shdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_shdr
argument_list|,
name|i_shdrp
operator|+
name|shindex
argument_list|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|i_shdrp
operator|+
name|shindex
expr_stmt|;
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shstrndx
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Read in the program headers.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phnum
operator|==
literal|0
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|Elf_Internal_Phdr
modifier|*
name|i_phdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
operator|(
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|i_ehdrp
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|==
name|NULL
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
name|i_phdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|i_phdr
operator|++
control|)
block|{
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_phdr
argument_list|,
sizeof|sizeof
name|x_phdr
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|x_phdr
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read in the string table containing the names of the sections.  We      will need the base pointer to this table later. */
comment|/* We read this inline now, so that we don't have to go through      bfd_section_from_shdr with it (since this particular strtab is      used to find all of the ELF section names.) */
name|shstrtab
operator|=
name|bfd_elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shstrtab
condition|)
goto|goto
name|got_no_match
goto|;
comment|/* Once all of the section headers have been read and converted, we      can start processing them.  Note that the first section header is      a dummy placeholder entry, so we ignore it.  */
for|for
control|(
name|shindex
operator|=
literal|1
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Let the backend double check the format and override global      information.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_object_p
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_object_p
call|)
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
return|return
operator|(
name|abfd
operator|->
name|xvec
operator|)
return|;
name|got_wrong_format_error
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|got_no_match
goto|;
name|got_no_match
label|:
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
operator|&&
name|new_tdata
operator|->
name|elf_sect_ptr
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
operator|->
name|elf_sect_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|preserved_tdata
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file writing */
end_comment

begin_comment
comment|/* Try to convert a non-ELF reloc into an ELF one.  */
end_comment

begin_function
specifier|static
name|boolean
name|validate_reloc
parameter_list|(
name|abfd
parameter_list|,
name|areloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|areloc
decl_stmt|;
block|{
comment|/* Check whether we really have an ELF howto. */
if|if
condition|(
operator|(
operator|*
name|areloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* Alien reloc: Try to determine its type to replace it with an 	 equivalent ELF reloc. */
if|if
condition|(
name|areloc
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
switch|switch
condition|(
name|areloc
operator|->
name|howto
operator|->
name|bitsize
condition|)
block|{
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|code
operator|=
name|BFD_RELOC_12_PCREL
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|code
operator|=
name|BFD_RELOC_24_PCREL
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|areloc
operator|->
name|howto
operator|->
name|pcrel_offset
operator|!=
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
condition|)
name|areloc
operator|->
name|addend
operator|+=
name|areloc
operator|->
name|address
expr_stmt|;
else|else
name|areloc
operator|->
name|addend
operator|-=
name|areloc
operator|->
name|address
expr_stmt|;
comment|/* addend is unsigned!! */
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|areloc
operator|->
name|howto
operator|->
name|bitsize
condition|)
block|{
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|code
operator|=
name|BFD_RELOC_14
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|26
case|:
name|code
operator|=
name|BFD_RELOC_26
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|howto
condition|)
name|areloc
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
return|return
name|true
return|;
name|fail
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: unsupported relocation type %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|areloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Write out the relocs.  */
end_comment

begin_function
specifier|static
name|void
name|write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|boolean
modifier|*
name|failedp
init|=
operator|(
name|boolean
operator|*
operator|)
name|data
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|outbound_relocas
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|outbound_relocs
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|int
name|use_rela_p
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
init|=
literal|0
decl_stmt|;
name|int
name|last_sym_idx
init|=
literal|0
decl_stmt|;
comment|/* If we have already failed, don't do anything.  */
if|if
condition|(
operator|*
name|failedp
condition|)
return|return;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* The linker backend writes the relocs out itself, and sets the      reloc_count field to zero to inhibit writing them here.  Also,      sometimes the SEC_RELOC flag gets set even when there aren't any      relocs.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return;
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
name|rela_hdr
operator|->
name|sh_entsize
operator|*
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|rela_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rela_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
comment|/* orelocation has the data, reloc_count has the count... */
if|if
condition|(
name|use_rela_p
condition|)
block|{
name|outbound_relocas
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|dst_rela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src_rela
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|src_rela
operator|=
name|outbound_relocas
operator|+
name|idx
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	     file, and absolute for an executable file or shared library. 	     The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
else|else
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|dst_rela
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst_rela
argument_list|,
name|src_rela
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* REL relocations */
block|{
name|outbound_relocs
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rel
name|dst_rel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|src_rel
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|int
name|n
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|src_rel
operator|=
name|outbound_relocs
operator|+
name|idx
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	     file, and absolute for an executable file or shared library. 	     The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|dst_rel
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
else|else
name|dst_rel
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|dst_rel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst_rel
argument_list|,
name|src_rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|write_out_phdrs
parameter_list|(
name|abfd
parameter_list|,
name|phdr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|Elf_External_Phdr
name|extphdr
decl_stmt|;
name|elf_swap_phdr_out
argument_list|(
name|abfd
argument_list|,
name|phdr
argument_list|,
operator|&
name|extphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|extphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|phdr
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|write_shdrs_and_ehdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
modifier|*
name|x_shdrp
decl_stmt|;
comment|/* Section header table, external form */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|unsigned
name|int
name|count
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* swap the header before spitting it out... */
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elf_swap_ehdr_out
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
argument_list|,
operator|&
name|x_ehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* at this point we've concocted all the ELF sections... */
name|x_shdrp
operator|=
operator|(
name|Elf_External_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
operator|*
operator|(
name|i_ehdrp
operator|->
name|e_shnum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_shdrp
condition|)
return|return
name|false
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|elf_debug_section
argument_list|(
name|count
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elf_swap_shdr_out
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|,
name|x_shdrp
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|i_ehdrp
operator|->
name|e_shoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|x_shdrp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
argument_list|,
name|i_ehdrp
operator|->
name|e_shnum
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
operator|)
condition|)
return|return
name|false
return|;
comment|/* need to dump the string table too... */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|elf_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|,
name|symptrs
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symptrs
decl_stmt|;
comment|/* Buffer for generated bfd symbols */
name|boolean
name|dynamic
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|long
name|symcount
decl_stmt|;
comment|/* Number of external ELF symbols */
name|elf_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Pointer to current bfd symbol */
name|elf_symbol_type
modifier|*
name|symbase
decl_stmt|;
comment|/* Buffer for generated bfd symbols */
name|Elf_Internal_Sym
name|i_sym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|x_symp
init|=
name|NULL
decl_stmt|;
comment|/* Read each raw ELF symbol, converting from external ELF form to      internal ELF form, and then using the information to create a      canonical bfd symbol table entry.       Note that we allocate the initial bfd canonical symbol buffer      based on a one-to-one mapping of the ELF symbols to canonical      symbols.  We actually use all the ELF symbols, so there will be no      space left over at the end.  When we have all the symbols, we      build the caller's pointer vector. */
if|if
condition|(
name|dynamic
condition|)
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
else|else
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
name|sym
operator|=
name|symbase
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|long
name|i
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|symbase
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symbase
operator|==
operator|(
name|elf_symbol_type
operator|*
operator|)
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|sym
operator|=
name|symbase
expr_stmt|;
comment|/* Temporarily allocate room for the raw ELF symbols.  */
name|x_symp
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|x_symp
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|x_symp
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|symcount
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Skip first symbol, which is a null dummy.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|x_symp
operator|+
name|i
argument_list|,
operator|&
name|i_sym
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sym
operator|->
name|internal_elf_sym
argument_list|,
operator|&
name|i_sym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELF_KEEP_EXTSYM
name|memcpy
argument_list|(
operator|&
name|sym
operator|->
name|native_elf_sym
argument_list|,
name|x_symp
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|i_sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|i_sym
operator|.
name|st_value
expr_stmt|;
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|i_sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i_sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|symbol
operator|.
name|section
operator|==
name|NULL
condition|)
block|{
comment|/* This symbol is in a section for which we did not 		     create a BFD section.  Just use bfd_abs_section, 		     although it is wrong.  FIXME.  */
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* Elf puts the alignment into the `value' field, and 		 the size into the `size' field.  BFD wants to see the 		 size in the value field, and doesn't care (at the 		 moment) about the alignment.  */
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|i_sym
operator|.
name|st_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|ELF_ST_BIND
argument_list|(
name|i_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STB_LOCAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
break|break;
case|case
name|STB_GLOBAL
case|:
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|i_sym
operator|.
name|st_shndx
operator|!=
name|SHN_COMMON
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
break|break;
case|case
name|STB_WEAK
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|i_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_SECTION
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FILE
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FILE
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
break|break;
case|case
name|STT_OBJECT
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dynamic
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_DYNAMIC
expr_stmt|;
comment|/* Do some backend-specific processing on this symbol.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_backend_symbol_processing
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_symbol_processing
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
name|sym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Do some backend-specific processing on this symbol table.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_backend_symbol_table_processing
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_symbol_table_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|symbase
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
block|}
comment|/* We rely on the zalloc to clear out the final symbol entry.  */
name|symcount
operator|=
name|sym
operator|-
name|symbase
expr_stmt|;
comment|/* Fill in the user's symbol pointer vector if needed.  */
if|if
condition|(
name|symptrs
condition|)
block|{
name|long
name|l
init|=
name|symcount
decl_stmt|;
name|sym
operator|=
name|symbase
expr_stmt|;
while|while
condition|(
name|l
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|symptrs
operator|++
operator|=
operator|&
name|sym
operator|->
name|symbol
expr_stmt|;
name|sym
operator|++
expr_stmt|;
block|}
operator|*
name|symptrs
operator|=
literal|0
expr_stmt|;
comment|/* Final null pointer */
block|}
if|if
condition|(
name|x_symp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|x_symp
argument_list|)
expr_stmt|;
return|return
name|symcount
return|;
name|error_return
label|:
if|if
condition|(
name|x_symp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|x_symp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read in and swap the external relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
specifier|const
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
specifier|const
name|d
init|=
name|elf_section_data
argument_list|(
name|asect
argument_list|)
decl_stmt|;
name|PTR
name|allocated
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|relents
decl_stmt|;
name|arelent
modifier|*
name|relent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|entsize
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|!=
name|NULL
operator|||
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|rel_filepos
operator|==
name|d
operator|->
name|rel_hdr
operator|.
name|sh_offset
operator|&&
operator|(
name|asect
operator|->
name|reloc_count
operator|==
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|/
name|d
operator|->
name|rel_hdr
operator|.
name|sh_entsize
operator|)
argument_list|)
expr_stmt|;
name|allocated
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|allocated
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|native_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|allocated
expr_stmt|;
name|relents
operator|=
operator|(
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|relents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|entsize
operator|=
name|d
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|relent
operator|=
name|relents
init|;
name|i
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|relent
operator|++
operator|,
name|native_relocs
operator|+=
name|entsize
control|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf_Internal_Rel
name|rel
decl_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
condition|)
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
block|{
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
name|rel
operator|.
name|r_offset
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|rel
operator|.
name|r_info
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
else|else
block|{
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|ps
operator|=
name|symbols
operator|+
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|*
name|ps
expr_stmt|;
comment|/* Canonicalize ELF section symbols.  FIXME: Why?  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|ps
expr_stmt|;
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|s
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|relent
operator|->
name|addend
operator|=
name|rela
operator|.
name|r_addend
expr_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto
call|)
argument_list|(
name|abfd
argument_list|,
name|relent
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto_rel
call|)
argument_list|(
name|abfd
argument_list|,
name|relent
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
block|}
name|asect
operator|->
name|relocation
operator|=
name|relents
expr_stmt|;
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|elf_debug_section
parameter_list|(
name|num
parameter_list|,
name|hdr
parameter_list|)
name|int
name|num
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSection#%d '%s' 0x%.8lx\n"
argument_list|,
name|num
argument_list|,
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|?
name|hdr
operator|->
name|bfd_section
operator|->
name|name
else|:
literal|""
argument_list|,
operator|(
name|long
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_name
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_type
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_addr
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_offset
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_link
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_info
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_entsize   = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_debug_file
parameter_list|(
name|ehdrp
parameter_list|)
name|Elf_Internal_Ehdr
modifier|*
name|ehdrp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_entry      = 0x%.8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phoff      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phnum      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phentsize  = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shoff      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shnum      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shentsize  = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|elf_symbol_flags
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" local"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" global"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_FUNCTION
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_KEEP
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" keep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_KEEP_G
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" keep_g"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_WEAK
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" weak"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" section-sym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_OLD_COMMON
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" old-common"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_NOT_AT_END
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" not-at-end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_CONSTRUCTOR
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" constructor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_WARNING
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" warning"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_INDIRECT
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" indirect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_FILE
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DYNAMIC
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|BSF_LOCAL
operator||
name|BSF_GLOBAL
operator||
name|BSF_DEBUGGING
operator||
name|BSF_FUNCTION
operator||
name|BSF_KEEP
operator||
name|BSF_KEEP_G
operator||
name|BSF_WEAK
operator||
name|BSF_SECTION_SYM
operator||
name|BSF_OLD_COMMON
operator||
name|BSF_NOT_AT_END
operator||
name|BSF_CONSTRUCTOR
operator||
name|BSF_WARNING
operator||
name|BSF_INDIRECT
operator||
name|BSF_FILE
operator||
name|BSF_DYNAMIC
operator|)
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|" unknown-bits"
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_include
include|#
directive|include
file|"elfcore.h"
end_include

begin_include
include|#
directive|include
file|"elflink.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Size-dependent data and functions.  */
end_comment

begin_function_decl
specifier|const
name|struct
name|elf_size_info
name|NAME
parameter_list|(
name|_bfd_elf
parameter_list|,
name|size_info
parameter_list|)
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf_External_Ehdr
argument_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Phdr
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Shdr
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Rel
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Rela
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Sym
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Dyn
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Note
parameter_list|)
operator|,
function_decl|ARCH_SIZE
operator|,
function_decl|FILE_ALIGN
operator|,
function_decl|ELFCLASS
operator|,
function_decl|EV_CURRENT
operator|,
function_decl|write_out_phdrs
operator|,
function_decl|write_shdrs_and_ehdr
operator|,
function_decl|write_relocs
operator|,
function_decl|elf_swap_symbol_out
operator|,
function_decl|elf_slurp_reloc_table
operator|,
function_decl|elf_slurp_symbol_table
operator|,
function_decl|elf_swap_dyn_in
end_function_decl

unit|};
end_unit

