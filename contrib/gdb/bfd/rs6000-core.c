begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IBM RS/6000 "XCOFF" back-end for BFD.    Copyright (C) 1990, 1991, 1995 Free Software Foundation, Inc.    FIXME: Can someone provide a transliteration of this name into ASCII?    Using the following chars caused a compiler warning on HIUX (so I replaced    them with octal escapes), and isn't useful without an understanding of what    character set it is.    Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,       and John Gilmore.    Archive support from Damon A. Permezel.    Contributed by IBM Corporation and Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This port currently only handles reading object files, except when    compiled on an RS/6000 host.  -- no archive support, no core files.    In all cases, it does not support writing.     FIXMEmgo comments are left from Metin Ozisik's original port.     This is in a separate file from coff-rs6000.c, because it includes    system include files that conflict with coff/rs6000.h.   */
end_comment

begin_comment
comment|/* Internalcoff.h and coffcode.h modify themselves based on this flag.  */
end_comment

begin_define
define|#
directive|define
name|RS6000COFF_C
value|1
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE
end_ifdef

begin_comment
comment|/* AOUTHDR is defined by the above.  We need another defn of it, from the    system include files.  Punt the old one and get us a new name for the    typedef in the system include files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AOUTHDR
end_ifdef

begin_undef
undef|#
directive|undef
name|AOUTHDR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AOUTHDR
value|second_AOUTHDR
end_define

begin_undef
undef|#
directive|undef
name|SCNHDR
end_undef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*	Support for core file stuff.. 					    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_comment
comment|/* Number of special purpose registers supported by gdb.  This value    should match `tm.h' in gdb directory.  Clean this mess up and use    the macros in sys/reg.h.  FIXMEmgo. */
end_comment

begin_define
define|#
directive|define
name|NUM_OF_SPEC_REGS
value|7
end_define

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->hdr)
end_define

begin_define
define|#
directive|define
name|core_datasec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->data_section)
end_define

begin_define
define|#
directive|define
name|core_stacksec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->stack_section)
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->reg_section)
end_define

begin_define
define|#
directive|define
name|core_reg2sec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->reg2_section)
end_define

begin_comment
comment|/* AIX 4.1 Changed the names and locations of a few items in the core file,    this seems to be the quickest easiet way to deal with it.      Note however that encoding magic addresses (STACK_END_ADDR) is going    to be _very_ fragile.  But I don't see any easy way to get that info    right now.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CORE_VERSION_1
end_ifdef

begin_define
define|#
directive|define
name|CORE_DATA_SIZE_FIELD
value|c_u.U_dsize
end_define

begin_define
define|#
directive|define
name|CORE_COMM_FIELD
value|c_u.U_comm
end_define

begin_define
define|#
directive|define
name|SAVE_FIELD
value|c_mst
end_define

begin_define
define|#
directive|define
name|STACK_END_ADDR
value|0x2ff23000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CORE_DATA_SIZE_FIELD
value|c_u.u_dsize
end_define

begin_define
define|#
directive|define
name|CORE_COMM_FIELD
value|c_u.u_comm
end_define

begin_define
define|#
directive|define
name|SAVE_FIELD
value|c_u.u_save
end_define

begin_define
define|#
directive|define
name|STACK_END_ADDR
value|0x2ff80000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are stored in the bfd's tdata */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|core_dump
name|hdr
decl_stmt|;
comment|/* core file header */
name|asection
modifier|*
name|data_section
decl_stmt|,
modifier|*
name|stack_section
decl_stmt|,
modifier|*
name|reg_section
decl_stmt|,
comment|/* section for GPRs and special registers. */
modifier|*
name|reg2_section
decl_stmt|;
comment|/* section for FPRs. */
comment|/* This tells us where everything is mapped (shared libraries and so on).      GDB needs it.  */
name|asection
modifier|*
name|ldinfo_section
decl_stmt|;
define|#
directive|define
name|core_ldinfosec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData *)(bfd->tdata.any))->ldinfo_section)
block|}
name|Rs6kCorData
typedef|;
end_typedef

begin_comment
comment|/* Decide if a given bfd represents a `core' file or not. There really is no    magic number or anything like, in rs6000coff. */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|rs6000coff_core_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|core_dump
name|coredata
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tmpptr
decl_stmt|;
comment|/* Use bfd_xxx routines, rather than O/S primitives to read coredata. FIXMEmgo */
name|fd
operator|=
name|open
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|coredata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|core_dump
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|core_dump
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If the core file ulimit is too small, the system will first      omit the data segment, then omit the stack, then decline to      dump core altogether (as far as I know UBLOCK_VALID and LE_VALID      are always set) (this is based on experimentation on AIX 3.2).      Now, the thing is that GDB users will be surprised      if segments just silently don't appear (well, maybe they would      think to check "info files", I don't know), but we have no way of      returning warnings (as opposed to errors).       For the data segment, we have no choice but to keep going if it's      not there, since the default behavior is not to dump it (regardless      of the ulimit, it's based on SA_FULLDUMP).  But for the stack segment,      if it's not there, we refuse to have anything to do with this core      file.  The usefulness of a core dump without a stack segment is pretty      limited anyway.  */
if|if
condition|(
operator|!
operator|(
name|coredata
operator|.
name|c_flag
operator|&
name|UBLOCK_VALID
operator|)
operator|||
operator|!
operator|(
name|coredata
operator|.
name|c_flag
operator|&
name|LE_VALID
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|coredata
operator|.
name|c_flag
operator|&
name|CORE_TRUNC
operator|)
operator|||
operator|!
operator|(
name|coredata
operator|.
name|c_flag
operator|&
name|USTACK_VALID
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Don't check the core file size for a full core, AIX 4.1 includes      additional shared library sections in a full core.  */
if|if
condition|(
operator|!
operator|(
name|coredata
operator|.
name|c_flag
operator|&
name|FULL_CORE
operator|)
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|coredata
operator|.
name|c_stack
operator|+
name|coredata
operator|.
name|c_size
operator|)
operator|!=
name|statbuf
operator|.
name|st_size
condition|)
block|{
comment|/* If the size is wrong, it means we're misinterpreting something.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Sanity check on the c_tab field.  */
if|if
condition|(
operator|(
name|u_long
operator|)
name|coredata
operator|.
name|c_tab
operator|<
sizeof|sizeof
name|coredata
operator|||
operator|(
name|u_long
operator|)
name|coredata
operator|.
name|c_tab
operator|>=
name|statbuf
operator|.
name|st_size
operator|||
operator|(
name|long
operator|)
name|coredata
operator|.
name|c_tab
operator|>=
operator|(
name|long
operator|)
name|coredata
operator|.
name|c_stack
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* maybe you should alloc space for the whole core chunk over here!! FIXMEmgo */
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|Rs6kCorData
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpptr
condition|)
return|return
name|NULL
return|;
name|set_tdata
argument_list|(
name|abfd
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
comment|/* Copy core file header.  */
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|coredata
expr_stmt|;
comment|/* .stack section. */
if|if
condition|(
operator|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".stack"
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|coredata
operator|.
name|c_size
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|STACK_END_ADDR
operator|-
name|coredata
operator|.
name|c_size
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|int
operator|)
name|coredata
operator|.
name|c_stack
expr_stmt|;
comment|/*???? */
comment|/* .reg section for GPRs and special registers. */
if|if
condition|(
operator|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg"
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
operator|(
literal|32
operator|+
name|NUM_OF_SPEC_REGS
operator|)
operator|*
literal|4
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
comment|/* not used?? */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
operator|.
name|SAVE_FIELD
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
expr_stmt|;
comment|/* .reg2 section for FPRs (floating point registers). */
if|if
condition|(
operator|(
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg2"
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
literal|8
operator|*
literal|32
expr_stmt|;
comment|/* 32 FPRs. */
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
comment|/* not used?? */
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
operator|.
name|SAVE_FIELD
operator|.
name|fpr
index|[
literal|0
index|]
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
expr_stmt|;
if|if
condition|(
operator|(
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".ldinfo"
expr_stmt|;
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
comment|/* To actually find out how long this section is in this particular      core dump would require going down the whole list of struct ld_info's.      See if we can just fake it.  */
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/* Not relevant for ldinfo section.  */
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|coredata
operator|.
name|c_tab
expr_stmt|;
comment|/* set up section chain here. */
name|abfd
operator|->
name|section_count
operator|=
literal|4
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_regsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_ldinfosec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|coredata
operator|.
name|c_flag
operator|&
name|FULL_CORE
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sec
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|sec
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|coredata
operator|.
name|CORE_DATA_SIZE_FIELD
expr_stmt|;
name|sec
operator|->
name|vma
operator|=
name|CDATA_ADDR
argument_list|(
name|coredata
operator|.
name|CORE_DATA_SIZE_FIELD
argument_list|)
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
operator|(
name|int
operator|)
name|coredata
operator|.
name|c_stack
operator|+
name|coredata
operator|.
name|c_size
expr_stmt|;
name|sec
operator|->
name|next
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|sec
expr_stmt|;
operator|++
name|abfd
operator|->
name|section_count
expr_stmt|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
comment|/* this is garbage for now. */
block|}
end_function

begin_comment
comment|/* return `true' if given core is from the given executable.. */
end_comment

begin_function
name|boolean
name|rs6000coff_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|struct
name|core_dump
name|coredata
decl_stmt|;
name|struct
name|ld_info
name|ldinfo
decl_stmt|;
name|char
name|pathname
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
comment|/* Use bfd_xxx routines, rather than O/S primitives, do error checking!!   								FIXMEmgo */
comment|/* Actually should be able to use bfd_get_section_contents now that      we have a .ldinfo section.  */
name|fd
operator|=
name|fopen
argument_list|(
name|core_bfd
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|coredata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|core_dump
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|coredata
operator|.
name|c_tab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|ldinfo
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldinfo
operator|.
name|ldinfo_filename
index|[
literal|0
index|]
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|ldinfo
operator|.
name|ldinfo_next
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|fd
argument_list|,
literal|"%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|str1
operator|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|str2
operator|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* step over character '/' */
name|str1
operator|=
name|str1
condition|?
name|str1
operator|+
literal|1
else|:
operator|&
name|pathname
index|[
literal|0
index|]
expr_stmt|;
name|str2
operator|=
name|str2
condition|?
name|str2
operator|+
literal|1
else|:
name|exec_bfd
operator|->
name|filename
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rs6000coff_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|com
init|=
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|.
name|CORE_COMM_FIELD
decl_stmt|;
if|if
condition|(
operator|*
name|com
condition|)
return|return
name|com
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rs6000coff_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|.
name|c_signo
return|;
block|}
end_function

begin_function
name|boolean
name|rs6000coff_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Reading a core file's sections will be slightly different. For the        rest of them we can use bfd_generic_get_section_contents () I suppose. */
comment|/* Make sure this routine works for any bfd and any section. FIXMEmgo. */
if|if
condition|(
name|abfd
operator|->
name|format
operator|==
name|bfd_core
operator|&&
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".reg"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mstsave
name|mstatus
decl_stmt|;
name|int
name|regoffset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
operator|.
name|gpr
index|[
literal|0
index|]
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
decl_stmt|;
comment|/* Assert that the only way this code will be executed is reading the          whole section. */
if|if
condition|(
name|offset
operator|||
name|count
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
operator|+
operator|(
literal|4
operator|*
name|NUM_OF_SPEC_REGS
operator|)
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"ERROR! in rs6000coff_get_section_contents()\n"
argument_list|)
expr_stmt|;
comment|/* for `.reg' section, `filepos' is a pointer to the `mstsave' structure          in the core file. */
comment|/* read GPR's into the location. */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|regoffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
comment|/* increment location to the beginning of special registers in the section,          reset register offset value to the beginning of first special register 	 in mstsave structure, and read special registers. */
name|location
operator|=
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|location
operator|+
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
argument_list|)
expr_stmt|;
name|regoffset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
operator|.
name|iar
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|regoffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
literal|4
operator|*
name|NUM_OF_SPEC_REGS
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|*
name|NUM_OF_SPEC_REGS
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
comment|/* increment location address, and read the special registers.. */
comment|/* FIXMEmgo */
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* else, use default bfd section content transfer. */
else|else
return|return
name|_bfd_generic_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AIX_CORE */
end_comment

end_unit

