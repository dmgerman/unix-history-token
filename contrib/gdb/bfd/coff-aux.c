begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Apple M68K COFF A/UX 3.x files.    Copyright 1996 Free Software Foundation, Inc.    Portions written by Richard Henderson<rth@tamu.edu>,    COMMON symbol munging cribbed from cf-m68klynx.c which was    written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_SYM
value|m68kaux_coff_vec
end_define

begin_define
define|#
directive|define
name|TARGET_NAME
value|"coff-m68k-aux"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TARG_AUX
end_ifndef

begin_define
define|#
directive|define
name|TARG_AUX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_comment
comment|/* 4k pages */
end_comment

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|0x1000
end_define

begin_comment
comment|/* On AUX, a STYP_NOLOAD|STYP_BSS section is part of a shared library. */
end_comment

begin_define
define|#
directive|define
name|BSS_NOLOAD_IS_SHARED_LIBRARY
end_define

begin_define
define|#
directive|define
name|_bfd_m68kcoff_howto_table
value|_bfd_m68kaux_howto_table
end_define

begin_define
define|#
directive|define
name|_bfd_m68kcoff_rtype2howto
value|_bfd_m68kaux_rtype2howto
end_define

begin_define
define|#
directive|define
name|_bfd_m68kcoff_howto2rtype
value|_bfd_m68kaux_howto2rtype
end_define

begin_define
define|#
directive|define
name|_bfd_m68kcoff_reloc_type_lookup
value|_bfd_m68kaux_reloc_type_lookup
end_define

begin_comment
comment|/* Rather than change names lots of places, reuse the same hack */
end_comment

begin_define
define|#
directive|define
name|LYNX_SPECIAL_FN
value|_bfd_m68kaux_special_fn
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_struct_decl
struct_decl|struct
name|internal_reloc
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|coff_link_hash_entry
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|internal_syment
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|_bfd_m68kaux_special_fn
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_m68k_aux_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_m68k_aux_link_add_one_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|coff_m68k_aux_rtype_to_howto
end_define

begin_define
define|#
directive|define
name|coff_link_add_one_symbol
value|coff_m68k_aux_link_add_one_symbol
end_define

begin_comment
comment|/* Compute the addend of a reloc.  If the reloc is to a common symbol,    the object file contains the value of the common symbol.  By the    time this is called, the linker may be using a different symbol    from a different object file with a different value.  Therefore, we    hack wildly to locate the original symbol from this file so that we    can make the correct adjustment.  This macro sets coffsym to the    symbol from the original file, and uses it to set the addend value    correctly.  If this is not a common symbol, the usual addend    calculation is done, except that an additional tweak is needed for    PC relative relocs.    FIXME: This macro refers to symbols and asect; these are from the    calling function, not the macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{								\     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)			\       coffsym = (obj_symbols (abfd)				\ 	         + (cache_ptr->sym_ptr_ptr - symbols));		\     else if (ptr)						\       coffsym = coff_symbol_from (abfd, ptr);			\     if (coffsym != (coff_symbol_type *) NULL			\&& coffsym->native->u.syment.n_scnum == 0)		\       cache_ptr->addend = - coffsym->native->u.syment.n_value;	\     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd		\&& ptr->section != (asection *) NULL)		\       cache_ptr->addend = - (ptr->section->vma + ptr->value);	\     else							\       cache_ptr->addend = 0;					\     if (ptr&& (reloc.r_type == R_PCRBYTE			\ 		|| reloc.r_type == R_PCRWORD			\ 		|| reloc.r_type == R_PCRLONG))			\       cache_ptr->addend += asect->vma;				\   }
end_define

begin_include
include|#
directive|include
file|"coff/aux-coff.h"
end_include

begin_comment
comment|/* override coff/internal.h and coff/m68k.h */
end_comment

begin_include
include|#
directive|include
file|"coff-m68k.c"
end_include

begin_comment
comment|/* For some reason when using m68k COFF the value stored in the .text    section for a reference to a common symbol is the value itself plus    any desired offset.  (taken from work done by Ian Taylor, Cygnus Support,    for I386 COFF).  */
end_comment

begin_comment
comment|/* If we are producing relocateable output, we need to do some    adjustments to the object file that are not done by the    bfd_perform_relocation function.  This function is called by every    reloc type to make any required adjustments.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|_bfd_m68kaux_special_fn
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|symvalue
name|diff
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* We are relocating a common symbol.  The current value in the 	 object file is ORIG + OFFSET, where ORIG is the value of the 	 common symbol as seen by the object file when it was compiled 	 (this may be zero if the symbol was undefined) and OFFSET is 	 the offset into the common symbol (normally zero, but may be 	 non-zero when referring to a field in a common structure). 	 ORIG is the negative of reloc_entry->addend, which is set by 	 the CALC_ADDEND macro below.  We want to replace the value in 	 the object file with NEW + OFFSET, where NEW is the value of 	 the common symbol which we are going to put in the final 	 object file.  NEW is symbol->value.  */
name|diff
operator|=
name|symbol
operator|->
name|value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
else|else
block|{
comment|/* For some reason bfd_perform_relocation always effectively 	 ignores the addend for a COFF target when producing 	 relocateable output.  This seems to be always wrong for 386 	 COFF, so we handle the addend here instead.  */
name|diff
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ((x& ~howto->dst_mask) | \        (((x& howto->src_mask) + diff)& howto->dst_mask))
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now let bfd_perform_relocation finish everything up.  */
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* coff-m68k.c uses the special COFF backend linker.  We need to    adjust common symbols.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_m68k_aux_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|arelent
name|relent
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|RTYPE2HOWTO
argument_list|(
operator|&
name|relent
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|relent
operator|.
name|howto
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|==
literal|0
operator|&&
name|sym
operator|->
name|n_value
operator|!=
literal|0
condition|)
block|{
comment|/* This is a common symbol.  The section contents include the 	 size (sym->n_value) as an addend.  The relocate_section 	 function will be adding in the final value of the symbol.  We 	 need to subtract out the current size in order to get the 	 correct result.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|addendp
operator|-=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
comment|/* If the output symbol is common (in which case this must be a      relocateable link), we need to add in the final size of the      common symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
operator|*
name|addendp
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
return|return
name|howto
return|;
block|}
end_function

begin_comment
comment|/* We need non-absolute symbols to override absolute symbols.  This    mirrors Apple's "solution" to let a static library symbol override    a shared library symbol.  On the whole not a good thing, given how    shared libraries work here, but can work if you are careful with    what you include in the shared object. */
end_comment

begin_function
name|boolean
name|coff_m68k_aux_link_add_one_symbol
parameter_list|(
name|info
parameter_list|,
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|,
name|string
parameter_list|,
name|copy
parameter_list|,
name|collect
parameter_list|,
name|hashp
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
name|hashp
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|BSF_WARNING
operator||
name|BSF_CONSTRUCTOR
operator||
name|BSF_WEAK
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
condition|)
block|{
comment|/* The new symbol is a definition or an indirect definition */
comment|/* This bit copied from linker.c */
if|if
condition|(
name|hashp
operator|!=
name|NULL
operator|&&
operator|*
name|hashp
operator|!=
name|NULL
condition|)
block|{
name|h
operator|=
operator|*
name|hashp
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|copy
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|notice_hash
operator|!=
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|notice_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|notice
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|hashp
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|hashp
operator|=
name|h
expr_stmt|;
comment|/* end duplication from linker.c */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|msec
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
else|else
name|msec
operator|=
name|bfd_ind_section_ptr
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|msec
argument_list|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|msec
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
comment|/* If we didn't exit early, finish processing in the generic routine */
return|return
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
name|string
argument_list|,
name|copy
argument_list|,
name|collect
argument_list|,
name|hashp
argument_list|)
return|;
block|}
end_function

end_unit

