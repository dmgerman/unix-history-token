begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for 32-bit SPARC NLM (NetWare Loadable Module)    Copyright (C) 1993 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|32
end_define

begin_include
include|#
directive|include
file|"nlm/sparc32-ext.h"
end_include

begin_define
define|#
directive|define
name|Nlm_External_Fixed_Header
value|Nlm32_sparc_External_Fixed_Header
end_define

begin_include
include|#
directive|include
file|"libnlm.h"
end_include

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_read_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_write_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_mangle_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_read_import
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_write_import
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_write_external
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_size_type
operator|,
name|asymbol
operator|*
operator|,
expr|struct
name|reloc_and_sec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|reloc_type
block|{
name|R_SPARC_NONE
init|=
literal|0
block|,
name|R_SPARC_8
block|,
name|R_SPARC_16
block|,
name|R_SPARC_32
block|,
name|R_SPARC_DISP8
block|,
name|R_SPARC_DISP16
block|,
name|R_SPARC_DISP32
block|,
name|R_SPARC_WDISP30
block|,
name|R_SPARC_WDISP22
block|,
name|R_SPARC_HI22
block|,
name|R_SPARC_22
block|,
name|R_SPARC_13
block|,
name|R_SPARC_LO10
block|,
name|R_SPARC_GOT10
block|,
name|R_SPARC_GOT13
block|,
name|R_SPARC_GOT22
block|,
name|R_SPARC_PC10
block|,
name|R_SPARC_PC22
block|,
name|R_SPARC_WPLT30
block|,
name|R_SPARC_COPY
block|,
name|R_SPARC_GLOB_DAT
block|,
name|R_SPARC_JMP_SLOT
block|,
name|R_SPARC_RELATIVE
block|,
name|R_SPARC_UA32
block|,
name|R_SPARC_max
block|}
enum|;
end_enum

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static CONST char *CONST reloc_type_names[] = {   "R_SPARC_NONE",   "R_SPARC_8",		"R_SPARC_16",		"R_SPARC_32",   "R_SPARC_DISP8",	"R_SPARC_DISP16",	"R_SPARC_DISP32",   "R_SPARC_WDISP30",	"R_SPARC_WDISP22",   "R_SPARC_HI22",	"R_SPARC_22",   "R_SPARC_13",		"R_SPARC_LO10",   "R_SPARC_GOT10",	"R_SPARC_GOT13",	"R_SPARC_GOT22",   "R_SPARC_PC10",	"R_SPARC_PC22",   "R_SPARC_WPLT30",   "R_SPARC_COPY",   "R_SPARC_GLOB_DAT",	"R_SPARC_JMP_SLOT",   "R_SPARC_RELATIVE",   "R_SPARC_UA32", };
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|nlm32_sparc_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_SPARC_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_NONE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_DISP8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_DISP16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_DISP32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00ffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_WDISP30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP22
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_WDISP22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_HI22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_LO10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GOT10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GOT13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GOT22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_PC10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_PC22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WPLT30
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_WPLT30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_COPY"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_UA32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read a NetWare sparc reloc.  */
end_comment

begin_struct
struct|struct
name|nlm32_sparc_reloc_ext
block|{
name|unsigned
name|char
name|offset
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|addend
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|type
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|pad1
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_read_reloc
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
name|secp
argument_list|,
name|rel
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
name|sym
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|rel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_vma
name|val
decl_stmt|,
name|addend
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|struct
name|nlm32_sparc_reloc_ext
name|tmp_reloc
decl_stmt|;
name|asection
modifier|*
name|code_sec
decl_stmt|,
modifier|*
name|data_sec
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|tmp_reloc
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|12
condition|)
return|return
name|false
return|;
name|code_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_CODE_NAME
argument_list|)
expr_stmt|;
name|data_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
operator|*
name|secp
operator|=
name|code_sec
expr_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|tmp_reloc
operator|.
name|offset
argument_list|)
expr_stmt|;
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|tmp_reloc
operator|.
name|addend
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|tmp_reloc
operator|.
name|type
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|val
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
sizeof|sizeof
argument_list|(
name|nlm32_sparc_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|reloc_howto_type
argument_list|)
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|nlm32_sparc_howto_table
index|[
name|index
index|]
operator|.
name|type
operator|==
name|type
condition|)
block|{
name|rel
operator|->
name|howto
operator|=
operator|&
name|nlm32_sparc_howto_table
index|[
name|index
index|]
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  address = %08lx, addend = %08lx, type = %d, howto = %08lx\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rel
operator|->
name|address
argument_list|,
name|rel
operator|->
name|addend
argument_list|,
name|type
argument_list|,
name|rel
operator|->
name|howto
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Write a NetWare sparc reloc.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_sparc_write_reloc
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|arelent
modifier|*
name|rel
decl_stmt|;
block|{
name|bfd_vma
name|val
decl_stmt|;
name|struct
name|nlm32_sparc_reloc_ext
name|tmp_reloc
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|reloc_howto_type
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
sizeof|sizeof
argument_list|(
name|nlm32_sparc_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|reloc_howto_type
argument_list|)
condition|;
name|index
operator|++
control|)
block|{
name|tmp
operator|=
operator|&
name|nlm32_sparc_howto_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|rightshift
operator|==
name|rel
operator|->
name|howto
operator|->
name|rightshift
operator|&&
name|tmp
operator|->
name|size
operator|==
name|rel
operator|->
name|howto
operator|->
name|size
operator|&&
name|tmp
operator|->
name|bitsize
operator|==
name|rel
operator|->
name|howto
operator|->
name|bitsize
operator|&&
name|tmp
operator|->
name|pc_relative
operator|==
name|rel
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
name|tmp
operator|->
name|bitpos
operator|==
name|rel
operator|->
name|howto
operator|->
name|bitpos
operator|&&
name|tmp
operator|->
name|src_mask
operator|==
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|&&
name|tmp
operator|->
name|dst_mask
operator|==
name|rel
operator|->
name|howto
operator|->
name|dst_mask
condition|)
block|{
name|type
operator|=
name|tmp
operator|->
name|type
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/*    * Netware wants a list of relocs for each address.    * Format is:    *	long	offset    *	long	addend    *	char	type    * That should be it.    */
comment|/* The value we write out is the offset into the appropriate      segment.  This offset is the section vma, adjusted by the vma of      the lowest section in that segment, plus the address of the      relocation.  */
if|#
directive|if
literal|0
block|val = bfd_get_section_vma (abfd, (*rel->sym_ptr_ptr)->section) + rel->address;
else|#
directive|else
name|val
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|rel
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  val = %08lx, addend = %08lx, type = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|,
name|rel
operator|->
name|addend
argument_list|,
name|rel
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
name|tmp_reloc
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|rel
operator|->
name|addend
argument_list|,
name|tmp_reloc
operator|.
name|addend
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
call|(
name|short
call|)
argument_list|(
name|rel
operator|->
name|howto
operator|->
name|type
argument_list|)
argument_list|,
name|tmp_reloc
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|tmp_reloc
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|12
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Mangle relocs for SPARC NetWare.  We can just use the standard    SPARC relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_sparc_mangle_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a NetWare sparc import record */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|nlm_sparc_read_import
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|nlm_relent
modifier|*
name|nlm_relocs
decl_stmt|;
comment|/* relocation records for symbol */
name|bfd_size_type
name|rcount
decl_stmt|;
comment|/* number of relocs */
name|bfd_byte
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
comment|/* temporary 32-bit value */
name|unsigned
name|char
name|symlength
decl_stmt|;
comment|/* length of symbol name */
name|char
modifier|*
name|name
decl_stmt|;
comment|/*    * First, read in the number of relocation    * entries for this symbol    */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|rcount
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/*    * Next, read in the length of the symbol    */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|symlength
argument_list|,
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symlength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/*    * Then read in the symbol    */
if|if
condition|(
name|bfd_read
argument_list|(
name|name
argument_list|,
name|symlength
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symlength
condition|)
return|return
name|false
return|;
name|name
index|[
name|symlength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
comment|/*    * Next, start reading in the relocs.    */
name|nlm_relocs
operator|=
operator|(
operator|(
expr|struct
name|nlm_relent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_relent
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|nlm_relocs
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|relocs
operator|=
name|nlm_relocs
expr_stmt|;
name|sym
operator|->
name|rcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|->
name|rcnt
operator|<
name|rcount
condition|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
name|nlm_sparc_read_reloc
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|section
argument_list|,
operator|&
name|nlm_relocs
operator|->
name|reloc
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|nlm_relocs
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|nlm_relocs
operator|++
expr_stmt|;
name|sym
operator|->
name|rcnt
operator|++
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_function
specifier|static
name|boolean
name|nlm_sparc_write_import
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|arelent
modifier|*
name|rel
decl_stmt|;
block|{
name|char
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|asection
modifier|*
name|code
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|bss
decl_stmt|,
modifier|*
name|symsec
decl_stmt|;
name|bfd_vma
name|base
decl_stmt|;
name|code
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_CODE_NAME
argument_list|)
expr_stmt|;
name|data
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
name|bss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
name|symsec
operator|=
operator|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|symsec
operator|==
name|code
condition|)
block|{
name|base
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symsec
operator|==
name|data
condition|)
block|{
name|base
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symsec
operator|==
name|bss
condition|)
block|{
name|base
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:<%x, 1>\n\t"
argument_list|,
name|__FUNCTION__
argument_list|,
name|base
operator|+
operator|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|base
operator|+
operator|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
if|if
condition|(
name|nlm_sparc_write_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an external reference.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_sparc_write_external
parameter_list|(
name|abfd
parameter_list|,
name|count
parameter_list|,
name|sym
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|reloc_and_sec
modifier|*
name|relocs
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
name|len
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
name|len
operator|=
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_write
argument_list|(
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
operator|)
operator|||
name|bfd_write
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nlm_sparc_write_reloc
argument_list|(
name|abfd
argument_list|,
name|relocs
index|[
name|i
index|]
operator|.
name|sec
argument_list|,
name|relocs
index|[
name|i
index|]
operator|.
name|rel
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|nlm_sparc_write_export
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_byte
name|len
decl_stmt|;
name|bfd_byte
name|temp
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:<%x, %d, %s>\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|||
name|bfd_write
argument_list|(
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
operator|||
name|bfd_write
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|nlm_swap_fixed_header_in
end_undef

begin_undef
undef|#
directive|undef
name|nlm_swap_fixed_header_out
end_undef

begin_include
include|#
directive|include
file|"nlmswap.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|nlm_backend_data
name|nlm32_sparc_backend
init|=
block|{
literal|"NetWare SPARC Module   \032"
block|,
sizeof|sizeof
argument_list|(
name|Nlm32_sparc_External_Fixed_Header
argument_list|)
block|,
literal|0
block|,
comment|/* optional_prefix_size */
name|bfd_arch_sparc
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
comment|/* backend_object_p */
literal|0
block|,
comment|/* write_prefix_func */
name|nlm_sparc_read_reloc
block|,
name|nlm_sparc_mangle_relocs
block|,
name|nlm_sparc_read_import
block|,
name|nlm_sparc_write_import
block|,
literal|0
block|,
comment|/* set_public_section */
literal|0
block|,
comment|/* get_public_offset */
name|nlm_swap_fixed_header_in
block|,
name|nlm_swap_fixed_header_out
block|,
name|nlm_sparc_write_external
block|,
name|nlm_sparc_write_export
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"nlm32-sparc"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|nlmNAME(sparc_vec)
end_define

begin_define
define|#
directive|define
name|TARGET_BACKEND_DATA
value|&nlm32_sparc_backend
end_define

begin_include
include|#
directive|include
file|"nlm-target.h"
end_include

end_unit

