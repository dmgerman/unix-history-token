begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Hitachi Super-H COFF binaries.    Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.    Contributed by Cygnus Support.    Written by Steve Chamberlain,<sac@cygnus.com>.    Relaxing code written by Ian Lance Taylor,<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"coff/sh.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* Internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|get_symbol_value
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|sh_coff_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default section alignment to 2**2.  */
end_comment

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_comment
comment|/* Generate long file names.  */
end_comment

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_comment
comment|/* The supported relocations.  There are a lot of relocations defined    in coff/internal.h which we do not expect to ever see.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sh_coff_howtos
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|1
block|}
block|,
block|{
literal|2
block|}
block|,
block|{
literal|3
block|}
block|,
comment|/* R_SH_PCREL8 */
block|{
literal|4
block|}
block|,
comment|/* R_SH_PCREL16 */
block|{
literal|5
block|}
block|,
comment|/* R_SH_HIGH8 */
block|{
literal|6
block|}
block|,
comment|/* R_SH_IMM24 */
block|{
literal|7
block|}
block|,
comment|/* R_SH_LOW16 */
block|{
literal|8
block|}
block|,
block|{
literal|9
block|}
block|,
comment|/* R_SH_PCDISP8BY4 */
name|HOWTO
argument_list|(
name|R_SH_PCDISP8BY2
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcdisp8by2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|11
block|}
block|,
comment|/* R_SH_PCDISP8 */
name|HOWTO
argument_list|(
name|R_SH_PCDISP
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcdisp12by2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|13
block|}
block|,
name|HOWTO
argument_list|(
name|R_SH_IMM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_imm32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
comment|/* R_SH_IMM8 */
block|{
literal|17
block|}
block|,
comment|/* R_SH_IMM8BY2 */
block|{
literal|18
block|}
block|,
comment|/* R_SH_IMM8BY4 */
block|{
literal|19
block|}
block|,
comment|/* R_SH_IMM4 */
block|{
literal|20
block|}
block|,
comment|/* R_SH_IMM4BY2 */
block|{
literal|21
block|}
block|,
comment|/* R_SH_IMM4BY4 */
name|HOWTO
argument_list|(
name|R_SH_PCRELIMM8BY2
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcrelimm8by2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_PCRELIMM8BY4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcrelimm8by4"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_IMM16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_imm16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_SWITCH16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_switch16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_SWITCH32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_switch32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_USES
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_uses"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_COUNT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_count"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
argument|R_SH_ALIGN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
argument|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
argument|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_align"
argument_list|,
comment|/* name */
argument|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
argument|false
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SH_COFF_HOWTO_COUNT
value|(sizeof sh_coff_howtos / sizeof sh_coff_howtos[0])
end_define

begin_comment
comment|/* Check for a bad magic number.  */
end_comment

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|SHBADMAG(x)
end_define

begin_comment
comment|/* Customize coffcode.h (this is not currently used).  */
end_comment

begin_define
define|#
directive|define
name|SH
value|1
end_define

begin_comment
comment|/* FIXME: This should not be set here.  */
end_comment

begin_define
define|#
directive|define
name|__A_MAGIC_SET__
end_define

begin_comment
comment|/* Swap the r_offset field in and out.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_IN_RELOC_OFFSET
value|bfd_h_get_32
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_OFFSET
value|bfd_h_put_32
end_define

begin_comment
comment|/* Swap out extra information in the reloc structure.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_EXTRA
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|do						\     {						\       dst->r_stuff[0] = 'S';			\       dst->r_stuff[1] = 'C';			\     }						\   while (0)
end_define

begin_comment
comment|/* Get the value of a symbol, when performing a relocation.  */
end_comment

begin_function
specifier|static
name|long
name|get_symbol_value
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|relocation
return|;
block|}
end_function

begin_comment
comment|/* This macro is used in coffcode.h to get the howto corresponding to    an internal reloc.  */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|relent
parameter_list|,
name|internal
parameter_list|)
define|\
value|((relent)->howto =				\    ((internal)->r_type< SH_COFF_HOWTO_COUNT	\     ?&sh_coff_howtos[(internal)->r_type]	\     : (reloc_howto_type *) NULL))
end_define

begin_comment
comment|/* This is the same as the macro in coffcode.h, except that it copies    r_offset into reloc_entry->addend for some relocs.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{                                                             \     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)                   \       coffsym = (obj_symbols (abfd)                             \                  + (cache_ptr->sym_ptr_ptr - symbols));         \     else if (ptr)                                               \       coffsym = coff_symbol_from (abfd, ptr);                   \     if (coffsym != (coff_symbol_type *) NULL                    \&& coffsym->native->u.syment.n_scnum == 0)              \       cache_ptr->addend = 0;                                    \     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd               \&& ptr->section != (asection *) NULL)              \       cache_ptr->addend = - (ptr->section->vma + ptr->value);   \     else                                                        \       cache_ptr->addend = 0;                                    \     if ((reloc).r_type == R_SH_SWITCH16				\ 	|| (reloc).r_type == R_SH_SWITCH32			\ 	|| (reloc).r_type == R_SH_USES				\ 	|| (reloc).r_type == R_SH_COUNT				\ 	|| (reloc).r_type == R_SH_ALIGN)			\       cache_ptr->addend = (reloc).r_offset;			\   }
end_define

begin_comment
comment|/* This is the howto function for the SH relocations.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|unsigned
name|short
name|r_type
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
name|data
decl_stmt|;
name|r_type
operator|=
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial linking--do nothing.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Almost all relocs have to do with relaxing.  If any work must be      done for them, it has been done in sh_relax_section.  */
if|if
condition|(
name|r_type
operator|!=
name|R_SH_IMM32
operator|&&
operator|(
name|r_type
operator|!=
name|R_SH_PCDISP
operator|||
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|bfd_reloc_ok
return|;
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|sym_value
operator|=
name|get_symbol_value
argument_list|(
name|symbol_in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SH_IMM32
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|sym_value
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|sym_value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
name|sym_value
operator|+=
operator|(
name|insn
operator|&
literal|0xfff
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0x800
condition|)
name|sym_value
operator|-=
literal|0x1000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|sym_value
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|<
operator|(
name|bfd_vma
operator|)
operator|-
literal|0x1000
operator|||
name|sym_value
operator|>=
literal|0x1000
condition|)
return|return
name|bfd_reloc_overflow
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* We can do relaxing.  */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|sh_relax_section
end_define

begin_comment
comment|/* We use the special COFF backend linker.  */
end_comment

begin_define
define|#
directive|define
name|coff_relocate_section
value|sh_relocate_section
end_define

begin_comment
comment|/* When relaxing, we need to use special code to get the relocated    section contents.  */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
define|\
value|sh_coff_get_relocated_section_contents
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_comment
comment|/* This function handles relaxing on the SH.     Function calls on the SH look like this:         movl  L1,r0        ...        jsr   @r0        ...      L1:        .long function     The compiler and assembler will cooperate to create R_SH_USES    relocs on the jsr instructions.  The r_offset field of the    R_SH_USES reloc is the PC relative offset to the instruction which    loads the register (the r_offset field is computed as though it    were a jump instruction, so the offset value is actually from four    bytes past the instruction).  The linker can use this reloc to    determine just which function is being called, and thus decide    whether it is possible to replace the jsr with a bsr.     If multiple function calls are all based on a single register load    (i.e., the same function is called multiple times), the compiler    guarantees that each function call will have an R_SH_USES reloc.    Therefore, if the linker is able to convert each R_SH_USES reloc    which refers to that address, it can safely eliminate the register    load.     When the assembler creates an R_SH_USES reloc, it examines it to    determine which address is being loaded (L1 in the above example).    It then counts the number of references to that address, and    creates an R_SH_COUNT reloc at that address.  The r_offset field of    the R_SH_COUNT reloc will be the number of references.  If the    linker is able to eliminate a register load, it can use the    R_SH_COUNT reloc to see whether it can also eliminate the function    address.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
operator|*
name|again
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocateable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|laddr
decl_stmt|,
name|paddr
decl_stmt|,
name|symval
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelfn
decl_stmt|,
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelcount
decl_stmt|;
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|bfd_signed_vma
name|foff
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_USES
condition|)
continue|continue;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* The r_offset field of the R_SH_USES reloc will point us to          the register load.  The 4 is because the r_offset field is          computed as though it were a jump offset, which are based          from 4 bytes after the jump instruction.  */
name|laddr
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
literal|4
operator|+
name|irel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|laddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES offset"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|laddr
argument_list|)
expr_stmt|;
comment|/* If the instruction is not mov.l NN,rN, we don't know what to          do.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator|!=
literal|0xd000
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the address from which the register is being loaded.  The       	 displacement in the mov.l instruction is quadrupled.  It is a       	 displacement from four bytes after the movl instruction, but,       	 before adding in the PC address, two least significant bits       	 of the PC are cleared.  We assume that the section is aligned       	 on a four byte boundary.  */
name|paddr
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|paddr
operator|*=
literal|4
expr_stmt|;
name|paddr
operator|+=
operator|(
name|laddr
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|paddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES load offset"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the reloc for the address from which the register is          being loaded.  This reloc will tell us which function is          actually being called.  */
name|paddr
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|irelfn
operator|=
name|internal_relocs
init|;
name|irelfn
operator|<
name|irelend
condition|;
name|irelfn
operator|++
control|)
if|if
condition|(
name|irelfn
operator|->
name|r_vaddr
operator|==
name|paddr
operator|&&
name|irelfn
operator|->
name|r_type
operator|==
name|R_SH_IMM32
condition|)
break|break;
if|if
condition|(
name|irelfn
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected reloc"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irelfn
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_scnum
operator|!=
literal|0
operator|&&
name|sym
operator|.
name|n_scnum
operator|!=
name|sec
operator|->
name|target_index
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: symbol in unexpected section"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
condition|)
block|{
name|symval
operator|=
operator|(
name|sym
operator|.
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|irelfn
operator|->
name|r_symndx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined                  symbol.  Just ignore it--it will be caught by the                  regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
name|symval
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|paddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
comment|/* See if this function call can be shortened.  */
name|foff
operator|=
operator|(
name|symval
operator|-
operator|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|foff
operator|<
operator|-
literal|0x1000
operator|||
name|foff
operator|>=
literal|0x1000
condition|)
block|{
comment|/* After all that work, we can't shorten this function call.  */
continue|continue;
block|}
comment|/* Shorten the function call.  */
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_relocs
operator|=
name|true
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_contents
operator|=
name|true
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
comment|/* Replace the jsr with a bsr.  */
comment|/* Change the R_SH_USES reloc into an R_SH_PCDISP reloc, and          replace the jsr with a bsr.  */
name|irel
operator|->
name|r_type
operator|=
name|R_SH_PCDISP
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
name|irelfn
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
condition|)
block|{
comment|/* If this needs to be changed because of future relaxing,              it will be handled here like other internal PCDISP              relocs.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xb000
operator||
operator|(
operator|(
name|foff
operator|>>
literal|1
operator|)
operator|&
literal|0xfff
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't fully resolve this yet, because the external              symbol value may be changed by future relaxing.  We let              the final link phase handle it.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xb000
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
comment|/* See if there is another R_SH_USES reloc referring to the same          register load.  */
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelend
condition|;
name|irelscan
operator|++
control|)
if|if
condition|(
name|irelscan
operator|->
name|r_type
operator|==
name|R_SH_USES
operator|&&
name|laddr
operator|==
name|irelscan
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
literal|4
operator|+
name|irelscan
operator|->
name|r_offset
condition|)
break|break;
if|if
condition|(
name|irelscan
operator|<
name|irelend
condition|)
block|{
comment|/* Some other function call depends upon this register load, 	     and we have not yet converted that function call. 	     Indeed, we may never be able to convert it.  There is 	     nothing else we can do at this point.  */
continue|continue;
block|}
comment|/* Look for a R_SH_COUNT reloc on the location where the          function address is stored.  Do this before deleting any          bytes, to avoid confusion about the address.  */
for|for
control|(
name|irelcount
operator|=
name|internal_relocs
init|;
name|irelcount
operator|<
name|irelend
condition|;
name|irelcount
operator|++
control|)
if|if
condition|(
name|irelcount
operator|->
name|r_vaddr
operator|==
name|paddr
operator|&&
name|irelcount
operator|->
name|r_type
operator|==
name|R_SH_COUNT
condition|)
break|break;
comment|/* Delete the register load.  */
if|if
condition|(
operator|!
name|sh_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|laddr
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, just in case it permits some          other function call to come within range, we should relax          again.  Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|true
expr_stmt|;
comment|/* Now check whether we got a COUNT reloc.  */
if|if
condition|(
name|irelcount
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected COUNT reloc"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* The number of uses is stored in the r_offset field.  We've          just deleted one.  */
if|if
condition|(
name|irelcount
operator|->
name|r_offset
operator|==
literal|0
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad count"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
operator|--
name|irelcount
operator|->
name|r_offset
expr_stmt|;
comment|/* If there are no more uses, we can delete the address.  Reload          the address from irelfn, in case it was changed by the          previous call to sh_relax_delete_bytes.  */
if|if
condition|(
name|irelcount
operator|->
name|r_offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sh_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irelfn
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* We've done all we can with that function call.  */
block|}
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for coff_link_input_bfd.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
name|irel
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|>
name|addr
operator|&&
name|count
operator|<
operator|(
literal|1
operator|<<
name|irel
operator|->
name|r_offset
operator|)
condition|)
block|{
name|irelalign
operator|=
name|irel
expr_stmt|;
name|toaddr
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|irelalign
operator|==
name|NULL
condition|)
name|sec
operator|->
name|_cooked_size
operator|-=
name|count
expr_stmt|;
else|else
name|memset
argument_list|(
name|contents
operator|+
name|toaddr
operator|-
name|count
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|nraddr
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|int
name|insn
init|=
literal|0
decl_stmt|;
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|int
name|off
decl_stmt|,
name|adjust
decl_stmt|,
name|oinsn
decl_stmt|;
name|bfd_signed_vma
name|voff
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
comment|/* Get the new reloc address.  */
name|nraddr
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|<
name|toaddr
operator|)
operator|||
operator|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|==
name|toaddr
operator|)
condition|)
name|nraddr
operator|-=
name|count
expr_stmt|;
comment|/* See if this reloc was for the bytes we have deleted, in which 	 case we no longer care about it.  */
if|if
condition|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|>=
name|addr
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|<
name|addr
operator|+
name|count
operator|&&
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_ALIGN
condition|)
name|irel
operator|->
name|r_type
operator|=
name|R_SH_UNUSED
expr_stmt|;
comment|/* If this is a PC relative reloc, see if the range it covers          includes the bytes we have deleted.  */
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
case|case
name|R_SH_PCDISP
case|:
case|case
name|R_SH_PCRELIMM8BY2
case|:
case|case
name|R_SH_PCRELIMM8BY4
case|:
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_IMM32
case|:
comment|/* If this reloc is against a symbol defined in this              section, and the symbol will not be adjusted below, we              must check the addend to see it will put the value in              range to be adjusted, and hence must be changed.  */
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irel
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
name|sym
operator|.
name|n_scnum
operator|==
name|sec
operator|->
name|target_index
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|<=
name|addr
operator|||
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sym
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x80
condition|)
name|off
operator|-=
literal|0x100
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irel
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
else|else
block|{
name|off
operator|=
name|insn
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x800
condition|)
name|off
operator|-=
literal|0x1000
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_PCRELIMM8BY2
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|R_SH_PCRELIMM8BY4
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
operator|(
name|start
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
operator|+
literal|4
operator|+
name|off
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH16
case|:
case|case
name|R_SH_SWITCH32
case|:
comment|/* These relocs types represent 	       .word L2-L1 	     The r_offset field holds the difference between the reloc 	     address and L1.  That is the start of the reloc, and 	     adding in the contents gives us the top.  We must adjust 	     both the r_offset field and the section contents.  */
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|-
operator|(
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|+=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
name|start
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_SWITCH16
condition|)
name|voff
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
else|else
name|voff
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
name|voff
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
operator|(
name|long
operator|)
name|irel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
operator|-
name|count
expr_stmt|;
else|else
name|adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
block|{
name|oinsn
operator|=
name|insn
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
case|case
name|R_SH_PCRELIMM8BY2
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCRELIMM8BY4
case|:
name|BFD_ASSERT
argument_list|(
name|adjust
operator|==
name|count
operator|||
name|count
operator|>=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|4
condition|)
name|insn
operator|+=
name|adjust
operator|/
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|irel
operator|->
name|r_vaddr
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
operator|++
name|insn
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH16
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|voff
operator|<
operator|-
literal|0x8000
operator|||
name|voff
operator|>=
literal|0x8000
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_signed_16
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH32
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
name|bfd_put_signed_32
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|irel
operator|->
name|r_offset
operator|+=
name|adjust
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|irel
operator|->
name|r_vaddr
operator|=
name|nraddr
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
block|}
comment|/* Look through all the other sections.  If there contain any IMM32      relocs against internal symbols which we are not going to adjust      below, we may need to adjust the addends.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelscanend
decl_stmt|;
name|bfd_byte
modifier|*
name|ocontents
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|sec
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* We always cache the relocs.  Perhaps, if info->keep_memory is          false, we should free them, if we are permitted to, when we          leave sh_coff_relax_section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|true
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ocontents
operator|=
name|NULL
expr_stmt|;
name|irelscanend
operator|=
name|internal_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelscanend
condition|;
name|irelscan
operator|++
control|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
if|if
condition|(
name|irelscan
operator|->
name|r_type
operator|!=
name|R_SH_IMM32
condition|)
continue|continue;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irelscan
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
name|sym
operator|.
name|n_scnum
operator|==
name|sec
operator|->
name|target_index
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|<=
name|addr
operator|||
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|ocontents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
expr_stmt|;
else|else
block|{
comment|/* We always cache the section contents.                          Perhaps, if info->keep_memory is false, we                          should free them, if we are permitted to,                          when we leave sh_coff_relax_section.  */
name|ocontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|ocontents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
operator|=
name|ocontents
expr_stmt|;
block|}
block|}
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_vaddr
operator|-
name|o
operator|->
name|vma
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sym
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_vaddr
operator|-
name|o
operator|->
name|vma
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|keep_contents
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Adjusting the internal symbols will not work if something has      already retrieved the generic symbols.  It would be possible to      make this work by adjusting the generic symbols at the same time.      However, this case should not arise in normal usage.  */
if|if
condition|(
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
operator|||
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: fatal: generic symbols retrieved before relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Adjust all the symbols.  */
name|sym_hash
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|n_scnum
operator|==
name|sec
operator|->
name|target_index
operator|&&
operator|(
name|bfd_vma
operator|)
name|isym
operator|.
name|n_value
operator|>
name|addr
operator|&&
operator|(
name|bfd_vma
operator|)
name|isym
operator|.
name|n_value
operator|<
name|toaddr
condition|)
block|{
name|isym
operator|.
name|n_value
operator|-=
name|count
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sym_hash
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>=
name|addr
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
name|esym
operator|+=
operator|(
name|isym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|sym_hash
operator|+=
name|isym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
comment|/* See if we can move the ALIGN reloc forward.  We have adjusted      r_vaddr for it already.  */
if|if
condition|(
name|irelalign
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|alignaddr
decl_stmt|;
name|alignaddr
operator|=
name|BFD_ALIGN
argument_list|(
name|irelalign
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignaddr
operator|!=
name|toaddr
condition|)
block|{
comment|/* Tail recursion.  */
return|return
name|sh_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irelalign
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_offset
argument_list|)
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a modification of _bfd_coff_generic_relocate_section, which    will handle SH relaxing.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
comment|/* Almost all relocs have to do with relaxing.  If any work must          be done for them, it has been done in sh_relax_section.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|!=
name|R_SH_IMM32
operator|&&
name|rel
operator|->
name|r_type
operator|!=
name|R_SH_PCDISP
condition|)
continue|continue;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
else|else
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|R_SH_PCDISP
condition|)
name|addend
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_type
operator|>=
name|SH_COFF_HOWTO_COUNT
condition|)
name|howto
operator|=
name|NULL
expr_stmt|;
else|else
name|howto
operator|=
operator|&
name|sh_coff_howtos
index|[
name|rel
operator|->
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* There is nothing to do for an internal PCDISP reloc.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|R_SH_PCDISP
condition|)
continue|continue;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|rstat
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|val
argument_list|,
name|addend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|!=
literal|0
condition|)
name|name
operator|=
name|obj_coff_strings
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|sym
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses sh_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|sh_coff_get_relocated_section_contents
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|internal_syms
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocateable
operator|||
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|==
name|NULL
operator|||
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|,
name|symbols
argument_list|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|->
name|contents
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|symesz
init|=
name|bfd_coff_symesz
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|isymp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|false
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|internal_syms
operator|=
operator|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|isymp
operator|=
name|internal_syms
expr_stmt|;
name|secpp
operator|=
name|sections
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|bfd_coff_swap_sym_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
name|isymp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymp
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
operator|*
name|secpp
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|input_bfd
argument_list|,
name|isymp
operator|->
name|n_scnum
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isymp
operator|->
name|n_value
operator|==
literal|0
condition|)
operator|*
name|secpp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
operator|*
name|secpp
operator|=
name|bfd_com_section_ptr
expr_stmt|;
block|}
name|esym
operator|+=
operator|(
name|isymp
operator|->
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|secpp
operator|+=
name|isymp
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
name|isymp
operator|+=
name|isymp
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sh_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|internal_syms
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
name|sections
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The target vectors.  */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|shcoff_vec
init|=
block|{
literal|"coff-sh"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/* leading symbol underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|shlcoff_vec
init|=
block|{
literal|"coff-shl"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little endian too*/
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/* leading symbol underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

end_unit

