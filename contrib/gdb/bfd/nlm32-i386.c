begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for 32-bit i386 NLM (NetWare Loadable Module)    Copyright (C) 1993 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|32
end_define

begin_include
include|#
directive|include
file|"nlm/i386-ext.h"
end_include

begin_define
define|#
directive|define
name|Nlm_External_Fixed_Header
value|Nlm32_i386_External_Fixed_Header
end_define

begin_include
include|#
directive|include
file|"libnlm.h"
end_include

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_read_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_write_import
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_mangle_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_read_import
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_write_external
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_size_type
operator|,
name|asymbol
operator|*
operator|,
expr|struct
name|reloc_and_sec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjust the reloc location by an absolute value.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|nlm_i386_abs_howto
init|=
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* Adjust the reloc location by a PC relative displacement.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|nlm_i386_pcrel_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DISP32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* Read a NetWare i386 reloc.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_read_reloc
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
name|secp
argument_list|,
name|rel
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
name|sym
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|rel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_byte
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* The value is an offset into either the code or data segment.      This is the location which needs to be adjusted.       If this is a relocation fixup rather than an imported symbol (the      sym argument is NULL) then the high bit is 0 if the location      needs to be adjusted by the address of the data segment, or 1 if      the location needs to be adjusted by the address of the code      segment.  If this is an imported symbol, then the high bit is 0      if the location is 0 if the location should be adjusted by the      offset to the symbol, or 1 if the location should adjusted by the      absolute value of the symbol.       The second most significant bit is 0 if the value is an offset      into the data segment, or 1 if the value is an offset into the      code segment.       All this translates fairly easily into a BFD reloc.  */
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|NLM_HIBIT
operator|)
operator|==
literal|0
condition|)
name|name
operator|=
name|NLM_INITIALIZED_DATA_NAME
expr_stmt|;
else|else
block|{
name|name
operator|=
name|NLM_CODE_NAME
expr_stmt|;
name|val
operator|&=
operator|~
name|NLM_HIBIT
expr_stmt|;
block|}
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
operator|&
name|nlm_i386_abs_howto
expr_stmt|;
block|}
else|else
block|{
comment|/* In this case we do not need to set the sym_ptr_ptr field.  */
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|NLM_HIBIT
operator|)
operator|==
literal|0
condition|)
name|rel
operator|->
name|howto
operator|=
operator|&
name|nlm_i386_pcrel_howto
expr_stmt|;
else|else
block|{
name|rel
operator|->
name|howto
operator|=
operator|&
name|nlm_i386_abs_howto
expr_stmt|;
name|val
operator|&=
operator|~
name|NLM_HIBIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|NLM_HIBIT
operator|>>
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|secp
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|secp
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|NLM_CODE_NAME
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|NLM_HIBIT
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|rel
operator|->
name|address
operator|=
name|val
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Write a NetWare i386 reloc.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_i386_write_import
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|arelent
modifier|*
name|rel
decl_stmt|;
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_byte
name|temp
index|[
literal|4
index|]
decl_stmt|;
comment|/* NetWare only supports two kinds of relocs.  We should check      special_function here, as well, but at the moment coff-i386      relocs uses a special_function which does not affect what we do      here.  */
if|if
condition|(
name|rel
operator|->
name|addend
operator|!=
literal|0
operator|||
name|rel
operator|->
name|howto
operator|==
name|NULL
operator|||
name|rel
operator|->
name|howto
operator|->
name|rightshift
operator|!=
literal|0
operator|||
name|rel
operator|->
name|howto
operator|->
name|size
operator|!=
literal|2
operator|||
name|rel
operator|->
name|howto
operator|->
name|bitsize
operator|!=
literal|32
operator|||
name|rel
operator|->
name|howto
operator|->
name|bitpos
operator|!=
literal|0
operator|||
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|!=
literal|0xffffffff
operator|||
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|!=
literal|0xffffffff
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
comment|/* The value we write out is the offset into the appropriate      segment.  This offset is the section vma, adjusted by the vma of      the lowest section in that segment, plus the address of the      relocation.  */
name|val
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|rel
operator|->
name|address
expr_stmt|;
comment|/* The second most significant bit is 0 if the value is an offset      into the data segment, or 1 if the value is an offset into the      code segment.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
name|val
operator|-=
name|nlm_get_text_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|val
operator||=
name|NLM_HIBIT
operator|>>
literal|1
expr_stmt|;
block|}
else|else
name|val
operator|-=
name|nlm_get_data_low
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* NetWare only supports absolute internal relocs.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The high bit is 1 if the reloc is against the code section, 0 	 if against the data section.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|val
operator||=
name|NLM_HIBIT
expr_stmt|;
block|}
else|else
block|{
comment|/* The high bit is 1 if this is an absolute reloc, 0 if it is PC 	 relative.  */
if|if
condition|(
operator|!
name|rel
operator|->
name|howto
operator|->
name|pc_relative
condition|)
name|val
operator||=
name|NLM_HIBIT
expr_stmt|;
else|else
block|{
comment|/* PC relative relocs on NetWare must be pcrel_offset.  */
if|if
condition|(
operator|!
name|rel
operator|->
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* I want to be able to use objcopy to turn a i386 a.out or COFF file    into a NetWare i386 module.  That means that the relocs from the    source file have to be mapped into relocs that apply to the target    file.  This function is called by nlm_set_section_contents to give    it a chance to rework the relocs.     This is actually a fairly general concept.  However, this is not a    general implementation.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_i386_mangle_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|arelent
modifier|*
modifier|*
name|rel_ptr_ptr
decl_stmt|,
modifier|*
modifier|*
name|rel_end
decl_stmt|;
name|rel_ptr_ptr
operator|=
name|sec
operator|->
name|orelocation
expr_stmt|;
name|rel_end
operator|=
name|rel_ptr_ptr
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel_ptr_ptr
operator|<
name|rel_end
condition|;
name|rel_ptr_ptr
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|rel
operator|=
operator|*
name|rel_ptr_ptr
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
comment|/* Note that no serious harm will ensue if we fail to change a 	 reloc.  We will wind up failing in nlm_i386_write_import.  */
comment|/* Make sure this reloc is within the data we have.  We only 4 	 byte relocs here, so we insist on having 4 bytes.  */
if|if
condition|(
name|rel
operator|->
name|address
operator|<
name|offset
operator|||
name|rel
operator|->
name|address
operator|+
literal|4
operator|>
name|offset
operator|+
name|count
condition|)
continue|continue;
comment|/* NetWare doesn't support reloc addends, so we get rid of them 	 here by simply adding them into the object data.  We handle 	 the symbol value, if any, the same way.  */
name|addend
operator|=
name|rel
operator|->
name|addend
operator|+
name|sym
operator|->
name|value
expr_stmt|;
comment|/* The value of a symbol is the offset into the section.  If the 	 symbol is in the .bss segment, we need to include the size of 	 the data segment in the offset as well.  Fortunately, we know 	 that at this point the size of the data section is in the NLM 	 header.  */
if|if
condition|(
operator|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
condition|)
name|addend
operator|+=
name|nlm_fixed_header
argument_list|(
name|abfd
argument_list|)
operator|->
name|dataImageSize
expr_stmt|;
if|if
condition|(
name|addend
operator|!=
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|!=
name|NULL
operator|&&
name|rel
operator|->
name|howto
operator|->
name|rightshift
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|size
operator|==
literal|2
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitsize
operator|==
literal|32
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitpos
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0xffffffff
operator|&&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|==
literal|0xffffffff
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|rel
operator|->
name|address
operator|-
name|offset
argument_list|)
expr_stmt|;
name|val
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|rel
operator|->
name|address
operator|-
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* NetWare uses a reloc with pcrel_offset set.  We adjust 	 pc_relative relocs accordingly.  We are going to change the 	 howto field, so we can only do this if the current one is 	 compatible.  We should check special_function here, but at 	 the moment coff-i386 uses a special_function which does not 	 affect what we are doing here.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
operator|&&
name|rel
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
operator|!
name|rel
operator|->
name|howto
operator|->
name|pcrel_offset
operator|&&
name|rel
operator|->
name|howto
operator|->
name|rightshift
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|size
operator|==
literal|2
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitsize
operator|==
literal|32
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitpos
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0xffffffff
operator|&&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|==
literal|0xffffffff
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
comment|/* When pcrel_offset is not set, it means that the negative 	     of the address of the memory location is stored in the 	     memory location.  We must add it back in.  */
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|rel
operator|->
name|address
operator|-
name|offset
argument_list|)
expr_stmt|;
name|val
operator|+=
name|rel
operator|->
name|address
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|rel
operator|->
name|address
operator|-
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
operator|&
name|nlm_i386_pcrel_howto
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a NetWare i386 import record */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|nlm_i386_read_import
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|nlmNAME
argument_list|(
name|symbol_type
argument_list|)
operator|*
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|nlm_relent
modifier|*
name|nlm_relocs
decl_stmt|;
comment|/* relocation records for symbol */
name|bfd_size_type
name|rcount
decl_stmt|;
comment|/* number of relocs */
name|bfd_byte
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
comment|/* temporary 32-bit value */
name|unsigned
name|char
name|symlength
decl_stmt|;
comment|/* length of symbol name */
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|symlength
argument_list|,
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|symlength
argument_list|)
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symlength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|name
argument_list|,
name|symlength
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symlength
condition|)
return|return
name|false
return|;
name|name
index|[
name|symlength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
name|rcount
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|nlm_relocs
operator|=
operator|(
operator|(
expr|struct
name|nlm_relent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_relent
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|nlm_relocs
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|relocs
operator|=
name|nlm_relocs
expr_stmt|;
name|sym
operator|->
name|rcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|->
name|rcnt
operator|<
name|rcount
condition|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
name|nlm_i386_read_reloc
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|section
argument_list|,
operator|&
name|nlm_relocs
operator|->
name|reloc
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|nlm_relocs
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|nlm_relocs
operator|++
expr_stmt|;
name|sym
operator|->
name|rcnt
operator|++
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Write out an external reference.  */
end_comment

begin_function
specifier|static
name|boolean
name|nlm_i386_write_external
parameter_list|(
name|abfd
parameter_list|,
name|count
parameter_list|,
name|sym
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|reloc_and_sec
modifier|*
name|relocs
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
name|len
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
name|NLM_TARGET_LONG_SIZE
index|]
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_write
argument_list|(
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bfd_byte
argument_list|)
operator|)
operator|||
name|bfd_write
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nlm_i386_write_import
argument_list|(
name|abfd
argument_list|,
name|relocs
index|[
name|i
index|]
operator|.
name|sec
argument_list|,
name|relocs
index|[
name|i
index|]
operator|.
name|rel
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"nlmswap.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|nlm_backend_data
name|nlm32_i386_backend
init|=
block|{
literal|"NetWare Loadable Module\032"
block|,
sizeof|sizeof
argument_list|(
name|Nlm32_i386_External_Fixed_Header
argument_list|)
block|,
literal|0
block|,
comment|/* optional_prefix_size */
name|bfd_arch_i386
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
comment|/* backend_object_p */
literal|0
block|,
comment|/* write_prefix_func */
name|nlm_i386_read_reloc
block|,
name|nlm_i386_mangle_relocs
block|,
name|nlm_i386_read_import
block|,
name|nlm_i386_write_import
block|,
literal|0
block|,
comment|/* set_public_section */
literal|0
block|,
comment|/* get_public_offset */
name|nlm_swap_fixed_header_in
block|,
name|nlm_swap_fixed_header_out
block|,
name|nlm_i386_write_external
block|,
literal|0
block|,
comment|/* write_export */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"nlm32-i386"
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|nlmNAME(i386_vec)
end_define

begin_define
define|#
directive|define
name|TARGET_BACKEND_DATA
value|&nlm32_i386_backend
end_define

begin_include
include|#
directive|include
file|"nlm-target.h"
end_include

end_unit

