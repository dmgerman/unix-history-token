begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for oasys objects.    Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support,<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|UNDERSCORE_HACK
value|1
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"oasys.h"
end_include

begin_include
include|#
directive|include
file|"liboasys.h"
end_include

begin_comment
comment|/* XXX - FIXME.  offsetof belongs in the system-specific files in    ../include/sys. */
end_comment

begin_comment
comment|/* Define offsetof for those systems which lack it */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|type
parameter_list|,
name|identifier
parameter_list|)
value|(size_t)&(((type *) 0)->identifier)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|oasys_read_record
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|oasys_record_union_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|oasys_write_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|oasys_write_record
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|oasys_record_enum_type
operator|,
name|oasys_record_union_type
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|oasys_write_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|oasys_write_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|oasys_write_end
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|oasys_write_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all the section data and relocation stuff too */
end_comment

begin_expr_stmt
name|PROTO
argument_list|(
specifier|static
name|boolean
argument_list|,
name|oasys_slurp_section_data
argument_list|,
operator|(
name|bfd
operator|*
name|CONST
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|boolean
name|oasys_read_record
parameter_list|(
name|abfd
parameter_list|,
name|record
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oasys_record_union_type
modifier|*
name|record
decl_stmt|;
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|record
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|record
operator|->
name|header
operator|.
name|length
operator|<=
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_read
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|record
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|record
operator|->
name|header
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|record
operator|->
name|header
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|oasys_string_length
parameter_list|(
name|record
parameter_list|)
name|oasys_record_union_type
modifier|*
name|record
decl_stmt|;
block|{
return|return
name|record
operator|->
name|header
operator|.
name|length
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|record
operator|->
name|symbol
operator|.
name|name
operator|-
operator|(
name|char
operator|*
operator|)
name|record
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  Slurp the symbol table by reading in all the records at the start file till we get to the first section record.  We'll sort the symbolss into  two lists, defined and undefined. The undefined symbols will be placed into the table according to their refno.  We do this by placing all undefined symbols at the front of the table moving in, and the defined symbols at the end of the table moving back.  */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|CONST
name|abfd
decl_stmt|;
block|{
name|oasys_record_union_type
name|record
decl_stmt|;
name|oasys_data_type
modifier|*
name|data
init|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|asymbol
modifier|*
name|dest_defined
decl_stmt|;
name|asymbol
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|string_ptr
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|symbols
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
comment|/* Buy enough memory for all the symbols and all the names */
name|data
operator|->
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
operator|*
name|abfd
operator|->
name|symcount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDERSCORE_HACK
comment|/* buy 1 more char for each symbol to keep the underscore in*/
name|data
operator|->
name|strings
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|data
operator|->
name|symbol_string_length
operator|+
name|abfd
operator|->
name|symcount
argument_list|)
expr_stmt|;
else|#
directive|else
name|data
operator|->
name|strings
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|data
operator|->
name|symbol_string_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|->
name|symbols
operator|||
operator|!
name|data
operator|->
name|strings
condition|)
return|return
name|false
return|;
name|dest_defined
operator|=
name|data
operator|->
name|symbols
operator|+
name|abfd
operator|->
name|symcount
operator|-
literal|1
expr_stmt|;
name|string_ptr
operator|=
name|data
operator|->
name|strings
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
while|while
condition|(
name|loop
condition|)
block|{
if|if
condition|(
operator|!
name|oasys_read_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|record
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|record
operator|.
name|header
operator|.
name|type
condition|)
block|{
case|case
name|oasys_record_is_header_enum
case|:
break|break;
case|case
name|oasys_record_is_local_enum
case|:
case|case
name|oasys_record_is_symbol_enum
case|:
block|{
name|int
name|flag
init|=
name|record
operator|.
name|header
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|oasys_record_is_local_enum
condition|?
operator|(
name|BSF_LOCAL
operator|)
else|:
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
decl_stmt|;
name|size_t
name|length
init|=
name|oasys_string_length
argument_list|(
operator|&
name|record
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|record
operator|.
name|symbol
operator|.
name|relb
operator|&
name|RELOCATION_TYPE_BITS
condition|)
block|{
case|case
name|RELOCATION_TYPE_ABS
case|:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|dest
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RELOCATION_TYPE_REL
case|:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|sections
index|[
name|record
operator|.
name|symbol
operator|.
name|relb
operator|&
name|RELOCATION_SECT_BITS
index|]
expr_stmt|;
if|if
condition|(
name|record
operator|.
name|header
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|oasys_record_is_local_enum
condition|)
block|{
name|dest
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
operator|(
operator|~
literal|0
operator|)
condition|)
block|{
comment|/* It seems that sometimes internal symbols are tied up, but 		       still get output, even though there is no 		       section */
name|dest
operator|->
name|section
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|dest
operator|->
name|flags
operator|=
name|flag
expr_stmt|;
block|}
break|break;
case|case
name|RELOCATION_TYPE_UND
case|:
name|dest
operator|=
name|data
operator|->
name|symbols
operator|+
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
case|case
name|RELOCATION_TYPE_COM
case|:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|dest
operator|->
name|name
operator|=
name|string_ptr
expr_stmt|;
name|dest
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
default|default:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|dest
operator|->
name|name
operator|=
name|string_ptr
expr_stmt|;
name|dest
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dest
operator|->
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|dest
operator|->
name|value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|symbol
operator|.
name|value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDERSCORE_HACK
if|if
condition|(
name|record
operator|.
name|symbol
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|string_ptr
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|string_ptr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|string_ptr
argument_list|,
name|record
operator|.
name|symbol
operator|.
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|string_ptr
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|string_ptr
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oasys_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|CONST
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|oasys_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|oasys_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|oasys_vec
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|oasys_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|location
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|asymbol
modifier|*
name|symbase
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
if|if
condition|(
name|oasys_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|symbase
operator|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbols
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|counter
operator|++
control|)
block|{
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
name|symbase
operator|++
expr_stmt|;
block|}
operator|*
name|location
operator|=
literal|0
expr_stmt|;
return|return
name|abfd
operator|->
name|symcount
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************** *  archive stuff */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|oasys_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|oasys_archive_header_type
name|header
decl_stmt|;
name|oasys_extarchive_header_type
name|header_ext
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|false
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|header_ext
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|header_ext
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|header_ext
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|header
operator|.
name|version
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|version
argument_list|)
expr_stmt|;
name|header
operator|.
name|mod_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|mod_count
argument_list|)
expr_stmt|;
name|header
operator|.
name|mod_tbl_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|mod_tbl_offset
argument_list|)
expr_stmt|;
name|header
operator|.
name|sym_tbl_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|sym_tbl_size
argument_list|)
expr_stmt|;
name|header
operator|.
name|sym_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|sym_count
argument_list|)
expr_stmt|;
name|header
operator|.
name|sym_tbl_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|sym_tbl_offset
argument_list|)
expr_stmt|;
name|header
operator|.
name|xref_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|xref_count
argument_list|)
expr_stmt|;
name|header
operator|.
name|xref_lst_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|xref_lst_offset
argument_list|)
expr_stmt|;
comment|/*     There isn't a magic number in an Oasys archive, so the best we     can do to verify reasnableness is to make sure that the values in     the header are too weird     */
if|if
condition|(
name|header
operator|.
name|version
operator|>
literal|10000
operator|||
name|header
operator|.
name|mod_count
operator|>
literal|10000
operator|||
name|header
operator|.
name|sym_count
operator|>
literal|100000
operator|||
name|header
operator|.
name|xref_count
operator|>
literal|100000
condition|)
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
comment|/*     That all worked, let's buy the space for the header and read in     the headers.     */
block|{
name|oasys_ar_data_type
modifier|*
name|ar
init|=
operator|(
name|oasys_ar_data_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_ar_data_type
argument_list|)
argument_list|)
decl_stmt|;
name|oasys_module_info_type
modifier|*
name|module
init|=
operator|(
name|oasys_module_info_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_module_info_type
argument_list|)
operator|*
name|header
operator|.
name|mod_count
argument_list|)
decl_stmt|;
name|oasys_module_table_type
name|record
decl_stmt|;
if|if
condition|(
operator|!
name|ar
operator|||
operator|!
name|module
condition|)
return|return
name|NULL
return|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_ar_data
operator|=
name|ar
expr_stmt|;
name|ar
operator|->
name|module
operator|=
name|module
expr_stmt|;
name|ar
operator|->
name|module_count
operator|=
name|header
operator|.
name|mod_count
expr_stmt|;
name|filepos
operator|=
name|header
operator|.
name|mod_tbl_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|mod_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* There are two ways of specifying the archive header */
if|if
condition|(
literal|0
condition|)
block|{
name|oasys_extmodule_table_type_a_type
name|record_ext
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|record_ext
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
condition|)
return|return
name|NULL
return|;
name|record
operator|.
name|mod_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|mod_size
argument_list|)
expr_stmt|;
name|record
operator|.
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|file_offset
argument_list|)
expr_stmt|;
name|record
operator|.
name|dep_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|dep_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|depee_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|depee_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|sect_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|sect_count
argument_list|)
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
literal|33
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|module
index|[
name|i
index|]
operator|.
name|name
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|module
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|record_ext
operator|.
name|mod_name
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|filepos
operator|+=
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
operator|+
name|record
operator|.
name|dep_count
operator|*
literal|4
operator|+
name|record
operator|.
name|depee_count
operator|*
literal|4
operator|+
name|record
operator|.
name|sect_count
operator|*
literal|8
operator|+
literal|187
expr_stmt|;
block|}
else|else
block|{
name|oasys_extmodule_table_type_b_type
name|record_ext
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|record_ext
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
condition|)
return|return
name|NULL
return|;
name|record
operator|.
name|mod_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|mod_size
argument_list|)
expr_stmt|;
name|record
operator|.
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|file_offset
argument_list|)
expr_stmt|;
name|record
operator|.
name|dep_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|dep_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|depee_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|depee_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|sect_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|sect_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|module_name_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|mod_name_length
argument_list|)
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|module_name_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|module
index|[
name|i
index|]
operator|.
name|name
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|module
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|1
argument_list|,
name|record
operator|.
name|module_name_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|record
operator|.
name|module_name_size
condition|)
return|return
name|NULL
return|;
name|module
index|[
name|i
index|]
operator|.
name|name
index|[
name|record
operator|.
name|module_name_size
index|]
operator|=
literal|0
expr_stmt|;
name|filepos
operator|+=
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
operator|+
name|record
operator|.
name|dep_count
operator|*
literal|4
operator|+
name|record
operator|.
name|module_name_size
operator|+
literal|1
expr_stmt|;
block|}
name|module
index|[
name|i
index|]
operator|.
name|size
operator|=
name|record
operator|.
name|mod_size
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|record
operator|.
name|file_offset
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|abfd
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|=
operator|(
name|oasys_data_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_data_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_SECS
value|16
end_define

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|oasys_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|oasys_data_type
modifier|*
name|oasys
decl_stmt|;
name|oasys_data_type
modifier|*
name|save
init|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|boolean
name|had_usefull
init|=
name|false
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|=
literal|0
expr_stmt|;
name|oasys_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|oasys
operator|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|oasys
operator|->
name|sections
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys
operator|->
name|sections
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Point to the start of the file */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|oasys
operator|->
name|symbol_string_length
operator|=
literal|0
expr_stmt|;
comment|/* Inspect the records, but only keep the section info -      remember the size of the symbols      */
name|oasys
operator|->
name|first_data_record
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
name|oasys_record_union_type
name|record
decl_stmt|;
if|if
condition|(
operator|!
name|oasys_read_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|record
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|record
operator|.
name|header
operator|.
name|length
operator|<
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|record
operator|.
name|header
argument_list|)
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
call|(
name|oasys_record_enum_type
call|)
argument_list|(
name|record
operator|.
name|header
operator|.
name|type
argument_list|)
condition|)
block|{
case|case
name|oasys_record_is_header_enum
case|:
name|had_usefull
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|oasys_record_is_symbol_enum
case|:
case|case
name|oasys_record_is_local_enum
case|:
comment|/* Count symbols and remember their size for a future malloc   */
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|oasys
operator|->
name|symbol_string_length
operator|+=
literal|1
operator|+
name|oasys_string_length
argument_list|(
operator|&
name|record
argument_list|)
expr_stmt|;
name|had_usefull
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|oasys_record_is_section_enum
case|:
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|;
if|if
condition|(
name|record
operator|.
name|section
operator|.
name|header
operator|.
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|record
operator|.
name|section
argument_list|)
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|buffer
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
goto|goto
name|fail
goto|;
name|section_number
operator|=
name|record
operator|.
name|section
operator|.
name|relb
operator|&
name|RELOCATION_SECT_BITS
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|section_number
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|oasys
operator|->
name|sections
index|[
name|section_number
index|]
operator|=
name|s
expr_stmt|;
switch|switch
condition|(
name|record
operator|.
name|section
operator|.
name|relb
operator|&
name|RELOCATION_TYPE_BITS
condition|)
block|{
case|case
name|RELOCATION_TYPE_ABS
case|:
case|case
name|RELOCATION_TYPE_REL
case|:
break|break;
case|case
name|RELOCATION_TYPE_UND
case|:
case|case
name|RELOCATION_TYPE_COM
case|:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|section
operator|.
name|value
argument_list|)
expr_stmt|;
name|s
operator|->
name|vma
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|section
operator|.
name|vma
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|had_usefull
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|oasys_record_is_data_enum
case|:
name|oasys
operator|->
name|first_data_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
name|record
operator|.
name|header
operator|.
name|length
expr_stmt|;
case|case
name|oasys_record_is_debug_enum
case|:
case|case
name|oasys_record_is_module_enum
case|:
case|case
name|oasys_record_is_named_section_enum
case|:
case|case
name|oasys_record_is_end_enum
case|:
if|if
condition|(
name|had_usefull
operator|==
name|false
condition|)
goto|goto
name|fail
goto|;
name|loop
operator|=
name|false
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
block|}
name|oasys
operator|->
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/*     Oasys support several architectures, but I can't see a simple way     to discover which one is in a particular file - we'll guess     */
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|!=
literal|0
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
block|}
comment|/*     We don't know if a section has data until we've read it..     */
name|oasys_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
operator|(
name|void
operator|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|oasys
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|=
name|save
expr_stmt|;
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|oasys_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbol
operator|->
name|section
condition|)
name|ret
operator|->
name|type
operator|=
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
condition|?
literal|'a'
else|:
literal|'A'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oasys_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|?
operator|(
name|CONST
name|char
operator|*
operator|)
literal|"*abs"
else|:
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  The howto table is build using the top two bits of a reloc byte to  index into it. The bits are PCREL,WORD/LONG */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"pcrel16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
argument|true
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"pcrel32"
argument_list|,
argument|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
argument|false
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all the section data and relocation stuff too */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_slurp_section_data
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|CONST
name|abfd
decl_stmt|;
block|{
name|oasys_record_union_type
name|record
decl_stmt|;
name|oasys_data_type
modifier|*
name|data
init|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|oasys_per_section_type
modifier|*
name|per
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* See if the data has been slurped already .. */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|per
operator|=
name|oasys_per_section
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|per
operator|->
name|initialized
operator|==
name|true
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|data
operator|->
name|first_data_record
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|data
operator|->
name|first_data_record
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
while|while
condition|(
name|loop
condition|)
block|{
if|if
condition|(
operator|!
name|oasys_read_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|record
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|record
operator|.
name|header
operator|.
name|type
condition|)
block|{
case|case
name|oasys_record_is_header_enum
case|:
break|break;
case|case
name|oasys_record_is_data_enum
case|:
block|{
name|bfd_byte
modifier|*
name|src
init|=
name|record
operator|.
name|data
operator|.
name|data
decl_stmt|;
name|bfd_byte
modifier|*
name|end_src
init|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|record
operator|)
operator|+
name|record
operator|.
name|header
operator|.
name|length
decl_stmt|;
name|bfd_byte
modifier|*
name|dst_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|dst_base_ptr
decl_stmt|;
name|unsigned
name|int
name|relbit
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|data
operator|->
name|sections
index|[
name|record
operator|.
name|data
operator|.
name|relb
operator|&
name|RELOCATION_SECT_BITS
index|]
decl_stmt|;
name|bfd_vma
name|dst_offset
decl_stmt|;
name|per
operator|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|per
operator|->
name|initialized
operator|==
name|false
condition|)
block|{
name|per
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|per
operator|->
name|data
condition|)
return|return
name|false
return|;
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|(
name|oasys_reloc_type
operator|*
operator|*
operator|)
operator|&
operator|(
name|section
operator|->
name|relocation
operator|)
expr_stmt|;
name|per
operator|->
name|had_vma
operator|=
name|false
expr_stmt|;
name|per
operator|->
name|initialized
operator|=
name|true
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
block|}
name|dst_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|data
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|per
operator|->
name|had_vma
operator|==
name|false
condition|)
block|{
comment|/* Take the first vma we see as the base */
name|section
operator|->
name|vma
operator|=
name|dst_offset
expr_stmt|;
name|per
operator|->
name|had_vma
operator|=
name|true
expr_stmt|;
block|}
name|dst_offset
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
name|dst_base_ptr
operator|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
expr_stmt|;
name|dst_ptr
operator|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|+
name|dst_offset
expr_stmt|;
if|if
condition|(
name|src
operator|<
name|end_src
condition|)
block|{
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
while|while
condition|(
name|src
operator|<
name|end_src
condition|)
block|{
name|unsigned
name|char
name|mod_byte
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|size_t
name|gap
init|=
name|end_src
operator|-
name|src
decl_stmt|;
name|count
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|mod_byte
operator|==
literal|0
operator|&&
name|gap
operator|>=
literal|8
condition|)
block|{
name|dst_ptr
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|2
index|]
operator|=
name|src
index|[
literal|2
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|3
index|]
operator|=
name|src
index|[
literal|3
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|4
index|]
operator|=
name|src
index|[
literal|4
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|5
index|]
operator|=
name|src
index|[
literal|5
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|6
index|]
operator|=
name|src
index|[
literal|6
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|7
index|]
operator|=
name|src
index|[
literal|7
index|]
expr_stmt|;
name|dst_ptr
operator|+=
literal|8
expr_stmt|;
name|src
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|relbit
operator|=
literal|1
init|;
name|count
operator|--
operator|!=
literal|0
operator|&&
name|src
operator|<
name|end_src
condition|;
name|relbit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|relbit
operator|&
name|mod_byte
condition|)
block|{
name|unsigned
name|char
name|reloc
init|=
operator|*
name|src
decl_stmt|;
comment|/* This item needs to be relocated */
switch|switch
condition|(
name|reloc
operator|&
name|RELOCATION_TYPE_BITS
condition|)
block|{
case|case
name|RELOCATION_TYPE_ABS
case|:
break|break;
case|case
name|RELOCATION_TYPE_REL
case|:
block|{
comment|/* Relocate the item relative to the section */
name|oasys_reloc_type
modifier|*
name|r
init|=
operator|(
name|oasys_reloc_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_reloc_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|false
return|;
operator|*
operator|(
name|per
operator|->
name|reloc_tail_ptr
operator|)
operator|=
name|r
expr_stmt|;
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|(
name|oasys_reloc_type
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Reference to undefined symbol */
name|src
operator|++
expr_stmt|;
comment|/* There is no symbol */
name|r
operator|->
name|symbol
operator|=
literal|0
expr_stmt|;
comment|/* Work out the howto */
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|r->relent.section = 				    data->sections[reloc& 						   RELOCATION_SECT_BITS];  				  r->relent.addend = - 				    r->relent.section->vma;
endif|#
directive|endif
name|r
operator|->
name|relent
operator|.
name|address
operator|=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|howto_table
index|[
name|reloc
operator|>>
literal|6
index|]
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|++
expr_stmt|;
comment|/* Fake up the data to look like it's got the -ve pc in it, this makes 				       it much easier to convert into other formats. This is done by 				       hitting the addend. 				       */
if|if
condition|(
name|r
operator|->
name|relent
operator|.
name|howto
operator|->
name|pc_relative
operator|==
name|true
condition|)
block|{
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RELOCATION_TYPE_UND
case|:
block|{
name|oasys_reloc_type
modifier|*
name|r
init|=
operator|(
name|oasys_reloc_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_reloc_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|false
return|;
operator|*
operator|(
name|per
operator|->
name|reloc_tail_ptr
operator|)
operator|=
name|r
expr_stmt|;
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|(
name|oasys_reloc_type
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Reference to undefined symbol */
name|src
operator|++
expr_stmt|;
comment|/* Get symbol number */
name|r
operator|->
name|symbol
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|src
index|[
literal|1
index|]
expr_stmt|;
comment|/* Work out the howto */
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|r->relent.section = (asection 						       *) NULL;
endif|#
directive|endif
name|r
operator|->
name|relent
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|address
operator|=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|howto_table
index|[
name|reloc
operator|>>
literal|6
index|]
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
comment|/* Fake up the data to look like it's got the -ve pc in it, this makes 				       it much easier to convert into other formats. This is done by 				       hitting the addend. 				       */
if|if
condition|(
name|r
operator|->
name|relent
operator|.
name|howto
operator|->
name|pc_relative
operator|==
name|true
condition|)
block|{
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RELOCATION_TYPE_COM
case|:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|dst_ptr
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|oasys_record_is_local_enum
case|:
case|case
name|oasys_record_is_symbol_enum
case|:
case|case
name|oasys_record_is_section_enum
case|:
break|break;
default|default:
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|newsect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|newsect
decl_stmt|;
block|{
name|newsect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_per_section_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
return|return
name|false
return|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
expr_stmt|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|section
operator|=
name|newsect
expr_stmt|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|initialized
operator|=
name|false
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|1
expr_stmt|;
comment|/* Turn the section string into an index */
name|sscanf
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|newsect
operator|->
name|target_index
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oasys_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|oasys_slurp_section_data
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|oasys_per_section_type
modifier|*
name|p
init|=
operator|(
name|oasys_per_section_type
operator|*
operator|)
name|section
operator|->
name|used_by_bfd
decl_stmt|;
name|oasys_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|initialized
operator|==
name|false
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|location
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|location
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|p
operator|->
name|data
operator|+
name|offset
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|long
name|oasys_canonicalize_reloc
parameter_list|(
name|ignore_abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|unsigned
name|int
name|reloc_count
init|=
literal|0
decl_stmt|;
name|oasys_reloc_type
modifier|*
name|src
init|=
operator|(
name|oasys_reloc_type
operator|*
operator|)
operator|(
name|section
operator|->
name|relocation
operator|)
decl_stmt|;
while|while
condition|(
name|src
operator|!=
operator|(
name|oasys_reloc_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if (src->relent.section == (asection *) NULL) 	{ 	  src->relent.sym_ptr_ptr = symbols + src->symbol; 	}
endif|#
directive|endif
operator|*
name|relptr
operator|++
operator|=
operator|&
name|src
operator|->
name|relent
expr_stmt|;
name|src
operator|=
name|src
operator|->
name|next
expr_stmt|;
name|reloc_count
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
operator|=
name|reloc_count
return|;
block|}
end_function

begin_comment
comment|/* Writing */
end_comment

begin_comment
comment|/* Calculate the checksum and write one record */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_write_record
parameter_list|(
name|abfd
parameter_list|,
name|type
parameter_list|,
name|record
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oasys_record_enum_type
name|type
decl_stmt|;
name|oasys_record_union_type
modifier|*
name|record
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|int
name|checksum
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|record
operator|->
name|header
operator|.
name|length
operator|=
name|size
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|type
operator|=
operator|(
name|int
operator|)
name|type
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|check_sum
operator|=
literal|0
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|fill
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|record
operator|->
name|pad
index|[
literal|0
index|]
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
name|record
operator|->
name|header
operator|.
name|check_sum
operator|=
literal|0xff
operator|&
operator|(
operator|-
name|checksum
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|record
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out all the symbols */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_write_syms
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|generic
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
name|count
operator|++
control|)
block|{
name|oasys_symbol_record_type
name|symbol
decl_stmt|;
name|asymbol
modifier|*
name|CONST
name|g
init|=
name|generic
index|[
name|count
index|]
decl_stmt|;
name|CONST
name|char
modifier|*
name|src
init|=
name|g
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|symbol
operator|.
name|name
decl_stmt|;
name|unsigned
name|int
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|g
operator|->
name|section
argument_list|)
condition|)
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_COM
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|g
operator|->
name|section
argument_list|)
condition|)
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_ABS
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|g
operator|->
name|section
argument_list|)
condition|)
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_UND
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
comment|/* Overload the value field with the output index number */
name|index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
comment|/* throw it away */
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|g
operator|->
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Sometime, the oasys tools give out a symbol with illegal 	   bits in it, we'll output it in the same broken way */
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_REL
operator||
literal|0
expr_stmt|;
block|}
else|else
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_REL
operator||
name|g
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNDERSCORE_HACK
if|if
condition|(
name|src
index|[
name|l
index|]
operator|==
literal|'_'
condition|)
name|dst
index|[
name|l
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|src
index|[
name|l
index|]
condition|)
block|{
name|dst
index|[
name|l
index|]
operator|=
name|src
index|[
name|l
index|]
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|value
argument_list|,
name|symbol
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
block|{
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_local_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|symbol
argument_list|,
name|offsetof
argument_list|(
name|oasys_symbol_record_type
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
operator|+
name|l
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_symbol_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|symbol
argument_list|,
name|offsetof
argument_list|(
name|oasys_symbol_record_type
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
operator|+
name|l
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|g
operator|->
name|value
operator|=
name|index
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write a section header for each section */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_write_sections
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
specifier|static
name|oasys_section_record_type
name|out
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|s
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: can not represent section `%s' in oasys"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|out
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_REL
operator||
name|s
operator|->
name|target_index
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_cooked_size
argument_list|,
name|out
operator|.
name|value
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|out
operator|.
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_section_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_write_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Create and write the header */
name|oasys_header_record_type
name|r
decl_stmt|;
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|r
operator|.
name|module_name
argument_list|)
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
name|r
operator|.
name|module_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|r
operator|.
name|module_name
argument_list|,
name|abfd
operator|->
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|r
operator|.
name|module_name
operator|+
name|length
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|.
name|module_name
argument_list|)
operator|-
name|length
argument_list|)
expr_stmt|;
name|r
operator|.
name|version_number
operator|=
name|OASYS_VERSION_NUMBER
expr_stmt|;
name|r
operator|.
name|rev_number
operator|=
name|OASYS_REV_NUMBER
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_header_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|r
argument_list|,
name|offsetof
argument_list|(
name|oasys_header_record_type
argument_list|,
name|description
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_write_end
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|oasys_end_record_type
name|end
decl_stmt|;
name|unsigned
name|char
name|null
init|=
literal|0
decl_stmt|;
name|end
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_ABS
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|end
operator|.
name|entry
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|end
operator|.
name|fill
argument_list|)
expr_stmt|;
name|end
operator|.
name|zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_end_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|end
argument_list|,
sizeof|sizeof
argument_list|(
name|end
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|null
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|comp
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
name|CONST
name|PTR
name|ap
decl_stmt|;
name|CONST
name|PTR
name|bp
decl_stmt|;
block|{
name|arelent
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|ap
operator|)
decl_stmt|;
name|arelent
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bp
operator|)
decl_stmt|;
return|return
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
return|;
block|}
end_function

begin_comment
comment|/*  Writing data..  */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_write_data
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_byte
modifier|*
name|raw_data
init|=
name|oasys_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
decl_stmt|;
name|oasys_data_record_type
name|processed_data
decl_stmt|;
name|bfd_size_type
name|current_byte_index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|relocs_to_go
init|=
name|s
operator|->
name|reloc_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
init|=
name|s
operator|->
name|orelocation
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
comment|/* Sort the reloc records so it's easy to insert the relocs into the 	   data */
name|qsort
argument_list|(
name|s
operator|->
name|orelocation
argument_list|,
name|s
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
operator|*
argument_list|)
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
name|current_byte_index
operator|=
literal|0
expr_stmt|;
name|processed_data
operator|.
name|relb
operator|=
name|s
operator|->
name|target_index
operator||
name|RELOCATION_TYPE_REL
expr_stmt|;
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|_cooked_size
condition|)
block|{
comment|/* Scan forwards by eight bytes or however much is left and see if 	       there are any relocations going on */
name|bfd_byte
modifier|*
name|mod
init|=
operator|&
name|processed_data
operator|.
name|data
index|[
literal|0
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
init|=
operator|&
name|processed_data
operator|.
name|data
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|mod
operator|=
literal|0
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|vma
operator|+
name|current_byte_index
argument_list|,
name|processed_data
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* Don't start a relocation unless you're sure you can finish it  	       within the same data record.  The worst case relocation is a  	       4-byte relocatable value which is split across two modification  	       bytes (1 relocation byte + 2 symbol reference bytes + 2 data +  	       1 modification byte + 2 data = 8 bytes total).  That's where  	       the magic number 8 comes from.  	    */
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|_raw_size
operator|&&
name|dst
operator|<=
operator|&
name|processed_data
operator|.
name|data
index|[
sizeof|sizeof
argument_list|(
name|processed_data
operator|.
name|data
argument_list|)
operator|-
literal|8
index|]
condition|)
block|{
if|if
condition|(
name|relocs_to_go
operator|!=
literal|0
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|p
decl_stmt|;
name|reloc_howto_type
modifier|*
specifier|const
name|how
init|=
name|r
operator|->
name|howto
decl_stmt|;
comment|/* There is a relocation, is it for this byte ? */
if|if
condition|(
name|r
operator|->
name|address
operator|==
name|current_byte_index
condition|)
block|{
name|unsigned
name|char
name|rel_byte
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|relocs_to_go
operator|--
expr_stmt|;
operator|*
name|mod
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|how
operator|->
name|pc_relative
condition|)
block|{
name|rel_byte
operator|=
name|RELOCATION_PCREL_BIT
expr_stmt|;
comment|/* Also patch the raw data so that it doesn't have 			 the -ve stuff any more */
if|if
condition|(
name|how
operator|->
name|size
operator|!=
literal|2
condition|)
block|{
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|raw_data
argument_list|)
operator|+
name|current_byte_index
argument_list|,
name|raw_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|raw_data
argument_list|)
operator|+
name|current_byte_index
argument_list|,
name|raw_data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rel_byte
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|how
operator|->
name|size
operator|==
literal|2
condition|)
block|{
name|rel_byte
operator||=
name|RELOCATION_32BIT_BIT
expr_stmt|;
block|}
comment|/* Is this a section relative relocation, or a symbol 		       relative relocation ? */
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if (r->section != (asection *) NULL) 			    {
comment|/* The relent has a section attached, so it must be section 			     relative */
block|rel_byte |= RELOCATION_TYPE_REL; 			      rel_byte |= r->section->output_section->target_index; 			      *dst++ = rel_byte; 			    } 			  else
endif|#
directive|endif
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
operator|(
name|r
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
comment|/* If this symbol has a section attached, then it 			     has already been resolved.  Change from a symbol 			     ref to a section ref */
if|if
condition|(
name|p
operator|->
name|section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|rel_byte
operator||=
name|RELOCATION_TYPE_REL
expr_stmt|;
name|rel_byte
operator||=
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|rel_byte
expr_stmt|;
block|}
else|else
block|{
name|rel_byte
operator||=
name|RELOCATION_TYPE_UND
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|rel_byte
expr_stmt|;
comment|/* Next two bytes are a symbol index - we can get 			       this from the symbol value which has been zapped 			       into the symbol index in the table when the 			       symbol table was written 			       */
operator|*
name|dst
operator|++
operator|=
name|p
operator|->
name|value
operator|>>
literal|8
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|p
operator|->
name|value
expr_stmt|;
block|}
block|}
define|#
directive|define
name|ADVANCE
value|{ if (++i>= 8) { i = 0; mod = dst++; *mod = 0; } current_byte_index++; }
comment|/* relocations never occur from an unloadable section, 		       so we can assume that raw_data is not NULL 		     */
operator|*
name|dst
operator|++
operator|=
operator|*
name|raw_data
operator|++
expr_stmt|;
name|ADVANCE
operator|*
name|dst
operator|++
operator|=
operator|*
name|raw_data
operator|++
expr_stmt|;
name|ADVANCE
if|if
condition|(
name|how
operator|->
name|size
operator|==
literal|2
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|raw_data
operator|++
expr_stmt|;
name|ADVANCE
operator|*
name|dst
operator|++
operator|=
operator|*
name|raw_data
operator|++
expr_stmt|;
name|ADVANCE
block|}
continue|continue;
block|}
block|}
comment|/* If this is coming from an unloadable section then copy 		   zeros */
if|if
condition|(
name|raw_data
operator|==
name|NULL
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|raw_data
operator|++
expr_stmt|;
block|}
name|ADVANCE
block|}
comment|/* Don't write a useless null modification byte */
if|if
condition|(
name|dst
operator|==
name|mod
operator|+
literal|1
condition|)
block|{
operator|--
name|dst
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_data_enum
argument_list|,
operator|(
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|processed_data
operator|)
argument_list|,
name|dst
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|processed_data
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|oasys_write_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|oasys_write_syms
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|oasys_write_sections
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|oasys_write_data
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|oasys_write_end
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/** exec and core file sections */
end_comment

begin_comment
comment|/* set section contents is complicated with OASYS since the format is * not a byte image, but a record stream. */
end_comment

begin_function
specifier|static
name|boolean
name|oasys_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
block|{
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_cooked_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
condition|)
return|return
name|false
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|+
name|offset
argument_list|)
argument_list|,
name|location
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Native-level interface to symbols. */
end_comment

begin_comment
comment|/* We read the symbols into a buffer, which is discarded when this function exits.  We read the strings into a buffer large enough to hold them all plus all the cached symbol entries. */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|oasys_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|oasys_symbol_type
modifier|*
name|new
init|=
operator|(
name|oasys_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* User should have checked the file flags; perhaps we should return BFD_NO_MORE_SYMBOLS if there are none? */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|oasys_openr_next_archived_file
parameter_list|(
name|arch
parameter_list|,
name|prev
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|bfd
modifier|*
name|prev
decl_stmt|;
block|{
name|oasys_ar_data_type
modifier|*
name|ar
init|=
name|OASYS_AR_DATA
argument_list|(
name|arch
argument_list|)
decl_stmt|;
name|oasys_module_info_type
modifier|*
name|p
decl_stmt|;
comment|/* take the next one from the arch state, or reset */
if|if
condition|(
name|prev
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Reset the index - the first two entries are bogus*/
name|ar
operator|->
name|module_index
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|ar
operator|->
name|module
operator|+
name|ar
operator|->
name|module_index
expr_stmt|;
name|ar
operator|->
name|module_index
operator|++
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|module_index
operator|<=
name|ar
operator|->
name|module_count
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|->
name|abfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|p
operator|->
name|abfd
operator|->
name|origin
operator|=
name|p
operator|->
name|pos
expr_stmt|;
name|p
operator|->
name|abfd
operator|->
name|filename
operator|=
name|p
operator|->
name|name
expr_stmt|;
comment|/* Fixup a pointer to this element for the member */
name|p
operator|->
name|abfd
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|p
expr_stmt|;
block|}
return|return
name|p
operator|->
name|abfd
return|;
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd
operator|*
operator|)
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|oasys_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|oasys_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|oasys_module_info_type
modifier|*
name|mod
init|=
operator|(
name|oasys_module_info_type
operator|*
operator|)
name|abfd
operator|->
name|arelt_data
decl_stmt|;
if|if
condition|(
name|mod
operator|==
operator|(
name|oasys_module_info_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|buf
operator|->
name|st_size
operator|=
name|mod
operator|->
name|size
expr_stmt|;
name|buf
operator|->
name|st_mode
operator|=
literal|0666
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|oasys_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|exec
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|oasys_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|oasys_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|oasys_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|oasys_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|oasys_construct_extended_name_table
define|\
value|((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \    bfd_true)
end_define

begin_define
define|#
directive|define
name|oasys_truncate_arname
value|bfd_dont_truncate_arname
end_define

begin_define
define|#
directive|define
name|oasys_write_armap
define|\
value|((boolean (*) \     PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int))) \    bfd_true)
end_define

begin_define
define|#
directive|define
name|oasys_read_ar_hdr
value|bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|oasys_get_elt_at_index
value|_bfd_generic_get_elt_at_index
end_define

begin_define
define|#
directive|define
name|oasys_update_armap_timestamp
value|bfd_true
end_define

begin_define
define|#
directive|define
name|oasys_bfd_is_local_label
value|bfd_generic_is_local_label
end_define

begin_define
define|#
directive|define
name|oasys_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|oasys_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|oasys_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|oasys_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|oasys_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|oasys_set_arch_mach
value|bfd_default_set_arch_mach
end_define

begin_define
define|#
directive|define
name|oasys_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|oasys_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|oasys_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|oasys_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_comment
comment|/*SUPPRESS 460 */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|oasys_vec
init|=
block|{
literal|"oasys"
block|,
comment|/* name */
name|bfd_target_oasys_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|oasys_object_p
block|,
comment|/* bfd_check_format */
name|oasys_archive_p
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|oasys_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|oasys_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

