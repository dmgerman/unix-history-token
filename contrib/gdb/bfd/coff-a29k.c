begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for AMD 29000 COFF binaries.    Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.    Contributed by David Wood at New York University 7/8/91.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|A29K
value|1
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"coff/a29k.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|get_symbol_value
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|a29k_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_a29k_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_a29k_adjust_symndx
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_define
define|#
directive|define
name|INSERT_HWORD
parameter_list|(
name|WORD
parameter_list|,
name|HWORD
parameter_list|)
define|\
value|(((WORD)& 0xff00ff00) | (((HWORD)& 0xff00)<< 8) | ((HWORD)& 0xff))
end_define

begin_define
define|#
directive|define
name|EXTRACT_HWORD
parameter_list|(
name|WORD
parameter_list|)
define|\
value|((((WORD)& 0x00ff0000)>> 8) | ((WORD)& 0xff))
end_define

begin_define
define|#
directive|define
name|SIGN_EXTEND_HWORD
parameter_list|(
name|HWORD
parameter_list|)
define|\
value|((HWORD)& 0x8000 ? (HWORD)|(~0xffffL) : (HWORD))
end_define

begin_comment
comment|/* Provided the symbol, returns the value reffed */
end_comment

begin_function
specifier|static
name|long
name|get_symbol_value
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|long
name|relocation
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|relocation
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
return|return
operator|(
name|relocation
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this function is in charge of performing all the 29k relocations */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|a29k_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* the consth relocation comes in two parts, we have to remember      the state between calls, in these variables */
specifier|static
name|boolean
name|part1_consth_active
init|=
name|false
decl_stmt|;
specifier|static
name|unsigned
name|long
name|part1_consth_value
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|sym_value
decl_stmt|;
name|unsigned
name|long
name|unsigned_value
decl_stmt|;
name|unsigned
name|short
name|r_type
decl_stmt|;
name|long
name|signed_value
decl_stmt|;
name|unsigned
name|long
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
comment|/*+ input_section->vma*/
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|data
operator|)
decl_stmt|;
name|r_type
operator|=
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
condition|)
block|{
comment|/* Partial linking - do nothing */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* Keep the state machine happy in case we're called again */
if|if
condition|(
name|r_type
operator|==
name|R_IHIHALF
condition|)
block|{
name|part1_consth_active
operator|=
name|true
expr_stmt|;
name|part1_consth_value
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|bfd_reloc_undefined
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|part1_consth_active
operator|)
operator|&&
operator|(
name|r_type
operator|!=
name|R_IHCONST
operator|)
condition|)
block|{
name|part1_consth_active
operator|=
name|false
expr_stmt|;
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Missing IHCONST"
expr_stmt|;
return|return
operator|(
name|bfd_reloc_dangerous
operator|)
return|;
block|}
name|sym_value
operator|=
name|get_symbol_value
argument_list|(
name|symbol_in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IREL
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* Take the value in the field and sign extend it */
name|signed_value
operator|=
name|EXTRACT_HWORD
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|signed_value
operator|=
name|SIGN_EXTEND_HWORD
argument_list|(
name|signed_value
argument_list|)
expr_stmt|;
name|signed_value
operator|<<=
literal|2
expr_stmt|;
comment|/* See the note on the R_IREL reloc in coff_a29k_relocate_section.  */
if|if
condition|(
name|signed_value
operator|==
operator|-
operator|(
name|long
operator|)
name|reloc_entry
operator|->
name|address
condition|)
name|signed_value
operator|=
literal|0
expr_stmt|;
name|signed_value
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|signed_value
operator|&
operator|~
literal|0x3ffff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Absolute jmp/call */
name|insn
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* Make it absolute */
comment|/* FIXME: Should we change r_type to R_IABS */
block|}
else|else
block|{
comment|/* Relative jmp/call, so subtract from the value the 	 address of the place we're coming from */
name|signed_value
operator|-=
operator|(
name|reloc_entry
operator|->
name|address
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|signed_value
operator|>
literal|0x1ffff
operator|||
name|signed_value
operator|<
operator|-
literal|0x20000
condition|)
return|return
operator|(
name|bfd_reloc_overflow
operator|)
return|;
block|}
name|signed_value
operator|>>=
literal|2
expr_stmt|;
name|insn
operator|=
name|INSERT_HWORD
argument_list|(
name|insn
argument_list|,
name|signed_value
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_ILOHALF
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|unsigned_value
operator|=
name|EXTRACT_HWORD
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|unsigned_value
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|insn
operator|=
name|INSERT_HWORD
argument_list|(
name|insn
argument_list|,
name|unsigned_value
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IHIHALF
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* consth, part 1         Just get the symbol value that is referenced */
name|part1_consth_active
operator|=
name|true
expr_stmt|;
name|part1_consth_value
operator|=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Don't modify insn until R_IHCONST */
break|break;
case|case
name|R_IHCONST
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* consth, part 2         Now relocate the reference */
if|if
condition|(
name|part1_consth_active
operator|==
name|false
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Missing IHIHALF"
expr_stmt|;
return|return
operator|(
name|bfd_reloc_dangerous
operator|)
return|;
block|}
comment|/* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
name|unsigned_value
operator|=
literal|0
expr_stmt|;
comment|/*EXTRACT_HWORD(insn)<< 16;*/
name|unsigned_value
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* r_symndx */
name|unsigned_value
operator|+=
name|part1_consth_value
expr_stmt|;
name|unsigned_value
operator|=
name|unsigned_value
operator|>>
literal|16
expr_stmt|;
name|insn
operator|=
name|INSERT_HWORD
argument_list|(
name|insn
argument_list|,
name|unsigned_value
argument_list|)
expr_stmt|;
name|part1_consth_active
operator|=
name|false
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_BYTE
case|:
name|insn
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|unsigned_value
operator|=
name|insn
operator|+
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|unsigned_value
operator|&
literal|0xffffff00
condition|)
return|return
operator|(
name|bfd_reloc_overflow
operator|)
return|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|unsigned_value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_HWORD
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|unsigned_value
operator|=
name|insn
operator|+
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|unsigned_value
operator|&
literal|0xffff0000
condition|)
return|return
operator|(
name|bfd_reloc_overflow
operator|)
return|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_WORD
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|error_message
operator|=
literal|"Unrecognized reloc"
expr_stmt|;
return|return
operator|(
name|bfd_reloc_dangerous
operator|)
return|;
block|}
return|return
operator|(
name|bfd_reloc_ok
operator|)
return|;
block|}
end_function

begin_comment
comment|/*      type	   rightshift 		       size 			  bitsize 			       pc-relative 				     bitpos 					 absolute 					     complain_on_overflow 						  special_function 						    relocation name 							       partial_inplace  								      src_mask */
end_comment

begin_comment
comment|/*FIXME: I'm not real sure about this table */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
block|{
name|R_ABS
block|,
literal|0
block|,
literal|3
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|a29k_reloc
block|,
literal|"ABS"
block|,
name|true
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
name|false
block|}
block|,
block|{
literal|1
block|}
block|,
block|{
literal|2
block|}
block|,
block|{
literal|3
block|}
block|,
block|{
literal|4
block|}
block|,
block|{
literal|5
block|}
block|,
block|{
literal|6
block|}
block|,
block|{
literal|7
block|}
block|,
block|{
literal|8
block|}
block|,
block|{
literal|9
block|}
block|,
block|{
literal|10
block|}
block|,
block|{
literal|11
block|}
block|,
block|{
literal|12
block|}
block|,
block|{
literal|13
block|}
block|,
block|{
literal|14
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|18
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|22
block|}
block|,
block|{
literal|23
block|}
block|,
block|{
name|R_IREL
block|,
literal|0
block|,
literal|3
block|,
literal|32
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_signed
block|,
name|a29k_reloc
block|,
literal|"IREL"
block|,
name|true
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
name|false
block|}
block|,
block|{
name|R_IABS
block|,
literal|0
block|,
literal|3
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|a29k_reloc
block|,
literal|"IABS"
block|,
name|true
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
name|false
block|}
block|,
block|{
name|R_ILOHALF
block|,
literal|0
block|,
literal|3
block|,
literal|16
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_signed
block|,
name|a29k_reloc
block|,
literal|"ILOHALF"
block|,
name|true
block|,
literal|0x0000ffff
block|,
literal|0x0000ffff
block|,
name|false
block|}
block|,
block|{
name|R_IHIHALF
block|,
literal|0
block|,
literal|3
block|,
literal|16
block|,
name|true
block|,
literal|16
block|,
name|complain_overflow_signed
block|,
name|a29k_reloc
block|,
literal|"IHIHALF"
block|,
name|true
block|,
literal|0xffff0000
block|,
literal|0xffff0000
block|,
name|false
block|}
block|,
block|{
name|R_IHCONST
block|,
literal|0
block|,
literal|3
block|,
literal|16
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_signed
block|,
name|a29k_reloc
block|,
literal|"IHCONST"
block|,
name|true
block|,
literal|0xffff0000
block|,
literal|0xffff0000
block|,
name|false
block|}
block|,
block|{
name|R_BYTE
block|,
literal|0
block|,
literal|0
block|,
literal|8
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|a29k_reloc
block|,
literal|"BYTE"
block|,
name|true
block|,
literal|0x000000ff
block|,
literal|0x000000ff
block|,
name|false
block|}
block|,
block|{
name|R_HWORD
block|,
literal|0
block|,
literal|1
block|,
literal|16
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|a29k_reloc
block|,
literal|"HWORD"
block|,
name|true
block|,
literal|0x0000ffff
block|,
literal|0x0000ffff
block|,
name|false
block|}
block|,
block|{
name|R_WORD
block|,
literal|0
block|,
literal|2
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|a29k_reloc
block|,
literal|"WORD"
block|,
name|true
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
name|false
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|A29KBADMAG(x)
end_define

begin_define
define|#
directive|define
name|RELOC_PROCESSING
parameter_list|(
name|relent
parameter_list|,
name|reloc
parameter_list|,
name|symbols
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|)
define|\
value|reloc_processing(relent, reloc, symbols, abfd, section)
end_define

begin_function
specifier|static
name|void
name|reloc_processing
parameter_list|(
name|relent
parameter_list|,
name|reloc
parameter_list|,
name|symbols
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|)
name|arelent
modifier|*
name|relent
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|static
name|bfd_vma
name|ihihalf_vaddr
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
name|relent
operator|->
name|address
operator|=
name|reloc
operator|->
name|r_vaddr
expr_stmt|;
name|relent
operator|->
name|howto
operator|=
name|howto_table
operator|+
name|reloc
operator|->
name|r_type
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|r_type
operator|==
name|R_IHCONST
condition|)
block|{
comment|/* The address of an R_IHCONST should always be the address of 	 the immediately preceding R_IHIHALF.  relocs generated by gas 	 are correct, but relocs generated by High C are different (I 	 can't figure out what the address means for High C).  We can 	 handle both gas and High C by ignoring the address here, and 	 simply reusing the address saved for R_IHIHALF.  */
if|if
condition|(
name|ihihalf_vaddr
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relent
operator|->
name|address
operator|=
name|ihihalf_vaddr
expr_stmt|;
name|ihihalf_vaddr
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|relent
operator|->
name|addend
operator|=
name|reloc
operator|->
name|r_symndx
expr_stmt|;
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
else|else
block|{
name|asymbol
modifier|*
name|ptr
decl_stmt|;
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|obj_convert
argument_list|(
name|abfd
argument_list|)
index|[
name|reloc
operator|->
name|r_symndx
index|]
expr_stmt|;
name|ptr
operator|=
operator|*
operator|(
name|relent
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&&
name|bfd_asymbol_bfd
argument_list|(
name|ptr
argument_list|)
operator|==
name|abfd
operator|&&
operator|(
operator|(
name|ptr
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|relent
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|relent
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
name|relent
operator|->
name|address
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|r_type
operator|==
name|R_IHIHALF
condition|)
name|ihihalf_vaddr
operator|=
name|relent
operator|->
name|address
expr_stmt|;
elseif|else
if|if
condition|(
name|ihihalf_vaddr
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The reloc processing routine for the optimized COFF linker.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_a29k_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|boolean
name|hihalf
decl_stmt|;
name|bfd_vma
name|hihalf_val
decl_stmt|;
comment|/* If we are performing a relocateable link, we don't need to do a      thing.  The caller will take care of adjusting the reloc      addresses and symbol indices.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|hihalf
operator|=
name|false
expr_stmt|;
name|hihalf_val
operator|=
literal|0
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|long
name|signed_value
decl_stmt|;
name|unsigned
name|long
name|unsigned_value
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
name|loc
operator|=
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* An R_IHCONST reloc does not have a symbol.  Instead, the          symbol index is an addend.  R_IHCONST is always used in          conjunction with R_IHHALF.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|!=
name|R_IHCONST
condition|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
else|else
block|{
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|hihalf
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
literal|"missing IHCONST reloc"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|hihalf
operator|=
name|false
expr_stmt|;
block|}
block|}
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|rel
operator|->
name|r_type
condition|)
block|{
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|R_IREL
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* Extract the addend.  */
name|signed_value
operator|=
name|EXTRACT_HWORD
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|signed_value
operator|=
name|SIGN_EXTEND_HWORD
argument_list|(
name|signed_value
argument_list|)
expr_stmt|;
name|signed_value
operator|<<=
literal|2
expr_stmt|;
comment|/* Unfortunately, there are two different versions of COFF 	     a29k.  In the original AMD version, the value stored in 	     the field for the R_IREL reloc is a simple addend.  In 	     the GNU version, the value is the negative of the address 	     of the reloc within section.  We try to cope here by 	     assuming the AMD version, unless the addend is exactly 	     the negative of the address; in the latter case we assume 	     the GNU version.  This means that something like 	         .text 		 nop 		 jmp i-4 	     will fail, because the addend of -4 will happen to equal 	     the negative of the address within the section.  The 	     compiler will never generate code like this.  	     At some point in the future we may want to take out this 	     check.  */
if|if
condition|(
name|signed_value
operator|==
operator|-
call|(
name|long
call|)
argument_list|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
condition|)
name|signed_value
operator|=
literal|0
expr_stmt|;
comment|/* Determine the destination of the jump.  */
name|signed_value
operator|+=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|signed_value
operator|&
operator|~
literal|0x3ffff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We can use an absolute jump.  */
name|insn
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make the destination PC relative.  */
name|signed_value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|signed_value
operator|>
literal|0x1ffff
operator|||
name|signed_value
operator|<
operator|-
literal|0x20000
condition|)
block|{
name|overflow
operator|=
name|true
expr_stmt|;
name|signed_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Put the adjusted value back into the instruction.  */
name|signed_value
operator|>>=
literal|2
expr_stmt|;
name|insn
operator|=
name|INSERT_HWORD
argument_list|(
name|insn
argument_list|,
name|signed_value
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_ILOHALF
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|unsigned_value
operator|=
name|EXTRACT_HWORD
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|unsigned_value
operator|+=
name|val
expr_stmt|;
name|insn
operator|=
name|INSERT_HWORD
argument_list|(
name|insn
argument_list|,
name|unsigned_value
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IHIHALF
case|:
comment|/* Save the value for the R_IHCONST reloc.  */
name|hihalf
operator|=
name|true
expr_stmt|;
name|hihalf_val
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|R_IHCONST
case|:
if|if
condition|(
operator|!
name|hihalf
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
literal|"missing IHIHALF reloc"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|hihalf_val
operator|=
literal|0
expr_stmt|;
block|}
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|unsigned_value
operator|=
name|rel
operator|->
name|r_symndx
operator|+
name|hihalf_val
expr_stmt|;
name|unsigned_value
operator|>>=
literal|16
expr_stmt|;
name|insn
operator|=
name|INSERT_HWORD
argument_list|(
name|insn
argument_list|,
name|unsigned_value
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|hihalf
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|R_BYTE
case|:
case|case
name|R_HWORD
case|:
case|case
name|R_WORD
case|:
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto_table
operator|+
name|rel
operator|->
name|r_type
argument_list|,
name|input_bfd
argument_list|,
name|val
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstat
operator|==
name|bfd_reloc_overflow
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|rstat
operator|!=
name|bfd_reloc_ok
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"*unknown*"
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|!=
literal|0
condition|)
name|name
operator|=
name|obj_coff_strings
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|sym
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto_table
index|[
name|rel
operator|->
name|r_type
index|]
operator|.
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_relocate_section
value|coff_a29k_relocate_section
end_define

begin_comment
comment|/* We don't want to change the symndx of a R_IHCONST reloc, since it    is actually an addend, not a symbol index at all.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|coff_a29k_adjust_symndx
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|,
name|ibfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|adjustedp
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|boolean
modifier|*
name|adjustedp
decl_stmt|;
block|{
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_IHCONST
condition|)
operator|*
name|adjustedp
operator|=
name|true
expr_stmt|;
else|else
operator|*
name|adjustedp
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_adjust_symndx
value|coff_a29k_adjust_symndx
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_decl_stmt
specifier|const
name|bfd_target
name|a29kcoff_big_vec
init|=
block|{
literal|"coff-a29k-big"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
comment|/* section flags */
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator|)
block|,
literal|'_'
block|,
comment|/* leading underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|}
decl_stmt|;
end_decl_stmt

end_unit

