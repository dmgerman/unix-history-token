begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Hitachi H8/300 COFF binaries.    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Written by Steve Chamberlain,<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"coff/h8300.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(1)
end_define

begin_comment
comment|/* special handling for H8/300 relocs.    We only come here for pcrel stuff and return normally if not an -r link.    When doing -r, we can't do any arithmetic for the pcrel stuff, because    the code in reloc.c assumes that we can manipulate the targets of    the pcrel branches.  This isn't so, since the H8/300 can do relaxing,     which means that the gap after the instruction may not be enough to    contain the offset required for the branch, so we have to use the only    the addend until the final link */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|special
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_RELBYTE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"8"
argument_list|,
name|false
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"16"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"32"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRBYTE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP8"
argument_list|,
name|false
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP16"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP32"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOVB1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"16/8"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOVB2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"8/16"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMP1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"16/pcrel"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMP2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"pcrecl/16"
argument_list|,
name|false
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMPL1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"24/pcrell"
argument_list|,
name|false
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMPL_B8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"pc8/24"
argument_list|,
name|false
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOVLB1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"24/8"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOVLB2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"8/24"
argument_list|,
name|false
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
comment|/* An indirect reference to a function.  This causes the function's address      to be added to the function vector in lo-mem and puts the address of      the function vector's entry in the jsr instruction.  */
name|HOWTO
argument_list|(
name|R_MEM_INDIRECT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"8/indirect"
argument_list|,
name|false
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn a howto into a reloc number */
end_comment

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|x
parameter_list|,
name|howto
parameter_list|)
define|\
value|{ x.r_type = select_reloc(howto); }
end_define

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|(H8300BADMAG(x)&& H8300HBADMAG(x))
end_define

begin_define
define|#
directive|define
name|H8300
value|1
end_define

begin_comment
comment|/* Customize coffcode.h */
end_comment

begin_define
define|#
directive|define
name|__A_MAGIC_SET__
end_define

begin_comment
comment|/* Code to swap in the reloc */
end_comment

begin_define
define|#
directive|define
name|SWAP_IN_RELOC_OFFSET
value|bfd_h_get_32
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_OFFSET
value|bfd_h_put_32
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_EXTRA
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|dst->r_stuff[0] = 'S'; \   dst->r_stuff[1] = 'C';
end_define

begin_function
specifier|static
name|int
name|select_reloc
parameter_list|(
name|howto
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
block|{
return|return
name|howto
operator|->
name|type
return|;
block|}
end_function

begin_comment
comment|/* Code to turn a r_type into a howto ptr, uses the above howto table    */
end_comment

begin_function
specifier|static
name|void
name|rtype2howto
parameter_list|(
name|internal
parameter_list|,
name|dst
parameter_list|)
name|arelent
modifier|*
name|internal
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|dst
decl_stmt|;
block|{
switch|switch
condition|(
name|dst
operator|->
name|r_type
condition|)
block|{
case|case
name|R_RELBYTE
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|0
expr_stmt|;
break|break;
case|case
name|R_RELWORD
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|R_RELLONG
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|R_PCRBYTE
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|R_PCRWORD
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|R_PCRLONG
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|5
expr_stmt|;
break|break;
case|case
name|R_MOVB1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|6
expr_stmt|;
break|break;
case|case
name|R_MOVB2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|7
expr_stmt|;
break|break;
case|case
name|R_JMP1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|R_JMP2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|9
expr_stmt|;
break|break;
case|case
name|R_JMPL1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|10
expr_stmt|;
break|break;
case|case
name|R_JMPL_B8
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|11
expr_stmt|;
break|break;
case|case
name|R_MOVLB1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|12
expr_stmt|;
break|break;
case|case
name|R_MOVLB2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|13
expr_stmt|;
break|break;
case|case
name|R_MEM_INDIRECT
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|14
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|internal
parameter_list|,
name|relocentry
parameter_list|)
value|rtype2howto(internal,relocentry)
end_define

begin_comment
comment|/* Perform any necessaru magic to the addend in a reloc entry */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ext_reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|cache_ptr->addend =  ext_reloc.r_offset;
end_define

begin_define
define|#
directive|define
name|RELOC_PROCESSING
parameter_list|(
name|relent
parameter_list|,
name|reloc
parameter_list|,
name|symbols
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|)
define|\
value|reloc_processing(relent, reloc, symbols, abfd, section)
end_define

begin_function
specifier|static
name|void
name|reloc_processing
parameter_list|(
name|relent
parameter_list|,
name|reloc
parameter_list|,
name|symbols
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|)
name|arelent
modifier|*
name|relent
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|relent
operator|->
name|address
operator|=
name|reloc
operator|->
name|r_vaddr
expr_stmt|;
name|rtype2howto
argument_list|(
name|relent
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|reloc
operator|->
name|r_symndx
operator|)
operator|>
literal|0
condition|)
block|{
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|obj_convert
argument_list|(
name|abfd
argument_list|)
index|[
name|reloc
operator|->
name|r_symndx
index|]
expr_stmt|;
block|}
else|else
block|{
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|relent
operator|->
name|addend
operator|=
name|reloc
operator|->
name|r_offset
expr_stmt|;
name|relent
operator|->
name|address
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
comment|/*  relent->section = 0;*/
block|}
end_function

begin_function
specifier|static
name|int
name|h8300_reloc16_estimate
parameter_list|(
name|abfd
parameter_list|,
name|input_section
parameter_list|,
name|reloc
parameter_list|,
name|shrink
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|shrink
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
comment|/* The address of the thing to be relocated will have moved back by     the size of the shrink  - but we don't change reloc->address here,    since we need it to know where the relocation lives in the source    uncooked section */
comment|/*  reloc->address -= shrink;   conceptual */
name|bfd_vma
name|address
init|=
name|reloc
operator|->
name|address
operator|-
name|shrink
decl_stmt|;
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_MOVB2
case|:
case|case
name|R_JMP2
case|:
name|shrink
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* Thing is a move one byte */
case|case
name|R_MOVB1
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0xff00
condition|)
block|{
comment|/* Change the reloc type from 16bit, possible 8 to 8bit 	     possible 16 */
name|reloc
operator|->
name|howto
operator|=
name|reloc
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* The place to relc moves back by one */
comment|/* This will be two bytes smaller in the long run */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* This is the 24 bit branch which could become an 8 bitter,         the relocation points to the first byte of the insn, not the        actual data */
case|case
name|R_JMPL1
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|dot
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
expr_stmt|;
comment|/* See if the address we're looking at within 127 bytes of where 	 we are, if so then we can use a small branch rather than the 	 jump we were going to */
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
if|if
condition|(
operator|-
literal|120
operator|<
operator|(
name|long
operator|)
name|gap
operator|&&
operator|(
name|long
operator|)
name|gap
operator|<
literal|120
condition|)
block|{
comment|/* Change the reloc type from 24bit, possible 8 to 8bit 	     possible 32 */
name|reloc
operator|->
name|howto
operator|=
name|reloc
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* This will be two bytes smaller in the long run */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_JMP1
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|dot
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
expr_stmt|;
comment|/* See if the address we're looking at within 127 bytes of where 	 we are, if so then we can use a small branch rather than the 	 jump we were going to */
name|gap
operator|=
name|value
operator|-
operator|(
name|dot
operator|-
name|shrink
operator|)
expr_stmt|;
if|if
condition|(
operator|-
literal|120
operator|<
operator|(
name|long
operator|)
name|gap
operator|&&
operator|(
name|long
operator|)
name|gap
operator|<
literal|120
condition|)
block|{
comment|/* Change the reloc type from 16bit, possible 8 to 8bit 	     possible 16 */
name|reloc
operator|->
name|howto
operator|=
name|reloc
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* The place to relc moves back by one */
comment|/* This will be two bytes smaller in the long run */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|shrink
return|;
block|}
end_function

begin_comment
comment|/* First phase of a relaxing link */
end_comment

begin_comment
comment|/* Reloc types    large		small    R_MOVB1		R_MOVB2		mov.b with 16bit or 8 bit address    R_JMP1		R_JMP2		jmp or pcrel branch    R_JMPL1		R_JMPL_B8	24jmp or pcrel branch    R_MOVLB1		R_MOVLB2	24 or 8 bit reloc for mov.b  */
end_comment

begin_function
specifier|static
name|void
name|h8300_reloc16_extra_cases
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|reloc
parameter_list|,
name|data
parameter_list|,
name|src_ptr
parameter_list|,
name|dst_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
modifier|*
name|src_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|dst_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|src_address
init|=
operator|*
name|src_ptr
decl_stmt|;
name|unsigned
name|int
name|dst_address
init|=
operator|*
name|dst_ptr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
comment|/* A 24 bit branch which could be a 8 bit pcrel, really pointing to 	 the byte before the 24bit hole, so we can treat it as a 32bit pointer */
case|case
name|R_PCRBYTE
case|:
block|{
name|bfd_vma
name|dot
init|=
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|int
name|gap
init|=
operator|(
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|-
name|dot
operator|)
decl_stmt|;
if|if
condition|(
name|gap
operator|>
literal|127
operator|||
name|gap
operator|<
operator|-
literal|128
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|gap
operator|&=
operator|~
literal|1
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|R_PCRWORD
case|:
block|{
name|bfd_vma
name|dot
init|=
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|int
name|gap
init|=
operator|(
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|-
name|dot
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gap
operator|>
literal|32767
operator|||
name|gap
operator|<
operator|-
literal|32768
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
case|case
name|R_MEM_INDIRECT
case|:
comment|/* Temporary  */
case|case
name|R_RELBYTE
case|:
block|{
name|unsigned
name|int
name|gap
init|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|gap
operator|<
literal|0xff
operator|||
operator|(
name|gap
operator|>=
literal|0x0000ff00
operator|&&
name|gap
operator|<=
literal|0x0000ffff
operator|)
operator|||
operator|(
name|gap
operator|>=
literal|0x00ffff00
operator|&&
name|gap
operator|<=
literal|0x00ffffff
operator|)
operator|||
operator|(
name|gap
operator|>=
literal|0xffffff00
operator|&&
name|gap
operator|<=
literal|0xffffffff
operator|)
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_JMP1
case|:
comment|/* A relword which would have like to have been a pcrel */
case|case
name|R_MOVB1
case|:
comment|/* A relword which would like to have been modified but 	     didn't make it */
case|case
name|R_RELWORD
case|:
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|R_RELLONG
case|:
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|R_MOVB2
case|:
comment|/* Special relaxed type, there will be a gap between where we 	     get stuff from and where we put stuff to now 	 	     for a mov.b @aa:16 -> mov.b @aa:8 	     opcode 0x6a 0x0y offset 	     ->     0x2y off 	     */
if|if
condition|(
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|!=
literal|0x6a
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|data
index|[
name|src_address
index|]
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Src is memory */
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|=
operator|(
name|data
index|[
name|src_address
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x20
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
comment|/* Src is reg */
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|=
operator|(
name|data
index|[
name|src_address
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x30
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* the offset must fit ! after all, what was all the relaxing 	     about ? */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
comment|/* Note the magic - src goes up by two bytes, but dst by only 	     one */
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|R_JMP2
case|:
comment|/* Speciial relaxed type */
block|{
name|bfd_vma
name|dot
init|=
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|int
name|gap
init|=
operator|(
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|-
name|dot
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|gap
operator|&
operator|~
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|gap
operator|&
literal|0xff00
operator|)
operator|!=
literal|0xff00
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|0x5e
case|:
comment|/* jsr -> bsr */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a
case|:
comment|/* jmp ->bra */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x40
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|R_JMPL_B8
case|:
comment|/* 24 bit branch which is now 8 bits */
comment|/* Speciial relaxed type */
block|{
name|bfd_vma
name|dot
init|=
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|int
name|gap
init|=
operator|(
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|-
name|dot
operator|-
literal|2
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|gap
operator|&
operator|~
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|gap
operator|&
literal|0xff00
operator|)
operator|!=
literal|0xff00
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|data
index|[
name|src_address
index|]
condition|)
block|{
case|case
literal|0x5e
case|:
comment|/* jsr -> bsr */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a
case|:
comment|/* jmp ->bra */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x40
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xde
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
break|break;
block|}
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
case|case
name|R_JMPL1
case|:
block|{
name|int
name|v
init|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|int
name|o
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
decl_stmt|;
name|v
operator|=
operator|(
name|v
operator|&
literal|0x00ffffff
operator|)
operator||
operator|(
name|o
operator|&
literal|0xff000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|v
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
comment|/* A 24 bit mov  which could be an 8 bit move, really pointing to 	 the byte before the 24bit hole, so we can treat it as a 32bit pointer */
case|case
name|R_MOVLB1
case|:
block|{
name|int
name|v
init|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|int
name|o
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
decl_stmt|;
name|v
operator|=
operator|(
name|v
operator|&
literal|0x00ffffff
operator|)
operator||
operator|(
name|o
operator|&
literal|0xff000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|v
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
operator|*
name|src_ptr
operator|=
name|src_address
expr_stmt|;
operator|*
name|dst_ptr
operator|=
name|dst_address
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_reloc16_extra_cases
value|h8300_reloc16_extra_cases
end_define

begin_define
define|#
directive|define
name|coff_reloc16_estimate
value|h8300_reloc16_estimate
end_define

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_undef
undef|#
directive|undef
name|coff_bfd_get_relocated_section_contents
end_undef

begin_undef
undef|#
directive|undef
name|coff_bfd_relax_section
end_undef

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
define|\
value|bfd_coff_reloc16_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|bfd_coff_reloc16_relax_section
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|h8300coff_vec
init|=
block|{
literal|"coff-h8300"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|'_'
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

end_unit

