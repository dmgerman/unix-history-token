begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for HP PA-RISC ELF files.    Copyright (C) 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.     Written by  	Center for Software Science 	Department of Computer Science 	University of Utah  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_comment
comment|/* The internal type of a symbol table extension entry.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|symext_entryS
typedef|;
end_typedef

begin_comment
comment|/* The external type of a symbol table extension entry.  */
end_comment

begin_define
define|#
directive|define
name|ELF32_PARISC_SX_SIZE
value|(4)
end_define

begin_define
define|#
directive|define
name|ELF32_PARISC_SX_GET
parameter_list|(
name|bfd
parameter_list|,
name|addr
parameter_list|)
value|bfd_h_get_32 ((bfd), (addr))
end_define

begin_define
define|#
directive|define
name|ELF32_PARISC_SX_PUT
parameter_list|(
name|bfd
parameter_list|,
name|val
parameter_list|,
name|addr
parameter_list|)
define|\
value|bfd_h_put_32 ((bfd), (val), (addr))
end_define

begin_comment
comment|/* HPPA symbol table extension entry types */
end_comment

begin_enum
enum|enum
name|elf32_hppa_symextn_types
block|{
name|PARISC_SXT_NULL
block|,
name|PARISC_SXT_SYMNDX
block|,
name|PARISC_SXT_ARG_RELOC
block|, }
enum|;
end_enum

begin_comment
comment|/* These macros compose and decompose the value of a symextn entry:     entry_type = ELF32_PARISC_SX_TYPE(word);    entry_value = ELF32_PARISC_SX_VAL(word);    word = ELF32_PARISC_SX_WORD(type,val);  */
end_comment

begin_define
define|#
directive|define
name|ELF32_PARISC_SX_TYPE
parameter_list|(
name|p
parameter_list|)
value|((p)>> 24)
end_define

begin_define
define|#
directive|define
name|ELF32_PARISC_SX_VAL
parameter_list|(
name|p
parameter_list|)
value|((p)& 0xFFFFFF)
end_define

begin_define
define|#
directive|define
name|ELF32_PARISC_SX_WORD
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|)
value|(((type)<< 24) + (val& 0xFFFFFF))
end_define

begin_comment
comment|/* The following was added facilitate implementation of the .hppa_symextn    section.  This section is built after the symbol table is built in the    elf_write_object_contents routine (called from bfd_close).  It is built    so late because it requires information that is not known until    the symbol and string table sections have been allocated, and    the symbol table has been built. */
end_comment

begin_define
define|#
directive|define
name|SYMEXTN_SECTION_NAME
value|".PARISC.symext"
end_define

begin_struct
struct|struct
name|symext_chain
block|{
name|symext_entryS
name|entry
decl_stmt|;
name|struct
name|symext_chain
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|symext_chain
name|symext_chainS
typedef|;
end_typedef

begin_comment
comment|/* We use three different hash tables to hold information for    linking PA ELF objects.     The first is the elf32_hppa_link_hash_table which is derived    from the standard ELF linker hash table.  We use this as a place to    attach other hash tables and static information.     The second is the stub hash table which is derived from the    base BFD hash table.  The stub hash table holds the information    necessary to build the linker stubs during a link.     The last hash table keeps track of argument location information needed    to build hash tables.  Each function with nonzero argument location    bits will have an entry in this table.  */
end_comment

begin_comment
comment|/* Hash table for linker stubs.  */
end_comment

begin_struct
struct|struct
name|elf32_hppa_stub_hash_entry
block|{
comment|/* Base hash table entry structure, we can get the name of the stub      (and thus know exactly what actions it performs) from the base      hash table entry.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Offset of the beginning of this stub.  */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* Given the symbol's value and its section we can determine its final      value when building the stubs (so the stub knows where to jump.  */
name|symvalue
name|target_value
decl_stmt|;
name|asection
modifier|*
name|target_section
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_hppa_stub_hash_table
block|{
comment|/* The hash table itself.  */
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
comment|/* The stub BFD.  */
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
comment|/* Where to place the next stub.  */
name|bfd_byte
modifier|*
name|location
decl_stmt|;
comment|/* Current offset in the stub section.  */
name|unsigned
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash table for argument location information.  */
end_comment

begin_struct
struct|struct
name|elf32_hppa_args_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* The argument location bits for this entry.  */
name|int
name|arg_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_hppa_args_hash_table
block|{
comment|/* The hash table itself.  */
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_hppa_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_hppa_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|elf32_hppa_stub_hash_table
modifier|*
name|stub_hash_table
decl_stmt|;
comment|/* The argument relocation bits hash table.  */
name|struct
name|elf32_hppa_args_hash_table
modifier|*
name|args_hash_table
decl_stmt|;
comment|/* A count of the number of output symbols.  */
name|unsigned
name|int
name|output_symbol_count
decl_stmt|;
comment|/* Stuff so we can handle DP relative relocations.  */
name|long
name|global_value
decl_stmt|;
name|int
name|global_sym_defined
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME.  */
end_comment

begin_define
define|#
directive|define
name|ARGUMENTS
value|0
end_define

begin_define
define|#
directive|define
name|RETURN_VALUE
value|1
end_define

begin_comment
comment|/* The various argument relocations that may be performed.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* No relocation.  */
name|NO
block|,
comment|/* Relocate 32 bits from GR to FP register.  */
name|GF
block|,
comment|/* Relocate 64 bits from a GR pair to FP pair.  */
name|GD
block|,
comment|/* Relocate 32 bits from FP to GR.  */
name|FG
block|,
comment|/* Relocate 64 bits from FP pair to GR pair.  */
name|DG
block|, }
name|arg_reloc_type
typedef|;
end_typedef

begin_comment
comment|/* What is being relocated (eg which argument or the return value).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ARG0
block|,
name|ARG1
block|,
name|ARG2
block|,
name|ARG3
block|,
name|RET
block|, }
name|arg_reloc_location
typedef|;
end_typedef

begin_comment
comment|/* ELF32/HPPA relocation support  	This file contains ELF32/HPPA relocation support as specified 	in the Stratus FTX/Golf Object File Format (SED-1762) dated 	February 1994.  */
end_comment

begin_include
include|#
directive|include
file|"elf32-hppa.h"
end_include

begin_include
include|#
directive|include
file|"hppa_stubs.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|hppa_elf_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|hppa_elf_relocate_insn
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|long
operator|,
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|hppa_elf_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elf_hppa_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_backend_symbol_table_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|elf_symbol_type
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf32_hppa_backend_begin_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf32_hppa_backend_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_entry_to_symext_chain
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|symext_chainS
operator|*
operator|*
operator|,
name|symext_chainS
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_hppa_tc_make_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|symext_chainS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|hppa_elf_is_local_label
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_hppa_bfd_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_hppa_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_hppa_stub_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_hppa_args_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_stub_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf32_hppa_stub_hash_table
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
operator|(
operator|*
operator|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_build_one_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_read_symext_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
expr|struct
name|elf32_hppa_args_hash_table
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|elf32_hppa_size_of_stub
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_arg_reloc_needed
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|arg_reloc_type
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf32_hppa_name_of_stub
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_size_symext
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_link_output_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ELF/PA relocation howto entries.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_hppa_howto_table
index|[
name|ELF_HOWTO_TABLE_SIZE
index|]
init|=
block|{
block|{
name|R_PARISC_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_NONE"
block|}
block|,
block|{
name|R_PARISC_DIR32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DIR32"
block|}
block|,
block|{
name|R_PARISC_DIR21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DIR21L"
block|}
block|,
block|{
name|R_PARISC_DIR17R
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DIR17R"
block|}
block|,
block|{
name|R_PARISC_DIR17F
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DIR17F"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DIR14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DIR14R"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_PCREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PCREL21L"
block|}
block|,
block|{
name|R_PARISC_PCREL17R
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PCREL17R"
block|}
block|,
block|{
name|R_PARISC_PCREL17F
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PCREL17F"
block|}
block|,
block|{
name|R_PARISC_PCREL17C
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PCREL17C"
block|}
block|,
block|{
name|R_PARISC_PCREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PCREL14R"
block|}
block|,
block|{
name|R_PARISC_PCREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|true
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PCREL14F"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DPREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DPREL21L"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DPREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DPREL14R"
block|}
block|,
block|{
name|R_PARISC_DPREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DPREL14F"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DLTREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DLTREL21L"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DLTREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DLTREL14R"
block|}
block|,
block|{
name|R_PARISC_DLTREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DLTREL14F"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DLTIND21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DLTIND21L"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DLTIND14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DLTIND14R"
block|}
block|,
block|{
name|R_PARISC_DLTIND14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_DLTIND14F"
block|}
block|,
block|{
name|R_PARISC_SETBASE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_SETBASE"
block|}
block|,
block|{
name|R_PARISC_BASEREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_BASEREL32"
block|}
block|,
block|{
name|R_PARISC_BASEREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_BASEREL21L"
block|}
block|,
block|{
name|R_PARISC_BASEREL17R
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_BASEREL17R"
block|}
block|,
block|{
name|R_PARISC_BASEREL17F
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_BASEREL17F"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_BASEREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_BASEREL14R"
block|}
block|,
block|{
name|R_PARISC_BASEREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_BASEREL14F"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_TEXTREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_TEXTREL32"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_DATAREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_PLABEL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PLABEL32"
block|}
block|,
block|{
name|R_PARISC_PLABEL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PLABEL21L"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_PLABEL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PLABEL14R"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_PLTIND21L
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PLTIND21L"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|,
block|{
name|R_PARISC_PLTIND14R
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PLTIND14R"
block|}
block|,
block|{
name|R_PARISC_PLTIND14F
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_PLTIND14F"
block|}
block|,
block|{
name|R_PARISC_COPY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_COPY"
block|}
block|,
block|{
name|R_PARISC_GLOB_DAT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_GLOB_DAT"
block|}
block|,
block|{
name|R_PARISC_JMP_SLOT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_JMP_SLOT"
block|}
block|,
block|{
name|R_PARISC_RELATIVE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|hppa_elf_reloc
block|,
literal|"R_PARISC_RELATIVE"
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|NULL
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where (what register type) is an argument comming from?  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|AR_NO
block|,
name|AR_GR
block|,
name|AR_FR
block|,
name|AR_FU
block|,
name|AR_FPDBL1
block|,
name|AR_FPDBL2
block|, }
name|arg_location
typedef|;
end_typedef

begin_comment
comment|/* Horizontal represents the callee's argument location information,    vertical represents caller's argument location information.  Value at a    particular X,Y location represents what (if any) argument relocation    needs to be performed to make caller and callee agree.  */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|arg_reloc_type
name|arg_mismatches
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|NO
block|,
name|GF
block|,
name|NO
block|,
name|GD
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|FG
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|DG
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|DG
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, but reversed for the return value.  */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|arg_reloc_type
name|ret_mismatches
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|NO
block|,
name|FG
block|,
name|NO
block|,
name|DG
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|GF
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|GD
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
name|NO
block|,
name|GD
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc static crud for symbol extension records.  */
end_comment

begin_decl_stmt
specifier|static
name|symext_chainS
modifier|*
name|symext_rootP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symext_chainS
modifier|*
name|symext_lastP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|symext_chain_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: We should be able to try this static variable!  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|symextn_contents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For linker stub hash tables.  */
end_comment

begin_define
define|#
directive|define
name|elf32_hppa_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct elf32_hppa_stub_hash_entry *) \    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_define
define|#
directive|define
name|elf32_hppa_stub_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_hash_traverse \    (&(table)->root, \     (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func), \     (info)))
end_define

begin_comment
comment|/* For linker args hash tables.  */
end_comment

begin_define
define|#
directive|define
name|elf32_hppa_args_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct elf32_hppa_args_hash_entry *) \    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_define
define|#
directive|define
name|elf32_hppa_args_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_hash_traverse \    (&(table)->root, \     (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func), \     (info)))
end_define

begin_define
define|#
directive|define
name|elf32_hppa_args_hash_table_init
parameter_list|(
name|table
parameter_list|,
name|newfunc
parameter_list|)
define|\
value|(bfd_hash_table_init \    (&(table)->root, \     (struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *, \ 					 struct bfd_hash_table *, \ 					 const char *))) (newfunc)))
end_define

begin_comment
comment|/* For HPPA linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf32_hppa_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct elf32_hppa_link_hash_entry *)				\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_define
define|#
directive|define
name|elf32_hppa_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the PA ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf32_hppa_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf32_hppa_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Extract specific argument location bits for WHICH from    the full argument location in AR.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_ARBITS
parameter_list|(
name|ar
parameter_list|,
name|which
parameter_list|)
value|((ar)>> (8 - ((which) * 2)))& 3
end_define

begin_comment
comment|/* Assorted hash table functions.  */
end_comment

begin_comment
comment|/* Initialize an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_hppa_stub_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_stub_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize a stub hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf32_hppa_stub_hash_table_init
argument_list|(
name|table
argument_list|,
name|stub_bfd
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|elf32_hppa_stub_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|table
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|location
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|stub_bfd
operator|=
name|stub_bfd
expr_stmt|;
return|return
operator|(
name|bfd_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|newfunc
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Initialize an entry in the argument location hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_hppa_args_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf32_hppa_args_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf32_hppa_args_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_args_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_args_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_args_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
comment|/* Initialize the local fields.  */
if|if
condition|(
name|ret
condition|)
name|ret
operator|->
name|arg_bits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create the derived linker hash table.  The PA ELF port uses the derived    hash table to keep information specific to the PA ELF linker (without    using static variables).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_hppa_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|stub_hash_table
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|args_hash_table
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|output_symbol_count
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|global_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|global_sym_defined
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Relocate the given INSN given the various input parameters.     FIXME: endianness and sizeof (long) issues abound here.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hppa_elf_relocate_insn
parameter_list|(
name|abfd
parameter_list|,
name|input_sect
parameter_list|,
name|insn
parameter_list|,
name|address
parameter_list|,
name|sym_value
parameter_list|,
name|r_addend
parameter_list|,
name|r_format
parameter_list|,
name|r_field
parameter_list|,
name|pcrel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|input_sect
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|address
decl_stmt|;
name|long
name|sym_value
decl_stmt|;
name|long
name|r_addend
decl_stmt|;
name|unsigned
name|long
name|r_format
decl_stmt|;
name|unsigned
name|long
name|r_field
decl_stmt|;
name|unsigned
name|long
name|pcrel
decl_stmt|;
block|{
name|unsigned
name|char
name|opcode
init|=
name|get_opcode
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|long
name|constant_value
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|LDO
case|:
case|case
name|LDB
case|:
case|case
name|LDH
case|:
case|case
name|LDW
case|:
case|case
name|LDWM
case|:
case|case
name|STB
case|:
case|case
name|STH
case|:
case|case
name|STW
case|:
case|case
name|STWM
case|:
case|case
name|COMICLR
case|:
case|case
name|SUBI
case|:
case|case
name|ADDIT
case|:
case|case
name|ADDI
case|:
case|case
name|LDIL
case|:
case|case
name|ADDIL
case|:
name|constant_value
operator|=
name|HPPA_R_CONSTANT
argument_list|(
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
name|sym_value
operator|-=
name|address
expr_stmt|;
name|sym_value
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
name|constant_value
argument_list|,
name|r_field
argument_list|)
expr_stmt|;
return|return
name|hppa_rebuild_insn
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|sym_value
argument_list|,
name|r_format
argument_list|)
return|;
case|case
name|BL
case|:
case|case
name|BE
case|:
case|case
name|BLE
case|:
comment|/* XXX computing constant_value is not needed??? */
name|constant_value
operator|=
name|assemble_17
argument_list|(
operator|(
name|insn
operator|&
literal|0x001f0000
operator|)
operator|>>
literal|16
argument_list|,
operator|(
name|insn
operator|&
literal|0x00001ffc
operator|)
operator|>>
literal|2
argument_list|,
name|insn
operator|&
literal|1
argument_list|)
expr_stmt|;
name|constant_value
operator|=
operator|(
name|constant_value
operator|<<
literal|15
operator|)
operator|>>
literal|15
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
block|{
name|sym_value
operator|-=
name|address
operator|+
name|input_sect
operator|->
name|output_offset
operator|+
name|input_sect
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|sym_value
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
operator|-
literal|8
argument_list|,
name|r_field
argument_list|)
expr_stmt|;
block|}
else|else
name|sym_value
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
name|constant_value
argument_list|,
name|r_field
argument_list|)
expr_stmt|;
return|return
name|hppa_rebuild_insn
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|sym_value
operator|>>
literal|2
argument_list|,
name|r_format
argument_list|)
return|;
default|default:
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
name|constant_value
operator|=
name|HPPA_R_CONSTANT
argument_list|(
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
name|sym_value
operator|-=
name|address
expr_stmt|;
return|return
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
name|constant_value
argument_list|,
name|r_field
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Relocate an HPPA ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|howto
operator|=
name|elf_hppa_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
operator|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|?
literal|0
else|:
name|sym
operator|->
name|st_value
operator|)
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'\0'
condition|)
name|sym_name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
block|}
comment|/* If args_hash_table is NULL, then we have encountered some 	 kind of link error (ex. undefined symbols).  Do not try to 	 apply any relocations, continue the loop so we can notify 	 the user of several errors in a single attempted link.  */
if|if
condition|(
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|args_hash_table
operator|==
name|NULL
condition|)
continue|continue;
name|r
operator|=
name|elf32_hppa_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|,
name|sym_sec
argument_list|,
name|sym_name
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
comment|/* This can happen for DP relative relocs if $global$ is 	       undefined.  This is a panic situation so we don't try 	       to continue.  */
case|case
name|bfd_reloc_undefined
case|:
case|case
name|bfd_reloc_notsupported
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
literal|"$global$"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|false
return|;
case|case
name|bfd_reloc_dangerous
case|:
block|{
comment|/* We use this return value to indicate that we performed 		   a "dangerous" relocation.  This doesn't mean we did 		   the wrong thing, it just means there may be some cleanup 		   that needs to be done here.  		   In particular we had to swap the last call insn and its 		   delay slot.  If the delay slot insn needed a relocation, 		   then we'll need to adjust the next relocation entry's 		   offset to account for the fact that the insn moved.  		   This hair wouldn't be necessary if we inserted stubs 		   between procedures and used a "bl" to get to the stub.  */
if|if
condition|(
name|rel
operator|!=
name|relend
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|next_rel
init|=
name|rel
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|+
literal|4
operator|==
name|next_rel
operator|->
name|r_offset
condition|)
name|next_rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
block|}
break|break;
block|}
default|default:
case|case
name|bfd_reloc_outofrange
case|:
case|case
name|bfd_reloc_overflow
case|:
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return one (or more) BFD relocations which implement the base    relocation with modifications based on format and field.  */
end_comment

begin_function
name|elf32_hppa_reloc_type
modifier|*
modifier|*
name|hppa_elf_gen_reloc_type
parameter_list|(
name|abfd
parameter_list|,
name|base_type
parameter_list|,
name|format
parameter_list|,
name|field
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|elf32_hppa_reloc_type
name|base_type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|field
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|elf32_hppa_reloc_type
modifier|*
name|finaltype
decl_stmt|;
name|elf32_hppa_reloc_type
modifier|*
modifier|*
name|final_types
decl_stmt|;
comment|/* Allocate slots for the BFD relocation.  */
name|final_types
operator|=
operator|(
name|elf32_hppa_reloc_type
operator|*
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|elf32_hppa_reloc_type
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_types
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Allocate space for the relocation itself.  */
name|finaltype
operator|=
operator|(
name|elf32_hppa_reloc_type
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|elf32_hppa_reloc_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finaltype
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Some reasonable defaults.  */
name|final_types
index|[
literal|0
index|]
operator|=
name|finaltype
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
define|#
directive|define
name|final_type
value|finaltype[0]
name|final_type
operator|=
name|base_type
expr_stmt|;
comment|/* Just a tangle of nested switch statements to deal with the braindamage      that a different field selector means a completely different relocation      for PA ELF.  */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|R_HPPA
case|:
case|case
name|R_HPPA_ABS_CALL
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|14
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR14R
expr_stmt|;
break|break;
case|case
name|e_rtsel
case|:
name|final_type
operator|=
name|R_PARISC_DLTREL14R
expr_stmt|;
break|break;
case|case
name|e_tsel
case|:
name|final_type
operator|=
name|R_PARISC_DLTREL14F
expr_stmt|;
break|break;
case|case
name|e_rpsel
case|:
name|final_type
operator|=
name|R_PARISC_PLABEL14R
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|17
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR17F
expr_stmt|;
break|break;
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR17R
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|21
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_lsel
case|:
case|case
name|e_lrsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR21L
expr_stmt|;
break|break;
case|case
name|e_ltsel
case|:
name|final_type
operator|=
name|R_PARISC_DLTREL21L
expr_stmt|;
break|break;
case|case
name|e_lpsel
case|:
name|final_type
operator|=
name|R_PARISC_PLABEL21L
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|32
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR32
expr_stmt|;
break|break;
case|case
name|e_psel
case|:
name|final_type
operator|=
name|R_PARISC_PLABEL32
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|R_HPPA_GOTOFF
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|14
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
name|final_type
operator|=
name|R_PARISC_DPREL14R
expr_stmt|;
break|break;
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DPREL14F
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|21
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_lrsel
case|:
case|case
name|e_lsel
case|:
name|final_type
operator|=
name|R_PARISC_DPREL21L
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|R_HPPA_PCREL_CALL
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|14
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL14R
expr_stmt|;
break|break;
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL14F
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|17
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL17R
expr_stmt|;
break|break;
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL17F
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|21
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_lsel
case|:
case|case
name|e_lrsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL21L
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
default|default:
return|return
name|NULL
return|;
block|}
return|return
name|final_types
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|final_type
end_undef

begin_comment
comment|/* Set the contents of a particular section at a particular location.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
comment|/* Ignore write requests for the symbol extension section until we've      had the chance to rebuild it ourselves.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".PARISC.symextn"
argument_list|)
operator|&&
operator|!
name|symext_chain_size
condition|)
return|return
name|true
return|;
else|else
return|return
name|_bfd_elf_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Translate from an elf into field into a howto relocation pointer.  */
end_comment

begin_function
specifier|static
name|void
name|elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_hppa_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Actually perform a relocation.  NOTE this is (mostly) superceeded    by elf32_hppa_bfd_final_link_relocate which is called by the new    fast linker.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|hppa_elf_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* It is no longer valid to call hppa_elf_reloc when creating      a final executable.  */
if|if
condition|(
name|output_bfd
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* Work around lossage in generic elf code to write relocations. 	 (maps different section symbols into the same symbol index).  */
if|if
condition|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|&&
name|symbol_in
operator|->
name|section
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
name|symbol_in
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
else|else
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Unsupported call to hppa_elf_reloc"
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_comment
comment|/* Actually perform a relocation as part of a final link.  This can get    rather hairy when linker stubs are needed.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_hppa_bfd_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|offset
parameter_list|,
name|value
parameter_list|,
name|addend
parameter_list|,
name|info
parameter_list|,
name|sym_sec
parameter_list|,
name|sym_name
parameter_list|,
name|is_local
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|int
name|is_local
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|unsigned
name|long
name|r_format
init|=
name|howto
operator|->
name|bitsize
decl_stmt|;
name|unsigned
name|long
name|r_field
init|=
name|e_fsel
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
name|boolean
name|r_pcrel
init|=
name|howto
operator|->
name|pc_relative
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* Make sure we have a value for $global$.  FIXME isn't this effectively      just like the gp pointer on MIPS?  Can we use those routines for this      purpose?  */
if|if
condition|(
operator|!
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|global_sym_defined
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"$global$"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If there isn't a $global$, then we're in deep trouble.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
comment|/* If $global$ isn't a defined symbol, then we're still in deep 	 trouble.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|global_value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|global_sym_defined
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_NONE
case|:
break|break;
case|case
name|R_PARISC_DIR32
case|:
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_PCREL17C
case|:
name|r_field
operator|=
name|e_fsel
expr_stmt|;
goto|goto
name|do_basic_type_1
goto|;
case|case
name|R_PARISC_DIR21L
case|:
case|case
name|R_PARISC_PCREL21L
case|:
name|r_field
operator|=
name|e_lrsel
expr_stmt|;
goto|goto
name|do_basic_type_1
goto|;
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_PCREL17R
case|:
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_PCREL14R
case|:
name|r_field
operator|=
name|e_rrsel
expr_stmt|;
goto|goto
name|do_basic_type_1
goto|;
comment|/* For all the DP relative relocations, we need to examine the symbol's        section.  If it's a code section, then "data pointer relative" makes        no sense.  In that case we don't adjust the "value", and for 21 bit        addil instructions, we change the source addend register from %dp to        %r0.  */
case|case
name|R_PARISC_DPREL21L
case|:
name|r_field
operator|=
name|e_lrsel
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfc000000
operator|)
operator|>>
literal|26
operator|==
literal|0xa
operator|&&
operator|(
name|insn
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
operator|==
literal|0x1b
condition|)
name|insn
operator|&=
operator|~
literal|0x03e00000
expr_stmt|;
block|}
else|else
name|value
operator|-=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|global_value
expr_stmt|;
goto|goto
name|do_basic_type_1
goto|;
case|case
name|R_PARISC_DPREL14R
case|:
name|r_field
operator|=
name|e_rrsel
expr_stmt|;
if|if
condition|(
operator|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|value
operator|-=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|global_value
expr_stmt|;
goto|goto
name|do_basic_type_1
goto|;
case|case
name|R_PARISC_DPREL14F
case|:
name|r_field
operator|=
name|e_fsel
expr_stmt|;
if|if
condition|(
operator|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|value
operator|-=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|global_value
expr_stmt|;
goto|goto
name|do_basic_type_1
goto|;
comment|/* These cases are separate as they may involve a lot more work        to deal with linker stubs.  */
case|case
name|R_PARISC_PLABEL32
case|:
case|case
name|R_PARISC_PLABEL21L
case|:
case|case
name|R_PARISC_PLABEL14R
case|:
case|case
name|R_PARISC_PCREL17F
case|:
block|{
name|bfd_vma
name|location
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|caller_args
decl_stmt|,
name|callee_args
decl_stmt|;
name|arg_reloc_type
name|arg_reloc_types
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_table
modifier|*
name|args_hash_table
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_entry
modifier|*
name|args_hash
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|stub_name
decl_stmt|;
comment|/* Get the field selector right.  We'll need it in a minute.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL17F
operator|||
name|r_type
operator|==
name|R_PARISC_PLABEL32
condition|)
name|r_field
operator|=
name|e_fsel
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLABEL21L
condition|)
name|r_field
operator|=
name|e_lrsel
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLABEL14R
condition|)
name|r_field
operator|=
name|e_rrsel
expr_stmt|;
comment|/* Find out where we are and where we're going.  */
name|location
operator|=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Now look for the argument relocation bits associated with the 	   target.  */
name|len
operator|=
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
name|len
operator|+=
literal|9
expr_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_name
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
comment|/* Local symbols have unique IDs.  */
if|if
condition|(
name|is_local
condition|)
name|sprintf
argument_list|(
name|new_name
operator|+
name|len
operator|-
literal|10
argument_list|,
literal|"_%08x"
argument_list|,
operator|(
name|int
operator|)
name|sym_sec
argument_list|)
expr_stmt|;
name|args_hash_table
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|args_hash_table
expr_stmt|;
name|args_hash
operator|=
name|elf32_hppa_args_hash_lookup
argument_list|(
name|args_hash_table
argument_list|,
name|new_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_hash
operator|==
name|NULL
condition|)
name|callee_args
operator|=
literal|0
expr_stmt|;
else|else
name|callee_args
operator|=
name|args_hash
operator|->
name|arg_bits
expr_stmt|;
comment|/* If this is a CALL relocation, then get the caller's bits 	   from the addend.  Else use the magic 0x155 value for PLABELS.  	   Also we don't care about the destination (value) for PLABELS.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL17F
condition|)
name|caller_args
operator|=
name|HPPA_R_ARG_RELOC
argument_list|(
name|addend
argument_list|)
expr_stmt|;
else|else
block|{
name|caller_args
operator|=
literal|0x155
expr_stmt|;
name|location
operator|=
name|value
expr_stmt|;
block|}
comment|/* Any kind of linker stub needed?  */
if|if
condition|(
operator|(
call|(
name|int
call|)
argument_list|(
name|value
operator|-
name|location
argument_list|)
operator|>
literal|0x3ffff
operator|)
operator|||
operator|(
call|(
name|int
call|)
argument_list|(
name|value
operator|-
name|location
argument_list|)
operator|<
operator|(
name|int
operator|)
literal|0xfffc0000
operator|)
operator|||
name|elf32_hppa_arg_reloc_needed
argument_list|(
name|caller_args
argument_list|,
name|callee_args
argument_list|,
name|arg_reloc_types
argument_list|)
condition|)
block|{
name|struct
name|elf32_hppa_stub_hash_table
modifier|*
name|stub_hash_table
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_hash
decl_stmt|;
name|asection
modifier|*
name|stub_section
decl_stmt|;
comment|/* Build a name for the stub.  */
name|len
operator|=
name|strlen
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|23
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|elf32_hppa_name_of_stub
argument_list|(
name|caller_args
argument_list|,
name|callee_args
argument_list|,
name|location
argument_list|,
name|value
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stub_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|stub_hash_table
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stub_hash_table
expr_stmt|;
name|stub_hash
operator|=
name|elf32_hppa_stub_hash_lookup
argument_list|(
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* We're done with that name.  */
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
comment|/* The stub BFD only has one section.  */
name|stub_section
operator|=
name|stub_hash_table
operator|->
name|stub_bfd
operator|->
name|sections
expr_stmt|;
if|if
condition|(
name|stub_hash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL17F
condition|)
block|{
name|unsigned
name|long
name|delay_insn
decl_stmt|;
name|unsigned
name|int
name|opcode
decl_stmt|,
name|rtn_reg
decl_stmt|,
name|ldo_target_reg
decl_stmt|,
name|ldo_src_reg
decl_stmt|;
comment|/* We'll need to peek at the next insn.  */
name|delay_insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|get_opcode
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* We also need to know the return register for this 		       call.  */
name|rtn_reg
operator|=
operator|(
name|insn
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
expr_stmt|;
name|ldo_src_reg
operator|=
operator|(
name|delay_insn
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
expr_stmt|;
name|ldo_target_reg
operator|=
operator|(
name|delay_insn
operator|&
literal|0x001f0000
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* Munge up the value and other parameters for 		       hppa_elf_relocate_insn.  */
name|value
operator|=
operator|(
name|stub_hash
operator|->
name|offset
operator|+
name|stub_section
operator|->
name|output_offset
operator|+
name|stub_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|r_format
operator|=
literal|17
expr_stmt|;
name|r_field
operator|=
name|e_fsel
expr_stmt|;
name|r_pcrel
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* We need to peek at the delay insn and determine if 		       we'll need to swap the branch and its delay insn.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|2
operator|)
operator|||
operator|(
name|opcode
operator|==
name|LDO
operator|&&
name|ldo_target_reg
operator|==
name|rtn_reg
operator|)
operator|||
operator|(
name|delay_insn
operator|==
literal|0x08000240
operator|)
condition|)
block|{
comment|/* No need to swap the branch and its delay slot, but 			   we do need to make sure to jump past the return 			   pointer update in the stub.  */
name|value
operator|+=
literal|4
expr_stmt|;
comment|/* If the delay insn does a return pointer adjustment, 			   then we have to make sure it stays valid.  */
if|if
condition|(
name|opcode
operator|==
name|LDO
operator|&&
name|ldo_target_reg
operator|==
name|rtn_reg
condition|)
block|{
name|delay_insn
operator|&=
literal|0xfc00ffff
expr_stmt|;
name|delay_insn
operator||=
operator|(
operator|(
literal|31
operator|<<
literal|21
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|delay_insn
argument_list|,
name|hit_data
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Use a BLE to reach the stub.  */
name|insn
operator|=
name|BLE_SR4_R0
expr_stmt|;
block|}
else|else
block|{
comment|/* Wonderful, we have to swap the call insn and its 			   delay slot.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|delay_insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* Use a BLE,n to reach the stub.  */
name|insn
operator|=
operator|(
name|BLE_SR4_R0
operator||
literal|0x2
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_elf_relocate_insn
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|insn
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|value
argument_list|,
name|addend
argument_list|,
name|r_format
argument_list|,
name|r_field
argument_list|,
name|r_pcrel
argument_list|)
expr_stmt|;
comment|/* Update the instruction word.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
else|else
block|{
comment|/* PLABEL stuff is easy.  */
name|value
operator|=
operator|(
name|stub_hash
operator|->
name|offset
operator|+
name|stub_section
operator|->
name|output_offset
operator|+
name|stub_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* We don't need the RP adjustment for PLABELs.  */
name|value
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLABEL32
condition|)
name|r_format
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLABEL21L
condition|)
name|r_format
operator|=
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLABEL14R
condition|)
name|r_format
operator|=
literal|14
expr_stmt|;
name|r_pcrel
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
return|return
name|bfd_reloc_notsupported
return|;
block|}
goto|goto
name|do_basic_type_1
goto|;
block|}
name|do_basic_type_1
label|:
name|insn
operator|=
name|hppa_elf_relocate_insn
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|insn
argument_list|,
name|offset
argument_list|,
name|value
argument_list|,
name|addend
argument_list|,
name|r_format
argument_list|,
name|r_field
argument_list|,
name|r_pcrel
argument_list|)
expr_stmt|;
break|break;
comment|/* Something we don't know how to handle.  */
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Update the instruction word.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_reloc_ok
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the howto table entry to perform the CODE    relocation for an ARCH machine.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_hppa_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|<
operator|(
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|elf_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if SYM represents a local label symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|hppa_elf_is_local_label
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
return|return
operator|(
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|sym
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do any backend specific processing when beginning to write an object    file.  For PA ELF we need to determine the size of the symbol extension    section *before* any other output processing happens.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_backend_begin_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|asection
modifier|*
name|symextn_sec
decl_stmt|;
comment|/* Size up the symbol extension section.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|outsymbols
operator|==
name|NULL
operator|&&
name|info
operator|==
name|NULL
operator|)
operator|||
name|symext_chain_size
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
comment|/* We were not called from the BFD ELF linker code, so we need 	 to examine the output BFD's outsymbols.  	 Note we can not build the symbol extensions now as the symbol 	 map hasn't been set up.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|elf_symbol_type
modifier|*
name|symbol
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|abfd
operator|->
name|outsymbols
index|[
name|i
index|]
decl_stmt|;
comment|/* Only functions ever need an entry in the symbol extension 	     section.  */
if|if
condition|(
operator|!
operator|(
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_FUNCTION
operator|)
condition|)
continue|continue;
comment|/* And only if they specify the locations of their arguments.  */
if|if
condition|(
name|symbol
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
operator|==
literal|0
condition|)
continue|continue;
comment|/* Yup.  This function symbol needs an entry.  */
name|symext_chain_size
operator|+=
literal|2
operator|*
name|ELF32_PARISC_SX_SIZE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
operator|==
name|true
condition|)
block|{
name|struct
name|elf32_hppa_args_hash_table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|args_hash_table
expr_stmt|;
comment|/* Determine the size of the symbol extension section.  */
name|elf32_hppa_args_hash_traverse
argument_list|(
name|table
argument_list|,
name|elf32_hppa_size_symext
argument_list|,
operator|&
name|symext_chain_size
argument_list|)
expr_stmt|;
block|}
comment|/* Now create the section and set its size.  We'll fill in the      contents later.  */
name|symextn_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|SYMEXTN_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|symextn_sec
operator|==
name|NULL
condition|)
name|symextn_sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|SYMEXTN_SECTION_NAME
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|symextn_sec
argument_list|,
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
name|symextn_sec
operator|->
name|output_section
operator|=
name|symextn_sec
expr_stmt|;
name|symextn_sec
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|symextn_sec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|symextn_sec
argument_list|,
name|symext_chain_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called for each entry in the args location hash table.  For each    entry we bump the size pointer by 2 records (16 bytes).  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_size_symext
parameter_list|(
name|gen_entry
parameter_list|,
name|in_args
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
decl_stmt|;
name|PTR
name|in_args
decl_stmt|;
block|{
name|bfd_size_type
modifier|*
name|sizep
init|=
operator|(
name|bfd_size_type
operator|*
operator|)
name|in_args
decl_stmt|;
operator|*
name|sizep
operator|+=
literal|2
operator|*
name|ELF32_PARISC_SX_SIZE
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Backend routine called by the linker for each output symbol.     For PA ELF we use this opportunity to add an appropriate entry    to the symbol extension chain for function symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_link_output_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|index
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_table
modifier|*
name|args_hash_table
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_entry
modifier|*
name|args_hash
decl_stmt|;
comment|/* If the args hash table is NULL, then we've encountered an error      of some sorts (for example, an undefined symbol).  In that case      we've got nothing else to do.       NOTE: elf_link_output_symbol will abort if we return false here!  */
if|if
condition|(
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|args_hash_table
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|index
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|output_symbol_count
operator|++
expr_stmt|;
comment|/* We need to look up this symbol in the args hash table to see if      it has argument relocation bits.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
return|return
name|true
return|;
comment|/* We know it's a function symbol of some kind.  */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
name|len
operator|+=
literal|9
expr_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
name|sprintf
argument_list|(
name|new_name
operator|+
name|len
operator|-
literal|10
argument_list|,
literal|"_%08x"
argument_list|,
operator|(
name|int
operator|)
name|section
argument_list|)
expr_stmt|;
comment|/* Now that we have the unique name, we can look it up in the      args hash table.  */
name|args_hash_table
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|args_hash_table
expr_stmt|;
name|args_hash
operator|=
name|elf32_hppa_args_hash_lookup
argument_list|(
name|args_hash_table
argument_list|,
name|new_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_hash
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* We know this symbol has arg reloc bits.  */
name|add_entry_to_symext_chain
argument_list|(
name|abfd
argument_list|,
name|args_hash
operator|->
name|arg_bits
argument_list|,
name|index
argument_list|,
operator|&
name|symext_rootP
argument_list|,
operator|&
name|symext_lastP
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Perform any processing needed late in the object file writing process.    For PA ELF we build and set the contents of the symbol extension    section.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_backend_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|linker
decl_stmt|;
block|{
name|asection
modifier|*
name|symextn_sec
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Now build the symbol extension section.  */
if|if
condition|(
name|symext_chain_size
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|linker
condition|)
block|{
comment|/* We were not called from the backend linker, so we still need 	 to build the symbol extension chain.           Look at each symbol, adding the appropriate information to the 	 symbol extension section list as necessary.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|elf_symbol_type
modifier|*
name|symbol
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|abfd
operator|->
name|outsymbols
index|[
name|i
index|]
decl_stmt|;
comment|/* Only functions ever need an entry in the symbol extension 	     section.  */
if|if
condition|(
operator|!
operator|(
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_FUNCTION
operator|)
condition|)
continue|continue;
comment|/* And only if they specify the locations of their arguments.  */
if|if
condition|(
name|symbol
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
operator|==
literal|0
condition|)
continue|continue;
comment|/* Add this symbol's information to the chain.  */
name|add_entry_to_symext_chain
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|tc_data
operator|.
name|hppa_arg_reloc
argument_list|,
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|.
name|i
argument_list|,
operator|&
name|symext_rootP
argument_list|,
operator|&
name|symext_lastP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now fill in the contents of the symbol extension section.  */
name|elf_hppa_tc_make_sections
argument_list|(
name|abfd
argument_list|,
name|symext_rootP
argument_list|)
expr_stmt|;
comment|/* And attach that as the section's contents.  */
name|symextn_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|SYMEXTN_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|symextn_sec
operator|==
operator|(
name|asection
operator|*
operator|)
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|symextn_sec
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|symextn_contents
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|symextn_sec
argument_list|,
name|symextn_sec
operator|->
name|contents
argument_list|,
name|symextn_sec
operator|->
name|output_offset
argument_list|,
name|symextn_sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the symbol extention chain to include the symbol pointed to    by SYMBOLP if SYMBOLP is a function symbol.  Used internally and by GAS.  */
end_comment

begin_function
specifier|static
name|void
name|add_entry_to_symext_chain
parameter_list|(
name|abfd
parameter_list|,
name|arg_reloc
parameter_list|,
name|sym_idx
parameter_list|,
name|symext_root
parameter_list|,
name|symext_last
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|arg_reloc
decl_stmt|;
name|unsigned
name|int
name|sym_idx
decl_stmt|;
name|symext_chainS
modifier|*
modifier|*
name|symext_root
decl_stmt|;
name|symext_chainS
modifier|*
modifier|*
name|symext_last
decl_stmt|;
block|{
name|symext_chainS
modifier|*
name|symextP
decl_stmt|;
comment|/* Allocate memory and initialize this entry.  */
name|symextP
operator|=
operator|(
name|symext_chainS
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|symext_chainS
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symextP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|symextP
index|[
literal|0
index|]
operator|.
name|entry
operator|=
name|ELF32_PARISC_SX_WORD
argument_list|(
name|PARISC_SXT_SYMNDX
argument_list|,
name|sym_idx
argument_list|)
expr_stmt|;
name|symextP
index|[
literal|0
index|]
operator|.
name|next
operator|=
operator|&
name|symextP
index|[
literal|1
index|]
expr_stmt|;
name|symextP
index|[
literal|1
index|]
operator|.
name|entry
operator|=
name|ELF32_PARISC_SX_WORD
argument_list|(
name|PARISC_SXT_ARG_RELOC
argument_list|,
name|arg_reloc
argument_list|)
expr_stmt|;
name|symextP
index|[
literal|1
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Now update the chain itself so it can be walked later to build      the symbol extension section.  */
if|if
condition|(
operator|*
name|symext_root
operator|==
name|NULL
condition|)
block|{
operator|*
name|symext_root
operator|=
operator|&
name|symextP
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|symext_last
operator|=
operator|&
name|symextP
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|symext_last
operator|)
operator|->
name|next
operator|=
operator|&
name|symextP
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|symext_last
operator|=
operator|&
name|symextP
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the symbol extension section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_hppa_tc_make_sections
parameter_list|(
name|abfd
parameter_list|,
name|symext_root
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|symext_chainS
modifier|*
name|symext_root
decl_stmt|;
block|{
name|symext_chainS
modifier|*
name|symextP
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|asection
modifier|*
name|symextn_sec
decl_stmt|;
name|symextn_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|SYMEXTN_SECTION_NAME
argument_list|)
expr_stmt|;
comment|/* Grab some memory for the contents of the symbol extension section      itself.  */
name|symextn_contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symextn_sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symextn_contents
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
comment|/* Fill in the contents of the symbol extension chain.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symextP
operator|=
name|symext_root
init|;
name|symextP
condition|;
name|symextP
operator|=
name|symextP
operator|->
name|next
operator|,
operator|++
name|i
control|)
name|ELF32_PARISC_SX_PUT
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|symextP
operator|->
name|entry
argument_list|,
name|symextn_contents
operator|+
name|i
operator|*
name|ELF32_PARISC_SX_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Do some PA ELF specific work after reading in the symbol table.    In particular attach the argument relocation from the    symbol extension section to the appropriate symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_backend_symbol_table_processing
parameter_list|(
name|abfd
parameter_list|,
name|esyms
parameter_list|,
name|symcnt
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|elf_symbol_type
modifier|*
name|esyms
decl_stmt|;
name|unsigned
name|int
name|symcnt
decl_stmt|;
block|{
name|Elf32_Internal_Shdr
modifier|*
name|symextn_hdr
init|=
name|bfd_elf_find_section
argument_list|(
name|abfd
argument_list|,
name|SYMEXTN_SECTION_NAME
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|current_sym_idx
init|=
literal|0
decl_stmt|;
comment|/* If no symbol extension existed, then all symbol extension information      is assumed to be zero.  */
if|if
condition|(
name|symextn_hdr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcnt
condition|;
name|i
operator|++
control|)
name|esyms
index|[
name|i
index|]
operator|.
name|tc_data
operator|.
name|hppa_arg_reloc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* FIXME:  Why not use bfd_get_section_contents here?  Also should give      memory back when we're done.  */
comment|/* Allocate a buffer of the appropriate size for the symextn section.  */
name|symextn_hdr
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symextn_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symextn_hdr
operator|->
name|contents
condition|)
return|return
name|false
return|;
comment|/* Read in the symextn section.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symextn_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|symextn_hdr
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|symextn_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symextn_hdr
operator|->
name|sh_size
condition|)
return|return
name|false
return|;
comment|/* Parse entries in the symbol extension section, updating the symtab      entries as we go */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symextn_hdr
operator|->
name|sh_size
operator|/
name|ELF32_PARISC_SX_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|symext_entryS
name|se
init|=
name|ELF32_PARISC_SX_GET
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|symextn_hdr
operator|->
name|contents
operator|+
name|i
operator|*
name|ELF32_PARISC_SX_SIZE
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|se_value
init|=
name|ELF32_PARISC_SX_VAL
argument_list|(
name|se
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|se_type
init|=
name|ELF32_PARISC_SX_TYPE
argument_list|(
name|se
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|se_type
condition|)
block|{
case|case
name|PARISC_SXT_NULL
case|:
break|break;
case|case
name|PARISC_SXT_SYMNDX
case|:
if|if
condition|(
name|se_value
operator|>=
name|symcnt
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|current_sym_idx
operator|=
name|se_value
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PARISC_SXT_ARG_RELOC
case|:
name|esyms
index|[
name|current_sym_idx
index|]
operator|.
name|tc_data
operator|.
name|hppa_arg_reloc
operator|=
name|se_value
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read and attach the symbol extension information for the symbols    in INPUT_BFD to the argument location hash table.  Handle locals    if DO_LOCALS is true; likewise for globals when DO_GLOBALS is true.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_read_symext_info
parameter_list|(
name|input_bfd
parameter_list|,
name|symtab_hdr
parameter_list|,
name|args_hash_table
parameter_list|,
name|local_syms
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_table
modifier|*
name|args_hash_table
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
block|{
name|asection
modifier|*
name|symextn_sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n_entries
decl_stmt|,
name|current_index
init|=
literal|0
decl_stmt|;
comment|/* Get the symbol extension section for this BFD.  If no section exists      then there's nothing to do.  Likewise if the section exists, but      has no contents.  */
name|symextn_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
name|SYMEXTN_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|symextn_sec
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* Done separately so we can turn off SEC_HAS_CONTENTS (see below).  */
if|if
condition|(
name|symextn_sec
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|symextn_sec
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
return|return
name|true
return|;
block|}
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|symextn_sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* How gross.  We turn off SEC_HAS_CONTENTS for the input symbol extension      sections to keep the generic ELF/BFD code from trying to do anything      with them.  We have to undo that hack temporarily so that we can read      in the contents with the generic code.  */
name|symextn_sec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|symextn_sec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|symextn_sec
operator|->
name|_raw_size
argument_list|)
operator|==
name|false
condition|)
block|{
name|symextn_sec
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Gross.  Turn off SEC_HAS_CONTENTS for the input symbol extension      sections (see above).  */
name|symextn_sec
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
name|n_entries
operator|=
name|symextn_sec
operator|->
name|_raw_size
operator|/
name|ELF32_PARISC_SX_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entries
condition|;
name|i
operator|++
control|)
block|{
name|symext_entryS
name|entry
init|=
name|ELF32_PARISC_SX_GET
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|i
operator|*
name|ELF32_PARISC_SX_SIZE
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|value
init|=
name|ELF32_PARISC_SX_VAL
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|type
init|=
name|ELF32_PARISC_SX_TYPE
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_entry
modifier|*
name|args_hash
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PARISC_SXT_NULL
case|:
break|break;
case|case
name|PARISC_SXT_SYMNDX
case|:
if|if
condition|(
name|value
operator|>=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|current_index
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|PARISC_SXT_ARG_RELOC
case|:
if|if
condition|(
name|current_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|input_bfd
argument_list|)
index|[
name|local_syms
index|[
name|current_index
index|]
operator|.
name|st_shndx
index|]
expr_stmt|;
name|sym_sec
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|local_syms
index|[
name|current_index
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|10
expr_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_name
operator|+
name|len
operator|-
literal|10
argument_list|,
literal|"_%08x"
argument_list|,
operator|(
name|int
operator|)
name|sym_sec
argument_list|)
expr_stmt|;
comment|/* This is a global symbol with argument location info. 		 We need to enter it into the hash table.  */
name|args_hash
operator|=
name|elf32_hppa_args_hash_lookup
argument_list|(
name|args_hash_table
argument_list|,
name|new_name
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_hash
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|args_hash
operator|->
name|arg_bits
operator|=
name|value
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|current_index
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|current_index
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|current_index
index|]
expr_stmt|;
comment|/* This is a global symbol with argument location 		 information.  We need to enter it into the hash table.  */
name|args_hash
operator|=
name|elf32_hppa_args_hash_lookup
argument_list|(
name|args_hash_table
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_hash
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|args_hash
operator|->
name|arg_bits
operator|=
name|value
expr_stmt|;
break|break;
block|}
else|else
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Undo the generic ELF code's subtraction of section->vma from the    value of each external symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|flagword
modifier|*
name|flagsp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
operator|*
name|valp
operator|+=
operator|(
operator|*
name|secp
operator|)
operator|->
name|vma
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine the name of the stub needed to perform a call assuming the    argument relocation bits for caller and callee are in CALLER and CALLEE    for a call from LOCATION to DESTINATION.  Copy the name into STUB_NAME.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_name_of_stub
parameter_list|(
name|caller
parameter_list|,
name|callee
parameter_list|,
name|location
parameter_list|,
name|destination
parameter_list|,
name|stub_name
parameter_list|)
name|unsigned
name|int
name|caller
decl_stmt|,
name|callee
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|,
name|destination
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
block|{
name|arg_reloc_type
name|arg_reloc_types
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|elf32_hppa_arg_reloc_needed
argument_list|(
name|caller
argument_list|,
name|callee
argument_list|,
name|arg_reloc_types
argument_list|)
condition|)
block|{
name|arg_reloc_location
name|i
decl_stmt|;
comment|/* Fill in the basic template.  */
name|strcpy
argument_list|(
name|stub_name
argument_list|,
literal|"__XX_XX_XX_XX_XX_stub_"
argument_list|)
expr_stmt|;
comment|/* Now fix the specifics.  */
for|for
control|(
name|i
operator|=
name|ARG0
init|;
name|i
operator|<=
name|RET
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|arg_reloc_types
index|[
name|i
index|]
condition|)
block|{
case|case
name|NO
case|:
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
operator|=
literal|'N'
expr_stmt|;
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|3
index|]
operator|=
literal|'O'
expr_stmt|;
break|break;
case|case
name|GF
case|:
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
operator|=
literal|'G'
expr_stmt|;
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|3
index|]
operator|=
literal|'F'
expr_stmt|;
break|break;
case|case
name|FG
case|:
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
operator|=
literal|'F'
expr_stmt|;
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|3
index|]
operator|=
literal|'G'
expr_stmt|;
break|break;
case|case
name|GD
case|:
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
operator|=
literal|'G'
expr_stmt|;
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|3
index|]
operator|=
literal|'D'
expr_stmt|;
break|break;
case|case
name|DG
case|:
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
operator|=
literal|'D'
expr_stmt|;
name|stub_name
index|[
literal|3
operator|*
name|i
operator|+
literal|3
index|]
operator|=
literal|'G'
expr_stmt|;
break|break;
block|}
block|}
else|else
name|strcpy
argument_list|(
name|stub_name
argument_list|,
literal|"_____long_branch_stub_"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if an argument relocation stub is needed to perform a    call assuming the argument relocation bits for caller and callee    are in CALLER and CALLEE.  Place the type of relocations (if any)    into stub_types_p.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_arg_reloc_needed
parameter_list|(
name|caller
parameter_list|,
name|callee
parameter_list|,
name|stub_types
parameter_list|)
name|unsigned
name|int
name|caller
decl_stmt|,
name|callee
decl_stmt|;
name|arg_reloc_type
name|stub_types
index|[
literal|5
index|]
decl_stmt|;
block|{
comment|/* Special case for no relocations.  */
if|if
condition|(
name|caller
operator|==
literal|0
operator|||
name|callee
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|arg_location
name|caller_loc
index|[
literal|5
index|]
decl_stmt|;
name|arg_location
name|callee_loc
index|[
literal|5
index|]
decl_stmt|;
comment|/* Extract the location information for the argument and return 	 value on both the caller and callee sides.  */
name|caller_loc
index|[
name|ARG0
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|caller
argument_list|,
name|ARG0
argument_list|)
expr_stmt|;
name|callee_loc
index|[
name|ARG0
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|callee
argument_list|,
name|ARG0
argument_list|)
expr_stmt|;
name|caller_loc
index|[
name|ARG1
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|caller
argument_list|,
name|ARG1
argument_list|)
expr_stmt|;
name|callee_loc
index|[
name|ARG1
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|callee
argument_list|,
name|ARG1
argument_list|)
expr_stmt|;
name|caller_loc
index|[
name|ARG2
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|caller
argument_list|,
name|ARG2
argument_list|)
expr_stmt|;
name|callee_loc
index|[
name|ARG2
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|callee
argument_list|,
name|ARG2
argument_list|)
expr_stmt|;
name|caller_loc
index|[
name|ARG3
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|caller
argument_list|,
name|ARG3
argument_list|)
expr_stmt|;
name|callee_loc
index|[
name|ARG3
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|callee
argument_list|,
name|ARG3
argument_list|)
expr_stmt|;
name|caller_loc
index|[
name|RET
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|caller
argument_list|,
name|RET
argument_list|)
expr_stmt|;
name|callee_loc
index|[
name|RET
index|]
operator|=
name|EXTRACT_ARBITS
argument_list|(
name|callee
argument_list|,
name|RET
argument_list|)
expr_stmt|;
comment|/* Check some special combinations.  This is necessary to 	 deal with double precision FP arguments.  */
if|if
condition|(
name|caller_loc
index|[
name|ARG0
index|]
operator|==
name|AR_FU
operator|||
name|caller_loc
index|[
name|ARG1
index|]
operator|==
name|AR_FU
condition|)
block|{
name|caller_loc
index|[
name|ARG0
index|]
operator|=
name|AR_FPDBL1
expr_stmt|;
name|caller_loc
index|[
name|ARG1
index|]
operator|=
name|AR_NO
expr_stmt|;
block|}
if|if
condition|(
name|caller_loc
index|[
name|ARG2
index|]
operator|==
name|AR_FU
operator|||
name|caller_loc
index|[
name|ARG3
index|]
operator|==
name|AR_FU
condition|)
block|{
name|caller_loc
index|[
name|ARG2
index|]
operator|=
name|AR_FPDBL2
expr_stmt|;
name|caller_loc
index|[
name|ARG3
index|]
operator|=
name|AR_NO
expr_stmt|;
block|}
if|if
condition|(
name|callee_loc
index|[
name|ARG0
index|]
operator|==
name|AR_FU
operator|||
name|callee_loc
index|[
name|ARG1
index|]
operator|==
name|AR_FU
condition|)
block|{
name|callee_loc
index|[
name|ARG0
index|]
operator|=
name|AR_FPDBL1
expr_stmt|;
name|callee_loc
index|[
name|ARG1
index|]
operator|=
name|AR_NO
expr_stmt|;
block|}
if|if
condition|(
name|callee_loc
index|[
name|ARG2
index|]
operator|==
name|AR_FU
operator|||
name|callee_loc
index|[
name|ARG3
index|]
operator|==
name|AR_FU
condition|)
block|{
name|callee_loc
index|[
name|ARG2
index|]
operator|=
name|AR_FPDBL2
expr_stmt|;
name|callee_loc
index|[
name|ARG3
index|]
operator|=
name|AR_NO
expr_stmt|;
block|}
comment|/* Now look up any relocation needed for each argument and the 	 return value.  */
name|stub_types
index|[
name|ARG0
index|]
operator|=
name|arg_mismatches
index|[
name|caller_loc
index|[
name|ARG0
index|]
index|]
index|[
name|callee_loc
index|[
name|ARG0
index|]
index|]
expr_stmt|;
name|stub_types
index|[
name|ARG1
index|]
operator|=
name|arg_mismatches
index|[
name|caller_loc
index|[
name|ARG1
index|]
index|]
index|[
name|callee_loc
index|[
name|ARG1
index|]
index|]
expr_stmt|;
name|stub_types
index|[
name|ARG2
index|]
operator|=
name|arg_mismatches
index|[
name|caller_loc
index|[
name|ARG2
index|]
index|]
index|[
name|callee_loc
index|[
name|ARG2
index|]
index|]
expr_stmt|;
name|stub_types
index|[
name|ARG3
index|]
operator|=
name|arg_mismatches
index|[
name|caller_loc
index|[
name|ARG3
index|]
index|]
index|[
name|callee_loc
index|[
name|ARG3
index|]
index|]
expr_stmt|;
name|stub_types
index|[
name|RET
index|]
operator|=
name|ret_mismatches
index|[
name|caller_loc
index|[
name|RET
index|]
index|]
index|[
name|callee_loc
index|[
name|RET
index|]
index|]
expr_stmt|;
return|return
operator|(
name|stub_types
index|[
name|ARG0
index|]
operator|!=
name|NO
operator|||
name|stub_types
index|[
name|ARG1
index|]
operator|!=
name|NO
operator|||
name|stub_types
index|[
name|ARG2
index|]
operator|!=
name|NO
operator|||
name|stub_types
index|[
name|ARG3
index|]
operator|!=
name|NO
operator|||
name|stub_types
index|[
name|RET
index|]
operator|!=
name|NO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the size of the stub needed to call from LOCATION to DESTINATION    (a function named SYM_NAME), with argument relocation bits CALLER and    CALLEE.  Return zero if no stub is needed to perform such a call.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|elf32_hppa_size_of_stub
parameter_list|(
name|callee
parameter_list|,
name|caller
parameter_list|,
name|location
parameter_list|,
name|destination
parameter_list|,
name|sym_name
parameter_list|)
name|unsigned
name|int
name|callee
decl_stmt|,
name|caller
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|,
name|destination
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
name|arg_reloc_type
name|arg_reloc_types
index|[
literal|5
index|]
decl_stmt|;
comment|/* Determine if a long branch or argument relocation stub is needed.      If an argument relocation stub is needed, the relocation will be      stored into arg_reloc_types.  */
if|if
condition|(
operator|!
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|location
operator|-
name|destination
argument_list|)
operator|>
literal|0x3ffff
operator|)
operator|||
operator|(
call|(
name|int
call|)
argument_list|(
name|location
operator|-
name|destination
argument_list|)
operator|<
operator|(
name|int
operator|)
literal|0xfffc0000
operator|)
operator|||
name|elf32_hppa_arg_reloc_needed
argument_list|(
name|caller
argument_list|,
name|callee
argument_list|,
name|arg_reloc_types
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Some kind of stub is needed.  Determine how big it needs to be.      First check for argument relocation stubs as they also handle      long calls.  Then check for long calls to millicode and finally      the normal long calls.  */
if|if
condition|(
name|arg_reloc_types
index|[
name|ARG0
index|]
operator|!=
name|NO
operator|||
name|arg_reloc_types
index|[
name|ARG1
index|]
operator|!=
name|NO
operator|||
name|arg_reloc_types
index|[
name|ARG2
index|]
operator|!=
name|NO
operator|||
name|arg_reloc_types
index|[
name|ARG3
index|]
operator|!=
name|NO
operator|||
name|arg_reloc_types
index|[
name|RET
index|]
operator|!=
name|NO
condition|)
block|{
comment|/* Some kind of argument relocation stub is needed.  */
name|unsigned
name|int
name|len
init|=
literal|16
decl_stmt|;
name|arg_reloc_location
name|i
decl_stmt|;
comment|/* Each GR or FG relocation takes 2 insns, each GD or DG 	 relocation takes 3 insns.  Plus 4 more insns for the          RP adjustment, ldil& (be | ble) and copy.  */
for|for
control|(
name|i
operator|=
name|ARG0
init|;
name|i
operator|<=
name|RET
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|arg_reloc_types
index|[
name|i
index|]
condition|)
block|{
case|case
name|GF
case|:
case|case
name|FG
case|:
name|len
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|GD
case|:
case|case
name|DG
case|:
name|len
operator|+=
literal|12
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Extra instructions are needed if we're relocating a return value.  */
if|if
condition|(
name|arg_reloc_types
index|[
name|RET
index|]
operator|!=
name|NO
condition|)
name|len
operator|+=
literal|12
expr_stmt|;
return|return
name|len
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"$$"
argument_list|,
name|sym_name
argument_list|,
literal|2
argument_list|)
operator|&&
name|strcmp
argument_list|(
literal|"$$dyncall"
argument_list|,
name|sym_name
argument_list|)
condition|)
return|return
literal|12
return|;
else|else
return|return
literal|16
return|;
block|}
end_function

begin_comment
comment|/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.    IN_ARGS contains the stub BFD and link info pointers.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf32_hppa_build_one_stub
parameter_list|(
name|gen_entry
parameter_list|,
name|in_args
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
decl_stmt|;
name|PTR
name|in_args
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|args
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|in_args
decl_stmt|;
name|bfd
modifier|*
name|stub_bfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|args
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|args
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_table
modifier|*
name|stub_hash_table
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|symvalue
name|sym_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* Initialize pointers to the stub hash table, the particular entry we      are building a stub for, and where (in memory) we should place the stub      instructions.  */
name|entry
operator|=
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|stub_hash_table
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stub_hash_table
expr_stmt|;
name|loc
operator|=
name|stub_hash_table
operator|->
name|location
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|entry
operator|->
name|offset
operator|=
name|stub_hash_table
operator|->
name|offset
expr_stmt|;
comment|/* The symbol's name starts at offset 22.  */
name|sym_name
operator|=
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|22
expr_stmt|;
name|sym_value
operator|=
operator|(
name|entry
operator|->
name|target_value
operator|+
name|entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"_____long_branch_stub_"
argument_list|,
name|entry
operator|->
name|root
operator|.
name|string
argument_list|,
literal|22
argument_list|)
condition|)
block|{
comment|/* This must be an argument or return value relocation stub.  */
name|unsigned
name|long
name|insn
decl_stmt|;
name|arg_reloc_location
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|begin_loc
init|=
name|loc
decl_stmt|;
comment|/* First the return pointer adjustment.  Depending on exact calling 	 sequence this instruction may be skipped.  */
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDO_M4_R31_R31
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
comment|/* If we are relocating a return value, then we're going to have 	 to return into the stub.  So we have to save off the user's 	 return pointer into the stack at RP'.  */
if|if
condition|(
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|14
argument_list|,
literal|"NO"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_R31_M8R30
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Iterate over the argument relocations, emitting instructions 	 to move them around as necessary.  */
for|for
control|(
name|i
operator|=
name|ARG0
init|;
name|i
operator|<=
name|ARG3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
argument_list|,
literal|"GF"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_ARG_M16R30
operator||
operator|(
operator|(
literal|26
operator|-
name|i
operator|)
operator|<<
literal|16
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FLDW_M16R30_FARG
operator||
operator|(
literal|4
operator|+
name|i
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
argument_list|,
literal|"FG"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FSTW_FARG_M16R30
operator||
operator|(
literal|4
operator|+
name|i
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M16R30_ARG
operator||
operator|(
operator|(
literal|26
operator|-
name|i
operator|)
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
argument_list|,
literal|"GD"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_ARG_M12R30
operator||
operator|(
operator|(
literal|26
operator|-
name|i
operator|)
operator|<<
literal|16
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_ARG_M16R30
operator||
operator|(
operator|(
literal|25
operator|-
name|i
operator|)
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FLDD_M16R30_FARG
operator||
operator|(
literal|5
operator|+
name|i
operator|)
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|3
operator|*
name|i
operator|+
literal|2
argument_list|,
literal|"DG"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FSTD_FARG_M16R30
operator||
operator|(
literal|5
operator|+
name|i
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M12R30_ARG
operator||
operator|(
operator|(
literal|26
operator|-
name|i
operator|)
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M16R30_ARG
operator||
operator|(
operator|(
literal|25
operator|-
name|i
operator|)
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|12
expr_stmt|;
block|}
block|}
comment|/* Load the high bits of the target address into %r1.  */
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
name|stub_bfd
argument_list|,
name|LDIL_R1
argument_list|,
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_lrsel
argument_list|)
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
comment|/* If we are relocating a return value, then we're going to have 	 to return into the stub, then perform the return value relocation.  */
if|if
condition|(
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|14
argument_list|,
literal|"NO"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* To return to the stub we "ble" to the target and copy the return 	     pointer from %r31 into %r2.  */
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
name|stub_bfd
argument_list|,
name|BLE_SR4_R1
argument_list|,
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_rrsel
argument_list|)
operator|>>
literal|2
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|COPY_R31_R2
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Reload the return pointer for our caller from the stack.  */
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M8R30_R31
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|12
expr_stmt|;
comment|/* Perform the return value relocation.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|14
argument_list|,
literal|"GF"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_ARG_M16R30
operator||
operator|(
literal|28
operator|<<
literal|16
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FLDW_M16R30_FARG
operator||
literal|4
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|14
argument_list|,
literal|"FG"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FSTW_FARG_M16R30
operator||
literal|4
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M16R30_ARG
operator||
operator|(
literal|28
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|2
argument_list|,
literal|"GD"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_ARG_M12R30
operator||
operator|(
literal|28
operator|<<
literal|16
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|STW_ARG_M16R30
operator||
operator|(
literal|29
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FLDD_M16R30_FARG
operator||
literal|4
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|entry
operator|->
name|root
operator|.
name|string
operator|+
literal|2
argument_list|,
literal|"DG"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|FSTD_FARG_M16R30
operator||
literal|4
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M12R30_ARG
operator||
operator|(
literal|28
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDW_M16R30_ARG
operator||
operator|(
literal|29
operator|<<
literal|16
operator|)
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|12
expr_stmt|;
block|}
comment|/* Branch back to the user's code now.  */
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|BV_N_0_R31
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* No return value relocation, so we can simply "be" to the 	     target and copy out return pointer into %r2.  */
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
name|stub_bfd
argument_list|,
name|BE_SR4_R1
argument_list|,
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_rrsel
argument_list|)
operator|>>
literal|2
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|COPY_R31_R2
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Update the location and offsets.  */
name|stub_hash_table
operator|->
name|location
operator|+=
operator|(
name|loc
operator|-
name|begin_loc
operator|)
expr_stmt|;
name|stub_hash_table
operator|->
name|offset
operator|+=
operator|(
name|loc
operator|-
name|begin_loc
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create one of two variant long branch stubs.  One for $$dyncall and 	 normal calls, the other for calls to millicode.  */
name|unsigned
name|long
name|insn
decl_stmt|;
name|int
name|millicode_call
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"$$"
argument_list|,
name|sym_name
argument_list|,
literal|2
argument_list|)
operator|&&
name|strcmp
argument_list|(
literal|"$$dyncall"
argument_list|,
name|sym_name
argument_list|)
condition|)
name|millicode_call
operator|=
literal|1
expr_stmt|;
comment|/* First the return pointer adjustment.  Depending on exact calling 	 sequence this instruction may be skipped.  */
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|LDO_M4_R31_R31
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* The next two instructions are the long branch itself.  A long branch 	 is formed with "ldil" loading the upper bits of the target address 	 into a register, then branching with "be" which adds in the lower bits. 	 Long branches to millicode nullify the delay slot of the "be".  */
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
name|stub_bfd
argument_list|,
name|LDIL_R1
argument_list|,
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_lrsel
argument_list|)
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
name|stub_bfd
argument_list|,
name|BE_SR4_R1
operator||
operator|(
name|millicode_call
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|,
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_rrsel
argument_list|)
operator|>>
literal|2
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|millicode_call
condition|)
block|{
comment|/* The sequence to call this stub places the return pointer into %r31, 	     the final target expects the return pointer in %r2, so copy the 	      return pointer into the proper register.  */
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|COPY_R31_R2
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* Update the location and offsets.  */
name|stub_hash_table
operator|->
name|location
operator|+=
literal|16
expr_stmt|;
name|stub_hash_table
operator|->
name|offset
operator|+=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* Update the location and offsets.  */
name|stub_hash_table
operator|->
name|location
operator|+=
literal|12
expr_stmt|;
name|stub_hash_table
operator|->
name|offset
operator|+=
literal|12
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* External entry points for sizing and building linker stubs.  */
end_comment

begin_comment
comment|/* Build all the stubs associated with the current output file.  The    stubs are kept in a hash table attached to the main linker hash    table.  This is called via hppaelf_finish in the linker.  */
end_comment

begin_function
name|boolean
name|elf32_hppa_build_stubs
parameter_list|(
name|stub_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* The stub BFD only has one section.  */
name|asection
modifier|*
name|stub_sec
init|=
name|stub_bfd
operator|->
name|sections
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_table
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|void
modifier|*
name|args
index|[
literal|2
index|]
decl_stmt|;
comment|/* So we can pass both the BFD for the stubs and the link info      structure to the routine which actually builds stubs.  */
name|args
index|[
literal|0
index|]
operator|=
name|stub_bfd
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|info
expr_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
name|size
operator|=
name|bfd_section_size
argument_list|(
name|stub_bfd
argument_list|,
name|stub_sec
argument_list|)
expr_stmt|;
name|stub_sec
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|stub_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|table
operator|=
name|elf32_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stub_hash_table
expr_stmt|;
name|table
operator|->
name|location
operator|=
name|stub_sec
operator|->
name|contents
expr_stmt|;
comment|/* Build the stubs as directed by the stub hash table.  */
name|elf32_hppa_stub_hash_traverse
argument_list|(
name|table
argument_list|,
name|elf32_hppa_build_one_stub
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine and set the size of the stub section for a final link.     The basic idea here is to examine all the relocations looking for    PC-relative calls to a target that is unreachable with a "bl"    instruction or calls where the caller and callee disagree on the    location of their arguments or return value.  */
end_comment

begin_function
name|boolean
name|elf32_hppa_size_stubs
parameter_list|(
name|stub_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|,
modifier|*
name|stub_sec
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|,
modifier|*
name|isym
decl_stmt|,
modifier|*
modifier|*
name|all_local_syms
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|ext_syms
decl_stmt|,
modifier|*
name|esym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|index
decl_stmt|,
name|bfd_count
init|=
literal|0
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_table
modifier|*
name|stub_hash_table
init|=
literal|0
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_table
modifier|*
name|args_hash_table
init|=
literal|0
decl_stmt|;
comment|/* Create and initialize the stub hash table.  */
name|stub_hash_table
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_stub_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_stub_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_hash_table
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf32_hppa_stub_hash_table_init
argument_list|(
name|stub_hash_table
argument_list|,
name|stub_bfd
argument_list|,
name|elf32_hppa_stub_hash_newfunc
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Likewise for the argument location hash table.  */
name|args_hash_table
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_args_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_args_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|args_hash_table
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf32_hppa_args_hash_table_init
argument_list|(
name|args_hash_table
argument_list|,
name|elf32_hppa_args_hash_newfunc
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Attach the hash tables to the main hash table.  */
name|elf32_hppa_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|stub_hash_table
operator|=
name|stub_hash_table
expr_stmt|;
name|elf32_hppa_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|args_hash_table
operator|=
name|args_hash_table
expr_stmt|;
comment|/* Count the number of input BFDs.  */
for|for
control|(
name|input_bfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
name|bfd_count
operator|++
expr_stmt|;
comment|/* We want to read in symbol extension records only once.  To do this      we need to read in the local symbols in parallel and save them for      later use; so hold pointers to the local symbols in an array.  */
name|all_local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
operator|*
argument_list|)
operator|*
name|bfd_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_local_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memset
argument_list|(
name|all_local_syms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
operator|*
argument_list|)
operator|*
name|bfd_count
argument_list|)
expr_stmt|;
comment|/* Walk over all the input BFDs adding entries to the args hash table      for all the external functions.  */
for|for
control|(
name|input_bfd
operator|=
name|link_info
operator|->
name|input_bfds
operator|,
name|index
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|index
operator|++
control|)
block|{
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* We need an array of the local symbols attached to the input bfd. 	 Unfortunately, we're going to have to read& swap them in.  */
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|all_local_syms
index|[
name|index
index|]
operator|=
name|local_syms
expr_stmt|;
name|ext_syms
operator|=
operator|(
name|Elf32_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_syms
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|ext_syms
argument_list|,
literal|1
argument_list|,
operator|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|)
argument_list|,
name|input_bfd
argument_list|)
operator|!=
operator|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ext_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Swap the local symbols in.  */
name|isym
operator|=
name|local_syms
expr_stmt|;
name|esym
operator|=
name|ext_syms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
operator|,
name|esym
operator|++
operator|,
name|isym
operator|++
control|)
name|bfd_elf32_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|isym
argument_list|)
expr_stmt|;
comment|/* Now we can free the external symbols.  */
name|free
argument_list|(
name|ext_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf32_hppa_read_symext_info
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|args_hash_table
argument_list|,
name|local_syms
argument_list|)
operator|==
name|false
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Magic as we know the stub bfd only has one section.  */
name|stub_sec
operator|=
name|stub_bfd
operator|->
name|sections
expr_stmt|;
comment|/* If generating a relocateable output file, then we don't      have to examine the relocs.  */
if|if
condition|(
name|link_info
operator|->
name|relocateable
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Now that we have argument location information for all the global      functions we can start looking for stubs.  */
for|for
control|(
name|input_bfd
operator|=
name|link_info
operator|->
name|input_bfds
operator|,
name|index
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|index
operator|++
control|)
block|{
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|all_local_syms
index|[
name|index
index|]
expr_stmt|;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
decl_stmt|;
name|Elf32_External_Rela
modifier|*
name|external_relocs
decl_stmt|,
modifier|*
name|erelaend
decl_stmt|,
modifier|*
name|erela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate space for the external relocations.  */
name|external_relocs
operator|=
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|section
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Likewise for the internal relocations.  */
name|internal_relocs
operator|=
operator|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|section
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Read in the external relocs.  */
name|input_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|input_rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|external_relocs
argument_list|,
literal|1
argument_list|,
name|input_rel_hdr
operator|->
name|sh_size
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|input_rel_hdr
operator|->
name|sh_size
condition|)
block|{
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Swap in the relocs.  */
name|erela
operator|=
name|external_relocs
expr_stmt|;
name|erelaend
operator|=
name|erela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erela
operator|<
name|erelaend
condition|;
name|erela
operator|++
operator|,
name|irela
operator|++
control|)
name|bfd_elf32_swap_reloca_in
argument_list|(
name|input_bfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
comment|/* We're done with the external relocs, free them.  */
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|long
name|r_type
decl_stmt|,
name|callee_args
decl_stmt|,
name|caller_args
decl_stmt|,
name|size_of_stub
decl_stmt|;
name|unsigned
name|long
name|r_index
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_hash
decl_stmt|;
name|struct
name|elf32_hppa_args_hash_entry
modifier|*
name|args_hash
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|symvalue
name|sym_value
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|,
name|destination
decl_stmt|;
name|char
modifier|*
name|new_name
init|=
name|NULL
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Only look for stubs on call instructions or plabel 		 references.  */
if|if
condition|(
name|r_type
operator|!=
name|R_PARISC_PCREL17F
operator|&&
name|r_type
operator|!=
name|R_PARISC_PLABEL32
operator|&&
name|r_type
operator|!=
name|R_PARISC_PLABEL21L
operator|&&
name|r_type
operator|!=
name|R_PARISC_PLABEL14R
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value, section 		 and argument relocation bits.  */
name|hash
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_index
expr_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|input_bfd
argument_list|)
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
name|sym_sec
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|sym_value
operator|=
operator|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|?
literal|0
else|:
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Tack on an ID so we can uniquely identify this local 		     symbol in the stub or arg info hash tables.  */
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s_%08x"
argument_list|,
name|sym_name
argument_list|,
operator|(
name|int
operator|)
name|sym_sec
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|new_name
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an external symbol.  */
name|long
name|index
decl_stmt|;
name|index
operator|=
name|r_index
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|hash
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_name
operator|=
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|sym_value
operator|=
name|hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
name|args_hash
operator|=
name|elf32_hppa_args_hash_lookup
argument_list|(
name|args_hash_table
argument_list|,
name|sym_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Get both caller and callee argument information.  */
if|if
condition|(
name|args_hash
operator|==
name|NULL
condition|)
name|callee_args
operator|=
literal|0
expr_stmt|;
else|else
name|callee_args
operator|=
name|args_hash
operator|->
name|arg_bits
expr_stmt|;
comment|/* For calls get the caller's bits from the addend of 		 the call relocation.  For PLABELS the caller's bits 		 are assumed to have all args& return values in general 		 registers (0x155).  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL17F
condition|)
name|caller_args
operator|=
name|HPPA_R_ARG_RELOC
argument_list|(
name|irela
operator|->
name|r_addend
argument_list|)
expr_stmt|;
else|else
name|caller_args
operator|=
literal|0x155
expr_stmt|;
comment|/* Now determine where the call point is.  */
name|location
operator|=
operator|(
name|section
operator|->
name|output_offset
operator|+
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|irela
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* We only care about the destination for PCREL function 		 calls (eg. we don't care for PLABELS).  */
if|if
condition|(
name|r_type
operator|!=
name|R_PARISC_PCREL17F
condition|)
name|location
operator|=
name|destination
expr_stmt|;
comment|/* Determine what (if any) linker stub is needed and its 		 size (in bytes).  */
name|size_of_stub
operator|=
name|elf32_hppa_size_of_stub
argument_list|(
name|callee_args
argument_list|,
name|caller_args
argument_list|,
name|location
argument_list|,
name|destination
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_of_stub
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
comment|/* Get the name of this stub.  */
name|len
operator|=
name|strlen
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|23
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
block|{
comment|/* Because sym_name was mallocd above for local 			 symbols.  */
if|if
condition|(
name|r_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|elf32_hppa_name_of_stub
argument_list|(
name|caller_args
argument_list|,
name|callee_args
argument_list|,
name|location
argument_list|,
name|destination
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stub_name
operator|+
literal|22
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
comment|/* Because sym_name was malloced above for local symbols.  */
if|if
condition|(
name|r_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|stub_hash
operator|=
name|elf32_hppa_stub_hash_lookup
argument_list|(
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_hash
operator|!=
name|NULL
condition|)
block|{
comment|/* The proper stub has already been created, nothing 			 else to do.  */
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_set_section_size
argument_list|(
name|stub_bfd
argument_list|,
name|stub_sec
argument_list|,
operator|(
name|bfd_section_size
argument_list|(
name|stub_bfd
argument_list|,
name|stub_sec
argument_list|)
operator|+
name|size_of_stub
operator|)
argument_list|)
expr_stmt|;
comment|/* Enter this entry into the linker stub hash table.  */
name|stub_hash
operator|=
name|elf32_hppa_stub_hash_lookup
argument_list|(
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_hash
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* We'll need these to determine the address that the 			 stub will branch to.  */
name|stub_hash
operator|->
name|target_value
operator|=
name|sym_value
expr_stmt|;
name|stub_hash
operator|->
name|target_section
operator|=
name|sym_sec
expr_stmt|;
block|}
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're done with the internal relocs, free them.  */
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're done with the local symbols, free them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bfd_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_local_syms
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|all_local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
comment|/* Return gracefully, avoiding dangling references to the hash tables.  */
if|if
condition|(
name|stub_hash_table
condition|)
block|{
name|elf32_hppa_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|stub_hash_table
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|stub_hash_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args_hash_table
condition|)
block|{
name|elf32_hppa_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|args_hash_table
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|args_hash_table
argument_list|)
expr_stmt|;
block|}
comment|/* Set the size of the stub section to zero since we're never going      to create them.   Avoids losing when we try to get its contents      too.  */
name|bfd_set_section_size
argument_list|(
name|stub_bfd
argument_list|,
name|stub_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Misc BFD support code.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_hppa_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label
value|hppa_elf_is_local_label
end_define

begin_comment
comment|/* Symbol extension stuff.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_set_section_contents
value|elf32_hppa_set_section_contents
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_table_processing
define|\
value|elf32_hppa_backend_symbol_table_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_begin_write_processing
define|\
value|elf32_hppa_backend_begin_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elf32_hppa_backend_final_write_processing
end_define

begin_comment
comment|/* Stuff for the BFD linker.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_hppa_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|elf32_hppa_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|elf32_hppa_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf32_hppa_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_hppa_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-hppa"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_hppa
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PARISC
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

