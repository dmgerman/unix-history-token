begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF linker support.    Copyright 1995, 1996 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ELF linker code.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_add_archive_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf_link_read_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_export_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This struct is used to pass information to routines called via    elf_link_hash_traverse which must return failure.  */
end_comment

begin_struct
struct|struct
name|elf_info_failed
block|{
name|boolean
name|failed
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Given an ELF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|boolean
name|elf_bfd_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|elf_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|elf_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add symbols from an ELF archive file to the linker hash table.  We    don't use _bfd_generic_link_add_archive_symbols because of a    problem which arises on UnixWare.  The UnixWare libc.so is an    archive which includes an entry libc.so.1 which defines a bunch of    symbols.  The libc.so archive also includes a number of other    object files, which also define symbols, some of which are the same    as those defined in libc.so.1.  Correct linking requires that we    consider each object file in turn, and include it if it defines any    symbols we need.  _bfd_generic_link_add_archive_symbols does not do    this; it looks through the list of undefined symbols, and includes    any object file which defines them.  When this algorithm is used on    UnixWare, it winds up pulling in libc.so.1 early and defining a    bunch of symbols.  This means that some of the other objects in the    archive are not included in the link, which is incorrect since they    precede libc.so.1 in the archive.     Fortunately, ELF archive handling is simpler than that done by    _bfd_generic_link_add_archive_symbols, which has to allow for a.out    oddities.  In ELF, if we find a symbol in the archive map, and the    symbol is currently undefined, we know that we must pull in that    object file.     Unfortunately, we do have to make multiple passes over the symbol    table until nothing further is resolved.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_add_archive_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|symindex
name|c
decl_stmt|;
name|boolean
modifier|*
name|defined
init|=
name|NULL
decl_stmt|;
name|boolean
modifier|*
name|included
init|=
name|NULL
decl_stmt|;
name|carsym
modifier|*
name|symdefs
decl_stmt|;
name|boolean
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* An empty archive is a special case.  */
if|if
condition|(
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Keep track of all symbols we know to be already defined, and all      files we know to be already included.  This is to speed up the      second and subsequent passes.  */
name|c
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|defined
operator|=
operator|(
name|boolean
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|included
operator|=
operator|(
name|boolean
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|defined
operator|==
operator|(
name|boolean
operator|*
operator|)
name|NULL
operator|||
name|included
operator|==
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memset
argument_list|(
name|defined
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|included
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|symdefs
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
expr_stmt|;
do|do
block|{
name|file_ptr
name|last
decl_stmt|;
name|symindex
name|i
decl_stmt|;
name|carsym
modifier|*
name|symdef
decl_stmt|;
name|carsym
modifier|*
name|symdefend
decl_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
name|symdef
operator|=
name|symdefs
expr_stmt|;
name|symdefend
operator|=
name|symdef
operator|+
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symdef
operator|<
name|symdefend
condition|;
name|symdef
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs_tail
decl_stmt|;
name|symindex
name|mark
decl_stmt|;
if|if
condition|(
name|defined
index|[
name|i
index|]
operator|||
name|included
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|symdef
operator|->
name|file_offset
operator|==
name|last
condition|)
block|{
name|included
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|symdef
operator|->
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|defined
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* We need to include this archive member.  */
name|element
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|symdef
operator|->
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|element
argument_list|,
name|bfd_object
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Doublecheck that we have not included this object 	     already--it should be impossible, but there may be 	     something wrong with the archive.  */
if|if
condition|(
name|element
operator|->
name|archive_pass
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|element
operator|->
name|archive_pass
operator|=
literal|1
expr_stmt|;
name|undefs_tail
operator|=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|element
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf_link_add_object_symbols
argument_list|(
name|element
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If there are any new undefined symbols, we need to make 	     another pass through the archive in order to see whether 	     they can be defined.  FIXME: This isn't perfect, because 	     common symbols wind up on undefs_tail and because an 	     undefined symbol which is defined later on in this pass 	     does not require another pass.  This isn't a bug, but it 	     does make the code less efficient than it could be.  */
if|if
condition|(
name|undefs_tail
operator|!=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
condition|)
name|loop
operator|=
name|true
expr_stmt|;
comment|/* Look backward to mark all symbols from this object file 	     which we have already seen in this pass.  */
name|mark
operator|=
name|i
expr_stmt|;
do|do
block|{
name|included
index|[
name|mark
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mark
operator|==
literal|0
condition|)
break|break;
operator|--
name|mark
expr_stmt|;
block|}
do|while
condition|(
name|symdefs
index|[
name|mark
index|]
operator|.
name|file_offset
operator|==
name|symdef
operator|->
name|file_offset
condition|)
do|;
comment|/* We mark subsequent symbols from this object file as we go 	     on through the loop.  */
name|last
operator|=
name|symdef
operator|->
name|file_offset
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|defined
operator|!=
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
if|if
condition|(
name|included
operator|!=
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an ELF object file to the linker hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*add_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*check_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
name|collect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|symcount
decl_stmt|;
name|size_t
name|extsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|weaks
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|add_symbol_hook
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_add_symbol_hook
expr_stmt|;
name|collect
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
expr_stmt|;
comment|/* As a GNU extension, any input sections which are named      .gnu.warning.SYMBOL are treated as warning symbols for the given      symbol.  This differs from .gnu.warning sections, which generate      warnings when they are included in an output file.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.warning."
argument_list|,
sizeof|sizeof
expr|".gnu.warning."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|sz
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|msg
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".gnu.warning."
operator|-
literal|1
argument_list|,
name|BSF_WARNING
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|msg
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* Clobber the section size so that the warning does                      not get copied into the output file.  */
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* A stripped shared library might only have a dynamic symbol table,      not a regular symbol table.  In that case we can still go ahead      and link using the dynamic symbol table.  */
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
operator|&&
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
block|}
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols at      this point.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|buf
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|&&
name|extsymcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* We store a pointer to the hash table entry for each external      symbol.  */
name|sym_hash
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_hash
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|!=
name|ET_DYN
condition|)
block|{
name|dynamic
operator|=
name|false
expr_stmt|;
comment|/* If we are creating a shared library, create all the dynamic          sections immediately.  We need to attach them to something,          so we attach them to this BFD, provided it is the right          format.  FIXME: If there are no input BFD's of the same          format as the output, we can't make a shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|add_needed
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|oldsize
decl_stmt|;
name|bfd_size_type
name|strindex
decl_stmt|;
name|dynamic
operator|=
name|true
expr_stmt|;
comment|/* You can't use -r against a dynamic object.  Also, there's no 	 hope of using a dynamic object which does not exactly match 	 the format of the output file.  */
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Find the name to use in a DT_NEEDED entry that refers to this 	 object.  If the object has a DT_SONAME entry, we use it. 	 Otherwise, if the generic linker stuck something in 	 elf_dt_name, we use that.  Otherwise, we just use the file 	 name.  If the generic linker put a null string into 	 elf_dt_name, we don't make a DT_NEEDED entry at all, even if 	 there is a DT_SONAME entry.  */
name|add_needed
operator|=
name|true
expr_stmt|;
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|add_needed
operator|=
name|false
expr_stmt|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|Elf_External_Dyn
modifier|*
name|extdyn
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|extdynend
decl_stmt|;
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|link
decl_stmt|;
name|dynbuf
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|PTR
operator|)
name|dynbuf
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|link
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
name|extdyn
operator|=
name|dynbuf
expr_stmt|;
name|extdynend
operator|=
name|extdyn
operator|+
name|s
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|extdyn
operator|<
name|extdynend
condition|;
name|extdyn
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|abfd
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_SONAME
condition|)
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|link
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|n
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_needed_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|link
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|needed
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We do not want to include any of the sections in a dynamic 	 object in the output file.  We hack by simply clobbering the 	 list of sections in the BFD.  This could be handled more 	 cleanly by, say, a new section flag; the existing 	 SEC_NEVER_LOAD flag is not the one we want, because that one 	 still implies that the section takes up space in the output 	 file.  */
name|abfd
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
comment|/* If this is the first dynamic object found in the link, create 	 the special sections required for dynamic linking.  */
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|add_needed
condition|)
block|{
comment|/* Add a DT_NEEDED entry for this dynamic object.  */
name|oldsize
operator|=
name|_bfd_stringtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
name|strindex
operator|=
name|_bfd_stringtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|strindex
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|oldsize
operator|==
name|_bfd_stringtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* The hash table size did not change, which means that 		 the dynamic object name was already entered.  If we 		 have already included this dynamic object in the 		 link, just ignore it.  There is no reason to include 		 a particular dynamic object more than once.  */
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
operator|&&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
name|strindex
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_NEEDED
argument_list|,
name|strindex
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Save the SONAME, if there is one, because sometimes the          linker emulation code will need to know it.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
name|extsymoff
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|extsymcount
argument_list|,
name|abfd
argument_list|)
operator|!=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|weaks
operator|=
name|NULL
expr_stmt|;
name|esymend
operator|=
name|buf
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
name|esym
operator|=
name|buf
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|sym_hash
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|int
name|bind
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|boolean
name|size_change_ok
decl_stmt|,
name|type_change_ok
decl_stmt|;
name|boolean
name|new_weakdef
decl_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
operator|==
name|STB_LOCAL
condition|)
block|{
comment|/* This should be impossible, since ELF requires that all 	     global symbols follow all local symbols, and that sh_info 	     point to the first global symbol.  Unfortunatealy, Irix 5 	     screws this up.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_GLOBAL
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_COMMON
condition|)
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_WEAK
condition|)
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
name|sec
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
name|value
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
else|else
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* What ELF calls the size we call the value.  What ELF 	     calls the value we call the alignment.  */
name|value
operator|=
name|sym
operator|.
name|st_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|add_symbol_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|add_symbol_hook
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The hook function sets the name to NULL if this symbol 	     should be skipped for some reason.  */
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
continue|continue;
block|}
comment|/* Sanity check that all possibilities were handled.  */
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|definition
operator|=
name|false
expr_stmt|;
else|else
name|definition
operator|=
name|true
expr_stmt|;
name|size_change_ok
operator|=
name|false
expr_stmt|;
name|type_change_ok
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|type_change_ok
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* We need to look up the symbol now in order to get some of 	     the dynamic object handling right.  We pass the hash 	     table entry in to _bfd_generic_link_add_one_symbol so 	     that it does not have to look it up again.  */
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* It's OK to change the type if it used to be a weak              definition.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|type_change_ok
operator|=
name|true
expr_stmt|;
comment|/* It's OK to change the size if it used to be a weak 	     definition, or if it used to be undefined, or if we will 	     be overriding an old definition.  */
if|if
condition|(
name|type_change_ok
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|size_change_ok
operator|=
name|true
expr_stmt|;
comment|/* If we are looking at a dynamic object, and this is a 	     definition, we need to see if it has already been defined 	     by some other object.  If it has, we want to use the 	     existing definition, and we do not want to report a 	     multiple symbol definition error; we do this by 	     clobbering sec to be bfd_und_section_ptr.  */
if|if
condition|(
name|dynamic
operator|&&
name|definition
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
name|bind
operator|==
name|STB_WEAK
operator|)
condition|)
block|{
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|definition
operator|=
name|false
expr_stmt|;
name|size_change_ok
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Similarly, if we are not looking at a dynamic object, and 	     we have a definition, we want to override any definition 	     we may have from a dynamic object.  Symbols from regular 	     files always take precedence over symbols from dynamic 	     objects, even if they are defined after the dynamic 	     object in the link.  */
if|if
condition|(
operator|!
name|dynamic
operator|&&
name|definition
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
operator|(
name|elf_elfheader
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
operator|)
condition|)
block|{
comment|/* Change the hash table entry to undefined, and let 		 _bfd_generic_link_add_one_symbol do the right thing 		 with the new definition.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
name|size_change_ok
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
name|new_weakdef
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dynamic
operator|&&
name|definition
operator|&&
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
operator|&&
name|h
operator|->
name|weakdef
operator|==
name|NULL
condition|)
block|{
comment|/* Keep a list of all weak defined non function symbols from 	     a dynamic object, using the weakdef field.  Later in this 	     function we will set the weakdef field to the correct 	     value.  We only put non-function symbols from dynamic 	     objects on this list, because that happens to be the only 	     time we need to know the normal symbol corresponding to a 	     weak symbol, and the information is time consuming to 	     figure out.  If the weakdef field is not already NULL, 	     then this symbol was already defined by some previous 	     dynamic object, and we will be using that previous 	     definition anyhow.  */
name|h
operator|->
name|weakdef
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|h
expr_stmt|;
name|new_weakdef
operator|=
name|true
expr_stmt|;
block|}
comment|/* Get the alignment of a common symbol.  */
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|bfd_log2
argument_list|(
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|int
name|old_flags
decl_stmt|;
name|boolean
name|dynsym
decl_stmt|;
name|int
name|new_flag
decl_stmt|;
comment|/* Remember the symbol size and type.  */
if|if
condition|(
name|sym
operator|.
name|st_size
operator|!=
literal|0
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|size
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|size
operator|!=
literal|0
operator|&&
name|h
operator|->
name|size
operator|!=
name|sym
operator|.
name|st_size
operator|&&
operator|!
name|size_change_ok
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Warning: size of symbol `%s' changed from %lu to %lu in %s"
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|h
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
operator|.
name|st_size
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|sym
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|STT_NOTYPE
operator|&&
name|h
operator|->
name|type
operator|!=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|&&
operator|!
name|type_change_ok
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Warning: type of symbol `%s' changed from %d to %d in %s"
argument_list|,
name|name
argument_list|,
name|h
operator|->
name|type
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
block|}
comment|/* Set a flag in the hash table entry indicating the type of 	     reference or definition we just found.  Keep a count of 	     the number of dynamic symbols we find.  A dynamic symbol 	     is one which is referenced or defined by both a regular 	     object and a shared object, or one which is referenced or 	     defined by more than one shared object.  */
name|old_flags
operator|=
name|h
operator|->
name|elf_link_hash_flags
expr_stmt|;
name|dynsym
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_DYNAMIC
expr_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
name|new_flag
operator|)
operator|!=
literal|0
operator|||
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|new_flag
expr_stmt|;
if|if
condition|(
name|dynsym
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
operator|!
name|new_weakdef
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|weakdef
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
block|}
comment|/* Now set the weakdefs field correctly for all the weak defined      symbols we found.  The only way to do this is to search all the      symbols.  Since we only need the information for non functions in      dynamic objects, that's the only time we actually put anything on      the list WEAKS.  We need this information so that if a regular      object refers to a symbol defined weakly in a dynamic object, the      real symbol in the dynamic object is also put in the dynamic      symbols; we also must arrange for both symbols to point to the      same memory location.  We could handle the general case of symbol      aliasing, but a general symbol alias can only be generated in      assembler code, handling it correctly would be very time      consuming, and other ELF linkers don't handle general aliasing      either.  */
while|while
condition|(
name|weaks
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hlook
decl_stmt|;
name|asection
modifier|*
name|slook
decl_stmt|;
name|bfd_vma
name|vlook
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hpp
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hppend
decl_stmt|;
name|hlook
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|hlook
operator|->
name|weakdef
expr_stmt|;
name|hlook
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
argument_list|)
expr_stmt|;
name|slook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|vlook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|hpp
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hppend
operator|=
name|hpp
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
init|;
name|hpp
operator|<
name|hppend
condition|;
name|hpp
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|*
name|hpp
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|!=
name|hlook
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|slook
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|vlook
condition|)
block|{
name|hlook
operator|->
name|weakdef
operator|=
name|h
expr_stmt|;
comment|/* If the weak definition is in the list of dynamic 		 symbols, make sure the real definition is put there 		 as well.  */
if|if
condition|(
name|hlook
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If this object is the same format as the output object, and it is      not a shared library, then let the backend look through the      relocs.       This is required to build global offset table entries and to      arrange for dynamic relocs.  It is not required for the      particular common case of linking non PIC code, even when linking      against shared libraries, but unfortunately there is no way of      knowing whether an object file has been compiled PIC or not.      Looking through the relocs is not particularly time consuming.      The problem is that we must either (1) keep the relocs in memory,      which causes the linker to require additional runtime memory or      (2) read the relocs twice from the input file, which wastes time.      This would be a good case for using mmap.       I have no idea how to handle linking PIC code into a file of a      different format.  It probably can't be done.  */
name|check_relocs
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|check_relocs
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
operator|&&
name|check_relocs
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* I believe we can ignore the relocs for any section which              does not form part of the final process image, such as a              debugging section.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|internal_relocs
operator|=
name|elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|ok
operator|=
call|(
modifier|*
name|check_relocs
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Create some sections which will be filled in with dynamic linking    information.  ABFD is an input file which requires dynamic sections    to be created.  The dynamic sections take up virtual memory space    when the final executable is run, so we need to create them before    addresses are assigned to the output sections.  We work out the    actual contents and size of these sections later.  */
end_comment

begin_function
name|boolean
name|elf_link_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|true
return|;
comment|/* Make sure that all dynamic sections use the same input BFD.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
else|else
name|abfd
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Note that we set the SEC_IN_MEMORY flag for all of these      sections.  */
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
comment|/* A dynamically linked executable has a .interp section, but a      shared library does not.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create a strtab to hold the dynamic symbol names.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|==
name|NULL
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The special symbol _DYNAMIC is always set to the start of the      .dynamic section.  This call occurs before we have processed the      symbols for any dynamic object, so we don't have to worry about      overriding a dynamic definition.  We could set _DYNAMIC in a      linker script, but we only want to define it if we are, in fact,      creating a .dynamic section.  We don't want to define it if there      is no .dynamic section, since on some ELF platforms the start up      code examines it to decide how to initialize the process.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_DYNAMIC"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Let the backend create the rest of the sections.  This lets the      backend set the right flags.  The backend will normally create      the .got and .plt sections.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_create_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the .dynamic table.  */
end_comment

begin_function
name|boolean
name|elf_add_dynamic_entry
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|tag
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
name|bfd_byte
modifier|*
name|newcontents
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|s
operator|->
name|_raw_size
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
name|newcontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|dyn
operator|.
name|d_tag
operator|=
name|tag
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|val
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|newcontents
operator|+
name|s
operator|->
name|_raw_size
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|newsize
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|newcontents
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read and swap the relocs for a section.  They may have been cached.    If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are not NULL,    they are used as buffers to read into.  They are known to be large    enough.  If the INTERNAL_RELOCS relocs argument is NULL, the return    value is allocated using either malloc or bfd_alloc, according to    the KEEP_MEMORY argument.  */
end_comment

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf_link_read_relocs
parameter_list|(
name|abfd
parameter_list|,
name|o
parameter_list|,
name|external_relocs
parameter_list|,
name|internal_relocs
parameter_list|,
name|keep_memory
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|PTR
name|external_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|boolean
name|keep_memory
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|PTR
name|alloc1
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|alloc2
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
condition|)
return|return
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
return|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|size
operator|=
name|o
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_memory
condition|)
name|internal_relocs
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|internal_relocs
operator|=
name|alloc2
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
block|{
name|alloc1
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc1
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|external_relocs
operator|=
name|alloc1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
name|external_relocs
argument_list|,
literal|1
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_hdr
operator|->
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Swap in the relocs.  For convenience, we always produce an      Elf_Internal_Rela array; if the relocs are Rel, we set the addend      to 0.  */
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|erelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|erelend
operator|=
name|erel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erel
operator|<
name|erelend
condition|;
name|erel
operator|++
operator|,
name|irela
operator|++
control|)
block|{
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
operator|&
name|irel
argument_list|)
expr_stmt|;
name|irela
operator|->
name|r_offset
operator|=
name|irel
operator|.
name|r_offset
expr_stmt|;
name|irela
operator|->
name|r_info
operator|=
name|irel
operator|.
name|r_info
expr_stmt|;
name|irela
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erelaend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|erelaend
operator|=
name|erela
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erela
operator|<
name|erelaend
condition|;
name|erela
operator|++
operator|,
name|irela
operator|++
control|)
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
block|}
comment|/* Cache the results for next time, if we can.  */
if|if
condition|(
name|keep_memory
condition|)
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
if|if
condition|(
name|alloc1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc1
argument_list|)
expr_stmt|;
comment|/* Don't free alloc2, since if it was allocated we are passing it      back (under the name of internal_relocs).  */
return|return
name|internal_relocs
return|;
name|error_return
label|:
if|if
condition|(
name|alloc1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record an assignment to a symbol made by a linker script.  We need    this in case some dynamic object refers to this symbol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|record_link_assignment
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|provide
argument_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|provide
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
comment|/* If this symbol is being provided by the linker script, and it is      currently defined by a dynamic object, but not by a regular      object, then mark it as undefined so that the generic linker will      force the correct value.  */
if|if
condition|(
name|provide
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|shared
operator|)
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is a weak defined symbol, and we know a corresponding 	 real symbol from the same dynamic object, make sure the real 	 symbol is also made into a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|weakdef
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Array used to determine the number of hash table buckets to use    based on the number of symbols there are.  If there are fewer than    3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,    fewer than 37 we use 17 buckets, and so forth.  We never use more    than 521 buckets.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|elf_buckets
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|37
block|,
literal|67
block|,
literal|97
block|,
literal|131
block|,
literal|197
block|,
literal|263
block|,
literal|521
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up the sizes and contents of the ELF dynamic sections.  This is    called by the ELF linker emulation before_allocation routine.  We    must set the sizes of the sections before the linker sets the    addresses of the various sections.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|size_dynamic_sections
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|soname
argument_list|,
name|rpath
argument_list|,
name|export_dynamic
argument_list|,
name|info
argument_list|,
name|sinterpptr
argument_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|soname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|export_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
modifier|*
name|sinterpptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* If there were no dynamic objects in the link, there is nothing to      do here.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* If we are supposed to export all symbols into the dynamic symbol      table (this is not the normal case), then do so.  */
if|if
condition|(
name|export_dynamic
condition|)
block|{
name|struct
name|elf_info_failed
name|eif
decl_stmt|;
name|eif
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|eif
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_export_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|struct
name|elf_info_failed
name|eif
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_size_type
name|strsize
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|sinterpptr
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|soname
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SONAME
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|symbolic
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMBOLIC
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|rpath
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|rpath
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RPATH
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Find all symbols which were defined in a dynamic object and make 	 the backend pick a reasonable value for them.  */
name|eif
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|eif
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_adjust_dynamic_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Add some entries to the .dynamic section.  We fill in some of the 	 values later, in elf_bfd_final_link, but we must add the entries 	 now so that we know the final size of the .dynamic section.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"_init"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_INIT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"_fini"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FINI
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|strsize
operator|=
name|_bfd_stringtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_HASH
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_STRTAB
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMTAB
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_STRSZ
argument_list|,
name|strsize
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* The backend must work out the sizes of all the other dynamic      sections.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_size_dynamic_sections
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|size_t
name|dynsymcount
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|bucketcount
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
comment|/* Set the size of the .dynsym and .hash sections.  We counted 	 the number of dynamic symbols in elf_link_add_object_symbols. 	 We will build the contents of .dynsym and .hash when we build 	 the final symbol table, because until then we do not know the 	 correct value to give the symbols.  We built the .dynstr 	 section as we went along in elf_link_add_object_symbols.  */
name|dynsymcount
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* The first entry in .dynsym is a dummy symbol.  */
name|isym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_shndx
operator|=
literal|0
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|elf_buckets
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|bucketcount
operator|=
name|elf_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|<
name|elf_buckets
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
operator|(
literal|2
operator|+
name|bucketcount
operator|+
name|dynsymcount
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|output_bfd
argument_list|,
name|bucketcount
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|output_bfd
argument_list|,
name|dynsymcount
argument_list|,
name|s
operator|->
name|contents
operator|+
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
operator|=
name|bucketcount
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This routine is used to export all defined symbols into the dynamic    symbol table.  It is called via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_export_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_info_failed
modifier|*
name|eif
init|=
operator|(
expr|struct
name|elf_info_failed
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make the backend pick a good value for a dynamic symbol.  This is    called via elf_link_hash_traverse, and also calls itself    recursively.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_adjust_dynamic_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_info_failed
modifier|*
name|eif
init|=
operator|(
expr|struct
name|elf_info_failed
operator|*
operator|)
name|data
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
comment|/* If this symbol was mentioned in a non-ELF file, try to set      DEF_REGULAR and REF_REGULAR correctly.  This is the only way to      permit a non-ELF file to correctly refer to a symbol defined in      an ELF dynamic object.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_ELF
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
else|else
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* If -Bsymbolic was used (which means to bind references to global      symbols to the definition within the shared object), and this      symbol was defined in a regular object, then it actually doesn't      need a PLT entry.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
operator|&&
name|eif
operator|->
name|info
operator|->
name|shared
operator|&&
name|eif
operator|->
name|info
operator|->
name|symbolic
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
comment|/* If this symbol does not require a PLT entry, and it is not      defined by a dynamic object, or is not referenced by a regular      object, ignore it.  We do have to handle a weak defined symbol,      even if no regular object refers to it, if we decided to add it      to the dynamic symbol table.  FIXME: Do we normally need to worry      about symbols which are defined by one dynamic object and      referenced by another one?  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|weakdef
operator|==
name|NULL
operator|||
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* If we've already adjusted this symbol, don't do it again.  This      can happen via a recursive call.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
comment|/* Don't look at this symbol again.  Note that we must set this      after checking the above conditions, because we may look at a      symbol once, decide not to do anything, and then get called      recursively later after REF_REGULAR is set below.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
expr_stmt|;
comment|/* If this is a weak definition, and we know a real definition, and      the real symbol is not itself defined by a regular object file,      then get a good value for the real definition.  We handle the      real symbol first, for the convenience of the backend routine.       Note that there is a confusing case here.  If the real definition      is defined by a regular object file, we don't get the real symbol      from the dynamic object, but we do get the weak symbol.  If the      processor backend uses a COPY reloc, then if some routine in the      dynamic object changes the real symbol, we will not see that      change in the corresponding weak symbol.  This is the way other      ELF linkers work as well, and seems to be a result of the shared      library model.       I will clarify this issue.  Most SVR4 shared libraries define the      variable _timezone and define timezone as a weak synonym.  The      tzset call changes _timezone.  If you write        extern int timezone;        int _timezone = 5;        int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }      you might expect that, since timezone is a synonym for _timezone,      the same number will print both times.  However, if the processor      backend uses a COPY reloc, then actually timezone will be copied      into your process image, and, since you define _timezone      yourself, _timezone will not.  Thus timezone and _timezone will      wind up at different memory locations.  The tzset call will set      _timezone, leaving timezone unchanged.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|weakdef
operator|=
name|h
operator|->
name|weakdef
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol is defined by a regular object file, so we 	     will not do anything special.  Clear weakdef for the 	     convenience of the processor backend.  */
name|h
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* There is an implicit reference by a regular object file 	     via the weak symbol.  */
name|weakdef
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
if|if
condition|(
operator|!
name|elf_adjust_dynamic_symbol
argument_list|(
name|weakdef
argument_list|,
operator|(
name|PTR
operator|)
name|eif
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_adjust_dynamic_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Final phase of ELF linker.  */
end_comment

begin_comment
comment|/* A structure we use to avoid passing large numbers of arguments.  */
end_comment

begin_struct
struct|struct
name|elf_final_link_info
block|{
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* Symbol string table.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|symstrtab
decl_stmt|;
comment|/* .dynsym section.  */
name|asection
modifier|*
name|dynsym_sec
decl_stmt|;
comment|/* .hash section.  */
name|asection
modifier|*
name|hash_sec
decl_stmt|;
comment|/* Buffer large enough to hold contents of any section.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Buffer large enough to hold external relocs of any section.  */
name|PTR
name|external_relocs
decl_stmt|;
comment|/* Buffer large enough to hold internal relocs of any section.  */
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
comment|/* Buffer large enough to hold external local symbols of any input      BFD.  */
name|Elf_External_Sym
modifier|*
name|external_syms
decl_stmt|;
comment|/* Buffer large enough to hold internal local symbols of any input      BFD.  */
name|Elf_Internal_Sym
modifier|*
name|internal_syms
decl_stmt|;
comment|/* Array large enough to hold a symbol index for each local symbol      of any input BFD.  */
name|long
modifier|*
name|indices
decl_stmt|;
comment|/* Array large enough to hold a section pointer for each local      symbol of any input BFD.  */
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
comment|/* Buffer to hold swapped out symbols.  */
name|Elf_External_Sym
modifier|*
name|symbuf
decl_stmt|;
comment|/* Number of swapped out symbols in buffer.  */
name|size_t
name|symbuf_count
decl_stmt|;
comment|/* Number of symbols which fit in symbuf.  */
name|size_t
name|symbuf_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_output_sym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_flush_output_syms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_input_bfd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_reloc_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This struct is used to pass information to routines called via    elf_link_hash_traverse which must return failure.  */
end_comment

begin_struct
struct|struct
name|elf_finfo_failed
block|{
name|boolean
name|failed
decl_stmt|;
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Do the final step of an ELF link.  */
end_comment

begin_function
name|boolean
name|elf_bfd_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
name|dynamic
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_final_link_info
name|finfo
decl_stmt|;
specifier|register
name|asection
modifier|*
name|o
decl_stmt|;
specifier|register
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|sub
decl_stmt|;
name|size_t
name|max_contents_size
decl_stmt|;
name|size_t
name|max_external_reloc_size
decl_stmt|;
name|size_t
name|max_internal_reloc_count
decl_stmt|;
name|size_t
name|max_sym_count
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Sym
name|elfsym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_finfo_failed
name|eif
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
name|dynamic
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|symstrtab
operator|=
name|elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|!=
name|NULL
operator|&&
name|finfo
operator|.
name|hash_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf_count
operator|=
literal|0
expr_stmt|;
comment|/* Count up the number of relocations we will output for each output      section, so that we know the sizes of the reloc sections.  We      also figure out some maximum sizes.  */
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_external_reloc_size
operator|=
literal|0
expr_stmt|;
name|max_internal_reloc_count
operator|=
literal|0
expr_stmt|;
name|max_sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
name|o
operator|->
name|reloc_count
operator|+=
name|sec
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
comment|/* We are interested in just local symbols, not all 		 symbols.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|size_t
name|sym_count
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
condition|)
name|sym_count
operator|=
operator|(
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
expr_stmt|;
else|else
name|sym_count
operator|=
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
if|if
condition|(
name|sym_count
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sym_count
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|ext_size
decl_stmt|;
name|ext_size
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|ext_size
operator|>
name|max_external_reloc_size
condition|)
name|max_external_reloc_size
operator|=
name|ext_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_internal_reloc_count
condition|)
name|max_internal_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
else|else
block|{
comment|/* Explicitly clear the SEC_RELOC flag.  The linker tends to 	     set it (this is probably a bug) and if it is set 	     assign_section_numbers will create a reloc section.  */
name|o
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
block|}
comment|/* If the SEC_ALLOC flag is not set, force the section VMA to 	 zero.  This is done in elf_fake_sections as well, but forcing 	 the VMA to 0 here will ensure that relocs against these 	 sections are handled correctly.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
name|o
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Figure out the file positions for everything but the symbol table      and the relocs.  We set symcount to force assign_section_numbers      to create a symbol table.  */
name|abfd
operator|->
name|symcount
operator|=
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That created the reloc sections.  Set their sizes, and assign      them file positions, and allocate some buffers.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
specifier|register
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pend
decl_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rel_hdr
operator|->
name|sh_size
operator|=
name|rel_hdr
operator|->
name|sh_entsize
operator|*
name|o
operator|->
name|reloc_count
expr_stmt|;
comment|/* The contents field must last into write_object_contents, 	     so we allocate it with bfd_alloc rather than malloc.  */
name|rel_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|rel_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|o
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|=
name|p
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* Use the reloc_count field as an index when outputting the 	     relocs.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|_bfd_elf_assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We have now assigned file positions for all the sections except      .symtab and .strtab.  We start the .symtab section at the current      file position, and write directly to it.  We build the .strtab      section in memory.  */
name|abfd
operator|->
name|symcount
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* sh_name is set in prep_headers.  */
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* sh_link is set in assign_section_numbers.  */
comment|/* sh_info is set below.  */
comment|/* sh_offset is set just below.  */
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
literal|4
expr_stmt|;
comment|/* FIXME: system dependent?  */
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symtab_hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Note that at this point elf_tdata (abfd)->next_file_pos is      incorrect.  We do not yet know the size of the .symtab section.      We correct next_file_pos below, after we do know the size.  */
comment|/* Allocate a buffer to hold swapped out symbols.  This is to avoid      continuously seeking to the right position in the file.  */
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
name|max_sym_count
operator|<
literal|20
condition|)
name|finfo
operator|.
name|symbuf_size
operator|=
literal|20
expr_stmt|;
else|else
name|finfo
operator|.
name|symbuf_size
operator|=
name|max_sym_count
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|finfo
operator|.
name|symbuf_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Start writing out the symbol table.  The first symbol is always a      dummy symbol.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|||
name|info
operator|->
name|relocateable
condition|)
block|{
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|bfd_und_section_ptr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|#
directive|if
literal|0
comment|/* Some standard ELF linkers do this, but we don't because it causes      bootstrap comparison failures.  */
comment|/* Output a file symbol for the output file as the second symbol.      We output this even if we are discarding local symbols, although      I'm not sure if this is correct.  */
block|elfsym.st_value = 0;   elfsym.st_size = 0;   elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);   elfsym.st_other = 0;   elfsym.st_shndx = SHN_ABS;   if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),&elfsym, bfd_abs_section_ptr))     goto error_return;
endif|#
directive|endif
comment|/* Output a symbol for each section.  We output these even if we are      discarding local symbols, since they are used for relocs.  These      symbols have no names.  We store the index of each one in the      index field of the section, so that we can find it again when      outputting relocs.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|||
name|info
operator|->
name|relocateable
condition|)
block|{
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|NULL
condition|)
name|o
operator|->
name|target_index
operator|=
name|abfd
operator|->
name|symcount
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Allocate some memory to hold information read in from the input      files.  */
name|finfo
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|max_external_reloc_size
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
operator|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_internal_reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
operator|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
operator|(
name|long
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
operator|&&
name|max_contents_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
operator|&&
name|max_external_reloc_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|internal_relocs
operator|==
name|NULL
operator|&&
name|max_internal_reloc_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|indices
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sections
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Since ELF permits relocations to be against local symbols, we      must have the local symbols available when we do the relocations.      Since we would rather only read the local symbols once, and we      would rather not keep them in memory, we handle all the      relocations for a single input file at the same time.       Unfortunately, there is no way to know the total number of local      symbols until we have seen all of them, and the local symbol      indices precede the global symbol indices.  This means that when      we are generating relocateable output, and we see a reloc against      a global symbol, we can not know the symbol index until we have      finished examining all the local symbols to see which ones we are      going to output.  To deal with this, we keep the relocations in      memory, and don't output them until the end of the link.  This is      an unfortunate waste of memory, but I don't see a good way around      it.  Fortunately, it only happens when performing a relocateable      link, which is not the common case.  FIXME: If keep_memory is set      we could write the relocs out and then read them again; I don't      know how bad the memory loss will be.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|sub
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
block|{
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|elf_reloc_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* That wrote out all the local symbols.  Finish up the symbol table      with the global symbols.  */
comment|/* The sh_info field records the index of the first non local      symbol.  */
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|abfd
operator|->
name|symcount
expr_stmt|;
if|if
condition|(
name|dynamic
condition|)
name|elf_section_data
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
literal|1
expr_stmt|;
comment|/* We get the global symbols from the hash table.  */
name|eif
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|eif
operator|.
name|finfo
operator|=
operator|&
name|finfo
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Flush all symbols to the file.  */
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
operator|&
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now we know the size of the symtab section.  */
name|off
operator|+=
name|symtab_hdr
operator|->
name|sh_size
expr_stmt|;
comment|/* Finish up and write out the symbol string table (.strtab)      section.  */
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set just below.  */
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symstrtab_hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symstrtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|finfo
operator|.
name|symstrtab
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Adjust the relocs to have the correct symbol indices.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|rel_hash
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
expr_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|rel_hash
operator|==
name|NULL
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|i
expr_stmt|;
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
operator|&
name|irel
argument_list|)
expr_stmt|;
name|irel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irel
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|i
expr_stmt|;
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set the reloc_count field to 0 to prevent write_relocs from 	 trying to swap the relocs out itself.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we are linking against a dynamic object, or generating a      shared library, finish up the dynamic linking information.  */
if|if
condition|(
name|dynamic
condition|)
block|{
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* Fix up .dynamic entries.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
comment|/* SVR4 linkers seem to set DT_INIT and DT_FINI based on                  magic _init and _fini symbols.  This is pretty ugly,                  but we are compatible.  */
case|case
name|DT_INIT
case|:
name|name
operator|=
literal|"_init"
expr_stmt|;
goto|goto
name|get_sym
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
literal|"_fini"
expr_stmt|;
name|get_sym
label|:
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|o
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
operator|(
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
block|{
comment|/* The symbol is imported from another shared 			   library and does not apply to this one.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
block|}
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|".hash"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|".dynstr"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|get_vma
label|:
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|o
operator|->
name|vma
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELASZ
case|:
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_REL
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
condition|)
name|type
operator|=
name|SHT_REL
expr_stmt|;
else|else
name|type
operator|=
name|SHT_RELA
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|type
operator|&&
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELASZ
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|hdr
operator|->
name|sh_size
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
literal|0
operator|||
name|hdr
operator|->
name|sh_addr
operator|<
name|dyn
operator|.
name|d_un
operator|.
name|d_val
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|hdr
operator|->
name|sh_addr
expr_stmt|;
block|}
block|}
block|}
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we have created any dynamic sections, then output them.  */
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|_raw_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* At this point, we are only interested in sections                  created by elf_link_create_dynamic_sections.  FIXME:                  This test is fragile.  */
continue|continue;
block|}
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_STRTAB
operator|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
literal|".dynstr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
name|file_ptr
name|off
decl_stmt|;
comment|/* The contents of the .dynstr section are actually in a                  stringtab.  */
name|off
operator|=
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_offset
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to the output symbol table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_output_sym
parameter_list|(
name|finfo
parameter_list|,
name|name
parameter_list|,
name|elfsym
parameter_list|,
name|input_sec
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|elfsym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*output_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
name|output_symbol_hook
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|elf_backend_link_output_symbol_hook
expr_stmt|;
if|if
condition|(
name|output_symbol_hook
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|output_symbol_hook
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|elfsym
argument_list|,
name|input_sec
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|elfsym
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|elfsym
operator|->
name|st_name
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|symstrtab
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsym
operator|->
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>=
name|finfo
operator|->
name|symbuf_size
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|elf_swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|elfsym
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|finfo
operator|->
name|symbuf
operator|+
name|finfo
operator|->
name|symbuf_count
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|finfo
operator|->
name|symbuf_count
expr_stmt|;
operator|++
name|finfo
operator|->
name|output_bfd
operator|->
name|symcount
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Flush the output symbols to the file.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_flush_output_syms
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
block|{
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab
decl_stmt|;
name|symtab
operator|=
operator|&
name|elf_tdata
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|symtab
operator|->
name|sh_offset
operator|+
name|symtab
operator|->
name|sh_size
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|symbuf
argument_list|,
name|finfo
operator|->
name|symbuf_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|finfo
operator|->
name|symbuf_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|symtab
operator|->
name|sh_size
operator|+=
name|finfo
operator|->
name|symbuf_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|symbuf_count
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an external symbol to the symbol table.  This is called from    the hash table traversal routine.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_finfo_failed
modifier|*
name|eif
init|=
operator|(
expr|struct
name|elf_finfo_failed
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf_final_link_info
modifier|*
name|finfo
init|=
name|eif
operator|->
name|finfo
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
comment|/* If we are not creating a shared library, and this symbol is      referenced by a shared library but is not defined anywhere, then      warn that it is undefined.  If we do not do this, the runtime      linker will complain that the symbol is undefined when the      program is run.  We don't have to worry about symbols that are      referenced by regular files, because we will already have issued      warnings for them.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* We don't want to output symbols that have never been mentioned by      a regular file, or that we have been told to strip.  However, if      h->indx is set to -2, the symbol is used by a reloc and we must      output it.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
comment|/* If we're stripping it, and it's not a dynamic symbol, there's      nothing else to do.  */
if|if
condition|(
name|strip
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|true
return|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|h
operator|->
name|size
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_link_hash_undefined
case|:
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefweak
case|:
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
block|{
name|input_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|input_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|input_sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* ELF symbols in relocateable files are section relative, 	       but in nonrelocateable files they are virtual 	       addresses.  */
name|sym
operator|.
name|st_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|input_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|sym
operator|.
name|st_value
operator|+=
name|input_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|bfd_get_flavour
argument_list|(
name|input_sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
name|elf_elfheader
argument_list|(
name|input_sec
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|input_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_COMMON
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|1
operator|<<
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
comment|/* We can't represent these symbols in ELF.  A warning symbol          may have come from a .gnu.warning.SYMBOL section anyhow.  We          just put the target symbol in the hash table.  If the target          symbol does not really exist, don't do anything.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
return|return
name|true
return|;
return|return
operator|(
name|elf_link_output_extsym
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
comment|/* If this symbol should be put in the .dynsym section, then put it      there now.  We have already know the symbol index.  We also fill      in the entry in the .hash section.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|size_t
name|bucket
decl_stmt|;
name|bfd_byte
modifier|*
name|bucketpos
decl_stmt|;
name|bfd_vma
name|chain
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
name|h
operator|->
name|dynstr_index
expr_stmt|;
comment|/* Give the processor backend a chance to tweak the symbol 	 value, and also to finish up anything that needs to be done 	 for this symbol.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_symbol
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|h
argument_list|,
operator|&
name|sym
argument_list|)
operator|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|elf_swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|finfo
operator|->
name|dynsym_sec
operator|->
name|contents
operator|)
operator|+
name|h
operator|->
name|dynindx
argument_list|)
argument_list|)
expr_stmt|;
name|bucketcount
operator|=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|bucketcount
expr_stmt|;
name|bucket
operator|=
operator|(
name|bfd_elf_hash
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|%
name|bucketcount
operator|)
expr_stmt|;
name|bucketpos
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucket
operator|+
literal|2
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
operator|)
expr_stmt|;
name|chain
operator|=
name|get_word
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|chain
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucketcount
operator|+
literal|2
operator|+
name|h
operator|->
name|dynindx
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we're stripping it, then it was just a dynamic symbol, and      there's nothing else to do.  */
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
name|h
operator|->
name|indx
operator|=
name|finfo
operator|->
name|output_bfd
operator|->
name|symcount
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|sym
argument_list|,
name|input_sec
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Link an input file into the linker output file.  This function    handles all the sections and relocations of the input file at once.    This is so that we only have to read the local symbols once, and    don't have to keep them in memory.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_input_bfd
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*relocate_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|long
modifier|*
name|pindex
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ppsection
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|relocate_section
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|elf_backend_relocate_section
expr_stmt|;
comment|/* If this is a dynamic object, we don't want to do anything here:      we don't want the local symbols, and we don't want the section      contents.  */
if|if
condition|(
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
name|true
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
comment|/* Read the local symbols.  */
if|if
condition|(
name|locsymcount
operator|>
literal|0
operator|&&
operator|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|finfo
operator|->
name|external_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|locsymcount
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|locsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Swap in the local symbols and write out the ones which we know      are going into the output file.  */
name|esym
operator|=
name|finfo
operator|->
name|external_syms
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|locsymcount
expr_stmt|;
name|isym
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|pindex
operator|=
name|finfo
operator|->
name|indices
expr_stmt|;
name|ppsection
operator|=
name|finfo
operator|->
name|sections
expr_stmt|;
for|for
control|(
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|isym
operator|++
operator|,
name|pindex
operator|++
operator|,
name|ppsection
operator|++
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
name|osym
decl_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|isym
argument_list|)
expr_stmt|;
operator|*
name|pindex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
operator|*
name|ppsection
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|>
literal|0
operator|&&
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|isec
operator|=
name|section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
block|{
comment|/* Who knows?  */
name|isec
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|ppsection
operator|=
name|isec
expr_stmt|;
comment|/* Don't output the first, undefined, symbol.  */
if|if
condition|(
name|esym
operator|==
name|finfo
operator|->
name|external_syms
condition|)
continue|continue;
comment|/* If we are stripping all symbols, we don't want to output this 	 one.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
continue|continue;
comment|/* We never output section symbols.  Instead, we use the section 	 symbol of the corresponding section in the output file.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
continue|continue;
comment|/* If we are discarding all local symbols, we don't want to 	 output this one.  If we are generating a relocateable output 	 file, then some of the local symbols may be required by 	 relocs; we output them below as we discover that they are 	 needed.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_all
condition|)
continue|continue;
comment|/* Get the name of the symbol.  */
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* See if we are discarding symbols with this name.  */
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|lprefix
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|lprefix_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* If we get here, we are going to output this symbol.  */
name|osym
operator|=
operator|*
name|isym
expr_stmt|;
comment|/* Adjust the section index for the output file.  */
name|osym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|isec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|osym
operator|.
name|st_shndx
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
operator|*
name|pindex
operator|=
name|output_bfd
operator|->
name|symcount
expr_stmt|;
comment|/* ELF symbols in relocateable files are section relative, but 	 in executable files they are virtual addresses.  Note that 	 this code assumes that all ELF sections have an associated 	 BFD section with a reasonable value for output_offset; below 	 we assume that they also have a reasonable value for 	 output_section.  Any special sections must be set up to meet 	 these requirements.  */
name|osym
operator|.
name|st_value
operator|+=
name|isec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|osym
operator|.
name|st_value
operator|+=
name|isec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
operator|&
name|osym
argument_list|,
name|isec
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Relocate the contents of each section.  */
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|!=
literal|0
operator|&&
name|input_bfd
operator|==
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynobj
condition|)
block|{
comment|/* Section was created by elf_link_create_dynamic_sections.              FIXME: This test is fragile.  */
continue|continue;
block|}
comment|/* Read the contents of the section.  */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
comment|/* Get the swapped relocs.  */
name|internal_relocs
operator|=
name|elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|external_relocs
argument_list|,
name|finfo
operator|->
name|internal_relocs
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
operator|&&
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
return|return
name|false
return|;
comment|/* Relocate the section by invoking a back end routine.  	     The back end routine is responsible for adjusting the 	     section contents as necessary, and (if using Rela relocs 	     and generating a relocateable output file) adjusting the 	     reloc addend as necessary.  	     The back end routine does not have to worry about setting 	     the reloc address or the reloc symbol index.  	     The back end routine is given a pointer to the swapped in 	     internal symbols, and can access the hash table entries 	     for the external symbols via elf_sym_hashes (input_bfd).  	     When generating relocateable output, the back end routine 	     must handle STB_LOCAL/STT_SECTION symbols specially.  The 	     output symbol is going to be a section symbol 	     corresponding to the output section, which will require 	     the addend to be adjusted.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|relocate_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
name|internal_relocs
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|finfo
operator|->
name|sections
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|output_rel_hdr
decl_stmt|;
comment|/* Adjust the reloc addresses and symbol indices.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|irela
operator|->
name|r_offset
operator|+=
name|o
operator|->
name|output_offset
expr_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|long
name|indx
decl_stmt|;
comment|/* This is a reloc against a global symbol.  We 			 have not yet output all the local symbols, so 			 we do not know the symbol index of any global 			 symbol.  We set the rel_hash entry for this 			 reloc to point to the global hash table entry 			 for this symbol.  The symbol index is then 			 set at the end of elf_bfd_final_link.  */
name|indx
operator|=
name|r_symndx
operator|-
name|extsymoff
expr_stmt|;
operator|*
name|rel_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
comment|/* Setting the index to -2 tells 			 elf_link_output_extsym that this symbol is 			 used by a reloc.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|<
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* This is a reloc against a local symbol. */
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
name|isym
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
comment|/* I suppose the backend ought to fill in the 			 section of any STT_SECTION symbol against a 			 processor specific section.  */
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|r_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|r_symndx
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
block|{
comment|/* You can't do ld -r -s.  */
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* This symbol was skipped earlier, but 			     since it is needed by a reloc, we 			     must output it now.  */
name|link
operator|=
name|symtab_hdr
operator|->
name|sh_link
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|isym
operator|->
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|isym
operator|->
name|st_value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|isym
operator|->
name|st_value
operator|+=
name|osec
operator|->
name|vma
expr_stmt|;
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|=
name|output_bfd
operator|->
name|symcount
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
name|isym
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|r_symndx
operator|=
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
name|irela
operator|->
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Swap out the relocs.  */
name|input_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|output_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|output_rel_hdr
operator|->
name|sh_entsize
operator|==
name|input_rel_hdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|erel
operator|=
operator|(
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|output_rel_hdr
operator|->
name|contents
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|erel
operator|++
control|)
block|{
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|irel
operator|.
name|r_offset
operator|=
name|irela
operator|->
name|r_offset
expr_stmt|;
name|irel
operator|.
name|r_info
operator|=
name|irela
operator|->
name|r_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|irela
operator|->
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|output_rel_hdr
operator|->
name|contents
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|erela
operator|++
control|)
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|+=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* Write out the modified section contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
name|o
operator|->
name|output_offset
argument_list|,
operator|(
name|o
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|o
operator|->
name|_cooked_size
else|:
name|o
operator|->
name|_raw_size
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc when linking an ELF file.  This is a reloc    requested by the linker, and does come from any input file.  This    is used to build constructor and destructor tables when linking    with -Ur.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_reloc_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash_ptr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
comment|/* Figure out the symbol index.  */
name|rel_hash_ptr
operator|=
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
name|indx
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|->
name|target_index
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Treat a reloc against a defined symbol as though it were          actually against the section.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|indx
operator|=
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* It seems that we ought to add the symbol value to the              addend here, but in practice it has already been added              because it was passed to constructor_callback.  */
name|addend
operator|+=
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Setting the index to -2 tells elf_link_output_extsym that 	     this symbol is used by a reloc.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|h
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If this is an inplace reloc, we must write the addend into the      object file.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|&&
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|?
name|bfd_section_name
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
argument_list|)
else|:
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|)
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|link_order
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
block|}
comment|/* The address of a reloc is relative to the section in a      relocateable file, and is a virtual address in an executable      file.  */
name|offset
operator|=
name|link_order
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
name|offset
operator|+=
name|output_section
operator|->
name|vma
expr_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
condition|)
block|{
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|irel
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|erel
operator|=
operator|(
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|irela
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|erela
operator|=
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
operator|++
name|output_section
operator|->
name|reloc_count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a pointer to live in a linker created section.  */
end_comment

begin_function
name|boolean
name|elf_create_pointer_linker_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|lsect
parameter_list|,
name|h
parameter_list|,
name|rel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
block|{
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr_linker_section_ptr
init|=
name|NULL
decl_stmt|;
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
empty_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Is this a global symbol? */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Has this symbol already been allocated, if so, our work is done */
if|if
condition|(
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|h
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
condition|)
return|return
name|true
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|h
operator|->
name|linker_section_pointer
expr_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|lsect
operator|->
name|rel_section
condition|)
name|lsect
operator|->
name|rel_section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Allocation of a pointer to a local symbol */
block|{
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr
init|=
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Allocate a table to hold the local symbols if first time */
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|int
name|num_symbols
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|ptr
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|num_symbols
operator|*
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|false
return|;
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_symbols
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Has this symbol already been allocated, if so, our work is done */
if|if
condition|(
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|ptr
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
condition|)
return|return
name|true
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|ptr
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 	     output a R_<xxx>_RELATIVE reloc so that the 	     dynamic linker can adjust this GOT entry.  */
name|BFD_ASSERT
argument_list|(
name|lsect
operator|->
name|rel_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lsect
operator|->
name|rel_section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate space for a pointer in the linker section, and allocate a new pointer record      from internal memory.  */
name|BFD_ASSERT
argument_list|(
name|ptr_linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linker_section_ptr
condition|)
return|return
name|false
return|;
name|linker_section_ptr
operator|->
name|next
operator|=
operator|*
name|ptr_linker_section_ptr
expr_stmt|;
name|linker_section_ptr
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|linker_section_ptr
operator|->
name|which
operator|=
name|lsect
operator|->
name|which
expr_stmt|;
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|false
expr_stmt|;
operator|*
name|ptr_linker_section_ptr
operator|=
name|linker_section_ptr
expr_stmt|;
if|if
condition|(
name|lsect
operator|->
name|hole_size
operator|&&
name|lsect
operator|->
name|hole_offset
operator|<
name|lsect
operator|->
name|max_hole_offset
condition|)
block|{
name|linker_section_ptr
operator|->
name|offset
operator|=
name|lsect
operator|->
name|section
operator|->
name|_raw_size
operator|-
name|lsect
operator|->
name|hole_size
expr_stmt|;
name|lsect
operator|->
name|hole_offset
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
name|lsect
operator|->
name|sym_offset
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|lsect
operator|->
name|sym_hash
condition|)
comment|/* Bump up symbol value if needed */
name|lsect
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
block|}
else|else
name|linker_section_ptr
operator|->
name|offset
operator|=
name|lsect
operator|->
name|section
operator|->
name|_raw_size
expr_stmt|;
name|lsect
operator|->
name|section
operator|->
name|_raw_size
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create pointer in linker section %s, offset = %ld, section size = %ld\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|linker_section_ptr
operator|->
name|offset
argument_list|,
operator|(
name|long
operator|)
name|lsect
operator|->
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|bfd_put_ptr
parameter_list|(
name|BFD
parameter_list|,
name|VAL
parameter_list|,
name|ADDR
parameter_list|)
value|bfd_put_64 (BFD, VAL, ADDR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|bfd_put_ptr
parameter_list|(
name|BFD
parameter_list|,
name|VAL
parameter_list|,
name|ADDR
parameter_list|)
value|bfd_put_32 (BFD, VAL, ADDR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fill in the address for a pointer generated in alinker section.  */
end_comment

begin_function
name|bfd_vma
name|elf_finish_pointer_linker_section
parameter_list|(
name|output_bfd
parameter_list|,
name|input_bfd
parameter_list|,
name|info
parameter_list|,
name|lsect
parameter_list|,
name|h
parameter_list|,
name|relocation
parameter_list|,
name|rel
parameter_list|,
name|relative_reloc
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|int
name|relative_reloc
decl_stmt|;
block|{
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
comment|/* global symbol */
block|{
name|linker_section_ptr
operator|=
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|h
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|symbolic
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 	     -Bsymbolic link and the symbol is defined 	     locally.  We must initialize this entry in the 	     global section.  	     When doing a dynamic link, we create a .rela.<xxx> 	     relocation entry to initialize the value.  This 	     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|!
name|linker_section_ptr
operator|->
name|written_address_p
condition|)
block|{
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|true
expr_stmt|;
name|bfd_put_ptr
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* local symbol */
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write out pointer if it hasn't been rewritten out before */
if|if
condition|(
operator|!
name|linker_section_ptr
operator|->
name|written_address_p
condition|)
block|{
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|true
expr_stmt|;
name|bfd_put_ptr
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srel
init|=
name|lsect
operator|->
name|rel_section
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
comment|/* We need to generate a relative reloc for the dynamic linker.  */
if|if
condition|(
operator|!
name|srel
condition|)
name|lsect
operator|->
name|rel_section
operator|=
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|lsect
operator|->
name|rel_name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
literal|0
argument_list|,
name|relative_reloc
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|lsect
operator|->
name|section
operator|->
name|contents
operator|)
operator|+
name|lsect
operator|->
name|section
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|lsect
operator|->
name|section
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
block|}
name|relocation
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|-
name|lsect
operator|->
name|hole_offset
operator|-
name|lsect
operator|->
name|sym_offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Finish pointer in linker section %s, offset = %ld (0x%lx)\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Subtract out the addend, because it will get added back in by the normal      processing.  */
return|return
name|relocation
operator|-
name|linker_section_ptr
operator|->
name|addend
return|;
block|}
end_function

end_unit

