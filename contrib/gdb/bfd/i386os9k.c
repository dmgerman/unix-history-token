begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for os9000 i386 binaries.    Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_include
include|#
directive|include
file|"os9k.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|os9k_callback
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swaps the information in an executable header taken from a raw byte    stream memory image, into the internal exec_header structure.  */
end_comment

begin_function
name|boolean
name|os9k_swap_exec_header_in
parameter_list|(
name|abfd
parameter_list|,
name|raw_bytes
parameter_list|,
name|execp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|mh_com
modifier|*
name|raw_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
block|{
name|mh_com
modifier|*
name|bytes
init|=
operator|(
name|mh_com
operator|*
operator|)
name|raw_bytes
decl_stmt|;
name|unsigned
name|int
name|dload
decl_stmt|,
name|dmemsize
decl_stmt|,
name|dmemstart
decl_stmt|;
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|m_sync
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
literal|0
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|m_exec
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_talign
operator|=
literal|2
expr_stmt|;
name|execp
operator|->
name|a_dalign
operator|=
literal|2
expr_stmt|;
name|execp
operator|->
name|a_balign
operator|=
literal|2
expr_stmt|;
name|dload
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|m_idata
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|dload
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|dload
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
operator|&
name|dmemstart
argument_list|,
sizeof|sizeof
argument_list|(
name|dmemstart
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dmemstart
argument_list|)
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|&
name|dmemsize
argument_list|,
sizeof|sizeof
argument_list|(
name|dmemsize
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dmemsize
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|execp
operator|->
name|a_tload
operator|=
literal|0
expr_stmt|;
name|execp
operator|->
name|a_dload
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|dmemstart
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|dload
operator|-
name|execp
operator|->
name|a_tload
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|dmemsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|m_data
argument_list|)
operator|-
name|execp
operator|->
name|a_data
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Swaps the information in an internal exec header structure into the    supplied buffer ready for writing to disk.  */
end_comment

begin_comment
unit|PROTO (void, os9k_swap_exec_header_out,          (bfd * abfd, 	  struct internal_exec * execp, 	  struct mh_com * raw_bytes)); void os9k_swap_exec_header_out (abfd, execp, raw_bytes)      bfd *abfd;      struct internal_exec *execp;      mh_com *raw_bytes; {   mh_com *bytes = (mh_com *) raw_bytes;
comment|/* Now fill in fields in the raw data, from the fields in the exec struct. */
end_comment

begin_endif
unit|bfd_h_put_32 (abfd, execp->a_info, bytes->e_info);   bfd_h_put_32 (abfd, execp->a_text, bytes->e_text);   bfd_h_put_32 (abfd, execp->a_data, bytes->e_data);   bfd_h_put_32 (abfd, execp->a_bss, bytes->e_bss);   bfd_h_put_32 (abfd, execp->a_syms, bytes->e_syms);   bfd_h_put_32 (abfd, execp->a_entry, bytes->e_entry);   bfd_h_put_32 (abfd, execp->a_trsize, bytes->e_trsize);   bfd_h_put_32 (abfd, execp->a_drsize, bytes->e_drsize);   bfd_h_put_32 (abfd, execp->a_tload, bytes->e_tload);   bfd_h_put_32 (abfd, execp->a_dload, bytes->e_dload);   bytes->e_talign[0] = execp->a_talign;   bytes->e_dalign[0] = execp->a_dalign;   bytes->e_balign[0] = execp->a_balign;   bytes->e_relaxable[0] = execp->a_relaxable; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|os9k_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
name|anexec
decl_stmt|;
name|mh_com
name|exec_bytes
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|exec_bytes
argument_list|,
name|MHCOM_BYTES_SIZE
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|MHCOM_BYTES_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|anexec
operator|.
name|a_info
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|exec_bytes
operator|.
name|m_sync
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|anexec
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|os9k_swap_exec_header_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec_bytes
argument_list|,
operator|&
name|anexec
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|aout_32_some_aout_object_p
argument_list|(
name|abfd
argument_list|,
operator|&
name|anexec
argument_list|,
name|os9k_callback
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish up the opening of a b.out file for reading.  Fill in all the    fields that are not handled by common code.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|os9k_callback
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|bss_start
decl_stmt|;
comment|/* Architecture and machine type */
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The positions of the string table and symbol table.  */
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The alignments of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_talign
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_dalign
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_balign
expr_stmt|;
comment|/* The starting addresses of the sections.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|execp
operator|->
name|a_tload
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|execp
operator|->
name|a_dload
expr_stmt|;
comment|/* And reload the sizes, since the aout module zaps them */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|execp
operator|->
name|a_text
expr_stmt|;
name|bss_start
operator|=
name|execp
operator|->
name|a_dload
operator|+
name|execp
operator|->
name|a_data
expr_stmt|;
comment|/* BSS = end of data section */
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|align_power
argument_list|(
name|bss_start
argument_list|,
name|execp
operator|->
name|a_balign
argument_list|)
expr_stmt|;
comment|/* The file positions of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|execp
operator|->
name|a_entry
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|execp
operator|->
name|a_dload
expr_stmt|;
comment|/* The file positions of the relocation info ***   obj_textsec (abfd)->rel_filepos = N_TROFF(*execp);   obj_datasec (abfd)->rel_filepos =  N_DROFF(*execp);   */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|MHCOM_BYTES_SIZE
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|struct bout_data_struct {   struct aoutdata a;   struct internal_exec e; };  static boolean os9k_mkobject (abfd)      bfd *abfd; {   struct bout_data_struct *rawptr;    rawptr = (struct bout_data_struct *) bfd_zalloc (abfd, sizeof (struct bout_data_struct));   if (rawptr == NULL)     return false;    abfd->tdata.bout_data = rawptr;   exec_hdr (abfd) =&rawptr->e;    obj_textsec (abfd) = (asection *) NULL;   obj_datasec (abfd) = (asection *) NULL;   obj_bsssec (abfd) = (asection *) NULL;    return true; }  static boolean os9k_write_object_contents (abfd)      bfd *abfd; {   struct external_exec swapped_hdr;    if (! aout_32_make_sections (abfd))     return false;    exec_hdr (abfd)->a_info = BMAGIC;    exec_hdr (abfd)->a_text = obj_textsec (abfd)->_raw_size;   exec_hdr (abfd)->a_data = obj_datasec (abfd)->_raw_size;   exec_hdr (abfd)->a_bss = obj_bsssec (abfd)->_raw_size;   exec_hdr (abfd)->a_syms = bfd_get_symcount (abfd) * sizeof (struct nlist);   exec_hdr (abfd)->a_entry = bfd_get_start_address (abfd);   exec_hdr (abfd)->a_trsize = ((obj_textsec (abfd)->reloc_count) * 			       sizeof (struct relocation_info));   exec_hdr (abfd)->a_drsize = ((obj_datasec (abfd)->reloc_count) * 			       sizeof (struct relocation_info));    exec_hdr (abfd)->a_talign = obj_textsec (abfd)->alignment_power;   exec_hdr (abfd)->a_dalign = obj_datasec (abfd)->alignment_power;   exec_hdr (abfd)->a_balign = obj_bsssec (abfd)->alignment_power;    exec_hdr (abfd)->a_tload = obj_textsec (abfd)->vma;   exec_hdr (abfd)->a_dload = obj_datasec (abfd)->vma;    bout_swap_exec_header_out (abfd, exec_hdr (abfd),&swapped_hdr);    if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0       || (bfd_write ((PTR)& swapped_hdr, 1, EXEC_BYTES_SIZE, abfd) 	  != EXEC_BYTES_SIZE))     return false;
comment|/* Now write out reloc info, followed by syms and strings */
end_comment

begin_escape
unit|if (bfd_get_symcount (abfd) != 0)     {       if (bfd_seek (abfd, (file_ptr) (N_SYMOFF (*exec_hdr (abfd))), SEEK_SET) 	  != 0) 	return false;        if (!aout_32_write_syms (abfd)) 	return false;        if (bfd_seek (abfd, (file_ptr) (N_TROFF (*exec_hdr (abfd))), SEEK_SET) 	  != 0) 	return false;        if (!b_out_squirt_out_relocs (abfd, obj_textsec (abfd))) 	return false;       if (bfd_seek (abfd, (file_ptr) (N_DROFF (*exec_hdr (abfd))), SEEK_SET) 	  != 0) 	return false;        if (!b_out_squirt_out_relocs (abfd, obj_datasec (abfd))) 	return false;     }   return true; }
end_escape

begin_comment
unit|static boolean os9k_set_section_contents (abfd, section, location, offset, count)      bfd *abfd;      sec_ptr section;      unsigned char *location;      file_ptr offset;      int count; {    if (abfd->output_has_begun == false)     {
comment|/* set by bfd.c handler */
end_comment

begin_comment
unit|if (! aout_32_make_sections (abfd)) 	return false;        obj_textsec (abfd)->filepos = sizeof (struct internal_exec);       obj_datasec (abfd)->filepos = obj_textsec (abfd)->filepos 	+ obj_textsec (abfd)->_raw_size;      }
comment|/* regardless, once we know what we're doing, we might as well get going */
end_comment

begin_endif
unit|if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0)     return false;    if (count != 0)     {       return (bfd_write ((PTR) location, 1, count, abfd) == count) ? true : false;     }   return true; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|int
name|os9k_sizeof_headers
parameter_list|(
name|ignore_abfd
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|boolean
name|ignore
decl_stmt|;
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_define
define|#
directive|define
name|aout_32_close_and_cleanup
value|aout_32_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|aout_32_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|os9k_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|os9k_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|os9k_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|os9k_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|os9k_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|os9k_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|i386os9k_vec
init|=
block|{
literal|"i386os9k"
block|,
comment|/* name */
name|bfd_target_os9k_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* hdr byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|WP_TEXT
operator|)
block|,
comment|/* object flags */
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* symbol leading char */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|os9k_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|bfd_false
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|bfd_false
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_bsd
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|os9k
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|, }
decl_stmt|;
end_decl_stmt

end_unit

