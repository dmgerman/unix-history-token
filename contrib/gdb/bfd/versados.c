begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for VERSAdos-E objects.     Versados is a Motorola trademark.     Copyright 1995 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*    SUBSECTION    VERSAdos-E relocateable object file format     DESCRIPTION     This module supports reading of VERSAdos relocateable    object files.     A VERSAdos file looks like contains     o Indentification Record    o External Symbol Definition Record    o Object Text Recrod    o End Record    */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_decl_stmt
specifier|static
name|boolean
name|versados_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|versados_scan
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|versados_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VHEADER
value|'1'
end_define

begin_define
define|#
directive|define
name|VESTDEF
value|'2'
end_define

begin_define
define|#
directive|define
name|VOTR
value|'3'
end_define

begin_define
define|#
directive|define
name|VEND
value|'4'
end_define

begin_define
define|#
directive|define
name|ES_BASE
value|17
end_define

begin_comment
comment|/* first symbol has esdid 17 */
end_comment

begin_comment
comment|/* Per file target dependent information */
end_comment

begin_comment
comment|/* one for each section */
end_comment

begin_struct
struct|struct
name|esdid
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* ptr to bfd version */
name|unsigned
name|char
modifier|*
name|contents
decl_stmt|;
comment|/* used to build image */
name|int
name|pc
decl_stmt|;
name|int
name|relocs
decl_stmt|;
comment|/* reloc count, valid end of pass 1 */
name|int
name|donerel
decl_stmt|;
comment|/* have relocs been translated */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|versados_data_struct
block|{
name|int
name|es_done
decl_stmt|;
comment|/* count of symbol index, starts at ES_BASE */
name|asymbol
modifier|*
name|symbols
decl_stmt|;
comment|/* pointer to local symbols */
name|char
modifier|*
name|strings
decl_stmt|;
comment|/* strings of all the above */
name|int
name|stringlen
decl_stmt|;
comment|/* len of string table (valid end of pass1) */
name|int
name|nsecsyms
decl_stmt|;
comment|/* number of sections */
name|int
name|ndefs
decl_stmt|;
comment|/* number of exported symbols (they dont get esdids) */
name|int
name|nrefs
decl_stmt|;
comment|/* number of imported symbols  (valid end of pass1) */
name|int
name|ref_idx
decl_stmt|;
comment|/* current processed value of the above */
name|int
name|def_idx
decl_stmt|;
name|int
name|pass_2_done
decl_stmt|;
name|struct
name|esdid
name|e
index|[
literal|16
index|]
decl_stmt|;
comment|/* per section info */
name|int
name|alert
decl_stmt|;
comment|/* to see if we're trampling */
name|asymbol
modifier|*
name|rest
index|[
literal|256
operator|-
literal|16
index|]
decl_stmt|;
comment|/* per symbol info */
block|}
name|tdata_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VDATA
parameter_list|(
name|abfd
parameter_list|)
value|(abfd->tdata.versados_data)
end_define

begin_define
define|#
directive|define
name|EDATA
parameter_list|(
name|abfd
parameter_list|,
name|n
parameter_list|)
value|(abfd->tdata.versados_data->e[n])
end_define

begin_define
define|#
directive|define
name|RDATA
parameter_list|(
name|abfd
parameter_list|,
name|n
parameter_list|)
value|(abfd->tdata.versados_data->rest[n])
end_define

begin_struct
struct|struct
name|ext_otr
block|{
name|unsigned
name|char
name|size
decl_stmt|;
name|char
name|type
decl_stmt|;
name|unsigned
name|char
name|map
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|esdid
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|200
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ext_vheader
block|{
name|unsigned
name|char
name|size
decl_stmt|;
name|char
name|type
decl_stmt|;
comment|/* record type */
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
comment|/* module name */
name|char
name|rev
decl_stmt|;
comment|/* module rev number */
name|char
name|lang
decl_stmt|;
name|char
name|vol
index|[
literal|4
index|]
decl_stmt|;
name|char
name|user
index|[
literal|2
index|]
decl_stmt|;
name|char
name|cat
index|[
literal|8
index|]
decl_stmt|;
name|char
name|fname
index|[
literal|8
index|]
decl_stmt|;
name|char
name|ext
index|[
literal|2
index|]
decl_stmt|;
name|char
name|time
index|[
literal|3
index|]
decl_stmt|;
name|char
name|date
index|[
literal|3
index|]
decl_stmt|;
name|char
name|rest
index|[
literal|211
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ext_esd
block|{
name|unsigned
name|char
name|size
decl_stmt|;
name|char
name|type
decl_stmt|;
name|unsigned
name|char
name|esd_entries
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ESD_ABS
value|0
end_define

begin_define
define|#
directive|define
name|ESD_COMMON
value|1
end_define

begin_define
define|#
directive|define
name|ESD_STD_REL_SEC
value|2
end_define

begin_define
define|#
directive|define
name|ESD_SHRT_REL_SEC
value|3
end_define

begin_define
define|#
directive|define
name|ESD_XDEF_IN_SEC
value|4
end_define

begin_define
define|#
directive|define
name|ESD_XREF_SYM
value|7
end_define

begin_define
define|#
directive|define
name|ESD_XREF_SEC
value|6
end_define

begin_define
define|#
directive|define
name|ESD_XDEF_IN_ABS
value|5
end_define

begin_union
union|union
name|ext_any
block|{
name|unsigned
name|char
name|size
decl_stmt|;
name|struct
name|ext_vheader
name|header
decl_stmt|;
name|struct
name|ext_esd
name|esd
decl_stmt|;
name|struct
name|ext_otr
name|otr
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* Initialize by filling in the hex conversion array. */
end_comment

begin_comment
comment|/* Set up the tdata information.  */
end_comment

begin_function
specifier|static
name|boolean
name|versados_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|versados_data
operator|==
name|NULL
condition|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|versados_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|alert
operator|=
literal|0x12345678
expr_stmt|;
block|}
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Report a problem in an S record file.  FIXME: This probably should    not call fprintf, but we really do need some mechanism for printing    error messages.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|versados_new_symbol
parameter_list|(
name|abfd
parameter_list|,
name|snum
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|snum
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|asymbol
modifier|*
name|n
init|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbols
operator|+
name|snum
decl_stmt|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|n
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|n
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_record
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|union
name|ext_any
modifier|*
name|ptr
decl_stmt|;
block|{
name|bfd_read
argument_list|(
operator|&
name|ptr
operator|->
name|size
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|ptr
operator|->
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|ptr
operator|->
name|size
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|get_4
parameter_list|(
name|pp
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
operator|*
name|pp
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|get_10
parameter_list|(
name|pp
parameter_list|,
name|name
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
operator|*
name|pp
decl_stmt|;
name|int
name|len
init|=
literal|10
decl_stmt|;
operator|*
name|pp
operator|+=
name|len
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
name|len
condition|)
block|{
operator|*
name|name
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
operator|*
name|name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|new_symbol_string
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|n
init|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|strings
decl_stmt|;
name|strcpy
argument_list|(
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|strings
operator|+=
name|strlen
argument_list|(
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|strings
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_esd
parameter_list|(
name|abfd
parameter_list|,
name|esd
parameter_list|,
name|pass
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ext_esd
modifier|*
name|esd
decl_stmt|;
name|int
name|pass
decl_stmt|;
block|{
comment|/* Read through the ext def for the est entries */
name|int
name|togo
init|=
name|esd
operator|->
name|size
operator|-
literal|2
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|bfd_vma
name|start
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
name|name
index|[
literal|11
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|esd
operator|->
name|esd_entries
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|togo
decl_stmt|;
while|while
condition|(
name|ptr
operator|<
name|end
condition|)
block|{
name|int
name|scn
init|=
operator|*
name|ptr
operator|&
literal|0xf
decl_stmt|;
name|int
name|typ
init|=
operator|(
operator|*
name|ptr
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
comment|/* Declare this section */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d"
argument_list|,
name|scn
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|target_index
operator|=
name|scn
expr_stmt|;
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|scn
argument_list|)
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|typ
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ESD_XREF_SEC
case|:
case|case
name|ESD_XREF_SYM
case|:
block|{
name|int
name|snum
init|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ref_idx
operator|++
decl_stmt|;
name|get_10
argument_list|(
operator|&
name|ptr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|stringlen
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|esidx
decl_stmt|;
name|asymbol
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|new_symbol_string
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|s
operator|=
name|versados_new_symbol
argument_list|(
name|abfd
argument_list|,
name|snum
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|bfd_und_section
argument_list|,
name|scn
argument_list|)
expr_stmt|;
name|esidx
operator|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|es_done
operator|++
expr_stmt|;
name|RDATA
argument_list|(
name|abfd
argument_list|,
name|esidx
operator|-
name|ES_BASE
argument_list|)
operator|=
name|s
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ESD_ABS
case|:
name|size
operator|=
name|get_4
argument_list|(
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|start
operator|=
name|get_4
argument_list|(
operator|&
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESD_STD_REL_SEC
case|:
case|case
name|ESD_SHRT_REL_SEC
case|:
block|{
name|sec
operator|->
name|_raw_size
operator|=
name|get_4
argument_list|(
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
break|break;
case|case
name|ESD_XDEF_IN_ABS
case|:
name|sec
operator|=
operator|(
name|asection
operator|*
operator|)
operator|&
name|bfd_abs_section
expr_stmt|;
case|case
name|ESD_XDEF_IN_SEC
case|:
block|{
name|int
name|snum
init|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|def_idx
operator|++
decl_stmt|;
name|long
name|val
decl_stmt|;
name|get_10
argument_list|(
operator|&
name|ptr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|get_4
argument_list|(
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
comment|/* Just remember the symbol */
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|stringlen
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asymbol
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|new_symbol_string
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|s
operator|=
name|versados_new_symbol
argument_list|(
name|abfd
argument_list|,
name|snum
operator|+
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|nrefs
argument_list|,
name|n
argument_list|,
name|val
argument_list|,
name|sec
argument_list|,
name|scn
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|R_RELWORD
value|1
end_define

begin_define
define|#
directive|define
name|R_RELLONG
value|2
end_define

begin_define
define|#
directive|define
name|R_RELWORD_NEG
value|3
end_define

begin_define
define|#
directive|define
name|R_RELLONG_NEG
value|4
end_define

begin_decl_stmt
name|reloc_howto_type
name|versados_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_RELWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"+v16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"+v32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELWORD_NEG
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"-v16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELLONG_NEG
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"-v32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|get_offset
parameter_list|(
name|len
parameter_list|,
name|ptr
parameter_list|)
name|int
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|int
name|i
decl_stmt|;
name|val
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x80
condition|)
name|val
operator||=
operator|~
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator||
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_otr
parameter_list|(
name|abfd
parameter_list|,
name|otr
parameter_list|,
name|pass
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ext_otr
modifier|*
name|otr
decl_stmt|;
name|int
name|pass
decl_stmt|;
block|{
name|unsigned
name|long
name|shift
decl_stmt|;
name|unsigned
name|char
modifier|*
name|srcp
init|=
name|otr
operator|->
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|otr
operator|+
name|otr
operator|->
name|size
decl_stmt|;
name|unsigned
name|int
name|bits
init|=
operator|(
name|otr
operator|->
name|map
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|otr
operator|->
name|map
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|otr
operator|->
name|map
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|otr
operator|->
name|map
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
decl_stmt|;
name|struct
name|esdid
modifier|*
name|esdid
init|=
operator|&
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|otr
operator|->
name|esdid
operator|-
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|contents
init|=
name|esdid
operator|->
name|contents
decl_stmt|;
name|int
name|need_contents
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|dst_idx
init|=
name|esdid
operator|->
name|pc
decl_stmt|;
for|for
control|(
name|shift
operator|=
operator|(
literal|1
operator|<<
literal|31
operator|)
init|;
name|shift
operator|&&
name|srcp
operator|<
name|endp
condition|;
name|shift
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|bits
operator|&
name|shift
condition|)
block|{
name|int
name|flag
init|=
operator|*
name|srcp
operator|++
decl_stmt|;
name|int
name|esdids
init|=
operator|(
name|flag
operator|>>
literal|5
operator|)
operator|&
literal|0x7
decl_stmt|;
name|int
name|sizeinwords
init|=
operator|(
operator|(
name|flag
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|offsetlen
init|=
name|flag
operator|&
literal|0x7
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|esdids
operator|==
literal|0
condition|)
block|{
comment|/* A zero esdid means the new pc is the offset given */
name|dst_idx
operator|+=
name|get_offset
argument_list|(
name|offsetlen
argument_list|,
name|srcp
argument_list|)
expr_stmt|;
name|srcp
operator|+=
name|offsetlen
expr_stmt|;
block|}
else|else
block|{
name|int
name|val
init|=
name|get_offset
argument_list|(
name|offsetlen
argument_list|,
name|srcp
operator|+
name|esdids
argument_list|)
decl_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|need_contents
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sizeinwords
operator|*
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|contents
index|[
name|dst_idx
operator|+
operator|(
name|sizeinwords
operator|*
literal|2
operator|)
operator|-
name|j
operator|-
literal|1
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|esdids
condition|;
name|j
operator|++
control|)
block|{
name|int
name|esdid
init|=
operator|*
name|srcp
operator|++
decl_stmt|;
if|if
condition|(
name|esdid
condition|)
block|{
name|int
name|rn
init|=
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|otr
operator|->
name|esdid
operator|-
literal|1
argument_list|)
operator|.
name|relocs
operator|++
decl_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
comment|/* this is the first pass over the data,  			     just remember that we need a reloc */
block|}
else|else
block|{
name|arelent
modifier|*
name|n
init|=
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|otr
operator|->
name|esdid
operator|-
literal|1
argument_list|)
operator|.
name|section
operator|->
name|relocation
operator|+
name|rn
decl_stmt|;
name|n
operator|->
name|address
operator|=
name|dst_idx
expr_stmt|;
name|n
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|esdid
expr_stmt|;
name|n
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|howto
operator|=
name|versados_howto_table
operator|+
operator|(
operator|(
name|j
operator|&
literal|1
operator|)
operator|*
literal|2
operator|)
operator|+
operator|(
name|sizeinwords
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
name|srcp
operator|+=
name|offsetlen
expr_stmt|;
name|dst_idx
operator|+=
name|sizeinwords
operator|*
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|need_contents
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dst_idx
operator|<
name|esdid
operator|->
name|section
operator|->
name|_raw_size
condition|)
if|if
condition|(
name|pass
operator|==
literal|2
condition|)
block|{
comment|/* absolute code, comes in 16 bit lumps */
name|contents
index|[
name|dst_idx
index|]
operator|=
name|srcp
index|[
literal|0
index|]
expr_stmt|;
name|contents
index|[
name|dst_idx
operator|+
literal|1
index|]
operator|=
name|srcp
index|[
literal|1
index|]
expr_stmt|;
block|}
name|dst_idx
operator|+=
literal|2
expr_stmt|;
name|srcp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|otr
operator|->
name|esdid
operator|-
literal|1
argument_list|)
operator|.
name|pc
operator|=
name|dst_idx
expr_stmt|;
if|if
condition|(
operator|!
name|contents
operator|&&
name|need_contents
condition|)
name|esdid
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|esdid
operator|->
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|versados_scan
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|loop
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|nsecs
init|=
literal|0
decl_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|nrefs
operator|=
literal|0
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ndefs
operator|=
literal|0
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ref_idx
operator|=
literal|0
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|def_idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
name|union
name|ext_any
name|any
decl_stmt|;
if|if
condition|(
operator|!
name|get_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|any
argument_list|)
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|any
operator|.
name|header
operator|.
name|type
condition|)
block|{
case|case
name|VHEADER
case|:
break|break;
case|case
name|VEND
case|:
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VESTDEF
case|:
name|process_esd
argument_list|(
name|abfd
argument_list|,
operator|&
name|any
operator|.
name|esd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOTR
case|:
name|process_otr
argument_list|(
name|abfd
argument_list|,
operator|&
name|any
operator|.
name|otr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now allocate space for the relocs and sections */
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|nrefs
operator|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ref_idx
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ndefs
operator|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|def_idx
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ref_idx
operator|=
literal|0
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|def_idx
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|nrefs
operator|+
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ndefs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|esdid
modifier|*
name|esdid
init|=
operator|&
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|esdid
operator|->
name|section
condition|)
block|{
name|esdid
operator|->
name|section
operator|->
name|relocation
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
operator|*
name|esdid
operator|->
name|relocs
argument_list|)
expr_stmt|;
name|esdid
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|esdid
operator|->
name|contents
condition|)
name|esdid
operator|->
name|section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
expr_stmt|;
name|esdid
operator|->
name|section
operator|->
name|reloc_count
operator|=
name|esdid
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|esdid
operator|->
name|relocs
condition|)
name|esdid
operator|->
name|section
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|esdid
operator|->
name|relocs
operator|=
literal|0
expr_stmt|;
comment|/* Add an entry into the symbol table for it */
name|nsecs
operator|++
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|stringlen
operator|+=
name|strlen
argument_list|(
name|esdid
operator|->
name|section
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|abfd
operator|->
name|symcount
operator|+=
name|nsecs
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
operator|*
operator|(
name|abfd
operator|->
name|symcount
operator|)
argument_list|)
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|strings
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|stringlen
argument_list|)
expr_stmt|;
comment|/* Actually fill in the section symbols,      we stick them at the end of the table */
for|for
control|(
name|j
operator|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|nrefs
operator|+
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ndefs
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|esdid
modifier|*
name|esdid
init|=
operator|&
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|esdid
operator|->
name|section
decl_stmt|;
if|if
condition|(
name|sec
condition|)
block|{
name|asymbol
modifier|*
name|s
init|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbols
operator|+
name|j
decl_stmt|;
name|s
operator|->
name|name
operator|=
name|new_symbol_string
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|s
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abfd
operator|->
name|symcount
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* Set this to nsecs - since we've already planted the section      symbols */
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|nsecsyms
operator|=
name|nsecs
expr_stmt|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|ref_idx
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check whether an existing file is a versados  file.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|versados_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|ext_vheader
name|ext
decl_stmt|;
name|unsigned
name|char
name|len
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
return|return
name|NULL
return|;
name|bfd_read
argument_list|(
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|ext
operator|.
name|type
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
operator|||
name|ext
operator|.
name|type
operator|!=
literal|'1'
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* ok, looks like a record, build the tdata and read       in.. */
if|if
condition|(
operator|!
name|versados_mkobject
argument_list|(
name|abfd
argument_list|)
operator|||
operator|!
name|versados_scan
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|versados_pass_2
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|union
name|ext_any
name|any
decl_stmt|;
if|if
condition|(
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|pass_2_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|es_done
operator|=
name|ES_BASE
expr_stmt|;
comment|/* read records till we get to where we want to be */
while|while
condition|(
literal|1
condition|)
block|{
name|get_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|any
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|any
operator|.
name|header
operator|.
name|type
condition|)
block|{
case|case
name|VEND
case|:
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|pass_2_done
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|VESTDEF
case|:
name|process_esd
argument_list|(
name|abfd
argument_list|,
operator|&
name|any
operator|.
name|esd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOTR
case|:
name|process_otr
argument_list|(
name|abfd
argument_list|,
operator|&
name|any
operator|.
name|otr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|versados_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|versados_pass_2
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|location
argument_list|,
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|target_index
argument_list|)
operator|.
name|contents
operator|+
name|offset
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|versados_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_function
specifier|static
name|boolean
name|versados_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|bytes_to_do
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|bytes_to_do
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|versados_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|exec
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|asymbol
modifier|*
name|versados_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
name|new
init|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of memory needed to read the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|versados_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|versados_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|unsigned
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|asymbol
modifier|*
name|s
decl_stmt|;
name|versados_pass_2
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
name|VDATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbols
init|;
name|i
operator|<
name|symcount
condition|;
name|s
operator|++
operator|,
name|i
operator|++
control|)
block|{
operator|*
name|alocation
operator|++
operator|=
name|s
expr_stmt|;
block|}
operator|*
name|alocation
operator|=
name|NULL
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
name|void
name|versados_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
name|void
name|versados_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|long
name|versados_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
name|long
name|versados_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|arelent
modifier|*
name|src
decl_stmt|;
name|versados_pass_2
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|src
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
if|if
condition|(
operator|!
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|target_index
argument_list|)
operator|.
name|donerel
condition|)
block|{
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|target_index
argument_list|)
operator|.
name|donerel
operator|=
literal|1
expr_stmt|;
comment|/* translate from indexes to symptr ptrs */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
name|int
name|esdid
init|=
operator|(
name|int
operator|)
name|src
index|[
name|count
index|]
operator|.
name|sym_ptr_ptr
decl_stmt|;
if|if
condition|(
name|esdid
operator|==
literal|0
condition|)
block|{
name|src
index|[
name|count
index|]
operator|.
name|sym_ptr_ptr
operator|=
name|bfd_abs_section
operator|.
name|symbol_ptr_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|esdid
operator|<
name|ES_BASE
condition|)
comment|/* Section relative thing */
block|{
name|struct
name|esdid
modifier|*
name|e
init|=
operator|&
name|EDATA
argument_list|(
name|abfd
argument_list|,
name|esdid
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
block|{
comment|/** relocation relative to section which was 		   never declared ! */
block|}
name|src
index|[
name|count
index|]
operator|.
name|sym_ptr_ptr
operator|=
name|e
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
else|else
block|{
name|src
index|[
name|count
index|]
operator|.
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|esdid
operator|-
name|ES_BASE
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_define
define|#
directive|define
name|versados_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|versados_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|versados_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_define
define|#
directive|define
name|versados_bfd_is_local_label
value|bfd_generic_is_local_label
end_define

begin_define
define|#
directive|define
name|versados_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|versados_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|versados_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|versados_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|versados_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|versados_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|versados_set_arch_mach
value|bfd_default_set_arch_mach
end_define

begin_define
define|#
directive|define
name|versados_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|versados_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|versados_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|versados_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|versados_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|versados_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|versados_vec
init|=
block|{
literal|"versados"
block|,
comment|/* name */
name|bfd_target_versados_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|versados_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|versados_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_false
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|versados
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|versados
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|versados
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|versados
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|versados
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

