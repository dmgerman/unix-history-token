begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD backend for hp-ux 9000/300    Copyright (C) 1990, 1991, 1994, 1995 Free Software Foundation, Inc.    Written by Glenn Engel.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*      hpux native  ------------> |               |                                | hp300hpux bfd | ----------> hpux w/gnu ext     hpux w/gnu extension ----> |               |       Support for the 9000/[34]00 has several limitations.       1. Shared libraries are not supported.       2. The output format from this bfd is not usable by native tools.      The primary motivation for writing this bfd was to allow use of     gdb and gcc for host based debugging and not to mimic the hp-ux tools     in every detail.  This leads to a significant simplification of the     code and a leap in performance.  The decision to not output hp native     compatible objects was further strengthened by the fact that the richness     of the gcc compiled objects could not be represented without loss of     information.  For example, while the hp format supports the concept of     secondary symbols, it does not support indirect symbols.  Another     reason is to maintain backwards compatibility with older implementations     of gcc on hpux which used 'hpxt' to translate .a and .o files into a     format which could be readily understood by the gnu linker and gdb.     This allows reading hp secondary symbols and converting them into     indirect symbols but the reverse it not always possible.      Another example of differences is that the hp format stores symbol offsets     in the object code while the gnu utilities use a field in the     relocation record for this.  To support the hp native format, the object     code would need to be patched with the offsets when producing .o files.      The basic technique taken in this implementation is to #include the code     from aoutx.h and aout-target.h with appropriate #defines to override     code where a unique implementation is needed:      {         #define a bunch of stuff         #include<aoutx.h>          implement a bunch of functions          #include "aout-target.h"     }      The hp symbol table is a bit different than other a.out targets.  Instead     of having an array of nlist items and an array of strings, hp's format     has them mixed together in one structure.  In addition, the strings are     not null terminated.  It looks something like this:      nlist element 1     string1     nlist element 2     string2     ...      The whole symbol table is read as one chunk and then we march thru it     and convert it to canonical form.  As we march thru the table, we copy     the nlist data into the internal form and we compact the strings and null     terminate them, using storage from the already allocated symbol table:      string1     null     string2     null  */
end_comment

begin_comment
comment|/* @@ Is this really so different from normal a.out that it needs to include    aoutx.h?  We should go through this file sometime and see what can be made    more dependent on aout32.o and what might need to be broken off and accessed    through the backend_data field.  Or, maybe we really do need such a    completely separate implementation.  I don't have time to investigate this    much further right now.  [raeburn:19930428.2124EST] */
end_comment

begin_comment
comment|/* @@ Also, note that there wind up being two versions of some routines, with    different names, only one of which actually gets used.  For example: 	slurp_symbol_table 	swap_std_reloc_in 	slurp_reloc_table 	get_symtab 	get_symtab_upper_bound 	canonicalize_reloc 	mkobject    This should also be fixed.  */
end_comment

begin_define
define|#
directive|define
name|TARGETNAME
value|"a.out-hp300hpux"
end_define

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CAT(hp300hpux_,OP)
end_define

begin_define
define|#
directive|define
name|external_exec
value|hp300hpux_exec_bytes
end_define

begin_define
define|#
directive|define
name|external_nlist
value|hp300hpux_nlist_bytes
end_define

begin_include
include|#
directive|include
file|"aout/hp300hpux.h"
end_include

begin_comment
comment|/* define these so we can compile unused routines in aoutx.h */
end_comment

begin_define
define|#
directive|define
name|e_strx
value|e_shlib
end_define

begin_define
define|#
directive|define
name|e_other
value|e_length
end_define

begin_define
define|#
directive|define
name|e_desc
value|e_almod
end_define

begin_define
define|#
directive|define
name|AR_PAD_CHAR
value|'/'
end_define

begin_define
define|#
directive|define
name|TARGET_IS_BIG_ENDIAN_P
end_define

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|bfd_arch_m68k
end_define

begin_define
define|#
directive|define
name|MY_get_section_contents
value|aout_32_get_section_contents
end_define

begin_define
define|#
directive|define
name|MY_slurp_armap
value|bfd_slurp_bsd_armap_f2
end_define

begin_comment
comment|/***********************************************/
end_comment

begin_comment
comment|/* provide overrides for routines in this file */
end_comment

begin_comment
comment|/***********************************************/
end_comment

begin_comment
comment|/* these don't use MY because that causes problems within JUMP_TABLE    (CAT winds up being expanded recursively, which ANSI C compilers    will not do).  */
end_comment

begin_define
define|#
directive|define
name|MY_get_symtab
value|hp300hpux_get_symtab
end_define

begin_define
define|#
directive|define
name|MY_get_symtab_upper_bound
value|hp300hpux_get_symtab_upper_bound
end_define

begin_define
define|#
directive|define
name|MY_canonicalize_reloc
value|hp300hpux_canonicalize_reloc
end_define

begin_define
define|#
directive|define
name|MY_write_object_contents
value|hp300hpux_write_object_contents
end_define

begin_define
define|#
directive|define
name|MY_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|MY_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|MY_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|MY_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|MY_final_link_callback
value|unused
end_define

begin_define
define|#
directive|define
name|MY_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_comment
comment|/* Until and unless we convert the slurp_reloc and slurp_symtab    routines in this file, we can not use the default aout    free_cached_info routine which assumes that the relocs and symtabs    were allocated using malloc.  */
end_comment

begin_define
define|#
directive|define
name|MY_bfd_free_cached_info
value|bfd_true
end_define

begin_define
define|#
directive|define
name|hp300hpux_write_syms
value|aout_32_write_syms
end_define

begin_define
define|#
directive|define
name|MY_callback
value|MY(callback)
end_define

begin_define
define|#
directive|define
name|MY_exec_hdr_flags
value|0x2
end_define

begin_define
define|#
directive|define
name|NAME_swap_exec_header_in
value|NAME(hp300hpux_32_,swap_exec_header_in)
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_UNDEFINED
value|0x00
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_ABSOLUTE
value|0x01
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_TEXT
value|0x02
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_DATA
value|0x03
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_BSS
value|0x04
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_COMMON
value|0x05
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_TYPE
value|0x0F
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_FILENAME
value|0x1F
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_ALIGN
value|0x10
end_define

begin_define
define|#
directive|define
name|HP_SYMTYPE_EXTERNAL
value|0x20
end_define

begin_define
define|#
directive|define
name|HP_SECONDARY_SYMBOL
value|0x40
end_define

begin_comment
comment|/* RELOCATION DEFINITIONS */
end_comment

begin_define
define|#
directive|define
name|HP_RSEGMENT_TEXT
value|0x00
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_DATA
value|0x01
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_BSS
value|0x02
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_EXTERNAL
value|0x03
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_PCREL
value|0x04
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_RDLT
value|0x05
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_RPLT
value|0x06
end_define

begin_define
define|#
directive|define
name|HP_RSEGMENT_NOOP
value|0x3F
end_define

begin_define
define|#
directive|define
name|HP_RLENGTH_BYTE
value|0x00
end_define

begin_define
define|#
directive|define
name|HP_RLENGTH_WORD
value|0x01
end_define

begin_define
define|#
directive|define
name|HP_RLENGTH_LONG
value|0x02
end_define

begin_define
define|#
directive|define
name|HP_RLENGTH_ALIGN
value|0x03
end_define

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT3(hp300hpux,_32_,y)
end_define

begin_define
define|#
directive|define
name|ARCH_SIZE
value|32
end_define

begin_comment
comment|/* aoutx.h requires definitions for BMAGIC and QMAGIC.  */
end_comment

begin_define
define|#
directive|define
name|BMAGIC
value|HPUX_DOT_O_MAGIC
end_define

begin_define
define|#
directive|define
name|QMAGIC
value|0314
end_define

begin_include
include|#
directive|include
file|"aoutx.h"
end_include

begin_comment
comment|/* Since the hpux symbol table has nlist elements interspersed with    strings and we need to insert som strings for secondary symbols, we    give ourselves a little extra padding up front to account for    this.  Note that for each non-secondary symbol we process, we gain    9 bytes of space for the discarded nlist element (one byte used for    null).  SYM_EXTRA_BYTES is the extra space.  */
end_comment

begin_define
define|#
directive|define
name|SYM_EXTRA_BYTES
value|1024
end_define

begin_comment
comment|/* Set parameters about this a.out file that are machine-dependent.    This routine is called from some_aout_object_p just before it returns.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|MY
function|(
name|callback
function|)
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Calculate the file positions of the parts of a newly read aout header */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|N_TXTSIZE
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The virtual memory addresses of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_TXTADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_DATADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_BSSADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|lma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|lma
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|lma
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
comment|/* The file offsets of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_TXTOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_DATOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the relocation info */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_TRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the string table and symbol table.  */
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_STROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* Determine the architecture and machine type of the object file.  */
ifdef|#
directive|ifdef
name|SET_ARCH_MACH
name|SET_ARCH_MACH
argument_list|(
name|abfd
argument_list|,
operator|*
name|execp
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|DEFAULT_ARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|==
name|gnu_encap_format
condition|)
block|{
comment|/* The file offsets of the relocation info */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_GNU_TRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_GNU_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the string table and symbol table.  */
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_GNU_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|execp
operator|->
name|a_syms
operator|)
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_syms
operator|/
literal|12
expr_stmt|;
name|obj_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
literal|12
expr_stmt|;
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|boolean
name|aout_32_write_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|MY
function|(
name|write_object_contents
function|)
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_size_type
name|text_size
decl_stmt|;
comment|/* dummy vars */
name|file_ptr
name|text_end
decl_stmt|;
name|memset
argument_list|(
operator|&
name|exec_bytes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|exec_bytes
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|CHOOSE_RELOC_SIZE
name|CHOOSE_RELOC_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|==
name|undecided_magic
condition|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|adjust_sizes_and_vmas
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|text_size
argument_list|,
operator|&
name|text_end
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
literal|0
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
operator|(
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|)
operator|*
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
operator|(
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|)
operator|*
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|N_SET_FLAGS
argument_list|(
operator|*
name|execp
argument_list|,
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_hdr_flags
argument_list|)
expr_stmt|;
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|,
operator|&
name|exec_bytes
argument_list|)
expr_stmt|;
comment|/* update fields not covered by default swap_exec_header_out */
comment|/* this is really the sym table size but we store it in drelocs */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
literal|12
argument_list|,
name|exec_bytes
operator|.
name|e_drelocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0L
argument_list|,
name|false
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|exec_bytes
argument_list|,
literal|1
argument_list|,
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXEC_BYTES_SIZE
operator|)
condition|)
return|return
name|false
return|;
comment|/* Write out the symbols, and then the relocs.  We must write out        the symbols first so that we know the symbol indices.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Skip the relocs to where we want to put the symbols.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|N_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
operator|+
name|execp
operator|->
name|a_drsize
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|MY
argument_list|(
name|write_syms
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|long
call|)
argument_list|(
name|N_TRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|squirt_out_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|long
call|)
argument_list|(
name|N_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|squirt_out_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* convert the hp symbol type to be the same as aout64.h usage so we */
end_comment

begin_comment
comment|/* can piggyback routines in aoutx.h.                                */
end_comment

begin_function
specifier|static
name|void
name|convert_sym_type
parameter_list|(
name|sym_pointer
parameter_list|,
name|cache_ptr
parameter_list|,
name|abfd
parameter_list|)
name|struct
name|external_nlist
modifier|*
name|sym_pointer
decl_stmt|;
name|aout_symbol_type
modifier|*
name|cache_ptr
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|name_type
decl_stmt|;
name|int
name|new_type
decl_stmt|;
name|name_type
operator|=
operator|(
name|cache_ptr
operator|->
name|type
operator|)
expr_stmt|;
name|new_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|name_type
operator|&
name|HP_SYMTYPE_ALIGN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* iou_error ("aligned symbol encountered: %s", name);*/
name|name_type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|name_type
operator|==
name|HP_SYMTYPE_FILENAME
condition|)
name|new_type
operator|=
name|N_FN
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|name_type
operator|&
name|HP_SYMTYPE_TYPE
condition|)
block|{
case|case
name|HP_SYMTYPE_UNDEFINED
case|:
name|new_type
operator|=
name|N_UNDF
expr_stmt|;
break|break;
case|case
name|HP_SYMTYPE_ABSOLUTE
case|:
name|new_type
operator|=
name|N_ABS
expr_stmt|;
break|break;
case|case
name|HP_SYMTYPE_TEXT
case|:
name|new_type
operator|=
name|N_TEXT
expr_stmt|;
break|break;
case|case
name|HP_SYMTYPE_DATA
case|:
name|new_type
operator|=
name|N_DATA
expr_stmt|;
break|break;
case|case
name|HP_SYMTYPE_BSS
case|:
name|new_type
operator|=
name|N_BSS
expr_stmt|;
break|break;
case|case
name|HP_SYMTYPE_COMMON
case|:
name|new_type
operator|=
name|N_COMM
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name_type
operator|&
name|HP_SYMTYPE_EXTERNAL
condition|)
name|new_type
operator||=
name|N_EXT
expr_stmt|;
if|if
condition|(
name|name_type
operator|&
name|HP_SECONDARY_SYMBOL
condition|)
block|{
switch|switch
condition|(
name|new_type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
name|new_type
operator|=
name|N_WEAKU
expr_stmt|;
break|break;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|new_type
operator|=
name|N_WEAKA
expr_stmt|;
break|break;
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|new_type
operator|=
name|N_WEAKT
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|new_type
operator|=
name|N_WEAKD
expr_stmt|;
break|break;
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|new_type
operator|=
name|N_WEAKB
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cache_ptr
operator|->
name|type
operator|=
name|new_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DESCRIPTION         Swaps the information in an executable header taken from a raw         byte stream memory image, into the internal exec_header         structure. */
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|raw_bytes
argument_list|,
name|execp
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|external_exec
modifier|*
name|raw_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* The internal_exec structure has some fields that are unused in this      configuration (IE for i960), so ensure that all such uninitialized      fields are zero'd out.  There are places where two of these structs      are memcmp'd, and thus the contents do matter. */
name|memset
argument_list|(
name|execp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
comment|/***************************************************************/
comment|/* check the header to see if it was generated by a bfd output */
comment|/* this is detected rather bizarely by requiring a bunch of    */
comment|/* header fields to be zero and an old unused field (now used) */
comment|/* to be set.                                                  */
comment|/***************************************************************/
do|do
block|{
name|long
name|syms
decl_stmt|;
name|struct
name|aout_data_struct
modifier|*
name|rawptr
decl_stmt|;
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_passize
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_supsize
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|syms
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drelocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
literal|0
condition|)
break|break;
comment|/* OK, we've passed the test as best as we can determine */
name|execp
operator|->
name|a_syms
operator|=
name|syms
expr_stmt|;
comment|/* allocate storage for where we will store this result */
name|rawptr
operator|=
operator|(
expr|struct
name|aout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rawptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|rawptr
expr_stmt|;
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|=
name|gnu_encap_format
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
block|}
end_block

begin_comment
comment|/* The hp symbol table is a bit different than other a.out targets.  Instead    of having an array of nlist items and an array of strings, hp's format    has them mixed together in one structure.  In addition, the strings are    not null terminated.  It looks something like this:     nlist element 1    string1    nlist element 2    string2    ...     The whole symbol table is read as one chunk and then we march thru it    and convert it to canonical form.  As we march thru the table, we copy    the nlist data into the internal form and we compact the strings and null    terminate them, using storage from the already allocated symbol table:     string1    null    string2    null    ... */
end_comment

begin_function
name|boolean
name|MY
function|(
name|slurp_symbol_table
function|)
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|symbol_bytes
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|syms
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|sym_pointer
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|sym_end
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|aout_symbol_type
modifier|*
name|cached
decl_stmt|;
name|unsigned
name|num_syms
init|=
literal|0
decl_stmt|;
comment|/* If there's no work to be done, don't do any */
if|if
condition|(
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|NULL
condition|)
return|return
name|true
return|;
name|symbol_bytes
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symbol_bytes
operator|+
name|SYM_EXTRA_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strings
condition|)
return|return
name|false
return|;
name|syms
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
operator|(
name|strings
operator|+
name|SYM_EXTRA_BYTES
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|syms
argument_list|,
name|symbol_bytes
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symbol_bytes
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sym_end
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|syms
operator|)
operator|+
name|symbol_bytes
operator|)
expr_stmt|;
comment|/* first, march thru the table and figure out how many symbols there are */
for|for
control|(
name|sym_pointer
operator|=
name|syms
init|;
name|sym_pointer
operator|<
name|sym_end
condition|;
name|sym_pointer
operator|++
operator|,
name|num_syms
operator|++
control|)
block|{
comment|/* skip over the embedded symbol. */
name|sym_pointer
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|sym_pointer
operator|)
operator|+
name|sym_pointer
operator|->
name|e_length
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|/* now that we know the symbol count, update the bfd header */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_syms
expr_stmt|;
name|cached
operator|=
operator|(
operator|(
name|aout_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cached
operator|==
name|NULL
operator|&&
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* as we march thru the hp symbol table, convert it into a list of      null terminated strings to hold the symbol names.  Make sure any      assignment to the strings pointer is done after we're thru using      the nlist so we don't overwrite anything important. */
comment|/* OK, now walk the new symtable, cacheing symbol properties */
block|{
name|aout_symbol_type
modifier|*
name|cache_ptr
init|=
name|cached
decl_stmt|;
name|aout_symbol_type
name|cache_save
decl_stmt|;
comment|/* Run through table and copy values */
for|for
control|(
name|sym_pointer
operator|=
name|syms
operator|,
name|cache_ptr
operator|=
name|cached
init|;
name|sym_pointer
operator|<
name|sym_end
condition|;
name|sym_pointer
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|=
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|desc
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_almod
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|type
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_length
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|other
operator|=
name|length
expr_stmt|;
comment|/* other not used, save length here */
name|cache_save
operator|=
operator|*
name|cache_ptr
expr_stmt|;
name|convert_sym_type
argument_list|(
name|sym_pointer
argument_list|,
name|cache_ptr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|translate_from_native_sym_flags
argument_list|(
name|abfd
argument_list|,
name|cache_ptr
argument_list|)
condition|)
return|return
name|false
return|;
comment|/********************************************************/
comment|/* for hpux, the 'lenght' value indicates the length of */
comment|/* the symbol name which follows the nlist entry.       */
comment|/********************************************************/
if|if
condition|(
name|length
condition|)
block|{
comment|/**************************************************************/
comment|/* the hp string is not null terminated so we create a new one*/
comment|/* by copying the string to overlap the just vacated nlist    */
comment|/* structure before it in memory.                             */
comment|/**************************************************************/
name|cache_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
name|strings
expr_stmt|;
name|memcpy
argument_list|(
name|strings
argument_list|,
name|sym_pointer
operator|+
literal|1
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|strings
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strings
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cache_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip over the embedded symbol. */
name|sym_pointer
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|sym_pointer
operator|)
operator|+
name|length
operator|)
expr_stmt|;
block|}
block|}
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|cached
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|MY
function|(
name|swap_std_reloc_in
function|)
parameter_list|(
name|abfd
parameter_list|,
name|bytes
parameter_list|,
name|cache_ptr
parameter_list|,
name|symbols
parameter_list|,
name|symcount
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|hp300hpux_reloc
modifier|*
name|bytes
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
init|=
literal|0
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
condition|)
block|{
case|case
name|HP_RSEGMENT_TEXT
case|:
name|r_index
operator|=
name|N_TEXT
expr_stmt|;
break|break;
case|case
name|HP_RSEGMENT_DATA
case|:
name|r_index
operator|=
name|N_DATA
expr_stmt|;
break|break;
case|case
name|HP_RSEGMENT_BSS
case|:
name|r_index
operator|=
name|N_BSS
expr_stmt|;
break|break;
case|case
name|HP_RSEGMENT_EXTERNAL
case|:
name|r_extern
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HP_RSEGMENT_PCREL
case|:
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_pcrel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HP_RSEGMENT_RDLT
case|:
break|break;
case|case
name|HP_RSEGMENT_RPLT
case|:
break|break;
case|case
name|HP_RSEGMENT_NOOP
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bytes
operator|->
name|r_length
index|[
literal|0
index|]
condition|)
block|{
case|case
name|HP_RLENGTH_BYTE
case|:
name|r_length
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HP_RLENGTH_WORD
case|:
name|r_length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HP_RLENGTH_LONG
case|:
name|r_length
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|cache_ptr
operator|->
name|howto
operator|=
name|howto_table_std
operator|+
name|r_length
operator|+
literal|4
operator|*
name|r_pcrel
expr_stmt|;
comment|/* FIXME-soon:  Roll baserel, jmptable, relative bits into howto setting */
comment|/* This macro uses the r_index value computed above */
if|if
condition|(
name|r_pcrel
operator|&&
name|r_extern
condition|)
block|{
comment|/* The GNU linker assumes any offset from beginning of section */
comment|/* is already incorporated into the image while the HP linker  */
comment|/* adds this in later.  Add it in now...                       */
name|MOVE_ADDRESS
argument_list|(
operator|-
name|cache_ptr
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MOVE_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|boolean
name|MY
function|(
name|slurp_reloc_table
function|)
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
name|struct
name|hp300hpux_reloc
modifier|*
name|rptr
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
name|doit
label|:
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|count
operator|=
name|reloc_size
operator|/
name|each_size
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_cache
operator|&&
name|count
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_cache
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
name|relocs
argument_list|,
literal|1
argument_list|,
name|reloc_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|reloc_size
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_cache
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|rptr
operator|=
operator|(
expr|struct
name|hp300hpux_reloc
operator|*
operator|)
name|relocs
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|cache_ptr
operator|=
name|reloc_cache
expr_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|MY
argument_list|(
name|swap_std_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* The following functions are identical to functions in aoutx.h except */
end_comment

begin_comment
comment|/* they refer to MY(func) rather than NAME(aout,func) and they also     */
end_comment

begin_comment
comment|/* call aout_32 versions if the input file was generated by gcc         */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_decl_stmt
name|long
name|aout_32_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asymbol
operator|*
operator|*
name|location
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|aout_32_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|aout_32_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|sec_ptr
name|section
operator|,
name|arelent
operator|*
operator|*
name|relptr
operator|,
name|asymbol
operator|*
operator|*
name|symbols
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|MY
function|(
name|get_symtab
function|)
parameter_list|(
name|abfd
parameter_list|,
name|location
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbase
decl_stmt|;
if|if
condition|(
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|==
name|gnu_encap_format
condition|)
return|return
name|aout_32_get_symtab
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|)
return|;
if|if
condition|(
operator|!
name|MY
argument_list|(
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|symbase
operator|=
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
init|;
name|counter
operator|++
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
control|)
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|(
name|symbase
operator|++
operator|)
expr_stmt|;
operator|*
name|location
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
name|long
name|MY
function|(
name|get_symtab_upper_bound
function|)
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|==
name|gnu_encap_format
condition|)
return|return
name|aout_32_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
operator|!
name|MY
argument_list|(
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|aout_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|long
name|MY
function|(
name|canonicalize_reloc
function|)
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|==
name|gnu_encap_format
condition|)
return|return
name|aout_32_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relptr
argument_list|,
name|symbols
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|tblptr
operator|||
name|MY
argument_list|(
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

