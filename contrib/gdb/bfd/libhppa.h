begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* HP PA-RISC SOM object file format:  definitions internal to BFD.    Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.     Contributed by the Center for Software Science at the    University of Utah (pa-gdb-bugs@cs.utah.edu).     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_HPPA_H
end_ifndef

begin_define
define|#
directive|define
name|_HPPA_H
end_define

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|4
end_define

begin_define
define|#
directive|define
name|PA_PAGESIZE
value|0x1000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNU C? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INLINE */
end_comment

begin_comment
comment|/* The PA instruction set variants.  */
end_comment

begin_enum
enum|enum
name|pa_arch
block|{
name|pa10
init|=
literal|10
block|,
name|pa11
init|=
literal|11
block|,
name|pa20
init|=
literal|20
block|}
enum|;
end_enum

begin_comment
comment|/* HP PA-RISC relocation types */
end_comment

begin_enum
enum|enum
name|hppa_reloc_field_selector_type
block|{
name|R_HPPA_FSEL
init|=
literal|0x0
block|,
name|R_HPPA_LSSEL
init|=
literal|0x1
block|,
name|R_HPPA_RSSEL
init|=
literal|0x2
block|,
name|R_HPPA_LSEL
init|=
literal|0x3
block|,
name|R_HPPA_RSEL
init|=
literal|0x4
block|,
name|R_HPPA_LDSEL
init|=
literal|0x5
block|,
name|R_HPPA_RDSEL
init|=
literal|0x6
block|,
name|R_HPPA_LRSEL
init|=
literal|0x7
block|,
name|R_HPPA_RRSEL
init|=
literal|0x8
block|,
name|R_HPPA_NSEL
init|=
literal|0x9
block|,
name|R_HPPA_NLSEL
init|=
literal|0xa
block|,
name|R_HPPA_NLRSEL
init|=
literal|0xb
block|,
name|R_HPPA_PSEL
init|=
literal|0xc
block|,
name|R_HPPA_LPSEL
init|=
literal|0xd
block|,
name|R_HPPA_RPSEL
init|=
literal|0xe
block|,
name|R_HPPA_TSEL
init|=
literal|0xf
block|,
name|R_HPPA_LTSEL
init|=
literal|0x10
block|,
name|R_HPPA_RTSEL
init|=
literal|0x11
block|}
enum|;
end_enum

begin_comment
comment|/* /usr/include/reloc.h defines these to constants.  We want to use    them in enums, so #undef them before we start using them.  We might    be able to fix this another way by simply managing not to include    /usr/include/reloc.h, but currently GDB picks up these defines    somewhere.  */
end_comment

begin_undef
undef|#
directive|undef
name|e_fsel
end_undef

begin_undef
undef|#
directive|undef
name|e_lssel
end_undef

begin_undef
undef|#
directive|undef
name|e_rssel
end_undef

begin_undef
undef|#
directive|undef
name|e_lsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rsel
end_undef

begin_undef
undef|#
directive|undef
name|e_ldsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rdsel
end_undef

begin_undef
undef|#
directive|undef
name|e_lrsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rrsel
end_undef

begin_undef
undef|#
directive|undef
name|e_nsel
end_undef

begin_undef
undef|#
directive|undef
name|e_nlsel
end_undef

begin_undef
undef|#
directive|undef
name|e_nlrsel
end_undef

begin_undef
undef|#
directive|undef
name|e_psel
end_undef

begin_undef
undef|#
directive|undef
name|e_lpsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rpsel
end_undef

begin_undef
undef|#
directive|undef
name|e_tsel
end_undef

begin_undef
undef|#
directive|undef
name|e_ltsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rtsel
end_undef

begin_undef
undef|#
directive|undef
name|e_one
end_undef

begin_undef
undef|#
directive|undef
name|e_two
end_undef

begin_undef
undef|#
directive|undef
name|e_pcrel
end_undef

begin_undef
undef|#
directive|undef
name|e_con
end_undef

begin_undef
undef|#
directive|undef
name|e_plabel
end_undef

begin_undef
undef|#
directive|undef
name|e_abs
end_undef

begin_comment
comment|/* for compatibility */
end_comment

begin_enum
enum|enum
name|hppa_reloc_field_selector_type_alt
block|{
name|e_fsel
init|=
name|R_HPPA_FSEL
block|,
name|e_lssel
init|=
name|R_HPPA_LSSEL
block|,
name|e_rssel
init|=
name|R_HPPA_RSSEL
block|,
name|e_lsel
init|=
name|R_HPPA_LSEL
block|,
name|e_rsel
init|=
name|R_HPPA_RSEL
block|,
name|e_ldsel
init|=
name|R_HPPA_LDSEL
block|,
name|e_rdsel
init|=
name|R_HPPA_RDSEL
block|,
name|e_lrsel
init|=
name|R_HPPA_LRSEL
block|,
name|e_rrsel
init|=
name|R_HPPA_RRSEL
block|,
name|e_nsel
init|=
name|R_HPPA_NSEL
block|,
name|e_nlsel
init|=
name|R_HPPA_NLSEL
block|,
name|e_nlrsel
init|=
name|R_HPPA_NLRSEL
block|,
name|e_psel
init|=
name|R_HPPA_PSEL
block|,
name|e_lpsel
init|=
name|R_HPPA_LPSEL
block|,
name|e_rpsel
init|=
name|R_HPPA_RPSEL
block|,
name|e_tsel
init|=
name|R_HPPA_TSEL
block|,
name|e_ltsel
init|=
name|R_HPPA_LTSEL
block|,
name|e_rtsel
init|=
name|R_HPPA_RTSEL
block|}
enum|;
end_enum

begin_enum
enum|enum
name|hppa_reloc_expr_type
block|{
name|R_HPPA_E_ONE
init|=
literal|0
block|,
name|R_HPPA_E_TWO
init|=
literal|1
block|,
name|R_HPPA_E_PCREL
init|=
literal|2
block|,
name|R_HPPA_E_CON
init|=
literal|3
block|,
name|R_HPPA_E_PLABEL
init|=
literal|7
block|,
name|R_HPPA_E_ABS
init|=
literal|18
block|}
enum|;
end_enum

begin_comment
comment|/* for compatibility */
end_comment

begin_enum
enum|enum
name|hppa_reloc_expr_type_alt
block|{
name|e_one
init|=
name|R_HPPA_E_ONE
block|,
name|e_two
init|=
name|R_HPPA_E_TWO
block|,
name|e_pcrel
init|=
name|R_HPPA_E_PCREL
block|,
name|e_con
init|=
name|R_HPPA_E_CON
block|,
name|e_plabel
init|=
name|R_HPPA_E_PLABEL
block|,
name|e_abs
init|=
name|R_HPPA_E_ABS
block|}
enum|;
end_enum

begin_comment
comment|/* Relocations for function calls must be accompanied by parameter    relocation bits.  These bits describe exactly where the caller has    placed the function's arguments and where it expects to find a return    value.     Both ELF and SOM encode this information within the addend field    of the call relocation.  (Note this could break very badly if one    was to make a call like bl foo + 0x12345678).     The high order 10 bits contain parameter relocation information,    the low order 22 bits contain the constant offset.  */
end_comment

begin_define
define|#
directive|define
name|HPPA_R_ARG_RELOC
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 22)& 0x3FF)
end_define

begin_define
define|#
directive|define
name|HPPA_R_CONSTANT
parameter_list|(
name|a
parameter_list|)
value|((((int)(a))<< 10)>> 10)
end_define

begin_define
define|#
directive|define
name|HPPA_R_ADDEND
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|(((r)<< 22) + ((c)& 0x3FFFFF))
end_define

begin_comment
comment|/* Some functions to manipulate PA instructions.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|assemble_3
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|6
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|7
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dis_assemble_3
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|;
name|unsigned
name|int
modifier|*
name|r
decl_stmt|;
block|{
operator|*
name|r
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|4
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|3
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|&
literal|7
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|assemble_12
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x7fe
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0xfff
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dis_assemble_12
parameter_list|(
name|as12
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|int
name|as12
decl_stmt|;
name|unsigned
name|int
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|y
operator|=
operator|(
name|as12
operator|&
literal|0x800
operator|)
operator|>>
literal|11
expr_stmt|;
operator|*
name|x
operator|=
operator|(
operator|(
name|as12
operator|&
literal|0x3ff
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|as12
operator|&
literal|0x400
operator|)
operator|>>
literal|10
operator|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|assemble_17
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
name|unsigned
name|long
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
operator|(
name|z
operator|&
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|y
operator|&
literal|0x7fe
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
return|return
name|temp
operator|&
literal|0x1ffff
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dis_assemble_17
parameter_list|(
name|as17
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
name|unsigned
name|int
name|as17
decl_stmt|;
name|unsigned
name|int
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|z
operator|=
operator|(
name|as17
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|x
operator|=
operator|(
name|as17
operator|&
literal|0x0f800
operator|)
operator|>>
literal|11
expr_stmt|;
operator|*
name|y
operator|=
operator|(
operator|(
operator|(
name|as17
operator|&
literal|0x00400
operator|)
operator|>>
literal|10
operator|)
operator||
operator|(
operator|(
name|as17
operator|&
literal|0x3ff
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|&
literal|0x7ff
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|assemble_21
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|;
block|{
name|unsigned
name|long
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xffe
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xc000
operator|)
operator|>>
literal|7
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x1f0000
operator|)
operator|>>
literal|14
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x003000
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
return|return
name|temp
operator|&
literal|0x1fffff
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dis_assemble_21
parameter_list|(
name|as21
parameter_list|,
name|x
parameter_list|)
name|unsigned
name|int
name|as21
decl_stmt|,
decl|*
name|x
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|long
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|as21
operator|&
literal|0x100000
operator|)
operator|>>
literal|20
expr_stmt|;
name|temp
operator||=
operator|(
name|as21
operator|&
literal|0x0ffe00
operator|)
operator|>>
literal|8
expr_stmt|;
name|temp
operator||=
operator|(
name|as21
operator|&
literal|0x000180
operator|)
operator|<<
literal|7
expr_stmt|;
name|temp
operator||=
operator|(
name|as21
operator|&
literal|0x00007c
operator|)
operator|<<
literal|14
expr_stmt|;
name|temp
operator||=
operator|(
name|as21
operator|&
literal|0x000003
operator|)
operator|<<
literal|12
expr_stmt|;
operator|*
name|x
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|sign_extend
parameter_list|(
name|x
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|,
name|len
decl_stmt|;
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|x
operator|>>
operator|(
name|len
operator|-
literal|1
operator|)
condition|?
operator|(
operator|-
literal|1
operator|<<
name|len
operator|)
operator||
name|x
else|:
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|ones
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|int
name|len_ones
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|len_ones
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|len_ones
operator|=
operator|(
name|len_ones
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|len_ones
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|sign_unext
parameter_list|(
name|x
parameter_list|,
name|len
parameter_list|,
name|result
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|int
modifier|*
name|result
decl_stmt|;
block|{
name|unsigned
name|int
name|len_ones
decl_stmt|;
name|len_ones
operator|=
name|ones
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|x
operator|&
name|len_ones
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|low_sign_extend
parameter_list|(
name|x
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|,
name|len
decl_stmt|;
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|x
operator|&
literal|0x1
condition|?
operator|(
operator|-
literal|1
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
operator||
name|x
operator|>>
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|low_sign_unext
parameter_list|(
name|x
parameter_list|,
name|len
parameter_list|,
name|result
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|int
modifier|*
name|result
decl_stmt|;
block|{
name|unsigned
name|int
name|temp
decl_stmt|;
name|unsigned
name|int
name|sign
decl_stmt|;
name|unsigned
name|int
name|rest
decl_stmt|;
name|unsigned
name|int
name|one_bit_at_len
decl_stmt|;
name|unsigned
name|int
name|len_ones
decl_stmt|;
name|len_ones
operator|=
name|ones
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|one_bit_at_len
operator|=
literal|1
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
name|sign_unext
argument_list|(
name|x
argument_list|,
name|len
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|sign
operator|=
name|temp
operator|&
name|one_bit_at_len
expr_stmt|;
name|sign
operator|>>=
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
name|rest
operator|=
name|temp
operator|&
operator|(
name|len_ones
operator|^
name|one_bit_at_len
operator|)
expr_stmt|;
name|rest
operator|<<=
literal|1
expr_stmt|;
operator|*
name|result
operator|=
name|rest
operator||
name|sign
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle field selectors for PA instructions.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|hppa_field_adjust
parameter_list|(
name|value
parameter_list|,
name|constant_value
parameter_list|,
name|r_field
parameter_list|)
name|unsigned
name|long
name|value
decl_stmt|;
name|unsigned
name|long
name|constant_value
decl_stmt|;
name|unsigned
name|short
name|r_field
decl_stmt|;
block|{
switch|switch
condition|(
name|r_field
condition|)
block|{
case|case
name|e_fsel
case|:
comment|/* F  : no change                      */
case|case
name|e_nsel
case|:
comment|/* N  : no change		       */
name|value
operator|+=
name|constant_value
expr_stmt|;
break|break;
case|case
name|e_lssel
case|:
comment|/* LS : if (bit 21) then add 0x800 				   arithmetic shift right 11 bits */
name|value
operator|+=
name|constant_value
expr_stmt|;
if|if
condition|(
name|value
operator|&
literal|0x00000400
condition|)
name|value
operator|+=
literal|0x800
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
literal|0xfffff800
operator|)
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rssel
case|:
comment|/* RS : Sign extend from bit 21        */
name|value
operator|+=
name|constant_value
expr_stmt|;
if|if
condition|(
name|value
operator|&
literal|0x00000400
condition|)
name|value
operator||=
literal|0xfffff800
expr_stmt|;
else|else
name|value
operator|&=
literal|0x7ff
expr_stmt|;
break|break;
case|case
name|e_lsel
case|:
comment|/* L  : Arithmetic shift right 11 bits */
case|case
name|e_nlsel
case|:
comment|/* NL  : Arithmetic shift right 11 bits */
name|value
operator|+=
name|constant_value
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
literal|0xfffff800
operator|)
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rsel
case|:
comment|/* R  : Set bits 0-20 to zero          */
name|value
operator|+=
name|constant_value
expr_stmt|;
name|value
operator|=
name|value
operator|&
literal|0x7ff
expr_stmt|;
break|break;
case|case
name|e_ldsel
case|:
comment|/* LD : Add 0x800, arithmetic shift 				   right 11 bits                  */
name|value
operator|+=
name|constant_value
expr_stmt|;
name|value
operator|+=
literal|0x800
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
literal|0xfffff800
operator|)
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rdsel
case|:
comment|/* RD : Set bits 0-20 to one           */
name|value
operator|+=
name|constant_value
expr_stmt|;
name|value
operator||=
literal|0xfffff800
expr_stmt|;
break|break;
case|case
name|e_lrsel
case|:
comment|/* LR : L with "rounded" constant      */
case|case
name|e_nlrsel
case|:
comment|/* NLR : NL with "rounded" constant      */
name|value
operator|=
name|value
operator|+
operator|(
operator|(
name|constant_value
operator|+
literal|0x1000
operator|)
operator|&
literal|0xffffe000
operator|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
literal|0xfffff800
operator|)
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rrsel
case|:
comment|/* RR : R with "rounded" constant      */
name|value
operator|=
name|value
operator|+
operator|(
operator|(
name|constant_value
operator|+
literal|0x1000
operator|)
operator|&
literal|0xffffe000
operator|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
literal|0x7ff
operator|)
operator|+
name|constant_value
operator|-
operator|(
operator|(
name|constant_value
operator|+
literal|0x1000
operator|)
operator|&
literal|0xffffe000
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* PA-RISC OPCODES */
end_comment

begin_define
define|#
directive|define
name|get_opcode
parameter_list|(
name|insn
parameter_list|)
value|((insn)& 0xfc000000)>> 26
end_define

begin_comment
comment|/* FIXME: this list is incomplete.  It should also be an enumerated    type rather than #defines.  */
end_comment

begin_define
define|#
directive|define
name|LDO
value|0x0d
end_define

begin_define
define|#
directive|define
name|LDB
value|0x10
end_define

begin_define
define|#
directive|define
name|LDH
value|0x11
end_define

begin_define
define|#
directive|define
name|LDW
value|0x12
end_define

begin_define
define|#
directive|define
name|LDWM
value|0x13
end_define

begin_define
define|#
directive|define
name|STB
value|0x18
end_define

begin_define
define|#
directive|define
name|STH
value|0x19
end_define

begin_define
define|#
directive|define
name|STW
value|0x1a
end_define

begin_define
define|#
directive|define
name|STWM
value|0x1b
end_define

begin_define
define|#
directive|define
name|COMICLR
value|0x24
end_define

begin_define
define|#
directive|define
name|SUBI
value|0x25
end_define

begin_define
define|#
directive|define
name|SUBIO
value|0x25
end_define

begin_define
define|#
directive|define
name|ADDIT
value|0x2c
end_define

begin_define
define|#
directive|define
name|ADDITO
value|0x2c
end_define

begin_define
define|#
directive|define
name|ADDI
value|0x2d
end_define

begin_define
define|#
directive|define
name|ADDIO
value|0x2d
end_define

begin_define
define|#
directive|define
name|LDIL
value|0x08
end_define

begin_define
define|#
directive|define
name|ADDIL
value|0x0a
end_define

begin_define
define|#
directive|define
name|MOVB
value|0x32
end_define

begin_define
define|#
directive|define
name|MOVIB
value|0x33
end_define

begin_define
define|#
directive|define
name|COMBT
value|0x20
end_define

begin_define
define|#
directive|define
name|COMBF
value|0x22
end_define

begin_define
define|#
directive|define
name|COMIBT
value|0x21
end_define

begin_define
define|#
directive|define
name|COMIBF
value|0x23
end_define

begin_define
define|#
directive|define
name|ADDBT
value|0x28
end_define

begin_define
define|#
directive|define
name|ADDBF
value|0x2a
end_define

begin_define
define|#
directive|define
name|ADDIBT
value|0x29
end_define

begin_define
define|#
directive|define
name|ADDIBF
value|0x2b
end_define

begin_define
define|#
directive|define
name|BVB
value|0x30
end_define

begin_define
define|#
directive|define
name|BB
value|0x31
end_define

begin_define
define|#
directive|define
name|BL
value|0x3a
end_define

begin_define
define|#
directive|define
name|BLE
value|0x39
end_define

begin_define
define|#
directive|define
name|BE
value|0x38
end_define

begin_comment
comment|/* Given a machine instruction, return its format.     FIXME:  opcodes which do not map to a known format    should return an error of some sort.  */
end_comment

begin_function
specifier|static
name|INLINE
name|char
name|bfd_hppa_insn2fmt
parameter_list|(
name|insn
parameter_list|)
name|unsigned
name|long
name|insn
decl_stmt|;
block|{
name|char
name|fmt
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
name|op
init|=
name|get_opcode
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|ADDI
case|:
case|case
name|ADDIT
case|:
case|case
name|SUBI
case|:
name|fmt
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|MOVB
case|:
case|case
name|MOVIB
case|:
case|case
name|COMBT
case|:
case|case
name|COMBF
case|:
case|case
name|COMIBT
case|:
case|case
name|COMIBF
case|:
case|case
name|ADDBT
case|:
case|case
name|ADDBF
case|:
case|case
name|ADDIBT
case|:
case|case
name|ADDIBF
case|:
case|case
name|BVB
case|:
case|case
name|BB
case|:
name|fmt
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|LDO
case|:
case|case
name|LDB
case|:
case|case
name|LDH
case|:
case|case
name|LDW
case|:
case|case
name|LDWM
case|:
case|case
name|STB
case|:
case|case
name|STH
case|:
case|case
name|STW
case|:
case|case
name|STWM
case|:
name|fmt
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|BL
case|:
case|case
name|BE
case|:
case|case
name|BLE
case|:
name|fmt
operator|=
literal|17
expr_stmt|;
break|break;
case|case
name|LDIL
case|:
case|case
name|ADDIL
case|:
name|fmt
operator|=
literal|21
expr_stmt|;
break|break;
default|default:
name|fmt
operator|=
literal|32
expr_stmt|;
break|break;
block|}
return|return
name|fmt
return|;
block|}
end_function

begin_comment
comment|/* Insert VALUE into INSN using R_FORMAT to determine exactly what    bits to change.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|long
name|hppa_rebuild_insn
parameter_list|(
name|abfd
parameter_list|,
name|insn
parameter_list|,
name|value
parameter_list|,
name|r_format
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|unsigned
name|long
name|r_format
decl_stmt|;
block|{
name|unsigned
name|long
name|const_part
decl_stmt|;
name|unsigned
name|long
name|rebuilt_part
decl_stmt|;
switch|switch
condition|(
name|r_format
condition|)
block|{
case|case
literal|11
case|:
block|{
name|unsigned
name|w1
decl_stmt|,
name|w
decl_stmt|;
name|const_part
operator|=
name|insn
operator|&
literal|0xffffe002
expr_stmt|;
name|dis_assemble_12
argument_list|(
name|value
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|rebuilt_part
operator|=
operator|(
name|w1
operator|<<
literal|2
operator|)
operator||
name|w
expr_stmt|;
return|return
name|const_part
operator||
name|rebuilt_part
return|;
block|}
case|case
literal|12
case|:
block|{
name|unsigned
name|w1
decl_stmt|,
name|w
decl_stmt|;
name|const_part
operator|=
name|insn
operator|&
literal|0xffffe002
expr_stmt|;
name|dis_assemble_12
argument_list|(
name|value
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|rebuilt_part
operator|=
operator|(
name|w1
operator|<<
literal|2
operator|)
operator||
name|w
expr_stmt|;
return|return
name|const_part
operator||
name|rebuilt_part
return|;
block|}
case|case
literal|14
case|:
name|const_part
operator|=
name|insn
operator|&
literal|0xffffc000
expr_stmt|;
name|low_sign_unext
argument_list|(
name|value
argument_list|,
literal|14
argument_list|,
operator|&
name|rebuilt_part
argument_list|)
expr_stmt|;
return|return
name|const_part
operator||
name|rebuilt_part
return|;
case|case
literal|17
case|:
block|{
name|unsigned
name|w1
decl_stmt|,
name|w2
decl_stmt|,
name|w
decl_stmt|;
name|const_part
operator|=
name|insn
operator|&
literal|0xffe0e002
expr_stmt|;
name|dis_assemble_17
argument_list|(
name|value
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|w2
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|rebuilt_part
operator|=
operator|(
name|w2
operator|<<
literal|2
operator|)
operator||
operator|(
name|w1
operator|<<
literal|16
operator|)
operator||
name|w
expr_stmt|;
return|return
name|const_part
operator||
name|rebuilt_part
return|;
block|}
case|case
literal|21
case|:
name|const_part
operator|=
name|insn
operator|&
literal|0xffe00000
expr_stmt|;
name|dis_assemble_21
argument_list|(
name|value
argument_list|,
operator|&
name|rebuilt_part
argument_list|)
expr_stmt|;
return|return
name|const_part
operator||
name|rebuilt_part
return|;
case|case
literal|32
case|:
name|const_part
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _HPPA_H */
end_comment

end_unit

