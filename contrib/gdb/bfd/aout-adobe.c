begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for a.out.adobe binaries.    Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.    Written by Cygnus Support.  Based on bout.c.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/adobe.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|a_out_adobe_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|aout_adobe_callback
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|aout_32_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|aout_32_write_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aout_adobe_write_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|sec_ptr
name|sect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swaps the information in an executable header taken from a raw byte    stream memory image, into the internal exec_header structure.  */
end_comment

begin_decl_stmt
name|void
name|aout_adobe_swap_exec_header_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|external_exec
operator|*
name|raw_bytes
operator|,
expr|struct
name|internal_exec
operator|*
name|execp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|aout_adobe_swap_exec_header_in
parameter_list|(
name|abfd
parameter_list|,
name|raw_bytes
parameter_list|,
name|execp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|external_exec
modifier|*
name|raw_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swaps the information in an internal exec header structure into the    supplied buffer ready for writing to disk.  */
end_comment

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|aout_adobe_swap_exec_header_out
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|internal_exec
operator|*
name|execp
operator|,
expr|struct
name|external_exec
operator|*
name|raw_bytes
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|aout_adobe_swap_exec_header_out
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|,
name|raw_bytes
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
decl_stmt|;
name|struct
name|external_exec
modifier|*
name|raw_bytes
decl_stmt|;
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* Now fill in fields in the raw data, from the fields in the exec struct. */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_info
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_text
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_data
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_bss
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_syms
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_entry
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_trsize
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_drsize
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|aout_adobe_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
name|anexec
decl_stmt|;
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|char
modifier|*
name|targ
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|exec_bytes
argument_list|,
literal|1
argument_list|,
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXEC_BYTES_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|anexec
operator|.
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|exec_bytes
operator|.
name|e_info
argument_list|)
expr_stmt|;
comment|/* Normally we just compare for the magic number.      However, a bunch of Adobe tools aren't fixed up yet; they generate      files using ZMAGIC(!).      If the environment variable GNUTARGET is set to "a.out.adobe", we will      take just about any a.out file as an Adobe a.out file.  FIXME!  */
if|if
condition|(
name|N_BADMAG
argument_list|(
name|anexec
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|targ
operator|=
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|&&
operator|!
name|strcmp
argument_list|(
name|targ
argument_list|,
name|a_out_adobe_vec
operator|.
name|name
argument_list|)
condition|)
empty_stmt|;
comment|/* Just continue anyway, if specifically set to this format */
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|aout_adobe_swap_exec_header_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec_bytes
argument_list|,
operator|&
name|anexec
argument_list|)
expr_stmt|;
return|return
name|aout_32_some_aout_object_p
argument_list|(
name|abfd
argument_list|,
operator|&
name|anexec
argument_list|,
name|aout_adobe_callback
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish up the opening of a b.out file for reading.  Fill in all the    fields that are not handled by common code.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|aout_adobe_callback
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|struct
name|external_segdesc
name|ext
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
name|try_again
index|[
literal|30
index|]
decl_stmt|;
comment|/* name and number */
name|char
modifier|*
name|newname
decl_stmt|;
name|int
name|trynum
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
comment|/* Architecture and machine type -- unknown in this format.  */
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_unknown
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The positions of the string table and symbol table.  */
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_STROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* Suck up the section information from the file, one section at a time.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|ext
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ext
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ext
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ext
operator|->
name|e_type
index|[
literal|0
index|]
condition|)
block|{
case|case
name|N_TEXT
case|:
name|section_name
operator|=
literal|".text"
expr_stmt|;
name|flags
operator|=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|section_name
operator|=
literal|".data"
expr_stmt|;
name|flags
operator|=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|section_name
operator|=
literal|".bss"
expr_stmt|;
name|flags
operator|=
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
literal|0
case|:
goto|goto
name|no_more_sections
goto|;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: Unknown section type in a.out.adobe file: %x\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|ext
operator|->
name|e_type
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|no_more_sections
goto|;
block|}
comment|/* First one is called ".text" or whatever; subsequent ones are        ".text1", ".text2", ... */
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|trynum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|sect
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_error
condition|)
return|return
literal|0
return|;
comment|/* Some other error -- slide into the sunset */
name|sprintf
argument_list|(
name|try_again
argument_list|,
literal|"%s%d"
argument_list|,
name|section_name
argument_list|,
operator|++
name|trynum
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|try_again
argument_list|)
expr_stmt|;
block|}
comment|/* Fix the name, if it is a sprintf'd name.  */
if|if
condition|(
name|sect
operator|->
name|name
operator|==
name|try_again
condition|)
block|{
name|newname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|sect
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|sect
operator|->
name|name
argument_list|)
expr_stmt|;
name|sect
operator|->
name|name
operator|=
name|newname
expr_stmt|;
block|}
comment|/* Now set the section's attributes.  */
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sect
operator|->
name|_raw_size
operator|=
operator|(
operator|(
name|ext
operator|->
name|e_size
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
comment|/* Assumed big-endian */
operator||
name|ext
operator|->
name|e_size
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|ext
operator|->
name|e_size
index|[
literal|2
index|]
expr_stmt|;
name|sect
operator|->
name|_cooked_size
operator|=
name|sect
operator|->
name|_raw_size
expr_stmt|;
name|sect
operator|->
name|vma
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_virtbase
argument_list|)
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_filebase
argument_list|)
expr_stmt|;
comment|/* FIXME XXX alignment? */
comment|/* Set relocation information for first section of each type.  */
if|if
condition|(
name|trynum
operator|==
literal|0
condition|)
switch|switch
condition|(
name|ext
operator|->
name|e_type
index|[
literal|0
index|]
condition|)
block|{
case|case
name|N_TEXT
case|:
name|sect
operator|->
name|rel_filepos
operator|=
name|N_TRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|sect
operator|->
name|reloc_count
operator|=
name|execp
operator|->
name|a_trsize
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|sect
operator|->
name|rel_filepos
operator|=
name|N_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|sect
operator|->
name|reloc_count
operator|=
name|execp
operator|->
name|a_drsize
expr_stmt|;
break|break;
block|}
block|}
name|no_more_sections
label|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|reloc_entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_std_external
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|symbol_entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_struct
struct|struct
name|bout_data_struct
block|{
name|struct
name|aoutdata
name|a
decl_stmt|;
name|struct
name|internal_exec
name|e
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|boolean
name|aout_adobe_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|bout_data_struct
modifier|*
name|rawptr
decl_stmt|;
name|rawptr
operator|=
operator|(
expr|struct
name|bout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bout_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|bout_data
operator|=
name|rawptr
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|reloc_entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_std_external
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|symbol_entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|aout_adobe_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|external_exec
name|swapped_hdr
decl_stmt|;
specifier|static
name|struct
name|external_segdesc
name|sentinel
index|[
literal|1
index|]
decl_stmt|;
comment|/* Initialized to zero */
name|asection
modifier|*
name|sect
decl_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_info
operator|=
name|ZMAGIC
expr_stmt|;
comment|/* Calculate text size as total of text sections, etc. */
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_text
operator|=
literal|0
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_data
operator|=
literal|0
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_bss
operator|=
literal|0
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_text
operator|+=
name|sect
operator|->
name|_raw_size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|+=
name|sect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_std_external
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_data
operator|+=
name|sect
operator|->
name|_raw_size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|+=
name|sect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_std_external
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|&&
operator|!
operator|(
name|sect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_bss
operator|+=
name|sect
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|aout_adobe_swap_exec_header_out
argument_list|(
name|abfd
argument_list|,
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|&
name|swapped_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|swapped_hdr
argument_list|,
literal|1
argument_list|,
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXEC_BYTES_SIZE
operator|)
condition|)
return|return
name|false
return|;
comment|/* Now write out the section information.  Text first, data next, rest      afterward.  */
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|aout_adobe_write_section
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
name|aout_adobe_write_section
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sect
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
operator|)
condition|)
block|{
name|aout_adobe_write_section
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write final `sentinel` section header (with type of 0).  */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|sentinel
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sentinel
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sentinel
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now write out reloc info, followed by syms and strings */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_SYMOFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|aout_32_write_syms
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_TRELOFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
if|if
condition|(
operator|!
name|aout_32_squirt_out_relocs
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_DRELOFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
if|if
condition|(
operator|!
name|aout_32_squirt_out_relocs
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aout_adobe_write_section
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|sect
decl_stmt|;
block|{
comment|/* FIXME XXX */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|boolean
name|aout_adobe_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|file_ptr
name|section_start
decl_stmt|;
name|sec_ptr
name|sect
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
comment|/* set by bfd.c handler */
comment|/* Assign file offsets to sections.  Text sections are first, and        are contiguous.  Then data sections.  Everything else at the end.  */
name|section_start
operator|=
name|N_TXTOFF
argument_list|(
name|ignore
operator|<
operator|--
operator|>
name|me
argument_list|)
expr_stmt|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|sect
operator|->
name|filepos
operator|=
name|section_start
expr_stmt|;
comment|/* FIXME:  Round to alignment */
name|section_start
operator|+=
name|sect
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
name|sect
operator|->
name|filepos
operator|=
name|section_start
expr_stmt|;
comment|/* FIXME:  Round to alignment */
name|section_start
operator|+=
name|sect
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|&&
operator|!
operator|(
name|sect
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
operator|)
condition|)
block|{
name|sect
operator|->
name|filepos
operator|=
name|section_start
expr_stmt|;
comment|/* FIXME:  Round to alignment */
name|section_start
operator|+=
name|sect
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
block|}
comment|/* regardless, once we know what we're doing, we might as well get going */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|aout_adobe_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|arch
operator|==
name|bfd_arch_unknown
operator|||
name|arch
operator|==
name|bfd_arch_m68k
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aout_adobe_sizeof_headers
parameter_list|(
name|ignore_abfd
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|boolean
name|ignore
decl_stmt|;
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build the transfer vector for Adobe A.Out files.  */
end_comment

begin_define
define|#
directive|define
name|aout_32_close_and_cleanup
value|aout_32_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_make_debug_symbol
define|\
value|((asymbol *(*) PARAMS ((bfd *, void *, unsigned long))) bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_reloc_type_lookup
define|\
value|((reloc_howto_type *(*) \     PARAMS ((bfd *, bfd_reloc_code_real_type))) bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|aout_32_set_arch_mach
value|aout_adobe_set_arch_mach
end_define

begin_define
define|#
directive|define
name|aout_32_set_section_contents
value|aout_adobe_set_section_contents
end_define

begin_define
define|#
directive|define
name|aout_32_sizeof_headers
value|aout_adobe_sizeof_headers
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|aout_32_get_section_contents_in_window
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_link_hash_table_create
define|\
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|a_out_adobe_vec
init|=
block|{
literal|"a.out.adobe"
block|,
comment|/* name */
name|bfd_target_aout_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is unknown (big assumed) */
name|BFD_ENDIAN_BIG
block|,
comment|/* hdr byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
comment|/* section flags */
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/*  symbol leading char */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|aout_adobe_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|aout_adobe_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|aout_adobe_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_bsd
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

