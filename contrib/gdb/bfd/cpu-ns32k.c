begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD support for the ns32k architecture.    Copyright (C) 1990, 1991, 1994, 1995 Free Software Foundation, Inc.    Almost totally rewritten by Ian Dall from initial work    by Andrew Cagney.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_decl_stmt
name|long
name|ns32k_get_displacement
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
name|buffer
operator|,
name|long
name|offset
operator|,
name|long
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ns32k_put_displacement
name|PARAMS
argument_list|(
operator|(
name|long
name|value
operator|,
name|bfd_byte
operator|*
name|buffer
operator|,
name|long
name|offset
operator|,
name|long
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ns32k_get_immediate
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
name|buffer
operator|,
name|long
name|offset
operator|,
name|long
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ns32k_put_immediate
name|PARAMS
argument_list|(
operator|(
name|long
name|value
operator|,
name|bfd_byte
operator|*
name|buffer
operator|,
name|long
name|offset
operator|,
name|long
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_reloc_status_type
name|ns32k_reloc_disp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc_entry
operator|,
expr|struct
name|symbol_cache_entry
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error_message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_reloc_status_type
name|ns32k_reloc_imm
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc_entry
operator|,
expr|struct
name|symbol_cache_entry
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error_message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_reloc_status_type
name|ns32k_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
name|howto
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|bfd_vma
name|address
operator|,
name|bfd_vma
name|value
operator|,
name|bfd_vma
name|addend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_reloc_status_type
name|ns32k_relocate_contents
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
name|howto
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|bfd_vma
name|relocation
operator|,
name|bfd_byte
operator|*
name|location
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|bfd_default_scan_num_mach
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|N
parameter_list|(
name|machine
parameter_list|,
name|printable
parameter_list|,
name|d
parameter_list|,
name|next
parameter_list|)
define|\
value|{  32, 32, 8, bfd_arch_ns32k, machine, "ns32k",printable,3,d,bfd_default_compatible,bfd_default_scan, next, }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|arch_info_struct
index|[]
init|=
block|{
name|N
argument_list|(
literal|32532
argument_list|,
literal|"ns32k:32532"
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
block|,
comment|/* the word ns32k will match this too */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_arch_info_type
name|bfd_ns32k_arch
init|=
name|N
argument_list|(
literal|32032
argument_list|,
literal|"ns32k:32032"
argument_list|,
name|false
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|ns32k_sign_extend
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
name|int
name|value
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
name|value
operator|=
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|?
name|value
operator||
operator|(
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|value
operator|)
return|;
block|}
end_function

begin_function
name|long
name|ns32k_get_displacement
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|long
name|value
decl_stmt|;
name|buffer
operator|+=
name|offset
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|value
operator|=
name|ns32k_sign_extend
argument_list|(
operator|*
name|buffer
argument_list|,
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|value
operator|=
name|ns32k_sign_extend
argument_list|(
operator|*
name|buffer
operator|++
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xff
operator|&
operator|*
name|buffer
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|value
operator|=
name|ns32k_sign_extend
argument_list|(
operator|*
name|buffer
operator|++
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xff
operator|&
operator|*
name|buffer
operator|++
operator|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xff
operator|&
operator|*
name|buffer
operator|++
operator|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xff
operator|&
operator|*
name|buffer
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
name|int
name|ns32k_put_displacement
parameter_list|(
name|value
parameter_list|,
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|long
name|value
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|buffer
operator|+=
name|offset
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|64
operator|||
name|value
operator|>
literal|63
condition|)
return|return
operator|-
literal|1
return|;
name|value
operator|&=
literal|0x7f
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|8192
operator|||
name|value
operator|>
literal|8191
condition|)
return|return
operator|-
literal|1
return|;
name|value
operator|&=
literal|0x3fff
expr_stmt|;
name|value
operator||=
literal|0x8000
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|0x1f000000
operator|||
name|value
operator|>=
literal|0x20000000
condition|)
return|return
operator|-
literal|1
return|;
name|value
operator||=
literal|0xc0000000
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|long
name|ns32k_get_immediate
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|long
name|value
init|=
literal|0
decl_stmt|;
name|buffer
operator|+=
name|offset
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|buffer
operator|++
operator|&
literal|0xff
operator|)
expr_stmt|;
case|case
literal|3
case|:
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|buffer
operator|++
operator|&
literal|0xff
operator|)
expr_stmt|;
case|case
literal|2
case|:
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|buffer
operator|++
operator|&
literal|0xff
operator|)
expr_stmt|;
case|case
literal|1
case|:
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|buffer
operator|++
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
name|int
name|ns32k_put_immediate
parameter_list|(
name|value
parameter_list|,
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|long
name|value
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|buffer
operator|+=
name|offset
operator|+
name|size
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|buffer
operator|--
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|buffer
operator|--
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|buffer
operator|--
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|buffer
operator|--
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is just like the standard perform_relocation except we  * use get_data and put_data which know about the ns32k  * storage methods.  * This is probably a lot more complicated than it needs to be!  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|do_ns32k_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|,
name|get_data
argument_list|,
name|put_data
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol_cache_entry
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|input_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
function_decl|(
modifier|*
name|get_data
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|put_data
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|reloc_target_output_section
decl_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_abs_section
operator|)
operator|&&
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* If we are not producing relocateable output, return an error if      the symbol is not defined.  An undefined weak symbol is      considered to have a value of zero (SVR4 ABI, p. 4-27).  */
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|flag
operator|=
name|bfd_reloc_undefined
expr_stmt|;
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targetted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|reloc_target_output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
name|output_bfd
operator|&&
name|howto
operator|->
name|partial_inplace
operator|==
name|false
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|reloc_target_output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|==
name|true
condition|)
block|{
comment|/* This is a PC relative relocation.  We want to set RELOCATION 	 to the distance between the address of the symbol and the 	 location.  RELOCATION is already the address of the symbol.  	 We start by subtracting the address of the section containing 	 the location.  	 If pcrel_offset is set, we must further subtract the position 	 of the location within the section.  Some targets arrange for 	 the addend to be the negative of the position of the location 	 within the section; for example, i386-aout does this.  For 	 i386-aout, pcrel_offset is false.  Some other targets do not 	 include the position of the location; for example, m88kbcs, 	 or ELF.  For those targets, pcrel_offset is true.  	 If we are producing relocateable output, then we must ensure 	 that this reloc will be correctly computed when the final 	 relocation is done.  If pcrel_offset is false we want to wind 	 up with the negative of the location within the section, 	 which means we must adjust the existing addend by the change 	 in the location within the section.  If pcrel_offset is true 	 we do not want to adjust the existing addend at all.  	 FIXME: This seems logical to me, but for the case of 	 producing relocateable output it is not what the code 	 actually does.  I don't want to change it, because it seems 	 far too likely that something will break.  */
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
operator|==
name|true
condition|)
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|==
name|false
condition|)
block|{
comment|/* This is a partial relocation, and we want to apply the relocation 	     to the reloc entry rather than the raw data. Modify the reloc 	     inplace to reflect what we now know.  */
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|flag
return|;
block|}
else|else
block|{
comment|/* This is a partial relocation, but inplace, so modify the 	     reloc record a bit.  	     If we've relocated with a symbol with a section, change 	     into a ref to the section belonging to the symbol.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* WTF?? */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_coff_flavour
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"aixcoff-rs6000"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|1
comment|/* For m68k-coff, the addend was being subtracted twice during 		 relocation with -r.  Removing the line below this comment 		 fixes that problem; see PR 2953.  However, Ian wrote the following, regarding removing the line below, which explains why it is still enabled:  --djm  If you put a patch like that into BFD you need to check all the COFF linkers.  I am fairly certain that patch will break coff-i386 (e.g., SCO); see coff_i386_reloc in coff-i386.c where I worked around the problem in a different way.  There may very well be a reason that the code works as it does.  Hmmm.  The first obvious point is that bfd_perform_relocation should not have any tests that depend upon the flavour.  It's seem like entirely the wrong place for such a thing.  The second obvious point is that the current code ignores the reloc addend when producing relocateable output for COFF.  That's peculiar.  In fact, I really have no idea what the point of the line you want to remove is.  A typical COFF reloc subtracts the old value of the symbol and adds in the new value to the location in the object file (if it's a pc relative reloc it adds the difference between the symbol value and the location).  When relocating we need to preserve that property.  BFD handles this by setting the addend to the negative of the old value of the symbol.  Unfortunately it handles common symbols in a non-standard way (it doesn't subtract the old value) but that's a different story (we can't change it without losing backward compatibility with old object files) (coff-i386 does subtract the old value, to be compatible with existing coff-i386 targets, like SCO).  So everything works fine when not producing relocateable output.  When we are producing relocateable output, logically we should do exactly what we do when not producing relocateable output.  Therefore, your patch is correct.  In fact, it should probably always just set reloc_entry->addend to 0 for all cases, since it is, in fact, going to add the value into the object file.  This won't hurt the COFF code, which doesn't use the addend; I'm not sure what it will do to other formats (the thing to check for would be whether any formats both use the addend and set partial_inplace).  When I wanted to make coff-i386 produce relocateable output, I ran into the problem that you are running into: I wanted to remove that line.  Rather than risk it, I made the coff-i386 relocs use a special function; it's coff_i386_reloc in coff-i386.c.  The function specifically adds the addend field into the object file, knowing that bfd_perform_relocation is not going to.  If you remove that line, then coff-i386.c will wind up adding the addend field in twice.  It's trivial to fix; it just needs to be done.  The problem with removing the line is just that it may break some working code.  With BFD it's hard to be sure of anything.  The right way to deal with this is simply to build and test at least all the supported COFF targets.  It should be straightforward if time and disk space consuming.  For each target:     1) build the linker     2) generate some executable, and link it using -r (I would        probably use paranoia.o and link against newlib/libc.a, which        for all the supported targets would be available in        /usr/cygnus/progressive/H-host/target/lib/libc.a).     3) make the change to reloc.c     4) rebuild the linker     5) repeat step 2     6) if the resulting object files are the same, you have at least        made it no worse     7) if they are different you have to figure out which version is        right */
name|relocation
operator|-=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
endif|#
directive|endif
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* FIXME: This overflow checking is incomplete, because the value      might have overflowed before we get here.  For a correct check we      need to compute the value in a size larger than bitsize, but we      can't reasonably do that for a reloc the same size as a host      machine word.      FIXME: We should also do overflow checking on the result after      adding in the value contained in the object file.  */
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_vma
name|check
decl_stmt|;
comment|/* Get the value that will be used for the relocation, but 	 starting at bit position zero.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
name|howto
operator|->
name|bitpos
condition|)
name|check
operator|=
name|relocation
operator|>>
operator|(
name|howto
operator|->
name|rightshift
operator|-
name|howto
operator|->
name|bitpos
operator|)
expr_stmt|;
else|else
name|check
operator|=
name|relocation
operator|<<
operator|(
name|howto
operator|->
name|bitpos
operator|-
name|howto
operator|->
name|rightshift
operator|)
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|complain_on_overflow
condition|)
block|{
case|case
name|complain_overflow_signed
case|:
block|{
comment|/* Assumes two's complement.  */
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
comment|/* The above right shift is incorrect for a signed value. 	       Fix it up by forcing on the upper bits.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
name|howto
operator|->
name|bitpos
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
operator|(
name|howto
operator|->
name|rightshift
operator|-
name|howto
operator|->
name|bitpos
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|check
operator|>
name|reloc_signed_max
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|check
operator|<
name|reloc_signed_min
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_unsigned
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_unsigned_max
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|check
operator|>
name|reloc_unsigned_max
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_bitfield
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_bits
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
block|{
comment|/* The above right shift is incorrect for a signed 		   value.  See if turning on the upper bits fixes the 		   overflow.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
name|howto
operator|->
name|bitpos
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
block|{
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
operator|(
name|howto
operator|->
name|rightshift
operator|-
name|howto
operator|->
name|bitpos
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
else|else
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*     Either we are relocating all the way, or we don't want to apply     the relocation to the reloc entry (probably because there isn't     any room in the output format to describe addends to relocs)     */
comment|/* The cast to bfd_vma avoids a bug in the Alpha OSF/1 C compiler      (OSF version 1.3, compiler version 3.11).  It miscompiles the      following program:       struct str      {        unsigned int i0;      } s = { 0 };       int      main ()      {        unsigned long x;         x = 0x100000000;        x<<= (unsigned long) s.i0;        if (x == 0) 	 printf ("failed\n");        else 	 printf ("succeeded (%lx)\n", x);      }      */
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Shift everything up to where it's going to be used */
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Wait for the day when all have the mask in them */
comment|/* What we do:      i instruction to be left alone      o offset within instruction      r relocation offset to apply      S src mask      D dst mask      N ~dst mask      A part 1      B part 2      R result       Do this:      i i i i i o o o o o        from bfd_get<size>      and           S S S S S    to get the size offset we want      +   r r r r r r r r r r  to get the final value to place      and           D D D D D  to chop to right size      -----------------------      A A A A A      And this:      ...   i i i i i o o o o o  from bfd_get<size>      and   N N N N N            get instruction      -----------------------      ...   B B B B B       And then:      B B B B B      or              A A A A A      -----------------------      R R R R R R R R R R        put into bfd_put<size>      */
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ( (x& ~howto->dst_mask) | (((x& howto->src_mask) +  relocation)& howto->dst_mask))
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|get_data
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|put_data
argument_list|(
name|x
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|relocation
condition|)
block|{
name|short
name|x
init|=
name|get_data
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|put_data
argument_list|(
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|relocation
condition|)
block|{
name|long
name|x
init|=
name|get_data
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|put_data
argument_list|(
name|x
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
block|{
name|long
name|x
init|=
name|get_data
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|relocation
operator|=
operator|-
name|relocation
expr_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|put_data
argument_list|(
name|x
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Do nothing */
break|break;
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|relocation
condition|)
block|{
name|bfd_vma
name|x
init|=
name|get_data
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|put_data
argument_list|(
name|x
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
name|bfd_reloc_other
return|;
block|}
if|if
condition|(
operator|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
operator|)
operator|&&
name|overflow
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|flag
return|;
block|}
end_block

begin_comment
comment|/* Relocate a given location using a given value and howto.  */
end_comment

begin_decl_stmt
name|bfd_reloc_status_type
name|do_ns32k_reloc_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|location
argument_list|,
name|get_data
argument_list|,
name|put_data
argument_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|relocation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_byte
modifier|*
name|location
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
function_decl|(
modifier|*
name|get_data
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|put_data
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|size
decl_stmt|;
name|bfd_vma
name|x
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
comment|/* If the size is negative, negate RELOCATION.  This isn't very      general.  */
if|if
condition|(
name|howto
operator|->
name|size
operator|<
literal|0
condition|)
name|relocation
operator|=
operator|-
name|relocation
expr_stmt|;
comment|/* Get the value we are going to relocate.  */
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
endif|#
directive|endif
name|x
operator|=
name|get_data
argument_list|(
name|location
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check for overflow.  FIXME: We may drop bits during the addition      which we don't check for.  We must either check at every single      operation, which would be tedious, or we must do the computations      in a type larger than bfd_vma, which would be inefficient.  */
name|overflow
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_vma
name|check
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
name|bfd_vma
name|add
decl_stmt|;
name|bfd_signed_vma
name|signed_add
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|==
literal|0
condition|)
block|{
name|check
operator|=
name|relocation
expr_stmt|;
name|signed_check
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
block|}
else|else
block|{
comment|/* Drop unwanted bits from the value we are relocating to.  */
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If this is a signed value, the rightshift just dropped 	     leading 1 bits (assuming twos complement).  */
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>=
literal|0
condition|)
name|signed_check
operator|=
name|check
expr_stmt|;
else|else
name|signed_check
operator|=
operator|(
name|check
operator||
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Get the value from the object file.  */
name|add
operator|=
name|x
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* Get the value from the object file with an appropriate sign. 	 The expression involving howto->src_mask isolates the upper 	 bit of src_mask.  If that bit is set in the value we are 	 adding, it is negative, and we subtract out that number times 	 two.  If src_mask includes the highest possible bit, then we 	 can not get the upper bit, but that does not matter since 	 signed_add needs no adjustment to become negative in that 	 case.  */
name|signed_add
operator|=
name|add
expr_stmt|;
if|if
condition|(
operator|(
name|add
operator|&
operator|(
operator|(
operator|(
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|)
operator|!=
literal|0
condition|)
name|signed_add
operator|-=
operator|(
operator|(
operator|(
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|<<
literal|1
expr_stmt|;
comment|/* Add the value from the object file, shifted so that it is a 	 straight number.  */
if|if
condition|(
name|howto
operator|->
name|bitpos
operator|==
literal|0
condition|)
block|{
name|check
operator|+=
name|add
expr_stmt|;
name|signed_check
operator|+=
name|signed_add
expr_stmt|;
block|}
else|else
block|{
name|check
operator|+=
name|add
operator|>>
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* For the signed case we use ADD, rather than SIGNED_ADD, 	     to avoid warnings from SVR4 cc.  This is OK since we 	     explictly handle the sign bits.  */
if|if
condition|(
name|signed_add
operator|>=
literal|0
condition|)
name|signed_check
operator|+=
name|add
operator|>>
name|howto
operator|->
name|bitpos
expr_stmt|;
else|else
name|signed_check
operator|+=
operator|(
operator|(
name|add
operator|>>
name|howto
operator|->
name|bitpos
operator|)
operator||
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|bitpos
operator|)
operator|)
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|howto
operator|->
name|complain_on_overflow
condition|)
block|{
case|case
name|complain_overflow_signed
case|:
block|{
comment|/* Assumes two's complement.  */
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_unsigned
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_unsigned_max
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
name|check
operator|>
name|reloc_unsigned_max
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_bitfield
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_bits
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|signed_check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Put RELOCATION in the right bits.  */
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Add RELOCATION to the right bits of X.  */
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|+
name|relocation
operator|)
operator|&
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
comment|/* Put the relocated value back in the object file.  */
switch|switch
condition|(
name|size
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
endif|#
directive|endif
name|put_data
argument_list|(
name|x
argument_list|,
name|location
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
return|;
block|}
end_block

begin_function
name|bfd_reloc_status_type
name|ns32k_reloc_disp
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|struct
name|symbol_cache_entry
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
return|return
name|do_ns32k_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|,
name|ns32k_get_displacement
argument_list|,
name|ns32k_put_displacement
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_reloc_status_type
name|ns32k_reloc_imm
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|struct
name|symbol_cache_entry
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
return|return
name|do_ns32k_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|,
name|ns32k_get_immediate
argument_list|,
name|ns32k_put_immediate
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_reloc_status_type
name|ns32k_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|address
parameter_list|,
name|value
parameter_list|,
name|addend
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
comment|/* Sanity check the address.  */
if|if
condition|(
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* This function assumes that we are dealing with a basic relocation      against a symbol.  We want to compute the value of the symbol to      relocate to.  This is just VALUE, the value of the symbol, plus      ADDEND, any addend associated with the reloc.  */
name|relocation
operator|=
name|value
operator|+
name|addend
expr_stmt|;
comment|/* If the relocation is PC relative, we want to set RELOCATION to      the distance between the symbol (currently in RELOCATION) and the      location we are relocating.  Some targets (e.g., i386-aout)      arrange for the contents of the section to be the negative of the      offset of the location within the section; for such targets      pcrel_offset is false.  Other targets (e.g., m88kbcs or ELF)      simply leave the contents of the section as zero; for such      targets pcrel_offset is true.  If pcrel_offset is false we do not      need to subtract out the offset of the location within the      section (which is just ADDRESS).  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
condition|)
name|relocation
operator|-=
name|address
expr_stmt|;
block|}
return|return
name|ns32k_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|contents
operator|+
name|address
argument_list|)
return|;
block|}
end_function

end_unit

