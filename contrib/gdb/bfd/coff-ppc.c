begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for PowerPC Microsoft Portable Executable files.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.     Original version pieced together by Kim Knuttila (krk@cygnus.com)     There is nothing new under the sun. This file draws a lot on other    coff files, in particular, those for the rs/6000, alpha, mips, and     intel backends, and the PE work for the arm.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Current State:    - objdump works    - relocs generated by gas    - ld will link files, but they do not run.    - dlltool will not produce correct output in some .reloc cases, and will       not produce the right glue code for dll function calls. */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"coff/powerpc.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BADMAG
end_ifdef

begin_undef
undef|#
directive|undef
name|BADMAG
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|PPCBADMAG(x)
end_define

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* The toc is a set of bfd_vma fields. We use the fact that valid         */
end_comment

begin_comment
comment|/* addresses are even (i.e. the bit representing "1" is off) to allow     */
end_comment

begin_comment
comment|/* us to encode a little extra information in the field                   */
end_comment

begin_comment
comment|/* - Unallocated addresses are intialized to 1.                           */
end_comment

begin_comment
comment|/* - Allocated addresses are even numbers.                                */
end_comment

begin_comment
comment|/* The first time we actually write a reference to the toc in the bfd,    */
end_comment

begin_comment
comment|/* we want to record that fact in a fixup file (if it is asked for), so   */
end_comment

begin_comment
comment|/* we keep track of whether or not an address has been written by marking */
end_comment

begin_comment
comment|/* the low order bit with a "1" upon writing                              */
end_comment

begin_define
define|#
directive|define
name|SET_UNALLOCATED
parameter_list|(
name|x
parameter_list|)
value|((x) = 1)
end_define

begin_define
define|#
directive|define
name|IS_UNALLOCATED
parameter_list|(
name|x
parameter_list|)
value|((x) == 1)
end_define

begin_define
define|#
directive|define
name|IS_WRITTEN
parameter_list|(
name|x
parameter_list|)
value|((x)& 1)
end_define

begin_define
define|#
directive|define
name|MARK_AS_WRITTEN
parameter_list|(
name|x
parameter_list|)
value|((x) |= 1)
end_define

begin_define
define|#
directive|define
name|MAKE_ADDR_AGAIN
parameter_list|(
name|x
parameter_list|)
value|((x)&= ~1)
end_define

begin_comment
comment|/* In order not to add an int to every hash table item for every coff    linker, we define our own hash table, derived from the coff one */
end_comment

begin_comment
comment|/* PE linker hash table entries. */
end_comment

begin_struct
struct|struct
name|ppc_coff_link_hash_entry
block|{
name|struct
name|coff_link_hash_entry
name|root
decl_stmt|;
comment|/* First entry, as required  */
comment|/* As we wonder around the relocs, we'll keep the assigned toc_offset      here */
name|bfd_vma
name|toc_offset
decl_stmt|;
comment|/* Our addition, as required */
name|int
name|symbol_is_glue
decl_stmt|;
name|unsigned
name|long
name|int
name|glue_insn
decl_stmt|;
name|char
name|eye_catcher
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Need a 7 char string for an eye catcher */
end_comment

begin_define
define|#
directive|define
name|EYE
value|"krkjunk"
end_define

begin_define
define|#
directive|define
name|CHECK_EYE
parameter_list|(
name|addr
parameter_list|)
define|\
value|if (strcmp(addr, EYE) != 0) \   { \     fprintf(stderr,\     "File %s, line %d, Hash check failure, bad eye %8s\n", \     __FILE__, __LINE__, addr); \     abort(); \  }
end_define

begin_comment
comment|/* PE linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_coff_link_hash_table
block|{
name|struct
name|coff_link_hash_table
name|root
decl_stmt|;
comment|/* First entry, as required */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ppc_coff_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to create an entry in the link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ppc_coff_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|ppc_coff_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_coff_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
name|_bfd_coff_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|SET_UNALLOCATED
argument_list|(
name|ret
operator|->
name|toc_offset
argument_list|)
expr_stmt|;
name|ret
operator|->
name|symbol_is_glue
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|glue_insn
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|->
name|eye_catcher
argument_list|,
name|EYE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize a PE linker hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ppc_coff_link_hash_table_init
argument_list|(
name|table
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|ppc_coff_link_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|_bfd_coff_link_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Create a PE linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc_coff_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|ppc_coff_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|ppc_coff_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_coff_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|ppc_coff_link_hash_table_init
argument_list|(
name|ret
argument_list|,
name|abfd
argument_list|,
name|ppc_coff_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Now, tailor coffcode.h to use our hash stuff */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|ppc_coff_link_hash_table_create
end_define

begin_escape
end_escape

begin_comment
comment|/* The nt loader points the toc register to&toc + 32768, in order to */
end_comment

begin_comment
comment|/* use the complete range of a 16-bit displacement (I guess). We have */
end_comment

begin_comment
comment|/* to adjust for this when we fix up loads displaced off the toc reg. */
end_comment

begin_define
define|#
directive|define
name|TOC_LOAD_ADJUSTMENT
value|(-32768)
end_define

begin_define
define|#
directive|define
name|TOC_SECTION_NAME
value|".private.toc"
end_define

begin_comment
comment|/* The main body of code is in coffcode.h.  */
end_comment

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(3)
end_define

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_comment
comment|/* these should definitely go in a header file somewhere... */
end_comment

begin_comment
comment|/* NOP */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ABSOLUTE
value|0x0000
end_define

begin_comment
comment|/* 64-bit address */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ADDR64
value|0x0001
end_define

begin_comment
comment|/* 32-bit address */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ADDR32
value|0x0002
end_define

begin_comment
comment|/* 26-bit address, shifted left 2 (branch absolute) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ADDR24
value|0x0003
end_define

begin_comment
comment|/* 16-bit address */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ADDR16
value|0x0004
end_define

begin_comment
comment|/* 16-bit address, shifted left 2 (load doubleword) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ADDR14
value|0x0005
end_define

begin_comment
comment|/* 26-bit PC-relative offset, shifted left 2 (branch relative) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_REL24
value|0x0006
end_define

begin_comment
comment|/* 16-bit PC-relative offset, shifted left 2 (br cond relative) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_REL14
value|0x0007
end_define

begin_comment
comment|/* 16-bit offset from TOC base */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_TOCREL16
value|0x0008
end_define

begin_comment
comment|/* 16-bit offset from TOC base, shifted left 2 (load doubleword) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_TOCREL14
value|0x0009
end_define

begin_comment
comment|/* 32-bit addr w/o image base */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_ADDR32NB
value|0x000A
end_define

begin_comment
comment|/* va of containing section (as in an image sectionhdr) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_SECREL
value|0x000B
end_define

begin_comment
comment|/* sectionheader number */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_SECTION
value|0x000C
end_define

begin_comment
comment|/* substitute TOC restore instruction iff symbol is glue code */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_IFGLUE
value|0x000D
end_define

begin_comment
comment|/* symbol is glue code; virtual address is TOC restore instruction */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_IMGLUE
value|0x000E
end_define

begin_comment
comment|/* va of containing section (limited to 16 bits) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_SECREL16
value|0x000F
end_define

begin_comment
comment|/* stuff to handle immediate data when the number of bits in the */
end_comment

begin_comment
comment|/* data is greater than the number of bits in the immediate field */
end_comment

begin_comment
comment|/* We need to do (usually) 32 bit arithmetic on 16 bit chunks */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_REFHI
value|0x0010
end_define

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_REFLO
value|0x0011
end_define

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_PAIR
value|0x0012
end_define

begin_comment
comment|/* This is essentially the same as tocrel16, with TOCDEFN assumed */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_TOCREL16_DEFN
value|0x0013
end_define

begin_comment
comment|/*  Flag bits in IMAGE_RELOCATION.TYPE */
end_comment

begin_comment
comment|/* subtract reloc value rather than adding it */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_NEG
value|0x0100
end_define

begin_comment
comment|/* fix branch prediction bit to predict branch taken */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_BRTAKEN
value|0x0200
end_define

begin_comment
comment|/* fix branch prediction bit to predict branch not taken */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_BRNTAKEN
value|0x0400
end_define

begin_comment
comment|/* toc slot defined in file (or, data in toc) */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_TOCDEFN
value|0x0800
end_define

begin_comment
comment|/* masks to isolate above values in IMAGE_RELOCATION.Type */
end_comment

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_TYPEMASK
value|0x00FF
end_define

begin_define
define|#
directive|define
name|IMAGE_REL_PPC_FLAGMASK
value|0x0F00
end_define

begin_define
define|#
directive|define
name|EXTRACT_TYPE
parameter_list|(
name|x
parameter_list|)
value|((x)& IMAGE_REL_PPC_TYPEMASK)
end_define

begin_define
define|#
directive|define
name|EXTRACT_FLAGS
parameter_list|(
name|x
parameter_list|)
value|((x)& IMAGE_REL_PPC_FLAGMASK)
end_define

begin_define
define|#
directive|define
name|EXTRACT_JUNK
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& ~(IMAGE_REL_PPC_TYPEMASK | IMAGE_REL_PPC_FLAGMASK))
end_define

begin_escape
end_escape

begin_comment
comment|/* static helper functions to make relocation work */
end_comment

begin_comment
comment|/* (Work In Progress) */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_refhi_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_reflo_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_pair_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_toc16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_addr32nb_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_section_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_secrel_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_imglue_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|symbol
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|in_reloc_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|reloc_howto_type
operator|*
name|howto
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* FIXME: It'll take a while to get through all of these. I only need a few to    get us started, so those I'll make sure work. Those marked FIXME are either    completely unverified or have a specific unknown marked in the comment */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/* Relocation entries for Windows/NT on PowerPC.                             */
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/* From the document "" we find the following listed as used relocs:         */
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/*   ABSOLUTE       : The noop                                               */
end_comment

begin_comment
comment|/*   ADDR[64|32|16] : fields that hold addresses in data fields or the       */
end_comment

begin_comment
comment|/*                    16 bit displacement field on a load/store.             */
end_comment

begin_comment
comment|/*   ADDR[24|14]    : fields that hold addresses in branch and cond          */
end_comment

begin_comment
comment|/*                    branches. These represent [26|16] bit addresses.       */
end_comment

begin_comment
comment|/*                    The low order 2 bits are preserved.                    */
end_comment

begin_comment
comment|/*   REL[24|14]     : branches relative to the Instruction Address           */
end_comment

begin_comment
comment|/*                    register. These represent [26|16] bit addresses,       */
end_comment

begin_comment
comment|/*                    as before. The instruction field will be zero, and     */
end_comment

begin_comment
comment|/*                    the address of the SYM will be inserted at link time.  */
end_comment

begin_comment
comment|/*   TOCREL16       : 16 bit displacement field referring to a slot in       */
end_comment

begin_comment
comment|/*                    toc.                                                   */
end_comment

begin_comment
comment|/*   TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14. */
end_comment

begin_comment
comment|/*   ADDR32NB       : 32 bit address relative to the virtual origin.         */
end_comment

begin_comment
comment|/*                    (On the alpha, this is always a linker generated thunk)*/
end_comment

begin_comment
comment|/*                    (i.e. 32bit addr relative to the image base)           */
end_comment

begin_comment
comment|/*   SECREL         : The value is relative to the start of the section      */
end_comment

begin_comment
comment|/*                    containing the symbol.                                 */
end_comment

begin_comment
comment|/*   SECTION        : access to the header containing the item. Supports the */
end_comment

begin_comment
comment|/*                    codeview debugger.                                     */
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/* In particular, note that the document does not indicate that the          */
end_comment

begin_comment
comment|/* relocations listed in the header file are used.                           */
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/*                                                                           */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc_coff_howto_table
index|[]
init|=
block|{
comment|/* IMAGE_REL_PPC_ABSOLUTE 0x0000   NOP */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ABSOLUTE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* dont complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ABSOLUTE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x00
argument_list|,
comment|/* src_mask */
literal|0x00
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_ADDR64 0x0001  64-bit address */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|3
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_ADDR32 0x0002  32-bit address */
comment|/* Used: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_ADDR24 0x0003  26-bit address, shifted left 2 (branch absolute) */
comment|/* the LI field is in bit 6 through bit 29 is 24 bits, + 2 for the shift */
comment|/* Of course, That's the IBM approved bit numbering, which is not what */
comment|/* anyone else uses.... The li field is in bit 2 thru 25 */
comment|/* Used: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR24"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x07fffffc
argument_list|,
comment|/* src_mask */
literal|0x07fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_ADDR16 0x0004  16-bit address */
comment|/* Used: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_ADDR14 0x0005 */
comment|/*  16-bit address, shifted left 2 (load doubleword) */
comment|/* FIXME: the mask is likely wrong, and the bit position may be as well */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR14
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_REL24 0x0006 */
comment|/*   26-bit PC-relative offset, shifted left 2 (branch relative) */
comment|/* Used: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REL24"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3fffffc
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_REL14 0x0007 */
comment|/*   16-bit PC-relative offset, shifted left 2 (br cond relative) */
comment|/* FIXME: the mask is likely wrong, and the bit position may be as well */
comment|/* FIXME: how does it know how far to shift? */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR14
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_TOCREL16 0x0008 */
comment|/*   16-bit offset from TOC base */
comment|/* Used: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_TOCREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_toc16_reloc
argument_list|,
comment|/* special_function */
literal|"TOCREL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_TOCREL14 0x0009 */
comment|/*   16-bit offset from TOC base, shifted left 2 (load doubleword) */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_TOCREL14
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TOCREL14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_ADDR32NB 0x000A */
comment|/*   32-bit addr w/ image base */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_ADDR32NB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ADDR32NB"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_SECREL 0x000B */
comment|/*   va of containing section (as in an image sectionhdr) */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_SECREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_secrel_reloc
argument_list|,
comment|/* special_function */
literal|"SECREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_SECTION 0x000C */
comment|/*   sectionheader number */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_SECTION
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_section_reloc
argument_list|,
comment|/* special_function */
literal|"SECTION"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_IFGLUE 0x000D */
comment|/*   substitute TOC restore instruction iff symbol is glue code */
comment|/* Used: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_IFGLUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"IFGLUE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_IMGLUE 0x000E */
comment|/*   symbol is glue code; virtual address is TOC restore instruction */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_IMGLUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_imglue_reloc
argument_list|,
comment|/* special_function */
literal|"IMGLUE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_SECREL16 0x000F */
comment|/*   va of containing section (limited to 16 bits) */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_SECREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SECREL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_REFHI             0x0010 */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_REFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_refhi_reloc
argument_list|,
comment|/* special_function */
literal|"REFHI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_REFLO             0x0011 */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_REFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_refhi_reloc
argument_list|,
comment|/* special_function */
literal|"REFLO"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_PAIR              0x0012 */
comment|/* Unused: */
name|HOWTO
argument_list|(
name|IMAGE_REL_PPC_PAIR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_pair_reloc
argument_list|,
comment|/* special_function */
literal|"PAIR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* IMAGE_REL_PPC_TOCREL16_DEFN 0x0013 */
comment|/*   16-bit offset from TOC base, without causing a definition */
comment|/* Used: */
name|HOWTO
argument_list|(
operator|(
name|IMAGE_REL_PPC_TOCREL16
operator||
name|IMAGE_REL_PPC_TOCDEFN
operator|)
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TOCREL16, TOCDEFN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Some really cheezy macros that can be turned on to test stderr :-) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_RELOC
end_ifdef

begin_define
define|#
directive|define
name|UN_IMPL
parameter_list|(
name|x
parameter_list|)
define|\
value|{                                                            \    static int i;                                             \    if (i == 0)                                               \      {                                                       \        i = 1;                                                \        fprintf(stderr,"Unimplemented Relocation -- %s\n",x); \      }                                                       \ }
end_define

begin_define
define|#
directive|define
name|DUMP_RELOC
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
define|\
value|{                                                    \    fprintf(stderr,"%s sym %d, addr %d, addend %d\n", \ 	   n, (*(r->sym_ptr_ptr))->name,             \ 	   r->address, r->addend);                   \ }
end_define

begin_comment
comment|/* Given a reloc name, n, and a pointer to an internal_reloc,     dump out interesting information on the contents   #define n_name		_n._n_name #define n_zeroes	_n._n_n._n_zeroes #define n_offset	_n._n_n._n_offset  */
end_comment

begin_define
define|#
directive|define
name|DUMP_RELOC2
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
define|\
value|{                                            \    fprintf(stderr,"%s sym %d, r_vaddr %d %s\n", \ 	   n, r->r_symndx, r->r_vaddr,\ 	   (((r->r_type)& IMAGE_REL_PPC_TOCDEFN) == 0) \ 	   ?" ":" TOCDEFN"  );      \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UN_IMPL
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DUMP_RELOC
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DUMP_RELOC2
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* toc construction and management routines */
end_comment

begin_decl_stmt
specifier|extern
name|bfd
modifier|*
name|bfd_of_toc_owner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|int
name|global_toc_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|int
name|import_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|int
name|first_thunk_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|int
name|thunk_size
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|toc_type
block|{
name|default_toc
block|,
name|toc_32
block|,
name|toc_64
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ref_category
block|{
name|priv
block|,
name|pub
block|,
name|data
block|}
enum|;
end_enum

begin_struct
struct|struct
name|list_ele
block|{
name|struct
name|list_ele
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|enum
name|ref_category
name|cat
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|list_ele
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|list_ele
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_toc
parameter_list|(
name|toc_section
parameter_list|,
name|our_toc_offset
parameter_list|,
name|cat
parameter_list|,
name|name
parameter_list|)
name|asection
modifier|*
name|toc_section
decl_stmt|;
name|int
name|our_toc_offset
decl_stmt|;
name|enum
name|ref_category
name|cat
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* add this entry to our toc addr-offset-name list */
name|struct
name|list_ele
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|list_ele
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|offset
operator|=
name|our_toc_offset
expr_stmt|;
name|t
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|t
operator|->
name|cat
operator|=
name|cat
expr_stmt|;
name|t
operator|->
name|addr
operator|=
name|toc_section
operator|->
name|output_offset
operator|+
name|our_toc_offset
expr_stmt|;
if|if
condition|(
name|head
operator|==
literal|0
condition|)
block|{
name|head
operator|=
name|t
expr_stmt|;
name|tail
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|->
name|next
operator|=
name|t
expr_stmt|;
name|tail
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* record a toc offset against a symbol */
end_comment

begin_function
specifier|static
name|int
name|ppc_record_toc_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|sym
parameter_list|,
name|toc_kind
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|enum
name|toc_type
name|toc_kind
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|t
decl_stmt|;
name|bfd_byte
modifier|*
name|old_contents
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|element_size
decl_stmt|;
name|int
name|data
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|ppc_coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|coff_symbol_struct
modifier|*
name|target
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|local_syms
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
operator|(
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|sym
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
literal|0
condition|)
block|{
name|CHECK_EYE
argument_list|(
name|h
operator|->
name|eye_catcher
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|local_syms
operator|=
name|obj_coff_local_toc_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* allocate a table */
name|local_syms
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|obj_coff_local_toc_table
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_syms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|SET_UNALLOCATED
argument_list|(
name|local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_UNALLOCATED
argument_list|(
name|local_syms
index|[
name|sym
index|]
argument_list|)
condition|)
block|{
name|local_syms
index|[
name|sym
index|]
operator|=
name|global_toc_size
expr_stmt|;
name|ret_val
operator|=
name|global_toc_size
expr_stmt|;
name|global_toc_size
operator|+=
literal|4
expr_stmt|;
comment|/* The size must fit in a 16bit displacment */
if|if
condition|(
name|global_toc_size
operator|>=
literal|65535
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exceeded toc size of 65535\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting toc_offset for local sym %d to %d\n"
argument_list|,
name|sym
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ret_val
operator|=
name|local_syms
index|[
name|sym
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"toc_offset already set for local sym %d to %d\n"
argument_list|,
name|sym
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* check to see if there's a toc slot allocated. If not, do it 	 here. It will be used in relocate_section */
if|if
condition|(
name|IS_UNALLOCATED
argument_list|(
name|h
operator|->
name|toc_offset
argument_list|)
condition|)
block|{
name|h
operator|->
name|toc_offset
operator|=
name|global_toc_size
expr_stmt|;
name|ret_val
operator|=
name|global_toc_size
expr_stmt|;
name|global_toc_size
operator|+=
literal|4
expr_stmt|;
comment|/* The size must fit in a 16bit displacment */
if|if
condition|(
name|global_toc_size
operator|>=
literal|65535
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exceeded toc size of 65535\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting toc_offset for sym %d (%s) [h=%p] to %d\n"
argument_list|,
name|sym
argument_list|,
name|name
argument_list|,
name|h
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ret_val
operator|=
name|h
operator|->
name|toc_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"toc_offset already set for sym %d (%s) [h=%p] to %d\n"
argument_list|,
name|sym
argument_list|,
name|name
argument_list|,
name|h
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* FIXME: record a toc offset against a data-in-toc symbol */
end_comment

begin_comment
comment|/* Now, there is currenly some confusion on what this means. In some     compilers one sees the moral equivalent of:       .tocd       define some data       .text       refer to the data with a [tocv] qualifier    In general, one sees something to indicate that a tocd has been    seen, and that would trigger the allocation of data in toc. The IBM    docs seem to suggest that anything with the TOCDEFN qualifier should    never trigger storage allocation. However, in the kernel32.lib that     we've been using for our test bed, there are a couple of variables    referenced that fail that test.     So it can't work that way. */
end_comment

begin_function
specifier|static
name|int
name|ppc_record_data_in_toc_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|sym
parameter_list|,
name|toc_kind
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|enum
name|toc_type
name|toc_kind
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|t
decl_stmt|;
name|bfd_byte
modifier|*
name|old_contents
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|element_size
decl_stmt|;
name|int
name|data
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|ppc_coff_link_hash_entry
modifier|*
name|h
init|=
literal|0
decl_stmt|;
name|struct
name|coff_symbol_struct
modifier|*
name|target
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|local_syms
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
operator|(
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|sym
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|local_syms
operator|=
name|obj_coff_local_toc_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* allocate a table */
name|local_syms
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|obj_coff_local_toc_table
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_syms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|SET_UNALLOCATED
argument_list|(
name|local_syms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_UNALLOCATED
argument_list|(
name|local_syms
index|[
name|sym
index|]
argument_list|)
condition|)
block|{
name|local_syms
index|[
name|sym
index|]
operator|=
name|global_toc_size
expr_stmt|;
name|ret_val
operator|=
name|global_toc_size
expr_stmt|;
name|global_toc_size
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting data_in_toc_offset for local sym %d to %d\n"
argument_list|,
name|sym
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ret_val
operator|=
name|local_syms
index|[
name|sym
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"data_in_toc_offset already set for local sym %d to %d\n"
argument_list|,
name|sym
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|CHECK_EYE
argument_list|(
name|h
operator|->
name|eye_catcher
argument_list|)
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* check to see if there's a toc slot allocated. If not, do it 	 here. It will be used in relocate_section */
if|if
condition|(
name|IS_UNALLOCATED
argument_list|(
name|h
operator|->
name|toc_offset
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|h->toc_offset = global_toc_size;
endif|#
directive|endif
name|ret_val
operator|=
name|global_toc_size
expr_stmt|;
comment|/* We're allocating a chunk of the toc, as opposed to a slot */
comment|/* FIXME: alignment? */
name|global_toc_size
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting data_in_toc_offset for sym %d (%s) [h=%p] to %d\n"
argument_list|,
name|sym
argument_list|,
name|name
argument_list|,
name|h
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ret_val
operator|=
name|h
operator|->
name|toc_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"data_in_toc_offset already set for sym %d (%s) [h=%p] to %d\n"
argument_list|,
name|sym
argument_list|,
name|name
argument_list|,
name|h
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* record a toc offset against a symbol */
end_comment

begin_function
specifier|static
name|void
name|ppc_mark_symbol_as_glue
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|,
name|rel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
block|{
name|struct
name|ppc_coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
operator|(
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|sym
index|]
operator|)
expr_stmt|;
name|CHECK_EYE
argument_list|(
name|h
operator|->
name|eye_catcher
argument_list|)
expr_stmt|;
name|h
operator|->
name|symbol_is_glue
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|glue_insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provided the symbol, returns the value reffed */
end_comment

begin_decl_stmt
specifier|static
name|long
name|get_symbol_value
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|get_symbol_value
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|long
name|relocation
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|relocation
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
return|return
operator|(
name|relocation
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if this relocation should    appear in the output .reloc section. */
end_comment

begin_function
specifier|static
name|boolean
name|in_reloc_p
parameter_list|(
name|abfd
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|howto
operator|->
name|pc_relative
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_ADDR32NB
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_TOCREL16
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_IMGLUE
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_IFGLUE
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_SECREL
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_SECTION
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_SECREL16
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_REFHI
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_REFLO
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_PAIR
operator|)
operator|&&
operator|(
name|howto
operator|->
name|type
operator|!=
name|IMAGE_REL_PPC_TOCREL16_DEFN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this function is in charge of performing all the ppc PE relocations */
end_comment

begin_comment
comment|/* Don't yet know if we want to do this this particular way ... (krk)  */
end_comment

begin_comment
comment|/* FIXME: (it is not yet enabled) */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|pe_ppc_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* the consth relocation comes in two parts, we have to remember      the state between calls, in these variables */
specifier|static
name|boolean
name|part1_consth_active
init|=
name|false
decl_stmt|;
specifier|static
name|unsigned
name|long
name|part1_consth_value
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|sym_value
decl_stmt|;
name|unsigned
name|long
name|unsigned_value
decl_stmt|;
name|unsigned
name|short
name|r_type
decl_stmt|;
name|long
name|signed_value
decl_stmt|;
name|unsigned
name|long
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
comment|/*+ input_section->vma*/
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|data
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pe_ppc_reloc (%s)\n"
argument_list|,
name|TARGET_LITTLE_NAME
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
condition|)
block|{
comment|/* Partial linking - do nothing */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* Keep the state machine happy in case we're called again */
if|if
condition|(
name|r_type
operator|==
name|IMAGE_REL_PPC_REFHI
condition|)
block|{
name|part1_consth_active
operator|=
name|true
expr_stmt|;
name|part1_consth_value
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|bfd_reloc_undefined
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|part1_consth_active
operator|)
operator|&&
operator|(
name|r_type
operator|!=
name|IMAGE_REL_PPC_PAIR
operator|)
condition|)
block|{
name|part1_consth_active
operator|=
name|false
expr_stmt|;
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Missing PAIR"
expr_stmt|;
return|return
operator|(
name|bfd_reloc_dangerous
operator|)
return|;
block|}
name|sym_value
operator|=
name|get_symbol_value
argument_list|(
name|symbol_in
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_reloc_ok
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The reloc processing routine for the optimized COFF linker.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_ppc_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|boolean
name|hihalf
decl_stmt|;
name|bfd_vma
name|hihalf_val
decl_stmt|;
name|asection
modifier|*
name|toc_section
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pe_ppc_relocate_section (%s) for %s in bfd %s\n"
argument_list|,
name|TARGET_LITTLE_NAME
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are performing a relocateable link, we don't need to do a      thing.  The caller will take care of adjusting the reloc      addresses and symbol indices.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|hihalf
operator|=
name|false
expr_stmt|;
name|hihalf_val
operator|=
literal|0
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|ppc_coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|short
name|r_type
init|=
name|EXTRACT_TYPE
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|r_flags
init|=
name|EXTRACT_FLAGS
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|junk
init|=
name|EXTRACT_JUNK
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
comment|/* now examine flags */
if|if
condition|(
name|r_flags
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc with flags found!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_NEG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" NEG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRNTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRNTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" TOCDEFN"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
name|loc
operator|=
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
comment|/* FIXME: check bounds on r_type */
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
operator|(
expr|struct
name|ppc_coff_link_hash_entry
operator|*
operator|)
operator|(
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
literal|0
condition|)
block|{
name|CHECK_EYE
argument_list|(
name|h
operator|->
name|eye_catcher
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
name|sec
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: PAIR unsupported in the following code */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CHECK_EYE
argument_list|(
name|h
operator|->
name|eye_catcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing %s\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|rstat
operator|=
name|bfd_reloc_ok
expr_stmt|;
comment|/* Each case must do its own relocation, setting rstat appropriately */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: during reloc processing -- unsupported reloc %s\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
case|case
name|IMAGE_REL_PPC_TOCREL16
case|:
block|{
name|bfd_vma
name|our_toc_offset
decl_stmt|;
name|int
name|fixit
decl_stmt|;
name|DUMP_RELOC2
argument_list|(
name|howto
operator|->
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|toc_section
operator|==
literal|0
condition|)
block|{
name|toc_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|bfd_of_toc_owner
argument_list|,
name|TOC_SECTION_NAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BFD of toc owner %p (%s), section addr of %s %p\n"
argument_list|,
name|bfd_of_toc_owner
argument_list|,
name|bfd_of_toc_owner
operator|->
name|filename
argument_list|,
name|TOC_SECTION_NAME
argument_list|,
name|toc_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|toc_section
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No Toc section!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  	     *  Amazing bit tricks present. As we may have seen earlier, we 	     *  use the 1 bit to tell us whether or not a toc offset has been 	     *  allocated. Now that they've all been allocated, we will use 	     *  the 1 bit to tell us if we've written this particular toc 	     *  entry out. 	     */
name|fixit
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
comment|/* it is a file local symbol */
name|int
modifier|*
name|local_toc_table
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
name|name
operator|=
name|sym
operator|->
name|_n
operator|.
name|_n_name
expr_stmt|;
name|local_toc_table
operator|=
name|obj_coff_local_toc_table
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|our_toc_offset
operator|=
name|local_toc_table
index|[
name|symndx
index|]
expr_stmt|;
if|if
condition|(
name|IS_WRITTEN
argument_list|(
name|our_toc_offset
argument_list|)
condition|)
block|{
comment|/* if it has been written out, it is marked with the  		       1 bit. Fix up our offset, but do not write it out 		       again. 		     */
name|MAKE_ADDR_AGAIN
argument_list|(
name|our_toc_offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not writing out toc_offset of %d for %s\n"
argument_list|,
name|our_toc_offset
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* write out the toc entry */
name|record_toc
argument_list|(
name|toc_section
argument_list|,
name|our_toc_offset
argument_list|,
name|priv
argument_list|,
name|strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing out toc_offset "
literal|"toc_section (%p,%p)+%d val %d for %s\n"
argument_list|,
name|toc_section
argument_list|,
name|toc_section
operator|->
name|contents
argument_list|,
name|our_toc_offset
argument_list|,
name|val
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|toc_section
operator|->
name|contents
operator|+
name|our_toc_offset
argument_list|)
expr_stmt|;
name|MARK_AS_WRITTEN
argument_list|(
name|local_toc_table
index|[
name|symndx
index|]
argument_list|)
expr_stmt|;
name|fixit
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|our_toc_offset
operator|=
name|h
operator|->
name|toc_offset
expr_stmt|;
if|if
condition|(
operator|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
operator|)
operator|==
name|IMAGE_REL_PPC_TOCDEFN
condition|)
if|#
directive|if
literal|0
comment|/* This is wrong. If tocdefn is on, we must unconditionally 		     assume the following path */
then|&& IS_UNALLOCATED(our_toc_offset))
endif|#
directive|endif
block|{
comment|/* This is unbelievable cheese. Some knowledgable asm  		       hacker has decided to use r2 as a base for loading  		       a value. He/She does this by setting the tocdefn bit,  		       and not supplying a toc definition. The behaviour is  		       then to use the difference between the value of the  		       symbol and the actual location of the toc as the toc  		       index.   		       In fact, what is usually happening is, because the 		       Import Address Table is mapped immediately following 		       the toc, some trippy library code trying for speed on 		       dll linkage, takes advantage of that and considers  		       the IAT to be part of the toc, thus saving a load. 		    */
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TOCDEFN is on, (%s) (%p) our_toc_offset = %x\n"
argument_list|,
name|name
argument_list|,
name|h
argument_list|,
name|our_toc_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|our_toc_offset
operator|=
name|val
operator|-
operator|(
name|toc_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|toc_section
operator|->
name|output_offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"               our_toc_offset set to %x\n"
argument_list|,
name|our_toc_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The size must still fit in a 16bit displacment */
if|if
condition|(
name|our_toc_offset
operator|>=
literal|65535
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TOCDEFN Relocation exceeded "
literal|"displacment of 65535\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|record_toc
argument_list|(
name|toc_section
argument_list|,
name|our_toc_offset
argument_list|,
name|pub
argument_list|,
name|strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_WRITTEN
argument_list|(
name|our_toc_offset
argument_list|)
condition|)
block|{
comment|/* if it has been written out, it is marked with the  		       1 bit. Fix up our offset, but do not write it out 		       again. 		     */
name|MAKE_ADDR_AGAIN
argument_list|(
name|our_toc_offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not writing out toc_offset of %d for %s\n"
argument_list|,
name|our_toc_offset
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|record_toc
argument_list|(
name|toc_section
argument_list|,
name|our_toc_offset
argument_list|,
name|pub
argument_list|,
name|strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
comment|/* write out the toc entry */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing out toc_offset "
literal|"toc_section (%p,%p)+%d val %d for %s\n"
argument_list|,
name|toc_section
argument_list|,
name|toc_section
operator|->
name|contents
argument_list|,
name|our_toc_offset
argument_list|,
name|val
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* write out the toc entry */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|toc_section
operator|->
name|contents
operator|+
name|our_toc_offset
argument_list|)
expr_stmt|;
name|MARK_AS_WRITTEN
argument_list|(
name|h
operator|->
name|toc_offset
argument_list|)
expr_stmt|;
comment|/* The tricky part is that this is the address that */
comment|/* needs a .reloc entry for it */
name|fixit
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixit
operator|&&
name|info
operator|->
name|base_file
condition|)
block|{
comment|/* So if this is non pcrelative, and is referenced 		   to a section or a common symbol, then it needs a reloc */
comment|/* relocation to a symbol in a section which 		   isn't absolute - we output the address here  		   to a file */
name|bfd_vma
name|addr
init|=
name|toc_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|toc_section
operator|->
name|output_offset
operator|+
name|our_toc_offset
decl_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe
condition|)
name|addr
operator|-=
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Toc Section .reloc candidate addr = %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwrite
argument_list|(
operator|&
name|addr
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|info
operator|->
name|base_file
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: this test is conservative */
if|if
condition|(
operator|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
operator|)
operator|!=
name|IMAGE_REL_PPC_TOCDEFN
operator|&&
name|our_toc_offset
operator|>
name|toc_section
operator|->
name|_raw_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reloc offset is bigger than the toc size!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now we know the relocation for this toc reference */
name|relocation
operator|=
name|our_toc_offset
operator|+
name|TOC_LOAD_ADJUSTMENT
expr_stmt|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IMAGE_REL_PPC_IFGLUE
case|:
block|{
comment|/* To solve this, we need to know whether or not the symbol */
comment|/* appearing on the call instruction is a glue function or not. */
comment|/* A glue function must announce itself via a IMGLUE reloc, and */
comment|/* the reloc contains the required toc restore instruction */
name|bfd_vma
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|my_name
decl_stmt|;
name|DUMP_RELOC2
argument_list|(
name|howto
operator|->
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
literal|0
condition|)
block|{
name|my_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|symbol_is_glue
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|h
operator|->
name|glue_insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|IMAGE_REL_PPC_SECREL
case|:
comment|/* Unimplemented: codeview debugging information */
comment|/* For fast access to the header of the section  	     containing the item. */
break|break;
case|case
name|IMAGE_REL_PPC_SECTION
case|:
comment|/* Unimplemented: codeview debugging information */
comment|/* Is used to indicate that the value should be relative 	     to the beginning of the section that contains the 	     symbol */
break|break;
case|case
name|IMAGE_REL_PPC_ABSOLUTE
case|:
block|{
specifier|const
name|char
modifier|*
name|my_name
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
name|my_name
operator|=
operator|(
name|syms
operator|+
name|symndx
operator|)
operator|->
name|_n
operator|.
name|_n_name
expr_stmt|;
else|else
block|{
name|my_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: unsupported reloc %s<file %s, section %s>\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sym %d (%s), r_vaddr %d (%x)\n"
argument_list|,
name|rel
operator|->
name|r_symndx
argument_list|,
name|my_name
argument_list|,
name|rel
operator|->
name|r_vaddr
argument_list|,
name|rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IMAGE_REL_PPC_IMGLUE
case|:
block|{
comment|/* There is nothing to do now. This reloc was noted in the first 	       pass over the relocs, and the glue instruction extracted */
specifier|const
name|char
modifier|*
name|my_name
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|symbol_is_glue
operator|==
literal|1
condition|)
break|break;
name|my_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: previously missed IMGLUE reloc %s<file %s, section %s>\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IMAGE_REL_PPC_ADDR32NB
case|:
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|DUMP_RELOC2
argument_list|(
name|howto
operator|->
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|".idata$2"
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
name|first_thunk_address
operator|==
literal|0
condition|)
block|{
comment|/* set magic values */
name|int
name|idata5offset
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
init|=
literal|0
decl_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__idata5_magic__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|first_thunk_address
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|-
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|idata5offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__idata6_magic__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|thunk_size
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-
name|idata5offset
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__idata4_magic__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|import_table_size
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"first computation triggered fta %x, ts %d(%x), its %d(%x)\n"
argument_list|,
name|first_thunk_address
argument_list|,
name|thunk_size
argument_list|,
name|thunk_size
argument_list|,
name|import_table_size
argument_list|,
name|import_table_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
comment|/* it is a file local symbol */
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
name|name
operator|=
name|sym
operator|->
name|_n
operator|.
name|_n_name
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|target
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|".idata$2"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|target
operator|=
literal|"__idata2_magic__"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|".idata$4"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|target
operator|=
literal|"__idata4_magic__"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|".idata$5"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|target
operator|=
literal|"__idata5_magic__"
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|myh
operator|=
literal|0
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|target
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing idata magic cookies, "
literal|"this cannot work anyway...\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|val
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|first_thunk_address
operator|==
literal|0
condition|)
block|{
name|int
name|idata5offset
decl_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__idata5_magic__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|first_thunk_address
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|-
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|idata5offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__idata6_magic__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|thunk_size
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-
name|idata5offset
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__idata4_magic__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|import_table_size
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"second computation triggered fta %x, ts %d(%x), its %d(%x)\n"
argument_list|,
name|first_thunk_address
argument_list|,
name|thunk_size
argument_list|,
name|thunk_size
argument_list|,
name|import_table_size
argument_list|,
name|import_table_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|val
operator|-
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IMAGE_REL_PPC_REL24
case|:
name|DUMP_RELOC2
argument_list|(
name|howto
operator|->
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|val
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|val
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_ADDR16
case|:
case|case
name|IMAGE_REL_PPC_ADDR24
case|:
case|case
name|IMAGE_REL_PPC_ADDR32
case|:
name|DUMP_RELOC2
argument_list|(
name|howto
operator|->
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|val
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|base_file
condition|)
block|{
comment|/* So if this is non pcrelative, and is referenced 	     to a section or a common symbol, then it needs a reloc */
if|if
condition|(
name|sym
operator|&&
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|in_reloc_p
argument_list|(
name|output_bfd
argument_list|,
name|howto
argument_list|)
condition|)
block|{
comment|/* relocation to a symbol in a section which 		 isn't absolute - we output the address here  		 to a file */
name|bfd_vma
name|addr
init|=
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe
condition|)
block|{
name|bfd_vma
name|before_addr
init|=
name|addr
decl_stmt|;
name|addr
operator|-=
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" adjusted down from %x to %x"
argument_list|,
name|before_addr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwrite
argument_list|(
operator|&
name|addr
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|info
operator|->
name|base_file
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"*unknown*"
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|!=
literal|0
condition|)
name|name
operator|=
name|obj_coff_strings
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|sym
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else 	      { 		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf); 		if (name == NULL) 		  return false; 	      }
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pe_ppc_relocate_section (%s) for %s in bfd %s RETURNING TRUE\n"
argument_list|,
name|TARGET_LITTLE_NAME
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pe_ppc_relocate_section (%s) for %s in bfd %s RETURNING TRUE\n"
argument_list|,
name|TARGET_LITTLE_NAME
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
end_ifdef

begin_decl_stmt
name|long
name|int
name|global_toc_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|bfd_of_toc_owner
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|import_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|first_thunk_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|thunk_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|list_ele
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|list_ele
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|h1
init|=
literal|"\n\t\t\tTOC MAPPING\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|h2
init|=
literal|" TOC    disassembly  Comments       Name\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|h3
init|=
literal|" Offset  spelling                   (if present)\n"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dump_toc
parameter_list|(
name|vfile
parameter_list|)
name|void
modifier|*
name|vfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
name|vfile
decl_stmt|;
name|struct
name|list_ele
modifier|*
name|t
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|h2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|h3
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|head
init|;
name|t
operator|!=
literal|0
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|cat
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|cat
operator|==
name|priv
condition|)
name|cat
operator|=
literal|"private       "
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|cat
operator|==
name|pub
condition|)
name|cat
operator|=
literal|"public        "
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|cat
operator|==
name|data
condition|)
name|cat
operator|=
literal|"data-in-toc   "
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|offset
operator|>
name|global_toc_size
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|offset
operator|<=
name|global_toc_size
operator|+
name|thunk_size
condition|)
name|cat
operator|=
literal|"IAT reference "
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"**** global_toc_size %d(%x), thunk_size %d(%x)\n"
argument_list|,
name|global_toc_size
argument_list|,
name|global_toc_size
argument_list|,
name|thunk_size
argument_list|,
name|thunk_size
argument_list|)
expr_stmt|;
name|cat
operator|=
literal|"Out of bounds!"
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %04lx    (%d)"
argument_list|,
name|t
operator|->
name|offset
argument_list|,
name|t
operator|->
name|offset
operator|-
literal|32768
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    %s %s\n"
argument_list|,
name|cat
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean
name|ppc_allocate_toc_section
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|foo
decl_stmt|;
specifier|static
name|char
name|test_char
init|=
literal|'1'
decl_stmt|;
if|if
condition|(
name|global_toc_size
operator|==
literal|0
condition|)
comment|/* FIXME: does this get me in trouble? */
return|return
name|true
return|;
if|if
condition|(
name|bfd_of_toc_owner
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There is no bfd that owns the toc section!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|bfd_of_toc_owner
argument_list|,
name|TOC_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No Toc section!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|foo
operator|=
name|bfd_alloc
argument_list|(
name|bfd_of_toc_owner
argument_list|,
name|global_toc_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|foo
argument_list|,
name|test_char
argument_list|,
name|global_toc_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|s
operator|->
name|_cooked_size
operator|=
name|global_toc_size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|ppc_process_before_allocation
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|i
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_process_before_allocation: BFD %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* here we have a bfd that is to be included on the link. We have a hook      to do reloc rummaging, before section sizes are nailed down. */
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* rummage around all the relocs and map the toc */
name|sec
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
if|if
condition|(
name|sec
operator|==
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
for|for
control|(
init|;
name|sec
operator|!=
literal|0
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|int
name|toc_offset
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  section %s reloc count %d\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* load the relocs */
comment|/* FIXME: there may be a storage leak here */
name|i
operator|=
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|i
init|;
name|rel
operator|<
name|i
operator|+
name|sec
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|short
name|r_type
init|=
name|EXTRACT_TYPE
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|r_flags
init|=
name|EXTRACT_FLAGS
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|junk
init|=
name|EXTRACT_JUNK
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RELOC
comment|/* now examine flags */
if|if
condition|(
name|r_flags
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc with flags found!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_NEG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" NEG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRNTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRNTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" TOCDEFN"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|IMAGE_REL_PPC_TOCREL16
case|:
if|#
directive|if
literal|0
comment|/* FIXME: 	       This remains unimplemented for now, as it currently adds 	       un-necessary elements to the toc. All we need to do today 	       is not do anything if TOCDEFN is on. 	    */
block|if ( r_flags& IMAGE_REL_PPC_TOCDEFN ) 	      toc_offset = ppc_record_data_in_toc_entry(abfd, info, sec,  							rel->r_symndx,  							default_toc); 	    else 	      toc_offset = ppc_record_toc_entry(abfd, info, sec,  						rel->r_symndx, default_toc);
endif|#
directive|endif
if|if
condition|(
operator|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
operator|)
operator|!=
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|toc_offset
operator|=
name|ppc_record_toc_entry
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|rel
operator|->
name|r_symndx
argument_list|,
name|default_toc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_IMGLUE
case|:
name|ppc_mark_symbol_as_glue
argument_list|(
name|abfd
argument_list|,
name|rel
operator|->
name|r_symndx
argument_list|,
name|rel
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_refhi_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"REFHI"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"REFHI"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_undefined
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_reflo_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"REFLO"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"REFLO"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_undefined
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_pair_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"PAIR"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"PAIR"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_undefined
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_toc16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"TOCREL16"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"TOCREL16"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|bfd_reloc_continue
return|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* ADDR32NB : 32 bit address relative to the virtual origin.         */
end_comment

begin_comment
comment|/*            (On the alpha, this is always a linker generated thunk)*/
end_comment

begin_comment
comment|/*            (i.e. 32bit addr relative to the image base)           */
end_comment

begin_comment
comment|/*                                                                   */
end_comment

begin_comment
comment|/*                                                                   */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_addr32nb_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"ADDR32NB"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"ADDR32NB"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_secrel_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"SECREL"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"SECREL"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_section_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"SECTION"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"SECTION"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_imglue_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|UN_IMPL
argument_list|(
literal|"IMGLUE"
argument_list|)
expr_stmt|;
name|DUMP_RELOC
argument_list|(
literal|"IMGLUE"
argument_list|,
name|reloc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_RELOC_INDEX
define|\
value|(sizeof(ppc_coff_howto_table) / sizeof(ppc_coff_howto_table[0]) - 1)
end_define

begin_comment
comment|/* FIXME: There is a possiblity that when we read in a reloc from a file,           that there are some bits encoded in the upper portion of the  	  type field. Not yet implemented. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ppc_coff_rtype2howto
name|PARAMS
argument_list|(
operator|(
name|arelent
operator|*
name|relent
operator|,
expr|struct
name|internal_reloc
operator|*
name|internal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ppc_coff_rtype2howto
parameter_list|(
name|relent
parameter_list|,
name|internal
parameter_list|)
name|arelent
modifier|*
name|relent
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal
decl_stmt|;
block|{
comment|/* We can encode one of three things in the type field, aside from the      type:      1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction         value, rather than an addition value      2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that         the branch is expected to be taken or not.      3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file      For now, we just strip this stuff to find the type, and ignore it other      than that.   */
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|short
name|r_type
init|=
name|EXTRACT_TYPE
argument_list|(
name|internal
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|r_flags
init|=
name|EXTRACT_FLAGS
argument_list|(
name|internal
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|junk
init|=
name|EXTRACT_JUNK
argument_list|(
name|internal
operator|->
name|r_type
argument_list|)
decl_stmt|;
comment|/* the masking process only slices off the bottom byte for r_type. */
if|if
condition|(
name|r_type
operator|>
name|MAX_RELOC_INDEX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_coff_rtype2howto: reloc index %d out of range [%d, %d]\n"
argument_list|,
name|internal
operator|->
name|r_type
argument_list|,
literal|0
argument_list|,
name|MAX_RELOC_INDEX
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* check for absolute crap */
if|if
condition|(
name|junk
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_coff_rtype2howto: reloc index %d contains junk %d\n"
argument_list|,
name|internal
operator|->
name|r_type
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_RELOC
comment|/* now examine flags */
if|if
condition|(
name|r_flags
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc with flags found!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_NEG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" NEG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRNTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRNTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" TOCDEFN"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|IMAGE_REL_PPC_ADDR16
case|:
case|case
name|IMAGE_REL_PPC_REL24
case|:
case|case
name|IMAGE_REL_PPC_ADDR24
case|:
case|case
name|IMAGE_REL_PPC_ADDR32
case|:
case|case
name|IMAGE_REL_PPC_IFGLUE
case|:
case|case
name|IMAGE_REL_PPC_ADDR32NB
case|:
case|case
name|IMAGE_REL_PPC_SECTION
case|:
case|case
name|IMAGE_REL_PPC_SECREL
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|internal
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_IMGLUE
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|internal
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_TOCREL16
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|internal
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|IMAGE_REL_PPC_TOCREL16_DEFN
expr_stmt|;
else|else
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|IMAGE_REL_PPC_TOCREL16
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Unsupported reloc %s [%d] used -- it may not work.\n"
argument_list|,
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
block|}
name|relent
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_ppc_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* We can encode one of three things in the type field, aside from the      type:      1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction         value, rather than an addition value      2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that         the branch is expected to be taken or not.      3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file      For now, we just strip this stuff to find the type, and ignore it other      than that.   */
name|unsigned
name|short
name|r_type
init|=
name|EXTRACT_TYPE
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|r_flags
init|=
name|EXTRACT_FLAGS
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|junk
init|=
name|EXTRACT_JUNK
argument_list|(
name|rel
operator|->
name|r_type
argument_list|)
decl_stmt|;
comment|/* the masking process only slices off the bottom byte for r_type. */
if|if
condition|(
name|r_type
operator|>
name|MAX_RELOC_INDEX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"coff_ppc_rtype_to_howto: index %d out of range [%d, %d]\n"
argument_list|,
name|r_type
argument_list|,
literal|0
argument_list|,
name|MAX_RELOC_INDEX
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* check for absolute crap */
if|if
condition|(
name|junk
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"coff_ppc_rtype_to_howto: reloc index %d contains junk %d\n"
argument_list|,
name|rel
operator|->
name|r_type
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_RELOC
comment|/* now examine flags */
if|if
condition|(
name|r_flags
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc with flags found!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_NEG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" NEG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_BRNTAKEN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" BRNTAKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" TOCDEFN"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|IMAGE_REL_PPC_ADDR32NB
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
operator|*
name|addendp
operator|-=
name|pe_data
argument_list|(
name|sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_TOCREL16
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_flags
operator|&
name|IMAGE_REL_PPC_TOCDEFN
condition|)
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|IMAGE_REL_PPC_TOCREL16_DEFN
expr_stmt|;
else|else
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|IMAGE_REL_PPC_TOCREL16
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_ADDR16
case|:
case|case
name|IMAGE_REL_PPC_REL24
case|:
case|case
name|IMAGE_REL_PPC_ADDR24
case|:
case|case
name|IMAGE_REL_PPC_ADDR32
case|:
case|case
name|IMAGE_REL_PPC_IFGLUE
case|:
case|case
name|IMAGE_REL_PPC_SECTION
case|:
case|case
name|IMAGE_REL_PPC_SECREL
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_PPC_IMGLUE
case|:
name|DUMP_RELOC2
argument_list|(
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Unsupported reloc %s [%d] used -- it may not work.\n"
argument_list|,
name|ppc_coff_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ppc_coff_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
block|}
return|return
name|howto
return|;
block|}
end_function

begin_comment
comment|/* a cheesy little macro to make the code a little more readable */
end_comment

begin_define
define|#
directive|define
name|HOW2MAP
parameter_list|(
name|bfd_rtype
parameter_list|,
name|ppc_rtype
parameter_list|)
define|\
value|case bfd_rtype: return&ppc_coff_howto_table[ppc_rtype]
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_coff_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_coff_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG_RELOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_coff_reloc_type_lookup for %s\n"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
name|HOW2MAP
argument_list|(
name|BFD_RELOC_32_GOTOFF
argument_list|,
name|IMAGE_REL_PPC_IMGLUE
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_16_GOT_PCREL
argument_list|,
name|IMAGE_REL_PPC_IFGLUE
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_16
argument_list|,
name|IMAGE_REL_PPC_ADDR16
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_PPC_B26
argument_list|,
name|IMAGE_REL_PPC_REL24
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_PPC_BA26
argument_list|,
name|IMAGE_REL_PPC_ADDR24
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_PPC_TOC16
argument_list|,
name|IMAGE_REL_PPC_TOCREL16
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_16_GOTOFF
argument_list|,
name|IMAGE_REL_PPC_TOCREL16_DEFN
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_32
argument_list|,
name|IMAGE_REL_PPC_ADDR32
argument_list|)
expr_stmt|;
name|HOW2MAP
argument_list|(
name|BFD_RELOC_RVA
argument_list|,
name|IMAGE_REL_PPC_ADDR32NB
argument_list|)
expr_stmt|;
default|default:
return|return
name|NULL
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|HOW2MAP
end_undef

begin_escape
end_escape

begin_comment
comment|/* Tailor coffcode.h -- macro heaven. */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
value|ppc_coff_rtype2howto (cache_ptr, dst)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
end_ifndef

begin_function_decl
specifier|static
name|void
name|ppc_coff_swap_sym_in_hook
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We use the special COFF backend linker, with our own special touch.  */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|ppc_coff_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|coff_ppc_rtype_to_howto
end_define

begin_define
define|#
directive|define
name|coff_relocate_section
value|coff_ppc_relocate_section
end_define

begin_define
define|#
directive|define
name|coff_bfd_final_link
value|ppc_bfd_coff_final_link
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
end_ifndef

begin_define
define|#
directive|define
name|coff_swap_sym_in_hook
value|ppc_coff_swap_sym_in_hook
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|internal
parameter_list|,
name|howto
parameter_list|)
value|{internal.r_type=howto->type;}
end_define

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|POWERPC_LE_PE
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
end_ifndef

begin_comment
comment|/* FIXME:    What we're trying to do here is allocate a toc section (early), and attach     it to the last bfd to be processed. This avoids the problem of having a toc    written out before all files have been processed. This code allocates    a toc section for every file, and records the last one seen. There are    at least two problems with this approach:    1. We allocate whole bunches of toc sections that are ignored, but at       at least we will not allocate a toc if no .toc is present.    2. It's not clear to me that being the last bfd read necessarily means       that you are the last bfd closed.    3. Doing it on a "swap in" hook depends on when the "swap in" is called,       and how often, etc. It's not clear to me that there isn't a hole here. */
end_comment

begin_function
specifier|static
name|void
name|ppc_coff_swap_sym_in_hook
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|in1
decl_stmt|;
if|if
condition|(
name|bfd_of_toc_owner
operator|!=
literal|0
condition|)
comment|/* we already have a toc, so go home */
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
literal|".toc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|foo
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|TOC_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
return|return;
block|}
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
ifdef|#
directive|ifdef
name|TOC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_coff_swap_sym_in_hook: about to create the %s section\n"
argument_list|,
name|TOC_SECTION_NAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|TOC_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"toc section allocation failed!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* save the bfd for later allocation */
name|bfd_of_toc_owner
operator|=
name|abfd
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|boolean
name|ppc_bfd_coff_final_link
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
end_ifndef

begin_function
specifier|static
name|boolean
name|ppc_do_last
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|==
name|bfd_of_toc_owner
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|ppc_get_last
parameter_list|()
block|{
return|return
name|bfd_of_toc_owner
return|;
block|}
end_function

begin_comment
comment|/* this piece of machinery exists only to guarantee that the bfd that holds    the toc section is written last.      This does depend on bfd_make_section attaching a new section to the    end of the section list for the bfd.      This is otherwise intended to be functionally the same as     cofflink.c:_bfd_coff_final_link(). It is specifically different only     where the POWERPC_LE_PE macro modifies the code. It is left in as a     precise form of comment. krk@cygnus.com */
end_comment

begin_define
define|#
directive|define
name|POWERPC_LE_PE
end_define

begin_comment
comment|/* Do the final link step.  */
end_comment

begin_function
name|boolean
name|ppc_bfd_coff_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd_size_type
name|symesz
decl_stmt|;
name|struct
name|coff_final_link_info
name|finfo
decl_stmt|;
name|boolean
name|debug_merge_allocated
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|size_t
name|max_sym_count
decl_stmt|;
name|size_t
name|max_lineno_count
decl_stmt|;
name|size_t
name|max_reloc_count
decl_stmt|;
name|size_t
name|max_output_reloc_count
decl_stmt|;
name|size_t
name|max_contents_size
decl_stmt|;
name|file_ptr
name|rel_filepos
decl_stmt|;
name|unsigned
name|int
name|relsz
decl_stmt|;
name|file_ptr
name|line_filepos
decl_stmt|;
name|unsigned
name|int
name|linesz
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|bfd_byte
modifier|*
name|external_relocs
init|=
name|NULL
decl_stmt|;
name|char
name|strbuf
index|[
name|STRING_SIZE_SIZE
index|]
decl_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|strtab
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|last_file_index
operator|=
operator|-
literal|1
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sec_ptrs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|debug_merge_allocated
operator|=
name|false
expr_stmt|;
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|strtab
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|strtab
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|coff_debug_merge_hash_table_init
argument_list|(
operator|&
name|finfo
operator|.
name|debug_merge
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|debug_merge_allocated
operator|=
name|true
expr_stmt|;
comment|/* Compute the file positions for all the sections.  */
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
name|bfd_coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Count the line numbers and relocation entries required for the      output file.  Set the file positions for the relocs.  */
name|rel_filepos
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relsz
operator|=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_lineno_count
operator|=
literal|0
expr_stmt|;
name|max_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
condition|)
name|o
operator|->
name|lineno_count
operator|+=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
name|o
operator|->
name|reloc_count
operator|+=
name|sec
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|lineno_count
operator|>
name|max_lineno_count
condition|)
name|max_lineno_count
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_reloc_count
condition|)
name|max_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
operator|)
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
name|o
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|o
operator|->
name|rel_filepos
operator|=
name|rel_filepos
expr_stmt|;
name|rel_filepos
operator|+=
name|o
operator|->
name|reloc_count
operator|*
name|relsz
expr_stmt|;
block|}
block|}
comment|/* If doing a relocateable link, allocate space for the pointers we      need to keep.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We use section_count + 1, rather than section_count, because          the target_index fields are 1 based.  */
name|finfo
operator|.
name|section_info
operator|=
operator|(
operator|(
expr|struct
name|coff_link_section_info
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|abfd
operator|->
name|section_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_section_info
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* We now know the size of the relocs, so we can determine the file      positions of the line numbers.  */
name|line_filepos
operator|=
name|rel_filepos
expr_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|max_output_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|lineno_count
operator|==
literal|0
condition|)
name|o
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|o
operator|->
name|line_filepos
operator|=
name|line_filepos
expr_stmt|;
name|line_filepos
operator|+=
name|o
operator|->
name|lineno_count
operator|*
name|linesz
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
comment|/* We don't know the indices of global symbols until we have              written out all the local symbols.  For each section in              the output file, we keep an array of pointers to hash              table entries.  Each entry in the array corresponds to a              reloc.  When we find a reloc against a global symbol, we              set the corresponding entry in this array so that we can              fix up the symbol index after we have written out all the              local symbols.  	     Because of this problem, we also keep the relocs in 	     memory until the end of the link.  This wastes memory, 	     but only when doing a relocateable link, which is not the 	     common case.  */
name|BFD_ASSERT
argument_list|(
name|info
operator|->
name|relocateable
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|=
operator|(
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|=
operator|(
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_hash_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|==
name|NULL
operator|||
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
name|max_output_reloc_count
condition|)
name|max_output_reloc_count
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Reset the reloc and lineno counts, so that we can use them to 	 count the number of entries we have output so far.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
block|}
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|line_filepos
expr_stmt|;
comment|/* Figure out the largest number of symbols in an input BFD.  Take      the opportunity to clear the output_has_begun fields of all the      input BFD's.  */
name|max_sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|size_t
name|sz
decl_stmt|;
name|sub
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
name|sz
operator|=
name|obj_raw_syment_count
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sz
expr_stmt|;
block|}
comment|/* Allocate some buffers used while linking.  */
name|finfo
operator|.
name|internal_syms
operator|=
operator|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|sec_ptrs
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
operator|(
name|long
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|max_sym_count
operator|+
literal|1
operator|)
operator|*
name|symesz
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_lineno_count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_reloc_count
operator|*
name|relsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
name|finfo
operator|.
name|internal_relocs
operator|=
operator|(
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sec_ptrs
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sym_indices
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
name|finfo
operator|.
name|outsyms
operator|==
name|NULL
operator|||
operator|(
name|finfo
operator|.
name|linenos
operator|==
name|NULL
operator|&&
name|max_lineno_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
operator|&&
name|max_contents_size
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
operator|&&
name|max_reloc_count
operator|>
literal|0
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|finfo
operator|.
name|internal_relocs
operator|==
name|NULL
operator|&&
name|max_reloc_count
operator|>
literal|0
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* We now know the position of everything in the file, except that      we don't know the size of the symbol table and therefore we don't      know where the string table starts.  We just build the string      table in memory as we go along.  We process all the relocations      for a single input file at once.  */
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|coff_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|_bfd_coff_start_final_link
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_coff_start_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_coff_flavour
operator|)
condition|)
block|{
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
operator|&&
operator|!
name|ppc_do_last
argument_list|(
name|sub
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|_bfd_coff_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_reloc_link_order
argument_list|(
name|abfd
argument_list|,
operator|&
name|finfo
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
block|{
specifier|extern
name|bfd
modifier|*
name|ppc_get_last
parameter_list|()
function_decl|;
name|bfd
modifier|*
name|last_one
init|=
name|ppc_get_last
argument_list|()
decl_stmt|;
if|if
condition|(
name|last_one
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|last_one
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|last_one
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Free up the buffers used by _bfd_coff_link_input_bfd.  */
name|coff_debug_merge_hash_table_free
argument_list|(
operator|&
name|finfo
operator|.
name|debug_merge
argument_list|)
expr_stmt|;
name|debug_merge_allocated
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|sec_ptrs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|sec_ptrs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sec_ptrs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|sym_indices
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|sym_indices
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|linenos
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|linenos
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The value of the last C_FILE symbol is supposed to be the symbol      index of the first external symbol.  Write it out again if      necessary.  */
if|if
condition|(
name|finfo
operator|.
name|last_file_index
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|finfo
operator|.
name|last_file
operator|.
name|n_value
operator|!=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|finfo
operator|.
name|last_file
operator|.
name|n_value
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
operator|.
name|last_file
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|finfo
operator|.
name|last_file_index
operator|*
name|symesz
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|,
name|symesz
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symesz
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the global symbols.  */
name|finfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|coff_link_hash_traverse
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_coff_write_global_sym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|failed
condition|)
goto|goto
name|error_return
goto|;
comment|/* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
if|if
condition|(
name|finfo
operator|.
name|outsyms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* Now that we have written out all the global symbols, we know 	 the symbol indices to use for relocs against them, and we can 	 finally write out the relocs.  */
name|external_relocs
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_output_reloc_count
operator|*
name|relsz
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelend
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|irel
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
expr_stmt|;
name|erel
operator|=
name|external_relocs
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|rel_hash
operator|++
operator|,
name|erel
operator|+=
name|relsz
control|)
block|{
if|if
condition|(
operator|*
name|rel_hash
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
expr_stmt|;
block|}
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|irel
argument_list|,
operator|(
name|PTR
operator|)
name|erel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|external_relocs
argument_list|,
name|relsz
argument_list|,
name|o
operator|->
name|reloc_count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|relsz
operator|*
name|o
operator|->
name|reloc_count
condition|)
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
name|external_relocs
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free up the section information.  */
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|finfo
operator|.
name|section_info
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Write out the string table.  */
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|#
directive|if
name|STRING_SIZE_SIZE
operator|==
literal|4
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|_bfd_stringtab_size
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
operator|+
name|STRING_SIZE_SIZE
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|strbuf
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Change bfd_h_put_32
endif|#
directive|endif
if|if
condition|(
name|bfd_write
argument_list|(
name|strbuf
argument_list|,
literal|1
argument_list|,
name|STRING_SIZE_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|STRING_SIZE_SIZE
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|finfo
operator|.
name|strtab
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
expr_stmt|;
comment|/* Setting bfd_get_symcount to 0 will cause write_object_contents to      not try to write out the symbols.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|debug_merge_allocated
condition|)
name|coff_debug_merge_hash_table_free
argument_list|(
operator|&
name|finfo
operator|.
name|debug_merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|strtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|finfo
operator|.
name|section_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sec_ptrs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sec_ptrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sym_indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sym_indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|outsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|linenos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|linenos
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The transfer vectors that lead the outside world to all of the above. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_LITTLE_SYM
end_ifdef

begin_decl_stmt
specifier|const
name|bfd_target
name|TARGET_LITTLE_SYM
init|=
block|{
name|TARGET_LITTLE_NAME
block|,
comment|/* name or coff-arm-little */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* FIXME: object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen??? FIXMEmgo */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
comment|/* _bfd_dummy_target */
name|coff_object_p
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_BIG_SYM
end_ifdef

begin_decl_stmt
specifier|const
name|bfd_target
name|TARGET_BIG_SYM
init|=
block|{
name|TARGET_BIG_NAME
block|,
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* FIXME: object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen??? FIXMEmgo */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
comment|/* _bfd_dummy_target */
name|coff_object_p
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

