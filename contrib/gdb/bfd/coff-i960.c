begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Intel 960 COFF files.    Copyright (C) 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|I960
value|1
end_define

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|I960BADMAG(x)
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"coff/i960.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* to allow easier abstraction-breaking */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|optcall_callback
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_i960_relocate
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_i960_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_i960_start_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_i960_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_i960_adjust_symndx
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(3)
end_define

begin_comment
comment|/* The i960 does not support an MMU, so COFF_PAGE_SIZE can be    arbitrarily small.  */
end_comment

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|1
end_define

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_comment
comment|/* This is just like the usual CALC_ADDEND, but it includes the    section VMA for PC relative relocs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CALC_ADDEND
end_ifndef

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{                                                             \     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)                   \       coffsym = (obj_symbols (abfd)                             \                  + (cache_ptr->sym_ptr_ptr - symbols));         \     else if (ptr)                                               \       coffsym = coff_symbol_from (abfd, ptr);                   \     if (coffsym != (coff_symbol_type *) NULL                    \&& coffsym->native->u.syment.n_scnum == 0)              \       cache_ptr->addend = 0;                                    \     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd               \&& ptr->section != (asection *) NULL)              \       cache_ptr->addend = - (ptr->section->vma + ptr->value);   \     else                                                        \       cache_ptr->addend = 0;                                    \     if (ptr&& (reloc.r_type == 25 || reloc.r_type == 27))	\       cache_ptr->addend += asect->vma;				\   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CALLS
value|0x66003800
end_define

begin_comment
comment|/* Template for 'calls' instruction	*/
end_comment

begin_define
define|#
directive|define
name|BAL
value|0x0b000000
end_define

begin_comment
comment|/* Template for 'bal' instruction	*/
end_comment

begin_define
define|#
directive|define
name|BAL_MASK
value|0x00ffffff
end_define

begin_function
specifier|static
name|bfd_reloc_status_type
name|optcall_callback
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|ignore_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|ignore_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* This item has already been relocated correctly, but we may be    * able to patch in yet better code - done by digging out the    * correct info on this symbol */
name|bfd_reloc_status_type
name|result
decl_stmt|;
name|coff_symbol_type
modifier|*
name|cs
init|=
name|coffsymbol
argument_list|(
name|symbol_in
argument_list|)
decl_stmt|;
comment|/* Don't do anything with symbols which aren't tied up yet,      except move the reloc. */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|cs
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* So the target symbol has to be of coff type, and the symbol       has to have the correct native information within it */
if|if
condition|(
operator|(
name|bfd_asymbol_flavour
argument_list|(
operator|&
name|cs
operator|->
name|symbol
argument_list|)
operator|!=
name|bfd_target_coff_flavour
operator|)
operator|||
operator|(
name|cs
operator|->
name|native
operator|==
operator|(
name|combined_entry_type
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
comment|/* This is interesting, consider the case where we're outputting coff 	 from a mix n match input, linking from coff to a symbol defined in a 	 bout file will cause this match to be true. Should I complain?  This 	 will only work if the bout symbol is non leaf.  */
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
literal|"uncertain calling convention for non-COFF symbol"
expr_stmt|;
name|result
operator|=
name|bfd_reloc_dangerous
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_LEAFEXT
case|:
comment|/* This is a call to a leaf procedure, replace instruction with a bal 	   to the correct location.  */
block|{
name|union
name|internal_auxent
modifier|*
name|aux
init|=
operator|&
operator|(
operator|(
name|cs
operator|->
name|native
operator|+
literal|2
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
decl_stmt|;
name|int
name|olf
init|=
operator|(
name|aux
operator|->
name|x_bal
operator|.
name|x_balntry
operator|-
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* We replace the original call instruction with a bal to 	     the bal entry point - the offset of which is described in 	     the 2nd auxent of the original symbol. We keep the native 	     sym and auxents untouched, so the delta between the two 	     is the offset of the bal entry point.  */
name|word
operator|=
operator|(
operator|(
name|word
operator|+
name|olf
operator|)
operator|&
name|BAL_MASK
operator|)
operator||
name|BAL
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|word
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
case|case
name|C_SCALL
case|:
comment|/* This is a call to a system call, replace with a calls to # */
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* i960 COFF is used by VxWorks 5.1.  However, VxWorks 5.1 does not    appear to correctly handle a reloc against a symbol defined in the    same object file.  It appears to simply discard such relocs, rather    than adding their values into the object file.  We handle this here    by converting all relocs against defined symbols into relocs    against the section symbol, when generating a relocateable output    file.     Note that this function is only called if we are not using the COFF    specific backend linker.  It only does something when doing a    relocateable link, which will almost certainly fail when not    generating COFF i960 output, so this function is actually no longer    useful.  It was used before this target was converted to use the    COFF specific backend linker.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_i960_relocate
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|==
name|NULL
condition|)
block|{
comment|/* Not generating relocateable output file.  */
return|return
name|bfd_reloc_continue
return|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Symbol is not defined, so no need to worry about it.  */
return|return
name|bfd_reloc_continue
return|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* I don't really know what the right action is for a common          symbol.  */
return|return
name|bfd_reloc_continue
return|;
block|}
comment|/* Convert the reloc to use the section symbol.  FIXME: This method      is ridiculous.  */
name|osec
operator|=
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
operator|->
name|tdata
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|coff_section_data
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
operator|->
name|tdata
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sec_name
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|,
modifier|*
modifier|*
name|sym_end
decl_stmt|;
name|sec_name
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
expr_stmt|;
name|syms
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym_end
operator|=
name|syms
operator|+
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|syms
operator|<
name|sym_end
condition|;
name|syms
operator|++
control|)
block|{
if|if
condition|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|syms
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|syms
operator|)
operator|->
name|value
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|syms
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|name
argument_list|,
name|sec_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|syms
operator|>=
name|sym_end
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|=
name|syms
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|osec
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|osec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_overflow
return|;
block|}
name|coff_section_data
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|syms
expr_stmt|;
block|}
comment|/* Let bfd_perform_relocation do its thing, which will include      stuffing the symbol addend into the object file.  */
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_rellong
init|=
name|HOWTO
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|R_RELLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_i960_relocate
argument_list|,
literal|"rellong"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_iprmed
init|=
name|HOWTO
argument_list|(
name|R_IPRMED
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_i960_relocate
argument_list|,
literal|"iprmed "
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_optcall
init|=
name|HOWTO
argument_list|(
name|R_OPTCALL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|optcall_callback
argument_list|,
literal|"optcall"
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_i960_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|BFD_RELOC_I960_CALLJ
case|:
return|return
operator|&
name|howto_optcall
return|;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|howto_rellong
return|;
case|case
name|BFD_RELOC_24_PCREL
case|:
return|return
operator|&
name|howto_iprmed
return|;
block|}
block|}
end_function

begin_comment
comment|/* The real code is in coffcode.h */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
define|\
value|{							\    reloc_howto_type *howto_ptr;				\    switch ((dst)->r_type) {				\      case 17: howto_ptr =&howto_rellong; break;	\      case 25: howto_ptr =&howto_iprmed; break;		\      case 27: howto_ptr =&howto_optcall; break;	\      default: howto_ptr = 0; break;			\      }							\    (cache_ptr)->howto = howto_ptr;			\  }
end_define

begin_comment
comment|/* i960 COFF is used by VxWorks 5.1.  However, VxWorks 5.1 does not    appear to correctly handle a reloc against a symbol defined in the    same object file.  It appears to simply discard such relocs, rather    than adding their values into the object file.  We handle this by    converting all relocs against global symbols into relocs against    internal symbols at the start of the section.  This routine is    called at the start of the linking process, and it creates the    necessary symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_i960_start_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd_size_type
name|symesz
init|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symesz
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|strncpy
argument_list|(
name|isym
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|o
operator|->
name|name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|isym
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|n_scnum
operator|=
name|o
operator|->
name|target_index
expr_stmt|;
name|isym
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
name|isym
operator|.
name|n_numaux
operator|=
literal|0
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|esym
argument_list|,
name|symesz
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symesz
condition|)
block|{
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The reloc processing routine for the optimized COFF linker.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_i960_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
init|=
name|bfd_reloc_ok
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
else|else
name|addend
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rel
operator|->
name|r_type
condition|)
block|{
case|case
literal|17
case|:
name|howto
operator|=
operator|&
name|howto_rellong
expr_stmt|;
break|break;
case|case
literal|25
case|:
name|howto
operator|=
operator|&
name|howto_iprmed
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|howto
operator|=
operator|&
name|howto_optcall
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|done
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|type
operator|==
name|R_OPTCALL
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|symndx
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|class
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|class
operator|=
name|h
operator|->
name|class
expr_stmt|;
else|else
name|class
operator|=
name|sym
operator|->
name|n_sclass
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_NULL
case|:
comment|/* This symbol is apparently not from a COFF input file.                  We warn, and then assume that it is not a leaf                  function.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
literal|"uncertain calling convention for non-COFF symbol"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_LEAFEXT
case|:
comment|/* This is a call to a leaf procedure; use the bal                  instruction.  */
block|{
name|long
name|olf
decl_stmt|;
name|unsigned
name|long
name|word
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|numaux
operator|==
literal|2
argument_list|)
expr_stmt|;
name|olf
operator|=
name|h
operator|->
name|aux
index|[
literal|1
index|]
operator|.
name|x_bal
operator|.
name|x_balntry
expr_stmt|;
block|}
else|else
block|{
name|bfd_byte
modifier|*
name|esyms
decl_stmt|;
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sym
operator|->
name|n_numaux
operator|==
literal|2
argument_list|)
expr_stmt|;
name|esyms
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esyms
operator|+=
operator|(
name|symndx
operator|+
literal|2
operator|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|esyms
argument_list|,
name|sym
operator|->
name|n_type
argument_list|,
name|sym
operator|->
name|n_sclass
argument_list|,
literal|1
argument_list|,
name|sym
operator|->
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
name|olf
operator|=
name|aux
operator|.
name|x_bal
operator|.
name|x_balntry
expr_stmt|;
block|}
name|word
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|contents
operator|+
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|)
argument_list|)
expr_stmt|;
name|word
operator|=
operator|(
operator|(
name|word
operator|+
name|olf
operator|-
name|val
operator|)
operator|&
name|BAL_MASK
operator|)
operator||
name|BAL
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|word
argument_list|,
operator|(
name|contents
operator|+
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|)
argument_list|)
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|C_SCALL
case|:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|addend
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
name|rstat
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|val
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust the symbol index of any reloc against a global symbol to    instead be a reloc against the internal symbol we created specially    for the section.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|coff_i960_adjust_symndx
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|,
name|ibfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|adjustedp
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|boolean
modifier|*
name|adjustedp
decl_stmt|;
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
operator|*
name|adjustedp
operator|=
name|false
expr_stmt|;
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|ibfd
argument_list|)
index|[
name|irel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
condition|)
return|return
name|true
return|;
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|target_index
operator|-
literal|1
expr_stmt|;
operator|*
name|adjustedp
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_start_final_link
value|coff_i960_start_final_link
end_define

begin_define
define|#
directive|define
name|coff_relocate_section
value|coff_i960_relocate_section
end_define

begin_define
define|#
directive|define
name|coff_adjust_symndx
value|coff_i960_adjust_symndx
end_define

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|coff_i960_reloc_type_lookup
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_decl_stmt
specifier|const
name|bfd_target
name|icoff_little_vec
init|=
block|{
literal|"coff-Intel-little"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|'_'
block|,
comment|/* leading underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|icoff_big_vec
init|=
block|{
literal|"coff-Intel-big"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|'_'
block|,
comment|/* leading underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

end_unit

