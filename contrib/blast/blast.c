begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* blast.c  * Copyright (C) 2003, 2012 Mark Adler  * For conditions of distribution and use, see copyright notice in blast.h  * version 1.2, 24 Oct 2012  *  * blast.c decompresses data compressed by the PKWare Compression Library.  * This function provides functionality similar to the explode() function of  * the PKWare library, hence the name "blast".  *  * This decompressor is based on the excellent format description provided by  * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the  * example Ben provided in the post is incorrect.  The distance 110001 should  * instead be 111000.  When corrected, the example byte stream becomes:  *  *    00 04 82 24 25 8f 80 7f  *  * which decompresses to "AIAIAIAIAIAIA" (without the quotes).  */
end_comment

begin_comment
comment|/*  * Change history:  *  * 1.0  12 Feb 2003     - First version  * 1.1  16 Feb 2003     - Fixed distance check for> 4 GB uncompressed data  * 1.2  24 Oct 2012     - Add note about using binary mode in stdio  *                      - Fix comparisons of differently signed integers  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* for setjmp(), longjmp(), and jmp_buf */
end_comment

begin_include
include|#
directive|include
file|"blast.h"
end_include

begin_comment
comment|/* prototype for blast() */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* for local function definitions */
end_comment

begin_define
define|#
directive|define
name|MAXBITS
value|13
end_define

begin_comment
comment|/* maximum code length */
end_comment

begin_define
define|#
directive|define
name|MAXWIN
value|4096
end_define

begin_comment
comment|/* maximum window size */
end_comment

begin_comment
comment|/* input and output state */
end_comment

begin_struct
struct|struct
name|state
block|{
comment|/* input state */
name|blast_in
name|infun
decl_stmt|;
comment|/* input function provided by user */
name|void
modifier|*
name|inhow
decl_stmt|;
comment|/* opaque information passed to infun() */
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
comment|/* next input location */
name|unsigned
name|left
decl_stmt|;
comment|/* available input at in */
name|int
name|bitbuf
decl_stmt|;
comment|/* bit buffer */
name|int
name|bitcnt
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* input limit error return state for bits() and decode() */
name|jmp_buf
name|env
decl_stmt|;
comment|/* output state */
name|blast_out
name|outfun
decl_stmt|;
comment|/* output function provided by user */
name|void
modifier|*
name|outhow
decl_stmt|;
comment|/* opaque information passed to outfun() */
name|unsigned
name|next
decl_stmt|;
comment|/* index of next write location in out[] */
name|int
name|first
decl_stmt|;
comment|/* true to check distances (for first 4K) */
name|unsigned
name|char
name|out
index|[
name|MAXWIN
index|]
decl_stmt|;
comment|/* output buffer and sliding window */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return need bits from the input stream.  This always leaves less than  * eight bits in the buffer.  bits() works properly for need == 0.  *  * Format notes:  *  * - Bits are stored in bytes from the least significant bit to the most  *   significant bit.  Therefore bits are dropped from the bottom of the bit  *   buffer, using shift right, and new bytes are appended to the top of the  *   bit buffer, using shift left.  */
end_comment

begin_function
name|local
name|int
name|bits
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|,
name|int
name|need
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
comment|/* bit accumulator */
comment|/* load at least need bits into val */
name|val
operator|=
name|s
operator|->
name|bitbuf
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|bitcnt
operator|<
name|need
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|left
operator|=
name|s
operator|->
name|infun
argument_list|(
name|s
operator|->
name|inhow
argument_list|,
operator|&
operator|(
name|s
operator|->
name|in
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|left
operator|==
literal|0
condition|)
name|longjmp
argument_list|(
name|s
operator|->
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* out of input */
block|}
name|val
operator||=
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|s
operator|->
name|in
operator|)
operator|++
argument_list|)
operator|<<
name|s
operator|->
name|bitcnt
expr_stmt|;
comment|/* load eight bits */
name|s
operator|->
name|left
operator|--
expr_stmt|;
name|s
operator|->
name|bitcnt
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* drop need bits and update buffer, always zero to seven bits left */
name|s
operator|->
name|bitbuf
operator|=
name|val
operator|>>
name|need
expr_stmt|;
name|s
operator|->
name|bitcnt
operator|-=
name|need
expr_stmt|;
comment|/* return need bits, zeroing the bits above that */
return|return
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|need
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of  * each length, which for a canonical code are stepped through in order.  * symbol[] are the symbol values in canonical order, where the number of  * entries is the sum of the counts in count[].  The decoding process can be  * seen in the function decode() below.  */
end_comment

begin_struct
struct|struct
name|huffman
block|{
name|short
modifier|*
name|count
decl_stmt|;
comment|/* number of symbols of each length */
name|short
modifier|*
name|symbol
decl_stmt|;
comment|/* canonically ordered symbols */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Decode a code from the stream s using huffman table h.  Return the symbol or  * a negative value if there is an error.  If all of the lengths are zero, i.e.  * an empty code, or if the code is incomplete and an invalid code is received,  * then -9 is returned after reading MAXBITS bits.  *  * Format notes:  *  * - The codes as stored in the compressed data are bit-reversed relative to  *   a simple integer ordering of codes of the same lengths.  Hence below the  *   bits are pulled from the compressed data one at a time and used to  *   build the code value reversed from what is in the stream in order to  *   permit simple integer comparisons for decoding.  *  * - The first code for the shortest length is all ones.  Subsequent codes of  *   the same length are simply integer decrements of the previous code.  When  *   moving up a length, a one bit is appended to the code.  For a complete  *   code, the last code of the longest length will be all zeros.  To support  *   this ordering, the bits pulled during decoding are inverted to apply the  *   more "natural" ordering starting with all zeros and incrementing.  */
end_comment

begin_function
name|local
name|int
name|decode
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|,
name|struct
name|huffman
modifier|*
name|h
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* current number of bits in code */
name|int
name|code
decl_stmt|;
comment|/* len bits being decoded */
name|int
name|first
decl_stmt|;
comment|/* first code of length len */
name|int
name|count
decl_stmt|;
comment|/* number of codes of length len */
name|int
name|index
decl_stmt|;
comment|/* index of first code of length len in symbol table */
name|int
name|bitbuf
decl_stmt|;
comment|/* bits from stream */
name|int
name|left
decl_stmt|;
comment|/* bits left in next or left to process */
name|short
modifier|*
name|next
decl_stmt|;
comment|/* next number of codes */
name|bitbuf
operator|=
name|s
operator|->
name|bitbuf
expr_stmt|;
name|left
operator|=
name|s
operator|->
name|bitcnt
expr_stmt|;
name|code
operator|=
name|first
operator|=
name|index
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|h
operator|->
name|count
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|left
operator|--
condition|)
block|{
name|code
operator||=
operator|(
name|bitbuf
operator|&
literal|1
operator|)
operator|^
literal|1
expr_stmt|;
comment|/* invert code */
name|bitbuf
operator|>>=
literal|1
expr_stmt|;
name|count
operator|=
operator|*
name|next
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|<
name|first
operator|+
name|count
condition|)
block|{
comment|/* if length len, return symbol */
name|s
operator|->
name|bitbuf
operator|=
name|bitbuf
expr_stmt|;
name|s
operator|->
name|bitcnt
operator|=
operator|(
name|s
operator|->
name|bitcnt
operator|-
name|len
operator|)
operator|&
literal|7
expr_stmt|;
return|return
name|h
operator|->
name|symbol
index|[
name|index
operator|+
operator|(
name|code
operator|-
name|first
operator|)
index|]
return|;
block|}
name|index
operator|+=
name|count
expr_stmt|;
comment|/* else update for next length */
name|first
operator|+=
name|count
expr_stmt|;
name|first
operator|<<=
literal|1
expr_stmt|;
name|code
operator|<<=
literal|1
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|left
operator|=
operator|(
name|MAXBITS
operator|+
literal|1
operator|)
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|s
operator|->
name|left
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|left
operator|=
name|s
operator|->
name|infun
argument_list|(
name|s
operator|->
name|inhow
argument_list|,
operator|&
operator|(
name|s
operator|->
name|in
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|left
operator|==
literal|0
condition|)
name|longjmp
argument_list|(
name|s
operator|->
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* out of input */
block|}
name|bitbuf
operator|=
operator|*
operator|(
name|s
operator|->
name|in
operator|)
operator|++
expr_stmt|;
name|s
operator|->
name|left
operator|--
expr_stmt|;
if|if
condition|(
name|left
operator|>
literal|8
condition|)
name|left
operator|=
literal|8
expr_stmt|;
block|}
return|return
operator|-
literal|9
return|;
comment|/* ran out of codes */
block|}
end_function

begin_comment
comment|/*  * Given a list of repeated code lengths rep[0..n-1], where each byte is a  * count (high four bits + 1) and a code length (low four bits), generate the  * list of code lengths.  This compaction reduces the size of the object code.  * Then given the list of code lengths length[0..n-1] representing a canonical  * Huffman code for n symbols, construct the tables required to decode those  * codes.  Those tables are the number of codes of each length, and the symbols  * sorted by length, retaining their original order within each length.  The  * return value is zero for a complete code set, negative for an over-  * subscribed code set, and positive for an incomplete code set.  The tables  * can be used if the return value is zero or positive, but they cannot be used  * if the return value is negative.  If the return value is zero, it is not  * possible for decode() using that table to return an error--any stream of  * enough bits will resolve to a symbol.  If the return value is positive, then  * it is possible for decode() using that table to return an error for received  * codes past the end of the incomplete lengths.  */
end_comment

begin_function
name|local
name|int
name|construct
parameter_list|(
name|struct
name|huffman
modifier|*
name|h
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|rep
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|symbol
decl_stmt|;
comment|/* current symbol when stepping through length[] */
name|int
name|len
decl_stmt|;
comment|/* current length when stepping through h->count[] */
name|int
name|left
decl_stmt|;
comment|/* number of possible codes left of current length */
name|short
name|offs
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* offsets in symbol table for each length */
name|short
name|length
index|[
literal|256
index|]
decl_stmt|;
comment|/* code lengths */
comment|/* convert compact repeat counts into symbol bit length list */
name|symbol
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
operator|*
name|rep
operator|++
expr_stmt|;
name|left
operator|=
operator|(
name|len
operator|>>
literal|4
operator|)
operator|+
literal|1
expr_stmt|;
name|len
operator|&=
literal|15
expr_stmt|;
do|do
block|{
name|length
index|[
name|symbol
operator|++
index|]
operator|=
name|len
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|left
condition|)
do|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|n
operator|=
name|symbol
expr_stmt|;
comment|/* count number of codes of each length */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
name|h
operator|->
name|count
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<
name|n
condition|;
name|symbol
operator|++
control|)
operator|(
name|h
operator|->
name|count
index|[
name|length
index|[
name|symbol
index|]
index|]
operator|)
operator|++
expr_stmt|;
comment|/* assumes lengths are within bounds */
if|if
condition|(
name|h
operator|->
name|count
index|[
literal|0
index|]
operator|==
name|n
condition|)
comment|/* no codes! */
return|return
literal|0
return|;
comment|/* complete, but decode() will fail */
comment|/* check for an over-subscribed or incomplete set of lengths */
name|left
operator|=
literal|1
expr_stmt|;
comment|/* one possible code of zero length */
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
block|{
name|left
operator|<<=
literal|1
expr_stmt|;
comment|/* one more bit, double codes left */
name|left
operator|-=
name|h
operator|->
name|count
index|[
name|len
index|]
expr_stmt|;
comment|/* deduct count from possible codes */
if|if
condition|(
name|left
operator|<
literal|0
condition|)
return|return
name|left
return|;
comment|/* over-subscribed--return negative */
block|}
comment|/* left> 0 means incomplete */
comment|/* generate offsets into symbol table for each length for sorting */
name|offs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<
name|MAXBITS
condition|;
name|len
operator|++
control|)
name|offs
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|offs
index|[
name|len
index|]
operator|+
name|h
operator|->
name|count
index|[
name|len
index|]
expr_stmt|;
comment|/*      * put symbols in table sorted by length, by symbol order within each      * length      */
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<
name|n
condition|;
name|symbol
operator|++
control|)
if|if
condition|(
name|length
index|[
name|symbol
index|]
operator|!=
literal|0
condition|)
name|h
operator|->
name|symbol
index|[
name|offs
index|[
name|length
index|[
name|symbol
index|]
index|]
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
comment|/* return zero for complete set, positive for incomplete set */
return|return
name|left
return|;
block|}
end_function

begin_comment
comment|/*  * Decode PKWare Compression Library stream.  *  * Format notes:  *  * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second  *   byte is 4, 5, or 6 for the number of extra bits in the distance code.  *   This is the base-2 logarithm of the dictionary size minus six.  *  * - Compressed data is a combination of literals and length/distance pairs  *   terminated by an end code.  Literals are either Huffman coded or  *   uncoded bytes.  A length/distance pair is a coded length followed by a  *   coded distance to represent a string that occurs earlier in the  *   uncompressed data that occurs again at the current location.  *  * - A bit preceding a literal or length/distance pair indicates which comes  *   next, 0 for literals, 1 for length/distance.  *  * - If literals are uncoded, then the next eight bits are the literal, in the  *   normal bit order in th stream, i.e. no bit-reversal is needed. Similarly,  *   no bit reversal is needed for either the length extra bits or the distance  *   extra bits.  *  * - Literal bytes are simply written to the output.  A length/distance pair is  *   an instruction to copy previously uncompressed bytes to the output.  The  *   copy is from distance bytes back in the output stream, copying for length  *   bytes.  *  * - Distances pointing before the beginning of the output data are not  *   permitted.  *  * - Overlapped copies, where the length is greater than the distance, are  *   allowed and common.  For example, a distance of one and a length of 518  *   simply copies the last byte 518 times.  A distance of four and a length of  *   twelve copies the last four bytes three times.  A simple forward copy  *   ignoring whether the length is greater than the distance or not implements  *   this correctly.  */
end_comment

begin_function
name|local
name|int
name|decomp
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|)
block|{
name|int
name|lit
decl_stmt|;
comment|/* true if literals are coded */
name|int
name|dict
decl_stmt|;
comment|/* log2(dictionary size) - 6 */
name|int
name|symbol
decl_stmt|;
comment|/* decoded symbol, extra bits for distance */
name|int
name|len
decl_stmt|;
comment|/* length for copy */
name|unsigned
name|dist
decl_stmt|;
comment|/* distance for copy */
name|int
name|copy
decl_stmt|;
comment|/* copy counter */
name|unsigned
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
comment|/* copy pointers */
specifier|static
name|int
name|virgin
init|=
literal|1
decl_stmt|;
comment|/* build tables once */
specifier|static
name|short
name|litcnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|litsym
index|[
literal|256
index|]
decl_stmt|;
comment|/* litcode memory */
specifier|static
name|short
name|lencnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|lensym
index|[
literal|16
index|]
decl_stmt|;
comment|/* lencode memory */
specifier|static
name|short
name|distcnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|distsym
index|[
literal|64
index|]
decl_stmt|;
comment|/* distcode memory */
specifier|static
name|struct
name|huffman
name|litcode
init|=
block|{
name|litcnt
block|,
name|litsym
block|}
decl_stmt|;
comment|/* length code */
specifier|static
name|struct
name|huffman
name|lencode
init|=
block|{
name|lencnt
block|,
name|lensym
block|}
decl_stmt|;
comment|/* length code */
specifier|static
name|struct
name|huffman
name|distcode
init|=
block|{
name|distcnt
block|,
name|distsym
block|}
decl_stmt|;
comment|/* distance code */
comment|/* bit lengths of literal codes */
specifier|static
specifier|const
name|unsigned
name|char
name|litlen
index|[]
init|=
block|{
literal|11
block|,
literal|124
block|,
literal|8
block|,
literal|7
block|,
literal|28
block|,
literal|7
block|,
literal|188
block|,
literal|13
block|,
literal|76
block|,
literal|4
block|,
literal|10
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|12
block|,
literal|10
block|,
literal|8
block|,
literal|23
block|,
literal|8
block|,
literal|9
block|,
literal|7
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|55
block|,
literal|8
block|,
literal|23
block|,
literal|24
block|,
literal|12
block|,
literal|11
block|,
literal|7
block|,
literal|9
block|,
literal|11
block|,
literal|12
block|,
literal|6
block|,
literal|7
block|,
literal|22
block|,
literal|5
block|,
literal|7
block|,
literal|24
block|,
literal|6
block|,
literal|11
block|,
literal|9
block|,
literal|6
block|,
literal|7
block|,
literal|22
block|,
literal|7
block|,
literal|11
block|,
literal|38
block|,
literal|7
block|,
literal|9
block|,
literal|8
block|,
literal|25
block|,
literal|11
block|,
literal|8
block|,
literal|11
block|,
literal|9
block|,
literal|12
block|,
literal|8
block|,
literal|12
block|,
literal|5
block|,
literal|38
block|,
literal|5
block|,
literal|38
block|,
literal|5
block|,
literal|11
block|,
literal|7
block|,
literal|5
block|,
literal|6
block|,
literal|21
block|,
literal|6
block|,
literal|10
block|,
literal|53
block|,
literal|8
block|,
literal|7
block|,
literal|24
block|,
literal|10
block|,
literal|27
block|,
literal|44
block|,
literal|253
block|,
literal|253
block|,
literal|253
block|,
literal|252
block|,
literal|252
block|,
literal|252
block|,
literal|13
block|,
literal|12
block|,
literal|45
block|,
literal|12
block|,
literal|45
block|,
literal|12
block|,
literal|61
block|,
literal|12
block|,
literal|45
block|,
literal|44
block|,
literal|173
block|}
decl_stmt|;
comment|/* bit lengths of length codes 0..15 */
specifier|static
specifier|const
name|unsigned
name|char
name|lenlen
index|[]
init|=
block|{
literal|2
block|,
literal|35
block|,
literal|36
block|,
literal|53
block|,
literal|38
block|,
literal|23
block|}
decl_stmt|;
comment|/* bit lengths of distance codes 0..63 */
specifier|static
specifier|const
name|unsigned
name|char
name|distlen
index|[]
init|=
block|{
literal|2
block|,
literal|20
block|,
literal|53
block|,
literal|230
block|,
literal|247
block|,
literal|151
block|,
literal|248
block|}
decl_stmt|;
specifier|static
specifier|const
name|short
name|base
index|[
literal|16
index|]
init|=
block|{
comment|/* base for length codes */
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|40
block|,
literal|72
block|,
literal|136
block|,
literal|264
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
name|extra
index|[
literal|16
index|]
init|=
block|{
comment|/* extra bits for length codes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|}
decl_stmt|;
comment|/* set up decoding tables (once--might not be thread-safe) */
if|if
condition|(
name|virgin
condition|)
block|{
name|construct
argument_list|(
operator|&
name|litcode
argument_list|,
name|litlen
argument_list|,
sizeof|sizeof
argument_list|(
name|litlen
argument_list|)
argument_list|)
expr_stmt|;
name|construct
argument_list|(
operator|&
name|lencode
argument_list|,
name|lenlen
argument_list|,
sizeof|sizeof
argument_list|(
name|lenlen
argument_list|)
argument_list|)
expr_stmt|;
name|construct
argument_list|(
operator|&
name|distcode
argument_list|,
name|distlen
argument_list|,
sizeof|sizeof
argument_list|(
name|distlen
argument_list|)
argument_list|)
expr_stmt|;
name|virgin
operator|=
literal|0
expr_stmt|;
block|}
comment|/* read header */
name|lit
operator|=
name|bits
argument_list|(
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|lit
operator|>
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|dict
operator|=
name|bits
argument_list|(
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|<
literal|4
operator|||
name|dict
operator|>
literal|6
condition|)
return|return
operator|-
literal|2
return|;
comment|/* decode literals and length/distance pairs */
do|do
block|{
if|if
condition|(
name|bits
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* get length */
name|symbol
operator|=
name|decode
argument_list|(
name|s
argument_list|,
operator|&
name|lencode
argument_list|)
expr_stmt|;
name|len
operator|=
name|base
index|[
name|symbol
index|]
operator|+
name|bits
argument_list|(
name|s
argument_list|,
name|extra
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|519
condition|)
break|break;
comment|/* end code */
comment|/* get distance */
name|symbol
operator|=
name|len
operator|==
literal|2
condition|?
literal|2
else|:
name|dict
expr_stmt|;
name|dist
operator|=
name|decode
argument_list|(
name|s
argument_list|,
operator|&
name|distcode
argument_list|)
operator|<<
name|symbol
expr_stmt|;
name|dist
operator|+=
name|bits
argument_list|(
name|s
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|dist
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|first
operator|&&
name|dist
operator|>
name|s
operator|->
name|next
condition|)
return|return
operator|-
literal|3
return|;
comment|/* distance too far back */
comment|/* copy length bytes from distance bytes back */
do|do
block|{
name|to
operator|=
name|s
operator|->
name|out
operator|+
name|s
operator|->
name|next
expr_stmt|;
name|from
operator|=
name|to
operator|-
name|dist
expr_stmt|;
name|copy
operator|=
name|MAXWIN
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|next
operator|<
name|dist
condition|)
block|{
name|from
operator|+=
name|copy
expr_stmt|;
name|copy
operator|=
name|dist
expr_stmt|;
block|}
name|copy
operator|-=
name|s
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|len
condition|)
name|copy
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|copy
expr_stmt|;
name|s
operator|->
name|next
operator|+=
name|copy
expr_stmt|;
do|do
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|copy
condition|)
do|;
if|if
condition|(
name|s
operator|->
name|next
operator|==
name|MAXWIN
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|outfun
argument_list|(
name|s
operator|->
name|outhow
argument_list|,
name|s
operator|->
name|out
argument_list|,
name|s
operator|->
name|next
argument_list|)
condition|)
return|return
literal|1
return|;
name|s
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* get literal and write it */
name|symbol
operator|=
name|lit
condition|?
name|decode
argument_list|(
name|s
argument_list|,
operator|&
name|litcode
argument_list|)
else|:
name|bits
argument_list|(
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|s
operator|->
name|out
index|[
name|s
operator|->
name|next
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|next
operator|==
name|MAXWIN
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|outfun
argument_list|(
name|s
operator|->
name|outhow
argument_list|,
name|s
operator|->
name|out
argument_list|,
name|s
operator|->
name|next
argument_list|)
condition|)
return|return
literal|1
return|;
name|s
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See comments in blast.h */
end_comment

begin_function
name|int
name|blast
parameter_list|(
name|blast_in
name|infun
parameter_list|,
name|void
modifier|*
name|inhow
parameter_list|,
name|blast_out
name|outfun
parameter_list|,
name|void
modifier|*
name|outhow
parameter_list|)
block|{
name|struct
name|state
name|s
decl_stmt|;
comment|/* input/output state */
name|int
name|err
decl_stmt|;
comment|/* return value */
comment|/* initialize input state */
name|s
operator|.
name|infun
operator|=
name|infun
expr_stmt|;
name|s
operator|.
name|inhow
operator|=
name|inhow
expr_stmt|;
name|s
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|bitcnt
operator|=
literal|0
expr_stmt|;
comment|/* initialize output state */
name|s
operator|.
name|outfun
operator|=
name|outfun
expr_stmt|;
name|s
operator|.
name|outhow
operator|=
name|outhow
expr_stmt|;
name|s
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|first
operator|=
literal|1
expr_stmt|;
comment|/* return if bits() or decode() tries to read past available input */
if|if
condition|(
name|setjmp
argument_list|(
name|s
operator|.
name|env
argument_list|)
operator|!=
literal|0
condition|)
comment|/* if came back here via longjmp(), */
name|err
operator|=
literal|2
expr_stmt|;
comment|/*  then skip decomp(), return error */
else|else
name|err
operator|=
name|decomp
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* decompress */
comment|/* write any leftover output and update the error code if needed */
if|if
condition|(
name|err
operator|!=
literal|1
operator|&&
name|s
operator|.
name|next
operator|&&
name|s
operator|.
name|outfun
argument_list|(
name|s
operator|.
name|outhow
argument_list|,
name|s
operator|.
name|out
argument_list|,
name|s
operator|.
name|next
argument_list|)
operator|&&
name|err
operator|==
literal|0
condition|)
name|err
operator|=
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Example of how to use blast() */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_define
define|#
directive|define
name|CHUNK
value|16384
end_define

begin_function
name|local
name|unsigned
name|inf
parameter_list|(
name|void
modifier|*
name|how
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|hold
index|[
name|CHUNK
index|]
decl_stmt|;
operator|*
name|buf
operator|=
name|hold
expr_stmt|;
return|return
name|fread
argument_list|(
name|hold
argument_list|,
literal|1
argument_list|,
name|CHUNK
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|how
argument_list|)
return|;
block|}
end_function

begin_function
name|local
name|int
name|outf
parameter_list|(
name|void
modifier|*
name|how
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
return|return
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|how
argument_list|)
operator|!=
name|len
return|;
block|}
end_function

begin_comment
comment|/* Decompress a PKWare Compression Library stream from stdin to stdout */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|n
decl_stmt|;
comment|/* decompress to stdout */
name|ret
operator|=
name|blast
argument_list|(
name|inf
argument_list|,
name|stdin
argument_list|,
name|outf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"blast error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* see if there are any leftover bytes */
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getchar
argument_list|()
operator|!=
name|EOF
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"blast warning: %d unused bytes of input\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* return blast() error code */
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

