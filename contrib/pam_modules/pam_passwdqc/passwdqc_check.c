begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000,2001 by Solar Designer. See LICENSE.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"passwdqc.h"
end_include

begin_define
define|#
directive|define
name|REASON_ERROR
define|\
value|"check failed"
end_define

begin_define
define|#
directive|define
name|REASON_SAME
define|\
value|"is the same as the old one"
end_define

begin_define
define|#
directive|define
name|REASON_SIMILAR
define|\
value|"is based on the old one"
end_define

begin_define
define|#
directive|define
name|REASON_SHORT
define|\
value|"too short"
end_define

begin_define
define|#
directive|define
name|REASON_LONG
define|\
value|"too long"
end_define

begin_define
define|#
directive|define
name|REASON_SIMPLESHORT
define|\
value|"not enough different characters or classes for this length"
end_define

begin_define
define|#
directive|define
name|REASON_SIMPLE
define|\
value|"not enough different characters or classes"
end_define

begin_define
define|#
directive|define
name|REASON_PERSONAL
define|\
value|"based on personal login information"
end_define

begin_define
define|#
directive|define
name|REASON_WORD
define|\
value|"based on a dictionary word and not a passphrase"
end_define

begin_define
define|#
directive|define
name|FIXED_BITS
value|15
end_define

begin_typedef
typedef|typedef
name|unsigned
name|long
name|fixed
typedef|;
end_typedef

begin_comment
comment|/*  * Calculates the expected number of different characters for a random  * password of a given length. The result is rounded down. We use this  * with the _requested_ minimum length (so longer passwords don't have  * to meet this strict requirement for their length).  */
end_comment

begin_function
specifier|static
name|int
name|expected_different
parameter_list|(
name|int
name|charset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|fixed
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|x
operator|=
operator|(
call|(
name|fixed
call|)
argument_list|(
name|charset
operator|-
literal|1
argument_list|)
operator|<<
name|FIXED_BITS
operator|)
operator|/
name|charset
expr_stmt|;
name|y
operator|=
name|x
expr_stmt|;
while|while
condition|(
operator|--
name|length
operator|>
literal|0
condition|)
name|y
operator|=
operator|(
name|y
operator|*
name|x
operator|)
operator|>>
name|FIXED_BITS
expr_stmt|;
name|z
operator|=
operator|(
name|fixed
operator|)
name|charset
operator|*
operator|(
operator|(
operator|(
name|fixed
operator|)
literal|1
operator|<<
name|FIXED_BITS
operator|)
operator|-
name|y
operator|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|z
operator|>>
name|FIXED_BITS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * A password is too simple if it is too short for its class, or doesn't  * contain enough different characters for its class, or doesn't contain  * enough words for a passphrase.  */
end_comment

begin_function
specifier|static
name|int
name|is_simple
parameter_list|(
name|passwdqc_params_t
modifier|*
name|params
parameter_list|,
name|char
modifier|*
name|newpass
parameter_list|)
block|{
name|int
name|length
decl_stmt|,
name|classes
decl_stmt|,
name|words
decl_stmt|,
name|chars
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|lowers
decl_stmt|,
name|uppers
decl_stmt|,
name|others
decl_stmt|,
name|unknowns
decl_stmt|;
name|int
name|c
decl_stmt|,
name|p
decl_stmt|;
name|length
operator|=
name|classes
operator|=
name|words
operator|=
name|chars
operator|=
literal|0
expr_stmt|;
name|digits
operator|=
name|lowers
operator|=
name|uppers
operator|=
name|others
operator|=
name|unknowns
operator|=
literal|0
expr_stmt|;
name|p
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|newpass
index|[
name|length
index|]
operator|)
condition|)
block|{
name|length
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|unknowns
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|digits
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|lowers
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|uppers
operator|++
expr_stmt|;
else|else
name|others
operator|++
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|isascii
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|isalpha
argument_list|(
name|p
argument_list|)
condition|)
name|words
operator|++
expr_stmt|;
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
operator|&
name|newpass
index|[
name|length
index|]
argument_list|,
name|c
argument_list|)
condition|)
name|chars
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|length
condition|)
return|return
literal|1
return|;
comment|/* Upper case characters and digits used in common ways don't increase the  * strength of a password */
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|newpass
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|uppers
operator|&&
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|uppers
operator|--
expr_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|newpass
index|[
name|length
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|digits
operator|&&
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|digits
operator|--
expr_stmt|;
comment|/* Count the number of different character classes we've seen. We assume  * that there're no non-ASCII characters for digits. */
name|classes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digits
condition|)
name|classes
operator|++
expr_stmt|;
if|if
condition|(
name|lowers
condition|)
name|classes
operator|++
expr_stmt|;
if|if
condition|(
name|uppers
condition|)
name|classes
operator|++
expr_stmt|;
if|if
condition|(
name|others
condition|)
name|classes
operator|++
expr_stmt|;
if|if
condition|(
name|unknowns
operator|&&
operator|(
operator|!
name|classes
operator|||
operator|(
name|digits
operator|&&
name|classes
operator|==
literal|1
operator|)
operator|)
condition|)
name|classes
operator|++
expr_stmt|;
for|for
control|(
init|;
name|classes
operator|>
literal|0
condition|;
name|classes
operator|--
control|)
switch|switch
condition|(
name|classes
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|length
operator|>=
name|params
operator|->
name|min
index|[
literal|0
index|]
operator|&&
name|chars
operator|>=
name|expected_different
argument_list|(
literal|10
argument_list|,
name|params
operator|->
name|min
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
literal|2
case|:
if|if
condition|(
name|length
operator|>=
name|params
operator|->
name|min
index|[
literal|1
index|]
operator|&&
name|chars
operator|>=
name|expected_different
argument_list|(
literal|36
argument_list|,
name|params
operator|->
name|min
index|[
literal|1
index|]
argument_list|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|params
operator|->
name|passphrase_words
operator|||
name|words
operator|<
name|params
operator|->
name|passphrase_words
condition|)
continue|continue;
if|if
condition|(
name|length
operator|>=
name|params
operator|->
name|min
index|[
literal|2
index|]
operator|&&
name|chars
operator|>=
name|expected_different
argument_list|(
literal|27
argument_list|,
name|params
operator|->
name|min
index|[
literal|2
index|]
argument_list|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
continue|continue;
case|case
literal|3
case|:
if|if
condition|(
name|length
operator|>=
name|params
operator|->
name|min
index|[
literal|3
index|]
operator|&&
name|chars
operator|>=
name|expected_different
argument_list|(
literal|62
argument_list|,
name|params
operator|->
name|min
index|[
literal|3
index|]
argument_list|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
continue|continue;
case|case
literal|4
case|:
if|if
condition|(
name|length
operator|>=
name|params
operator|->
name|min
index|[
literal|4
index|]
operator|&&
name|chars
operator|>=
name|expected_different
argument_list|(
literal|95
argument_list|,
name|params
operator|->
name|min
index|[
literal|4
index|]
argument_list|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unify
parameter_list|(
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dst
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|sptr
operator|=
name|src
expr_stmt|;
name|dptr
operator|=
name|dst
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|sptr
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|dptr
operator|++
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
operator|*
name|dptr
operator|++
operator|=
operator|*
name|sptr
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sptr
operator|++
condition|)
do|;
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|reverse
parameter_list|(
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dst
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|sptr
operator|=
operator|&
name|src
index|[
name|strlen
argument_list|(
name|src
argument_list|)
index|]
expr_stmt|;
name|dptr
operator|=
name|dst
expr_stmt|;
while|while
condition|(
name|sptr
operator|>
name|src
condition|)
operator|*
name|dptr
operator|++
operator|=
operator|*
operator|--
name|sptr
expr_stmt|;
operator|*
name|dptr
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clean
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
name|dst
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Needle is based on haystack if both contain a long enough common  * substring and needle would be too simple for a password with the  * substring removed.  */
end_comment

begin_function
specifier|static
name|int
name|is_based
parameter_list|(
name|passwdqc_params_t
modifier|*
name|params
parameter_list|,
name|char
modifier|*
name|haystack
parameter_list|,
name|char
modifier|*
name|needle
parameter_list|,
name|char
modifier|*
name|original
parameter_list|)
block|{
name|char
modifier|*
name|scratch
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|match
decl_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|match_length
condition|)
comment|/* disabled */
return|return
literal|0
return|;
if|if
condition|(
name|params
operator|->
name|match_length
operator|<
literal|0
condition|)
comment|/* misconfigured */
return|return
literal|1
return|;
if|if
condition|(
name|strstr
argument_list|(
name|haystack
argument_list|,
name|needle
argument_list|)
condition|)
comment|/* based on haystack entirely */
return|return
literal|1
return|;
name|scratch
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|needle
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|length
operator|-
name|params
operator|->
name|match_length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|params
operator|->
name|match_length
init|;
name|i
operator|+
name|j
operator|<=
name|length
condition|;
name|j
operator|++
control|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|haystack
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|needle
index|[
name|i
index|]
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
operator|&
name|needle
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|scratch
operator|=
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|scratch
argument_list|,
name|original
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|scratch
index|[
name|i
index|]
argument_list|,
operator|&
name|original
index|[
name|i
operator|+
name|j
index|]
argument_list|,
name|length
operator|+
literal|1
operator|-
operator|(
name|i
operator|+
name|j
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_simple
argument_list|(
name|params
argument_list|,
name|scratch
argument_list|)
condition|)
block|{
name|clean
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
break|break;
block|}
name|clean
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This wordlist check is now the least important given the checks above  * and the support for passphrases (which are based on dictionary words,  * and checked by other means). It is still useful to trap simple short  * passwords (if short passwords are allowed) that are word-based, but  * passed the other checks due to uncommon capitalization, digits, and  * special characters. We (mis)use the same set of words that are used  * to generate random passwords. This list is much smaller than those  * used for password crackers, and it doesn't contain common passwords  * that aren't short English words. Perhaps support for large wordlists  * should still be added, even though this is now of little importance.  */
end_comment

begin_function
specifier|static
name|int
name|is_word_based
parameter_list|(
name|passwdqc_params_t
modifier|*
name|params
parameter_list|,
name|char
modifier|*
name|needle
parameter_list|,
name|char
modifier|*
name|original
parameter_list|)
block|{
name|char
name|word
index|[
literal|7
index|]
decl_stmt|;
name|char
modifier|*
name|unified
decl_stmt|;
name|int
name|index
decl_stmt|;
name|word
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|0x1000
condition|;
name|index
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|word
argument_list|,
name|_passwdqc_wordset_4k
index|[
name|index
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|<
name|params
operator|->
name|match_length
condition|)
continue|continue;
name|unified
operator|=
name|unify
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_based
argument_list|(
name|params
argument_list|,
name|unified
argument_list|,
name|needle
argument_list|,
name|original
argument_list|)
condition|)
block|{
name|clean
argument_list|(
name|unified
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|clean
argument_list|(
name|unified
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|_passwdqc_check
parameter_list|(
name|passwdqc_params_t
modifier|*
name|params
parameter_list|,
name|char
modifier|*
name|newpass
parameter_list|,
name|char
modifier|*
name|oldpass
parameter_list|,
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|char
name|truncated
index|[
literal|9
index|]
decl_stmt|,
modifier|*
name|reversed
decl_stmt|;
name|char
modifier|*
name|u_newpass
decl_stmt|,
modifier|*
name|u_reversed
decl_stmt|;
name|char
modifier|*
name|u_oldpass
decl_stmt|;
name|char
modifier|*
name|u_name
decl_stmt|,
modifier|*
name|u_gecos
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
name|int
name|length
decl_stmt|;
name|reversed
operator|=
name|NULL
expr_stmt|;
name|u_newpass
operator|=
name|u_reversed
operator|=
name|NULL
expr_stmt|;
name|u_oldpass
operator|=
name|NULL
expr_stmt|;
name|u_name
operator|=
name|u_gecos
operator|=
name|NULL
expr_stmt|;
name|reason
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|oldpass
operator|&&
operator|!
name|strcmp
argument_list|(
name|oldpass
argument_list|,
name|newpass
argument_list|)
condition|)
name|reason
operator|=
name|REASON_SAME
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|newpass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reason
operator|&&
name|length
operator|<
name|params
operator|->
name|min
index|[
literal|4
index|]
condition|)
name|reason
operator|=
name|REASON_SHORT
expr_stmt|;
if|if
condition|(
operator|!
name|reason
operator|&&
name|length
operator|>
name|params
operator|->
name|max
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|max
operator|==
literal|8
condition|)
block|{
name|truncated
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|truncated
argument_list|,
name|newpass
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|newpass
operator|=
name|truncated
expr_stmt|;
if|if
condition|(
name|oldpass
operator|&&
operator|!
name|strncmp
argument_list|(
name|oldpass
argument_list|,
name|newpass
argument_list|,
literal|8
argument_list|)
condition|)
name|reason
operator|=
name|REASON_SAME
expr_stmt|;
block|}
else|else
name|reason
operator|=
name|REASON_LONG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reason
operator|&&
name|is_simple
argument_list|(
name|params
argument_list|,
name|newpass
argument_list|)
condition|)
block|{
if|if
condition|(
name|length
operator|<
name|params
operator|->
name|min
index|[
literal|1
index|]
operator|&&
name|params
operator|->
name|min
index|[
literal|1
index|]
operator|<=
name|params
operator|->
name|max
condition|)
name|reason
operator|=
name|REASON_SIMPLESHORT
expr_stmt|;
else|else
name|reason
operator|=
name|REASON_SIMPLE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reason
condition|)
block|{
if|if
condition|(
operator|(
name|reversed
operator|=
name|reverse
argument_list|(
name|newpass
argument_list|)
operator|)
condition|)
block|{
name|u_newpass
operator|=
name|unify
argument_list|(
name|newpass
argument_list|)
expr_stmt|;
name|u_reversed
operator|=
name|unify
argument_list|(
name|reversed
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldpass
condition|)
name|u_oldpass
operator|=
name|unify
argument_list|(
name|oldpass
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
condition|)
block|{
name|u_name
operator|=
name|unify
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|u_gecos
operator|=
name|unify
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|reversed
operator|||
operator|!
name|u_newpass
operator|||
operator|!
name|u_reversed
operator|||
operator|(
name|oldpass
operator|&&
operator|!
name|u_oldpass
operator|)
operator|||
operator|(
name|pw
operator|&&
operator|(
operator|!
name|u_name
operator|||
operator|!
name|u_gecos
operator|)
operator|)
condition|)
name|reason
operator|=
name|REASON_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reason
operator|&&
name|oldpass
operator|&&
name|params
operator|->
name|similar_deny
operator|&&
operator|(
name|is_based
argument_list|(
name|params
argument_list|,
name|u_oldpass
argument_list|,
name|u_newpass
argument_list|,
name|newpass
argument_list|)
operator|||
name|is_based
argument_list|(
name|params
argument_list|,
name|u_oldpass
argument_list|,
name|u_reversed
argument_list|,
name|reversed
argument_list|)
operator|)
condition|)
name|reason
operator|=
name|REASON_SIMILAR
expr_stmt|;
if|if
condition|(
operator|!
name|reason
operator|&&
name|pw
operator|&&
operator|(
name|is_based
argument_list|(
name|params
argument_list|,
name|u_name
argument_list|,
name|u_newpass
argument_list|,
name|newpass
argument_list|)
operator|||
name|is_based
argument_list|(
name|params
argument_list|,
name|u_name
argument_list|,
name|u_reversed
argument_list|,
name|reversed
argument_list|)
operator|||
name|is_based
argument_list|(
name|params
argument_list|,
name|u_gecos
argument_list|,
name|u_newpass
argument_list|,
name|newpass
argument_list|)
operator|||
name|is_based
argument_list|(
name|params
argument_list|,
name|u_gecos
argument_list|,
name|u_reversed
argument_list|,
name|reversed
argument_list|)
operator|)
condition|)
name|reason
operator|=
name|REASON_PERSONAL
expr_stmt|;
if|if
condition|(
operator|!
name|reason
operator|&&
name|strlen
argument_list|(
name|newpass
argument_list|)
operator|<
name|params
operator|->
name|min
index|[
literal|2
index|]
operator|&&
operator|(
name|is_word_based
argument_list|(
name|params
argument_list|,
name|u_newpass
argument_list|,
name|newpass
argument_list|)
operator|||
name|is_word_based
argument_list|(
name|params
argument_list|,
name|u_reversed
argument_list|,
name|reversed
argument_list|)
operator|)
condition|)
name|reason
operator|=
name|REASON_WORD
expr_stmt|;
name|memset
argument_list|(
name|truncated
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|truncated
argument_list|)
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|reversed
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|u_newpass
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|u_reversed
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|u_oldpass
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|u_name
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|u_gecos
argument_list|)
expr_stmt|;
return|return
name|reason
return|;
block|}
end_function

end_unit

