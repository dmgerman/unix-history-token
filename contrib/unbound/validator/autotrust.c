begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/autotrust.c - RFC5011 trust anchor management for unbound.  *  * Copyright (c) 2009, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * Contains autotrust implementation. The implementation was taken from   * the autotrust daemon (BSD licensed), written by Matthijs Mekking.  * It was modified to fit into unbound. The state table process is the same.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"validator/autotrust.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_utils.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_sigcrypt.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"services/mesh.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kcache.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"sldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|"sldns/str2wire.h"
end_include

begin_include
include|#
directive|include
file|"sldns/keyraw.h"
end_include

begin_include
include|#
directive|include
file|"sldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/** number of times a key must be seen before it can become valid */
end_comment

begin_define
define|#
directive|define
name|MIN_PENDINGCOUNT
value|2
end_define

begin_comment
comment|/** Event: Revoked */
end_comment

begin_function_decl
specifier|static
name|void
name|do_revoked
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|autr_global_data
modifier|*
name|autr_global_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|autr_global_data
modifier|*
name|global
decl_stmt|;
name|global
operator|=
operator|(
expr|struct
name|autr_global_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|global
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|global
condition|)
return|return
name|NULL
return|;
name|rbtree_init
argument_list|(
operator|&
name|global
operator|->
name|probe
argument_list|,
operator|&
name|probetree_cmp
argument_list|)
expr_stmt|;
return|return
name|global
return|;
block|}
end_function

begin_function
name|void
name|autr_global_delete
parameter_list|(
name|struct
name|autr_global_data
modifier|*
name|global
parameter_list|)
block|{
if|if
condition|(
operator|!
name|global
condition|)
return|return;
comment|/* elements deleted by parent */
name|memset
argument_list|(
name|global
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|global
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|global
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|probetree_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|a
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|x
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|b
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|y
decl_stmt|;
name|log_assert
argument_list|(
name|a
operator|->
name|autr
operator|&&
name|b
operator|->
name|autr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|autr
operator|->
name|next_probe_time
operator|<
name|b
operator|->
name|autr
operator|->
name|next_probe_time
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|autr
operator|->
name|next_probe_time
operator|>
name|b
operator|->
name|autr
operator|->
name|next_probe_time
condition|)
return|return
literal|1
return|;
comment|/* time is equal, sort on trust point identity */
return|return
name|anchor_cmp
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|autr_get_num_anchors
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|size_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|anchors
condition|)
return|return
literal|0
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchors
operator|->
name|autr
condition|)
name|res
operator|=
name|anchors
operator|->
name|autr
operator|->
name|probe
operator|.
name|count
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/** Position in string */
end_comment

begin_function
specifier|static
name|int
name|position_in_string
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|sub
parameter_list|)
block|{
name|char
modifier|*
name|pos
init|=
name|strstr
argument_list|(
name|str
argument_list|,
name|sub
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|str
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|sub
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Debug routine to print pretty key information */
end_comment

begin_function_decl
specifier|static
name|void
name|verbose_key
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|enum
name|verbosity_value
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**   * Implementation of debug pretty key print   * @param ta: trust anchor key with DNSKEY data.  * @param level: verbosity level to print at.  * @param format: printf style format string.  */
end_comment

begin_function
specifier|static
name|void
name|verbose_key
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|enum
name|verbosity_value
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|level
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|sldns_wire2str_dname
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
decl_stmt|;
name|int
name|keytag
init|=
operator|(
name|int
operator|)
name|sldns_calc_keytag_raw
argument_list|(
name|sldns_wirerr_get_rdata
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatalen
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|msg
index|[
name|MAXSYSLOGMSGLEN
index|]
decl_stmt|;
name|vsnprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|level
argument_list|,
literal|"%s key %d %s"
argument_list|,
name|str
condition|?
name|str
else|:
literal|"??"
argument_list|,
name|keytag
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Parse comments   * @param str: to parse  * @param ta: trust key autotrust metadata  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|parse_comments
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|)
block|{
name|int
name|len
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|,
name|timestamp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|comment
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|comments
init|=
name|comment
decl_stmt|;
if|if
condition|(
operator|!
name|comment
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in parse"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* skip over whitespace and data at start of line */
while|while
condition|(
operator|*
name|str
operator|!=
literal|'\0'
operator|&&
operator|*
name|str
operator|!=
literal|';'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|';'
condition|)
name|str
operator|++
expr_stmt|;
comment|/* copy comments */
while|while
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|comments
operator|=
operator|*
name|str
expr_stmt|;
name|comments
operator|++
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|comments
operator|=
literal|'\0'
expr_stmt|;
name|comments
operator|=
name|comment
expr_stmt|;
comment|/* read state */
name|pos
operator|=
name|position_in_string
argument_list|(
name|comments
argument_list|,
literal|"state="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|comments
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pos
operator|<=
literal|0
condition|)
name|ta
operator|->
name|s
operator|=
name|AUTR_STATE_VALID
expr_stmt|;
else|else
block|{
name|int
name|s
init|=
operator|(
name|int
operator|)
name|comments
index|[
name|pos
index|]
operator|-
literal|'0'
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|AUTR_STATE_START
case|:
case|case
name|AUTR_STATE_ADDPEND
case|:
case|case
name|AUTR_STATE_VALID
case|:
case|case
name|AUTR_STATE_MISSING
case|:
case|case
name|AUTR_STATE_REVOKED
case|:
case|case
name|AUTR_STATE_REMOVED
case|:
name|ta
operator|->
name|s
operator|=
name|s
expr_stmt|;
break|break;
default|default:
name|verbose_key
argument_list|(
name|ta
argument_list|,
name|VERB_OPS
argument_list|,
literal|"has undefined "
literal|"state, considered NewKey"
argument_list|)
expr_stmt|;
name|ta
operator|->
name|s
operator|=
name|AUTR_STATE_START
expr_stmt|;
break|break;
block|}
block|}
comment|/* read pending count */
name|pos
operator|=
name|position_in_string
argument_list|(
name|comments
argument_list|,
literal|"count="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|comments
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pos
operator|<=
literal|0
condition|)
name|ta
operator|->
name|pending_count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|comments
operator|+=
name|pos
expr_stmt|;
name|ta
operator|->
name|pending_count
operator|=
operator|(
name|uint8_t
operator|)
name|atoi
argument_list|(
name|comments
argument_list|)
expr_stmt|;
block|}
comment|/* read last change */
name|pos
operator|=
name|position_in_string
argument_list|(
name|comments
argument_list|,
literal|"lastchange="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|comments
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|comments
operator|+=
name|pos
expr_stmt|;
name|timestamp
operator|=
name|atoi
argument_list|(
name|comments
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
operator|!
name|timestamp
condition|)
name|ta
operator|->
name|last_change
operator|=
literal|0
expr_stmt|;
else|else
name|ta
operator|->
name|last_change
operator|=
operator|(
name|time_t
operator|)
name|timestamp
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Check if a line contains data (besides comments) */
end_comment

begin_function
specifier|static
name|int
name|str_contains_data
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
name|comment
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|comment
operator|||
operator|*
name|str
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|' '
operator|&&
operator|*
name|str
operator|!=
literal|'\t'
condition|)
return|return
literal|1
return|;
name|str
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Get DNSKEY flags  * rdata without rdatalen in front of it. */
end_comment

begin_function
specifier|static
name|int
name|dnskey_flags
parameter_list|(
name|uint16_t
name|t
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint16_t
name|f
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|memmove
argument_list|(
operator|&
name|f
argument_list|,
name|rdata
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|f
operator|=
name|ntohs
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|f
return|;
block|}
end_function

begin_comment
comment|/** Check if KSK DNSKEY.  * pass rdata without rdatalen in front of it */
end_comment

begin_function
specifier|static
name|int
name|rr_is_dnskey_sep
parameter_list|(
name|uint16_t
name|t
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|dnskey_flags
argument_list|(
name|t
argument_list|,
name|rdata
argument_list|,
name|len
argument_list|)
operator|&
name|DNSKEY_BIT_SEP
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Check if TA is KSK DNSKEY */
end_comment

begin_function
specifier|static
name|int
name|ta_is_dnskey_sep
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|)
block|{
return|return
operator|(
name|dnskey_flags
argument_list|(
name|sldns_wirerr_get_type
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdata
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatalen
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|)
operator|&
name|DNSKEY_BIT_SEP
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Check if REVOKED DNSKEY  * pass rdata without rdatalen in front of it */
end_comment

begin_function
specifier|static
name|int
name|rr_is_dnskey_revoked
parameter_list|(
name|uint16_t
name|t
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|dnskey_flags
argument_list|(
name|t
argument_list|,
name|rdata
argument_list|,
name|len
argument_list|)
operator|&
name|LDNS_KEY_REVOKE_KEY
operator|)
return|;
block|}
end_function

begin_comment
comment|/** create ta */
end_comment

begin_function
specifier|static
name|struct
name|autr_ta
modifier|*
name|autr_ta_create
parameter_list|(
name|uint8_t
modifier|*
name|rr
parameter_list|,
name|size_t
name|rr_len
parameter_list|,
name|size_t
name|dname_len
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
init|=
operator|(
expr|struct
name|autr_ta
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ta
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
block|{
name|free
argument_list|(
name|rr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ta
operator|->
name|rr
operator|=
name|rr
expr_stmt|;
name|ta
operator|->
name|rr_len
operator|=
name|rr_len
expr_stmt|;
name|ta
operator|->
name|dname_len
operator|=
name|dname_len
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/** create tp */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|autr_tp_create
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|own
parameter_list|,
name|size_t
name|own_len
parameter_list|,
name|uint16_t
name|dc
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|NULL
return|;
name|tp
operator|->
name|name
operator|=
name|memdup
argument_list|(
name|own
argument_list|,
name|own_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tp
operator|->
name|namelen
operator|=
name|own_len
expr_stmt|;
name|tp
operator|->
name|namelabs
operator|=
name|dname_count_labels
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tp
operator|->
name|node
operator|.
name|key
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|dclass
operator|=
name|dc
expr_stmt|;
name|tp
operator|->
name|autr
operator|=
operator|(
expr|struct
name|autr_point_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
operator|->
name|autr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|autr
condition|)
block|{
name|free
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tp
operator|->
name|autr
operator|->
name|pnode
operator|.
name|key
operator|=
name|tp
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|tp
operator|->
name|node
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"trust anchor presented twice"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
operator|->
name|autr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
operator|&
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
operator|&
name|tp
operator|->
name|autr
operator|->
name|pnode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"trust anchor in probetree twice"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
operator|->
name|autr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_init
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|,
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|,
name|tp
operator|->
name|autr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
operator|->
name|autr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/** delete assembled rrsets */
end_comment

begin_function
specifier|static
name|void
name|autr_rrset_delete
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
condition|)
block|{
name|free
argument_list|(
name|r
operator|->
name|rk
operator|.
name|dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|entry
operator|.
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|autr_point_delete
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return;
name|lock_unprotect
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|lock_unprotect
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|,
name|tp
operator|->
name|autr
argument_list|)
expr_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|autr_rrset_delete
argument_list|(
name|tp
operator|->
name|ds_rrset
argument_list|)
expr_stmt|;
name|autr_rrset_delete
argument_list|(
name|tp
operator|->
name|dnskey_rrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|autr
condition|)
block|{
name|struct
name|autr_ta
modifier|*
name|p
init|=
name|tp
operator|->
name|autr
operator|->
name|keys
decl_stmt|,
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|rr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|free
argument_list|(
name|tp
operator|->
name|autr
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
operator|->
name|autr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** find or add a new trust point for autotrust */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|find_add_tp
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|rr
parameter_list|,
name|size_t
name|rr_len
parameter_list|,
name|size_t
name|dname_len
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|anchor_find
argument_list|(
name|anchors
argument_list|,
name|rr
argument_list|,
name|dname_count_labels
argument_list|(
name|rr
argument_list|)
argument_list|,
name|dname_len
argument_list|,
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
if|if
condition|(
operator|!
name|tp
operator|->
name|autr
condition|)
block|{
name|log_err
argument_list|(
literal|"anchor cannot be with and without autotrust"
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|tp
return|;
block|}
name|tp
operator|=
name|autr_tp_create
argument_list|(
name|anchors
argument_list|,
name|rr
argument_list|,
name|dname_len
argument_list|,
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|NULL
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/** Add trust anchor from RR */
end_comment

begin_function
specifier|static
name|struct
name|autr_ta
modifier|*
name|add_trustanchor_frm_rr
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|rr
parameter_list|,
name|size_t
name|rr_len
parameter_list|,
name|size_t
name|dname_len
parameter_list|,
name|struct
name|trust_anchor
modifier|*
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
init|=
name|autr_ta_create
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
return|return
name|NULL
return|;
operator|*
name|tp
operator|=
name|find_add_tp
argument_list|(
name|anchors
argument_list|,
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|tp
condition|)
block|{
name|free
argument_list|(
name|ta
operator|->
name|rr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ta
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* add ta to tp */
name|ta
operator|->
name|next
operator|=
operator|(
operator|*
name|tp
operator|)
operator|->
name|autr
operator|->
name|keys
expr_stmt|;
operator|(
operator|*
name|tp
operator|)
operator|->
name|autr
operator|->
name|keys
operator|=
name|ta
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
operator|(
operator|*
name|tp
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/**  * Add new trust anchor from a string in file.  * @param anchors: all anchors  * @param str: string with anchor and comments, if any comments.  * @param tp: trust point returned.  * @param origin: what to use for @  * @param origin_len: length of origin  * @param prev: previous rr name  * @param prev_len: length of prev  * @param skip: if true, the result is NULL, but not an error, skip it.  * @return new key in trust point.  */
end_comment

begin_function
specifier|static
name|struct
name|autr_ta
modifier|*
name|add_trustanchor_frm_str
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|trust_anchor
modifier|*
modifier|*
name|tp
parameter_list|,
name|uint8_t
modifier|*
name|origin
parameter_list|,
name|size_t
name|origin_len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|prev_len
parameter_list|,
name|int
modifier|*
name|skip
parameter_list|)
block|{
name|uint8_t
name|rr
index|[
name|LDNS_RR_BUF_SIZE
index|]
decl_stmt|;
name|size_t
name|rr_len
init|=
sizeof|sizeof
argument_list|(
name|rr
argument_list|)
decl_stmt|,
name|dname_len
decl_stmt|;
name|uint8_t
modifier|*
name|drr
decl_stmt|;
name|int
name|lstatus
decl_stmt|;
if|if
condition|(
operator|!
name|str_contains_data
argument_list|(
name|str
argument_list|,
literal|';'
argument_list|)
condition|)
block|{
operator|*
name|skip
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
comment|/* empty line */
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|lstatus
operator|=
name|sldns_str2wire_rr_buf
argument_list|(
name|str
argument_list|,
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|,
literal|0
argument_list|,
name|origin
argument_list|,
name|origin_len
argument_list|,
operator|*
name|prev
argument_list|,
operator|*
name|prev_len
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"ldns error while converting string to RR at%d: %s: %s"
argument_list|,
name|LDNS_WIREPARSE_OFFSET
argument_list|(
name|lstatus
argument_list|)
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|lstatus
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|memdup
argument_list|(
name|rr
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
operator|*
name|prev_len
operator|=
name|dname_len
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|prev
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in add_trustanchor"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DNSKEY
operator|&&
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DS
condition|)
block|{
operator|*
name|skip
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
comment|/* only DS and DNSKEY allowed */
block|}
name|drr
operator|=
name|memdup
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drr
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in add trustanchor"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|add_trustanchor_frm_rr
argument_list|(
name|anchors
argument_list|,
name|drr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|,
name|tp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * Load single anchor   * @param anchors: all points.  * @param str: comments line  * @param fname: filename  * @param origin: the $ORIGIN.  * @param origin_len: length of origin  * @param prev: passed to ldns.  * @param prev_len: length of prev  * @param skip: if true, the result is NULL, but not an error, skip it.  * @return false on failure, otherwise the tp read.  */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|load_trustanchor
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|uint8_t
modifier|*
name|origin
parameter_list|,
name|size_t
name|origin_len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|prev_len
parameter_list|,
name|int
modifier|*
name|skip
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
init|=
name|NULL
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|ta
operator|=
name|add_trustanchor_frm_str
argument_list|(
name|anchors
argument_list|,
name|str
argument_list|,
operator|&
name|tp
argument_list|,
name|origin
argument_list|,
name|origin_len
argument_list|,
name|prev
argument_list|,
name|prev_len
argument_list|,
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
return|return
name|NULL
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_comments
argument_list|(
name|str
argument_list|,
name|ta
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|autr
operator|->
name|file
condition|)
block|{
name|tp
operator|->
name|autr
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|autr
operator|->
name|file
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/** iterator for DSes from keylist. return true if a next element exists */
end_comment

begin_function
specifier|static
name|int
name|assemble_iterate_ds
parameter_list|(
name|struct
name|autr_ta
modifier|*
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rr
parameter_list|,
name|size_t
modifier|*
name|rr_len
parameter_list|,
name|size_t
modifier|*
name|dname_len
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|rr
argument_list|,
operator|(
operator|*
name|list
operator|)
operator|->
name|rr_len
argument_list|,
operator|(
operator|*
name|list
operator|)
operator|->
name|dname_len
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
condition|)
block|{
operator|*
name|rr
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|rr
expr_stmt|;
operator|*
name|rr_len
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|rr_len
expr_stmt|;
operator|*
name|dname_len
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|dname_len
expr_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** iterator for DNSKEYs from keylist. return true if a next element exists */
end_comment

begin_function
specifier|static
name|int
name|assemble_iterate_dnskey
parameter_list|(
name|struct
name|autr_ta
modifier|*
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rr
parameter_list|,
name|size_t
modifier|*
name|rr_len
parameter_list|,
name|size_t
modifier|*
name|dname_len
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|rr
argument_list|,
operator|(
operator|*
name|list
operator|)
operator|->
name|rr_len
argument_list|,
operator|(
operator|*
name|list
operator|)
operator|->
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
operator|(
operator|(
operator|*
name|list
operator|)
operator|->
name|s
operator|==
name|AUTR_STATE_VALID
operator|||
operator|(
operator|*
name|list
operator|)
operator|->
name|s
operator|==
name|AUTR_STATE_MISSING
operator|)
condition|)
block|{
operator|*
name|rr
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|rr
expr_stmt|;
operator|*
name|rr_len
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|rr_len
expr_stmt|;
operator|*
name|dname_len
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|dname_len
expr_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** see if iterator-list has any elements in it, or it is empty */
end_comment

begin_function
specifier|static
name|int
name|assemble_iterate_hasfirst
parameter_list|(
name|int
name|iter
parameter_list|(
name|struct
name|autr_ta
modifier|*
modifier|*
parameter_list|,
name|uint8_t
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|list
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rr
init|=
name|NULL
decl_stmt|;
name|size_t
name|rr_len
init|=
literal|0
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
return|return
name|iter
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** number of elements in iterator list */
end_comment

begin_function
specifier|static
name|size_t
name|assemble_iterate_count
parameter_list|(
name|int
name|iter
parameter_list|(
name|struct
name|autr_ta
modifier|*
modifier|*
parameter_list|,
name|uint8_t
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|list
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rr
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|,
name|rr_len
init|=
literal|0
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/**  * Create a ub_packed_rrset_key allocated on the heap.  * It therefore does not have the correct ID value, and cannot be used  * inside the cache.  It can be used in storage outside of the cache.  * Keys for the cache have to be obtained from alloc.h .  * @param iter: iterator over the elements in the list.  It filters elements.  * @param list: the list.  * @return key allocated or NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|ub_packed_rrset_heap_key
parameter_list|(
name|int
name|iter
parameter_list|(
name|struct
name|autr_ta
modifier|*
modifier|*
parameter_list|,
name|uint8_t
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|list
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rr
init|=
name|NULL
decl_stmt|;
name|size_t
name|rr_len
init|=
literal|0
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|iter
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|)
condition|)
return|return
name|NULL
return|;
name|k
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
return|return
name|NULL
return|;
name|k
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|dname_len
expr_stmt|;
name|k
operator|->
name|rk
operator|.
name|dname
operator|=
name|memdup
argument_list|(
name|rr
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/**  * Create packed_rrset data on the heap.  * @param iter: iterator over the elements in the list.  It filters elements.  * @param list: the list.  * @return data allocated or NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|packed_rrset_data
modifier|*
name|packed_rrset_heap_data
parameter_list|(
name|int
name|iter
parameter_list|(
name|struct
name|autr_ta
modifier|*
modifier|*
parameter_list|,
name|uint8_t
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|list
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rr
init|=
name|NULL
decl_stmt|;
name|size_t
name|rr_len
init|=
literal|0
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|data
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|,
name|rrsig_count
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|total
decl_stmt|;
name|uint8_t
modifier|*
name|nextrdata
decl_stmt|;
name|struct
name|autr_ta
modifier|*
name|list_i
decl_stmt|;
name|time_t
name|ttl
init|=
literal|0
decl_stmt|;
name|list_i
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|iter
argument_list|(
operator|&
name|list_i
argument_list|,
operator|&
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
operator|==
name|LDNS_RR_TYPE_RRSIG
condition|)
name|rrsig_count
operator|++
expr_stmt|;
else|else
name|count
operator|++
expr_stmt|;
comment|/* sizeof the rdlength + rdatalen */
name|len
operator|+=
literal|2
operator|+
name|sldns_wirerr_get_rdatalen
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
name|ttl
operator|=
operator|(
name|time_t
operator|)
name|sldns_wirerr_get_ttl
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|rrsig_count
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* allocate */
name|total
operator|=
name|count
operator|+
name|rrsig_count
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|+
name|total
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
comment|/* fill it */
name|data
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|data
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|data
operator|->
name|rrsig_count
operator|=
name|rrsig_count
expr_stmt|;
name|data
operator|->
name|rr_len
operator|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|)
expr_stmt|;
name|data
operator|->
name|rr_data
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|rr_len
index|[
name|total
index|]
operator|)
expr_stmt|;
name|data
operator|->
name|rr_ttl
operator|=
operator|(
name|time_t
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|rr_data
index|[
name|total
index|]
operator|)
expr_stmt|;
name|nextrdata
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|rr_ttl
index|[
name|total
index|]
operator|)
expr_stmt|;
comment|/* fill out len, ttl, fields */
name|list_i
operator|=
name|list
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|iter
argument_list|(
operator|&
name|list_i
argument_list|,
operator|&
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|)
condition|)
block|{
name|data
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
operator|(
name|time_t
operator|)
name|sldns_wirerr_get_ttl
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|<
name|data
operator|->
name|ttl
condition|)
name|data
operator|->
name|ttl
operator|=
name|data
operator|->
name|rr_ttl
index|[
name|i
index|]
expr_stmt|;
name|data
operator|->
name|rr_len
index|[
name|i
index|]
operator|=
literal|2
comment|/* the rdlength */
operator|+
name|sldns_wirerr_get_rdatalen
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* fixup rest of ptrs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|->
name|rr_data
index|[
name|i
index|]
operator|=
name|nextrdata
expr_stmt|;
name|nextrdata
operator|+=
name|data
operator|->
name|rr_len
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* copy data in there */
name|list_i
operator|=
name|list
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|iter
argument_list|(
operator|&
name|list_i
argument_list|,
operator|&
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
name|data
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|sldns_wirerr_get_rdatawl
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|,
name|data
operator|->
name|rr_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|rrsig_count
operator|&&
name|data
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|count
operator|=
name|data
operator|->
name|rrsig_count
expr_stmt|;
comment|/* rrset type is RRSIG */
name|data
operator|->
name|rrsig_count
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  * Assemble the trust anchors into DS and DNSKEY packed rrsets.  * Uses only VALID and MISSING DNSKEYs.  * Read the sldns_rrs and builds packed rrsets  * @param tp: the trust point. Must be locked.  * @return false on malloc failure.  */
end_comment

begin_function
specifier|static
name|int
name|autr_assemble
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|ubds
init|=
name|NULL
decl_stmt|,
modifier|*
name|ubdnskey
init|=
name|NULL
decl_stmt|;
comment|/* make packed rrset keys - malloced with no ID number, they 	 * are not in the cache */
comment|/* make packed rrset data (if there is a key) */
if|if
condition|(
name|assemble_iterate_hasfirst
argument_list|(
name|assemble_iterate_ds
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
condition|)
block|{
name|ubds
operator|=
name|ub_packed_rrset_heap_key
argument_list|(
name|assemble_iterate_ds
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ubds
condition|)
goto|goto
name|error_cleanup
goto|;
name|ubds
operator|->
name|entry
operator|.
name|data
operator|=
name|packed_rrset_heap_data
argument_list|(
name|assemble_iterate_ds
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ubds
operator|->
name|entry
operator|.
name|data
condition|)
goto|goto
name|error_cleanup
goto|;
block|}
comment|/* make packed DNSKEY data */
if|if
condition|(
name|assemble_iterate_hasfirst
argument_list|(
name|assemble_iterate_dnskey
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
condition|)
block|{
name|ubdnskey
operator|=
name|ub_packed_rrset_heap_key
argument_list|(
name|assemble_iterate_dnskey
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ubdnskey
condition|)
goto|goto
name|error_cleanup
goto|;
name|ubdnskey
operator|->
name|entry
operator|.
name|data
operator|=
name|packed_rrset_heap_data
argument_list|(
name|assemble_iterate_dnskey
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ubdnskey
operator|->
name|entry
operator|.
name|data
condition|)
block|{
name|error_cleanup
label|:
name|autr_rrset_delete
argument_list|(
name|ubds
argument_list|)
expr_stmt|;
name|autr_rrset_delete
argument_list|(
name|ubdnskey
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* we have prepared the new keys so nothing can go wrong any more. 	 * And we are sure we cannot be left without trustanchor after 	 * any errors. Put in the new keys and remove old ones. */
comment|/* free the old data */
name|autr_rrset_delete
argument_list|(
name|tp
operator|->
name|ds_rrset
argument_list|)
expr_stmt|;
name|autr_rrset_delete
argument_list|(
name|tp
operator|->
name|dnskey_rrset
argument_list|)
expr_stmt|;
comment|/* assign the data to replace the old */
name|tp
operator|->
name|ds_rrset
operator|=
name|ubds
expr_stmt|;
name|tp
operator|->
name|dnskey_rrset
operator|=
name|ubdnskey
expr_stmt|;
name|tp
operator|->
name|numDS
operator|=
name|assemble_iterate_count
argument_list|(
name|assemble_iterate_ds
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
expr_stmt|;
name|tp
operator|->
name|numDNSKEY
operator|=
name|assemble_iterate_count
argument_list|(
name|assemble_iterate_dnskey
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|keys
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** parse integer */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|parse_int
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
name|x
init|=
operator|(
name|unsigned
name|int
operator|)
name|strtol
argument_list|(
name|line
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|e
condition|)
block|{
operator|*
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* parse error */
return|return
literal|0
return|;
block|}
operator|*
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* matched */
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/** parse id sequence for anchor */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|parse_id
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|uint16_t
name|dclass
decl_stmt|;
name|uint8_t
modifier|*
name|dname
decl_stmt|;
name|size_t
name|dname_len
decl_stmt|;
comment|/* read the owner name */
name|char
modifier|*
name|next
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
return|return
name|NULL
return|;
name|next
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|sldns_str2wire_dname
argument_list|(
name|line
argument_list|,
operator|&
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname
condition|)
return|return
name|NULL
return|;
comment|/* read the class */
name|dclass
operator|=
name|parse_int
argument_list|(
name|next
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* find the trust point */
name|tp
operator|=
name|autr_tp_create
argument_list|(
name|anchors
argument_list|,
name|dname
argument_list|,
name|dname_len
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/**   * Parse variable from trustanchor header   * @param line: to parse  * @param anchors: the anchor is added to this, if "id:" is seen.  * @param anchor: the anchor as result value or previously returned anchor  * 	value to read the variable lines into.  * @return: 0 no match, -1 failed syntax error, +1 success line read.  * 	+2 revoked trust anchor file.  */
end_comment

begin_function
specifier|static
name|int
name|parse_var_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|struct
name|trust_anchor
modifier|*
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
init|=
operator|*
name|anchor
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;id: "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|anchor
operator|=
name|parse_id
argument_list|(
name|anchors
argument_list|,
name|line
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|anchor
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;REVOKED"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
condition|)
block|{
name|log_err
argument_list|(
literal|"REVOKED statement must be at start of file"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;last_queried: "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|-
literal|1
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|last_queried
operator|=
operator|(
name|time_t
operator|)
name|parse_int
argument_list|(
name|line
operator|+
literal|16
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;last_success: "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|-
literal|1
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|last_success
operator|=
operator|(
name|time_t
operator|)
name|parse_int
argument_list|(
name|line
operator|+
literal|16
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;next_probe_time: "
argument_list|,
literal|19
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|-
literal|1
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|=
operator|(
name|time_t
operator|)
name|parse_int
argument_list|(
name|line
operator|+
literal|19
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
operator|&
name|tp
operator|->
name|autr
operator|->
name|pnode
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;query_failed: "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|-
literal|1
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|query_failed
operator|=
operator|(
name|uint8_t
operator|)
name|parse_int
argument_list|(
name|line
operator|+
literal|16
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;query_interval: "
argument_list|,
literal|18
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|-
literal|1
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|query_interval
operator|=
operator|(
name|time_t
operator|)
name|parse_int
argument_list|(
name|line
operator|+
literal|18
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;retry_time: "
argument_list|,
literal|14
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|-
literal|1
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|retry_time
operator|=
operator|(
name|time_t
operator|)
name|parse_int
argument_list|(
name|line
operator|+
literal|14
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** handle origin lines */
end_comment

begin_function
specifier|static
name|int
name|handle_origin
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|origin
parameter_list|,
name|size_t
modifier|*
name|origin_len
parameter_list|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"$ORIGIN"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|free
argument_list|(
operator|*
name|origin
argument_list|)
expr_stmt|;
name|line
operator|+=
literal|7
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
operator|*
name|origin
operator|=
name|sldns_str2wire_dname
argument_list|(
name|line
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
operator|*
name|origin_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|origin
condition|)
name|log_warn
argument_list|(
literal|"malloc failure or parse error in $ORIGIN"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Read one line and put multiline RRs onto one line string */
end_comment

begin_function
specifier|static
name|int
name|read_multiline
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|int
modifier|*
name|linenr
parameter_list|)
block|{
name|char
modifier|*
name|pos
init|=
name|buf
decl_stmt|;
name|size_t
name|left
init|=
name|len
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
operator|&&
name|fgets
argument_list|(
name|pos
argument_list|,
operator|(
name|int
operator|)
name|left
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|i
decl_stmt|,
name|poslen
init|=
name|strlen
argument_list|(
name|pos
argument_list|)
decl_stmt|;
operator|(
operator|*
name|linenr
operator|)
operator|++
expr_stmt|;
comment|/* check what the new depth is after the line */
comment|/* this routine cannot handle braces inside quotes, 		   say for TXT records, but this routine only has to read keys */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poslen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pos
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
index|[
name|i
index|]
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"mismatch: too many ')'"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|depth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
index|[
name|i
index|]
operator|==
literal|';'
condition|)
block|{
break|break;
block|}
block|}
comment|/* normal oneline or last line: keeps newline and comments */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* more lines expected, snip off comments and newline */
if|if
condition|(
name|poslen
operator|>
literal|0
condition|)
name|pos
index|[
name|poslen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* strip newline */
if|if
condition|(
name|strchr
argument_list|(
name|pos
argument_list|,
literal|';'
argument_list|)
condition|)
name|strchr
argument_list|(
name|pos
argument_list|,
literal|';'
argument_list|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* strip comments */
comment|/* move to paste other lines behind this one */
name|poslen
operator|=
name|strlen
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|poslen
expr_stmt|;
name|left
operator|-=
name|poslen
expr_stmt|;
comment|/* the newline is changed into a space */
if|if
condition|(
name|left
operator|<=
literal|2
comment|/* space and eos */
condition|)
block|{
name|log_err
argument_list|(
literal|"line too long"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|pos
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pos
operator|+=
literal|1
expr_stmt|;
name|left
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"mismatch: too many '('"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pos
operator|!=
name|buf
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|autr_read_file
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|)
block|{
comment|/* the file descriptor */
name|FILE
modifier|*
name|fd
decl_stmt|;
comment|/* keep track of line numbers */
name|int
name|line_nr
init|=
literal|0
decl_stmt|;
comment|/* single line */
name|char
name|line
index|[
literal|10240
index|]
decl_stmt|;
comment|/* trust point being read */
name|struct
name|trust_anchor
modifier|*
name|tp
init|=
name|NULL
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* for $ORIGIN parsing */
name|uint8_t
modifier|*
name|origin
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|size_t
name|origin_len
init|=
literal|0
decl_stmt|,
name|prev_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|nm
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"unable to open %s for reading: %s"
argument_list|,
name|nm
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"reading autotrust anchor file %s"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|read_multiline
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fd
argument_list|,
operator|&
name|line_nr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|||
operator|(
name|r
operator|=
name|parse_var_line
argument_list|(
name|line
argument_list|,
name|anchors
argument_list|,
operator|&
name|tp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"could not parse auto-trust-anchor-file "
literal|"%s line %d"
argument_list|,
name|nm
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|1
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|2
condition|)
block|{
name|log_warn
argument_list|(
literal|"trust anchor %s has been revoked"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|str_contains_data
argument_list|(
name|line
argument_list|,
literal|';'
argument_list|)
condition|)
continue|continue;
comment|/* empty lines allowed */
if|if
condition|(
name|handle_origin
argument_list|(
name|line
argument_list|,
operator|&
name|origin
argument_list|,
operator|&
name|origin_len
argument_list|)
condition|)
continue|continue;
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp2
operator|=
name|load_trustanchor
argument_list|(
name|anchors
argument_list|,
name|line
argument_list|,
name|nm
argument_list|,
name|origin
argument_list|,
name|origin_len
argument_list|,
operator|&
name|prev
argument_list|,
operator|&
name|prev_len
argument_list|,
operator|&
name|r
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|r
condition|)
name|log_err
argument_list|(
literal|"failed to load trust anchor from %s "
literal|"at line %i, skipping"
argument_list|,
name|nm
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
comment|/* try to do the rest */
continue|continue;
block|}
if|if
condition|(
name|tp
operator|&&
name|tp
operator|!=
name|tp2
condition|)
block|{
name|log_err
argument_list|(
literal|"file %s has mismatching data inside: "
literal|"the file may only contain keys for one name, "
literal|"remove keys for other domain names"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tp
operator|=
name|tp2
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
block|{
name|log_err
argument_list|(
literal|"failed to read %s"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* now assemble the data into DNSKEY and DS packed rrsets */
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autr_assemble
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"malloc failure assembling %s"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** string for a trustanchor state */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|trustanchor_state2str
parameter_list|(
name|autr_state_t
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|AUTR_STATE_START
case|:
return|return
literal|"  START  "
return|;
case|case
name|AUTR_STATE_ADDPEND
case|:
return|return
literal|" ADDPEND "
return|;
case|case
name|AUTR_STATE_VALID
case|:
return|return
literal|"  VALID  "
return|;
case|case
name|AUTR_STATE_MISSING
case|:
return|return
literal|" MISSING "
return|;
case|case
name|AUTR_STATE_REVOKED
case|:
return|return
literal|" REVOKED "
return|;
case|case
name|AUTR_STATE_REMOVED
case|:
return|return
literal|" REMOVED "
return|;
block|}
return|return
literal|" UNKNOWN "
return|;
block|}
end_function

begin_comment
comment|/** print ID to file */
end_comment

begin_function
specifier|static
name|int
name|print_id
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|sldns_wire2str_dname
argument_list|(
name|nm
argument_list|,
name|nmlen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in write to %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;id: %s %d\n"
argument_list|,
name|s
argument_list|,
operator|(
name|int
operator|)
name|dclass
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not write to %s: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autr_write_contents
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|char
name|tmi
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|autr_ta
modifier|*
name|ta
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
comment|/* write pretty header */
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"; autotrust trust anchor file\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not write to %s: %s"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|autr
operator|->
name|revoked
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;REVOKED\n"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"; The zone has all keys revoked, and is\n"
literal|"; considered as if it has no trust anchors.\n"
literal|"; the remainder of the file is the last probe.\n"
literal|"; to restart the trust anchor, overwrite this file.\n"
literal|"; with one containing valid DNSKEYs or DSes.\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not write to %s: %s"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|print_id
argument_list|(
name|out
argument_list|,
name|fn
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
operator|->
name|namelen
argument_list|,
name|tp
operator|->
name|dclass
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;last_queried: %u ;;%s"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|last_queried
argument_list|,
name|ctime_r
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|autr
operator|->
name|last_queried
operator|)
argument_list|,
name|tmi
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;last_success: %u ;;%s"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|last_success
argument_list|,
name|ctime_r
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|autr
operator|->
name|last_success
operator|)
argument_list|,
name|tmi
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;next_probe_time: %u ;;%s"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
argument_list|,
name|ctime_r
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|)
argument_list|,
name|tmi
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;query_failed: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|query_failed
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;query_interval: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|query_interval
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|out
argument_list|,
literal|";;retry_time: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|retry_time
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not write to %s: %s"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* write anchors */
for|for
control|(
name|ta
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|ta
condition|;
name|ta
operator|=
name|ta
operator|->
name|next
control|)
block|{
comment|/* by default do not store START and REMOVED keys */
if|if
condition|(
name|ta
operator|->
name|s
operator|==
name|AUTR_STATE_START
condition|)
continue|continue;
if|if
condition|(
name|ta
operator|->
name|s
operator|==
name|AUTR_STATE_REMOVED
condition|)
continue|continue;
comment|/* only store keys */
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
continue|continue;
name|str
operator|=
name|sldns_wire2str_rr
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
operator|!
name|str
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"malloc failure writing %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s ;;state=%d [%s] ;;count=%d "
literal|";;lastchange=%u ;;%s"
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|ta
operator|->
name|s
argument_list|,
name|trustanchor_state2str
argument_list|(
name|ta
operator|->
name|s
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ta
operator|->
name|pending_count
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ta
operator|->
name|last_change
argument_list|,
name|ctime_r
argument_list|(
operator|&
operator|(
name|ta
operator|->
name|last_change
operator|)
argument_list|,
name|tmi
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not write to %s: %s"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|autr_write_file
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|fname
init|=
name|tp
operator|->
name|autr
operator|->
name|file
decl_stmt|;
name|char
name|tempf
index|[
literal|2048
index|]
decl_stmt|;
name|log_assert
argument_list|(
name|tp
operator|->
name|autr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
block|{
name|log_err
argument_list|(
literal|"autr_write_file: Module environment is NULL."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* unique name with pid number and thread number */
name|snprintf
argument_list|(
name|tempf
argument_list|,
sizeof|sizeof
argument_list|(
name|tempf
argument_list|)
argument_list|,
literal|"%s.%d-%d"
argument_list|,
name|fname
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|env
operator|->
name|worker
condition|?
operator|*
operator|(
name|int
operator|*
operator|)
name|env
operator|->
name|worker
else|:
literal|0
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: write to disk: %s"
argument_list|,
name|tempf
argument_list|)
expr_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|tempf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"could not open autotrust file for writing, %s: %s"
argument_list|,
name|tempf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|autr_write_contents
argument_list|(
name|out
argument_list|,
name|tempf
argument_list|,
name|tp
argument_list|)
condition|)
block|{
comment|/* failed to write contents (completely) */
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempf
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"could not completely write: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|out
argument_list|)
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"could not fflush(%s): %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FSYNC
if|if
condition|(
name|fsync
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"could not fsync(%s): %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FlushFileBuffers
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|_fileno
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fclose
argument_list|(
name|out
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"could not complete write: %s: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* success; overwrite actual file */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: replaced %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* windows does not replace file with rename() */
endif|#
directive|endif
if|if
condition|(
name|rename
argument_list|(
name|tempf
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"rename(%s to %s): %s"
argument_list|,
name|tempf
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**   * Verify if dnskey works for trust point   * @param env: environment (with time) for verification  * @param ve: validator environment (with options) for verification.  * @param tp: trust point to verify with  * @param rrset: DNSKEY rrset to verify.  * @return false on failure, true if verification successful.  */
end_comment

begin_function
specifier|static
name|int
name|verify_dnskey
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|sigalg
index|[
name|ALGO_NEEDS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|downprot
init|=
name|env
operator|->
name|cfg
operator|->
name|harden_algo_downgrade
decl_stmt|;
name|enum
name|sec_status
name|sec
init|=
name|val_verify_DNSKEY_with_TA
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|rrset
argument_list|,
name|tp
operator|->
name|ds_rrset
argument_list|,
name|tp
operator|->
name|dnskey_rrset
argument_list|,
name|downprot
condition|?
name|sigalg
else|:
name|NULL
argument_list|,
operator|&
name|reason
argument_list|)
decl_stmt|;
comment|/* sigalg is ignored, it returns algorithms signalled to exist, but 	 * in 5011 there are no other rrsets to check.  if downprot is 	 * enabled, then it checks that the DNSKEY is signed with all 	 * algorithms available in the trust store. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: validate DNSKEY with anchor: %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|sec
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sec
operator|==
name|sec_status_secure
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|rrsig_get_expiry
parameter_list|(
name|uint8_t
modifier|*
name|d
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* rrsig: 2(rdlen), 2(type) 1(alg) 1(v) 4(origttl), then 4(expi), (4)incep) */
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|8
operator|+
literal|4
condition|)
return|return
literal|0
return|;
return|return
name|sldns_read_uint32
argument_list|(
name|d
operator|+
literal|2
operator|+
literal|8
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Find minimum expiration interval from signatures */
end_comment

begin_function
specifier|static
name|time_t
name|min_expiry
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|dd
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int32_t
name|t
decl_stmt|,
name|r
init|=
literal|15
operator|*
literal|24
operator|*
literal|3600
decl_stmt|;
comment|/* 15 days max */
for|for
control|(
name|i
operator|=
name|dd
operator|->
name|count
init|;
name|i
operator|<
name|dd
operator|->
name|count
operator|+
name|dd
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|rrsig_get_expiry
argument_list|(
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int32_t
operator|)
name|t
operator|-
operator|(
name|int32_t
operator|)
operator|*
name|env
operator|->
name|now
operator|>
literal|0
condition|)
block|{
name|t
operator|-=
operator|(
name|int32_t
operator|)
operator|*
name|env
operator|->
name|now
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|r
condition|)
name|r
operator|=
name|t
expr_stmt|;
block|}
block|}
return|return
operator|(
name|time_t
operator|)
name|r
return|;
block|}
end_function

begin_comment
comment|/** Is rr self-signed revoked key */
end_comment

begin_function
specifier|static
name|int
name|rr_is_selfsigned_revoked
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|size_t
name|i
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
decl_stmt|;
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"seen REVOKE flag, check self-signed, rr %d"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* no algorithm downgrade protection necessary, if it is selfsigned 	 * revoked it can be removed. */
name|sec
operator|=
name|dnskey_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|dnskey_rrset
argument_list|,
name|i
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
name|sec
operator|==
name|sec_status_secure
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Set fetched value */
end_comment

begin_function
specifier|static
name|void
name|seen_trustanchor
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|uint8_t
name|seen
parameter_list|)
block|{
name|ta
operator|->
name|fetched
operator|=
name|seen
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|pending_count
operator|<
literal|250
condition|)
comment|/* no numerical overflow, please */
name|ta
operator|->
name|pending_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/** set revoked value */
end_comment

begin_function
specifier|static
name|void
name|seen_revoked_trustanchor
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|uint8_t
name|revoked
parameter_list|)
block|{
name|ta
operator|->
name|revoked
operator|=
name|revoked
expr_stmt|;
block|}
end_function

begin_comment
comment|/** revoke a trust anchor */
end_comment

begin_function
specifier|static
name|void
name|revoke_dnskey
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|uint16_t
name|flags
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
return|return;
if|if
condition|(
name|sldns_wirerr_get_rdatalen
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
operator|<
literal|2
condition|)
return|return;
name|data
operator|=
name|sldns_wirerr_get_rdata
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
expr_stmt|;
name|flags
operator|=
name|sldns_read_uint16
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|&&
operator|(
name|flags
operator|&
name|LDNS_KEY_REVOKE_KEY
operator|)
condition|)
name|flags
operator|^=
name|LDNS_KEY_REVOKE_KEY
expr_stmt|;
comment|/* flip */
else|else
name|flags
operator||=
name|LDNS_KEY_REVOKE_KEY
expr_stmt|;
name|sldns_write_uint16
argument_list|(
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Compare two RRs skipping the REVOKED bit. Pass rdata(no len) */
end_comment

begin_function
specifier|static
name|int
name|dnskey_compare_skip_revbit
parameter_list|(
name|uint8_t
modifier|*
name|a
parameter_list|,
name|size_t
name|a_len
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|size_t
name|b_len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|a_len
operator|!=
name|b_len
condition|)
return|return
operator|-
literal|1
return|;
comment|/* compare RRs RDATA byte for byte. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a_len
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|rdf1
decl_stmt|,
name|rdf2
decl_stmt|;
name|rdf1
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|rdf2
operator|=
name|b
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
comment|/* this is the second part of the flags field */
name|rdf1
operator||=
name|LDNS_KEY_REVOKE_KEY
expr_stmt|;
name|rdf2
operator||=
name|LDNS_KEY_REVOKE_KEY
expr_stmt|;
block|}
if|if
condition|(
name|rdf1
operator|<
name|rdf2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|rdf1
operator|>
name|rdf2
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** compare trust anchor with rdata, 0 if equal. Pass rdata(no len) */
end_comment

begin_function
specifier|static
name|int
name|ta_compare
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|a
parameter_list|,
name|uint16_t
name|t
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|size_t
name|b_len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|b
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|a
operator|->
name|rr
argument_list|,
name|a
operator|->
name|rr_len
argument_list|,
name|a
operator|->
name|dname_len
argument_list|)
operator|!=
name|t
condition|)
return|return
operator|(
name|int
operator|)
name|sldns_wirerr_get_type
argument_list|(
name|a
operator|->
name|rr
argument_list|,
name|a
operator|->
name|rr_len
argument_list|,
name|a
operator|->
name|dname_len
argument_list|)
operator|-
operator|(
name|int
operator|)
name|t
return|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_DNSKEY
condition|)
block|{
return|return
name|dnskey_compare_skip_revbit
argument_list|(
name|sldns_wirerr_get_rdata
argument_list|(
name|a
operator|->
name|rr
argument_list|,
name|a
operator|->
name|rr_len
argument_list|,
name|a
operator|->
name|dname_len
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatalen
argument_list|(
name|a
operator|->
name|rr
argument_list|,
name|a
operator|->
name|rr_len
argument_list|,
name|a
operator|->
name|dname_len
argument_list|)
argument_list|,
name|b
argument_list|,
name|b_len
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_DS
condition|)
block|{
if|if
condition|(
name|sldns_wirerr_get_rdatalen
argument_list|(
name|a
operator|->
name|rr
argument_list|,
name|a
operator|->
name|rr_len
argument_list|,
name|a
operator|->
name|dname_len
argument_list|)
operator|!=
name|b_len
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|memcmp
argument_list|(
name|sldns_wirerr_get_rdata
argument_list|(
name|a
operator|->
name|rr
argument_list|,
name|a
operator|->
name|rr_len
argument_list|,
name|a
operator|->
name|dname_len
argument_list|)
argument_list|,
name|b
argument_list|,
name|b_len
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**   * Find key  * @param tp: to search in  * @param t: rr type of the rdata.  * @param rdata: to look for  (no rdatalen in it)  * @param rdata_len: length of rdata  * @param result: returns NULL or the ta key looked for.  * @return false on malloc failure during search. if true examine result.  */
end_comment

begin_function
specifier|static
name|int
name|find_key
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|uint16_t
name|t
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|,
name|struct
name|autr_ta
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
decl_stmt|;
if|if
condition|(
operator|!
name|tp
operator|||
operator|!
name|rdata
condition|)
block|{
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ta
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|ta
condition|;
name|ta
operator|=
name|ta
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ta_compare
argument_list|(
name|ta
argument_list|,
name|t
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|ta
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** add key and clone RR and tp already locked. rdata without rdlen. */
end_comment

begin_function
specifier|static
name|struct
name|autr_ta
modifier|*
name|add_key
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|uint32_t
name|ttl
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
decl_stmt|;
name|uint8_t
modifier|*
name|rr
decl_stmt|;
name|size_t
name|rr_len
decl_stmt|,
name|dname_len
decl_stmt|;
name|uint16_t
name|rrtype
init|=
name|htons
argument_list|(
name|LDNS_RR_TYPE_DNSKEY
argument_list|)
decl_stmt|;
name|uint16_t
name|rrclass
init|=
name|htons
argument_list|(
name|LDNS_RR_CLASS_IN
argument_list|)
decl_stmt|;
name|uint16_t
name|rdlen
init|=
name|htons
argument_list|(
name|rdata_len
argument_list|)
decl_stmt|;
name|dname_len
operator|=
name|tp
operator|->
name|namelen
expr_stmt|;
name|ttl
operator|=
name|htonl
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|rr_len
operator|=
name|dname_len
operator|+
literal|10
comment|/* type,class,ttl,rdatalen */
operator|+
name|rdata_len
expr_stmt|;
name|rr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|rr_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rr
condition|)
return|return
name|NULL
return|;
name|memmove
argument_list|(
name|rr
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rr
operator|+
name|dname_len
argument_list|,
operator|&
name|rrtype
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rr
operator|+
name|dname_len
operator|+
literal|2
argument_list|,
operator|&
name|rrclass
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rr
operator|+
name|dname_len
operator|+
literal|4
argument_list|,
operator|&
name|ttl
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rr
operator|+
name|dname_len
operator|+
literal|8
argument_list|,
operator|&
name|rdlen
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rr
operator|+
name|dname_len
operator|+
literal|10
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|)
expr_stmt|;
name|ta
operator|=
name|autr_ta_create
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
block|{
comment|/* rr freed in autr_ta_create */
return|return
name|NULL
return|;
block|}
comment|/* link in, tp already locked */
name|ta
operator|->
name|next
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|keys
operator|=
name|ta
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/** get TTL from DNSKEY rrset */
end_comment

begin_function
specifier|static
name|time_t
name|key_ttl
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
return|return
name|d
operator|->
name|ttl
return|;
block|}
end_function

begin_comment
comment|/** update the time values for the trustpoint */
end_comment

begin_function
specifier|static
name|void
name|set_tp_times
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|time_t
name|rrsig_exp_interval
parameter_list|,
name|time_t
name|origttl
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
name|time_t
name|x
decl_stmt|,
name|qi
init|=
name|tp
operator|->
name|autr
operator|->
name|query_interval
decl_stmt|,
name|rt
init|=
name|tp
operator|->
name|autr
operator|->
name|retry_time
decl_stmt|;
comment|/* x = MIN(15days, ttl/2, expire/2) */
name|x
operator|=
literal|15
operator|*
literal|24
operator|*
literal|3600
expr_stmt|;
if|if
condition|(
name|origttl
operator|/
literal|2
operator|<
name|x
condition|)
name|x
operator|=
name|origttl
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|rrsig_exp_interval
operator|/
literal|2
operator|<
name|x
condition|)
name|x
operator|=
name|rrsig_exp_interval
operator|/
literal|2
expr_stmt|;
comment|/* MAX(1hr, x) */
if|if
condition|(
operator|!
name|autr_permit_small_holddown
condition|)
block|{
if|if
condition|(
name|x
operator|<
literal|3600
condition|)
name|tp
operator|->
name|autr
operator|->
name|query_interval
operator|=
literal|3600
expr_stmt|;
else|else
name|tp
operator|->
name|autr
operator|->
name|query_interval
operator|=
name|x
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|autr
operator|->
name|query_interval
operator|=
name|x
expr_stmt|;
comment|/* x= MIN(1day, ttl/10, expire/10) */
name|x
operator|=
literal|24
operator|*
literal|3600
expr_stmt|;
if|if
condition|(
name|origttl
operator|/
literal|10
operator|<
name|x
condition|)
name|x
operator|=
name|origttl
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|rrsig_exp_interval
operator|/
literal|10
operator|<
name|x
condition|)
name|x
operator|=
name|rrsig_exp_interval
operator|/
literal|10
expr_stmt|;
comment|/* MAX(1hr, x) */
if|if
condition|(
operator|!
name|autr_permit_small_holddown
condition|)
block|{
if|if
condition|(
name|x
operator|<
literal|3600
condition|)
name|tp
operator|->
name|autr
operator|->
name|retry_time
operator|=
literal|3600
expr_stmt|;
else|else
name|tp
operator|->
name|autr
operator|->
name|retry_time
operator|=
name|x
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|autr
operator|->
name|retry_time
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|qi
operator|!=
name|tp
operator|->
name|autr
operator|->
name|query_interval
operator|||
name|rt
operator|!=
name|tp
operator|->
name|autr
operator|->
name|retry_time
condition|)
block|{
operator|*
name|changed
operator|=
literal|1
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"orig_ttl is %d"
argument_list|,
operator|(
name|int
operator|)
name|origttl
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"rrsig_exp_interval is %d"
argument_list|,
operator|(
name|int
operator|)
name|rrsig_exp_interval
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"query_interval: %d, retry_time: %d"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|query_interval
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|retry_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** init events to zero */
end_comment

begin_function
specifier|static
name|void
name|init_events
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
decl_stmt|;
for|for
control|(
name|ta
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|ta
condition|;
name|ta
operator|=
name|ta
operator|->
name|next
control|)
block|{
name|ta
operator|->
name|fetched
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** check for revoked keys without trusting any other information */
end_comment

begin_function
specifier|static
name|void
name|check_contains_revoked
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|dd
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|dnskey_rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNSKEY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dd
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|rr_is_dnskey_sep
argument_list|(
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
operator|||
operator|!
name|rr_is_dnskey_revoked
argument_list|(
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
condition|)
continue|continue;
comment|/* not a revoked KSK */
if|if
condition|(
operator|!
name|find_key
argument_list|(
name|tp
argument_list|,
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|,
operator|&
name|ta
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* malloc fail in compare*/
block|}
if|if
condition|(
operator|!
name|ta
condition|)
continue|continue;
comment|/* key not found */
if|if
condition|(
name|rr_is_selfsigned_revoked
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* checked if there is an rrsig signed by this key. */
comment|/* same keytag, but stored can be revoked already, so  			 * compare keytags, with +0 or +128(REVOKE flag) */
name|log_assert
argument_list|(
name|dnskey_calc_keytag
argument_list|(
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
operator|-
literal|128
operator|==
name|sldns_calc_keytag_raw
argument_list|(
name|sldns_wirerr_get_rdata
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatalen
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|)
operator|||
name|dnskey_calc_keytag
argument_list|(
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
operator|==
name|sldns_calc_keytag_raw
argument_list|(
name|sldns_wirerr_get_rdata
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatalen
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|,
name|ta
operator|->
name|dname_len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* checks conversion*/
name|verbose_key
argument_list|(
name|ta
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"is self-signed revoked"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
operator|->
name|revoked
condition|)
operator|*
name|changed
operator|=
literal|1
expr_stmt|;
name|seen_revoked_trustanchor
argument_list|(
name|ta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_revoked
argument_list|(
name|env
argument_list|,
name|ta
argument_list|,
name|changed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** See if a DNSKEY is verified by one of the DSes */
end_comment

begin_function
specifier|static
name|int
name|key_matches_a_ds
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|size_t
name|key_idx
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|dd
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|ds_rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|ds_idx
decl_stmt|,
name|num
init|=
name|dd
operator|->
name|count
decl_stmt|;
name|int
name|d
init|=
name|val_favorite_ds_algo
argument_list|(
name|ds_rrset
argument_list|)
decl_stmt|;
name|char
modifier|*
name|reason
init|=
literal|""
decl_stmt|;
for|for
control|(
name|ds_idx
operator|=
literal|0
init|;
name|ds_idx
operator|<
name|num
condition|;
name|ds_idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ds_digest_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
operator|||
operator|!
name|ds_key_algo_is_supported
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
operator|||
name|ds_get_digest_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
operator|!=
name|d
condition|)
continue|continue;
if|if
condition|(
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
operator|!=
name|dnskey_get_algo
argument_list|(
name|dnskey_rrset
argument_list|,
name|key_idx
argument_list|)
operator|||
name|dnskey_calc_keytag
argument_list|(
name|dnskey_rrset
argument_list|,
name|key_idx
argument_list|)
operator|!=
name|ds_get_keytag
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|ds_digest_match_dnskey
argument_list|(
name|env
argument_list|,
name|dnskey_rrset
argument_list|,
name|key_idx
argument_list|,
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS match attempt failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dnskey_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|dnskey_rrset
argument_list|,
name|key_idx
argument_list|,
operator|&
name|reason
argument_list|)
operator|==
name|sec_status_secure
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS match failed because the key "
literal|"does not verify the keyset: %s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Set update events */
end_comment

begin_function
specifier|static
name|int
name|update_events
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|dd
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|dnskey_rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNSKEY
argument_list|)
expr_stmt|;
name|init_events
argument_list|(
name|tp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dd
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|rr_is_dnskey_sep
argument_list|(
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rr_is_dnskey_revoked
argument_list|(
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
condition|)
block|{
comment|/* self-signed revoked keys already detected before, 			 * other revoked keys are not 'added' again */
continue|continue;
block|}
comment|/* is a key of this type supported?. Note rr_list and 		 * packed_rrset are in the same order. */
if|if
condition|(
operator|!
name|dnskey_algo_is_supported
argument_list|(
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* skip unknown algorithm key, it is useless to us */
name|log_nametypeclass
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"trust point has "
literal|"unsupported algorithm at"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|tp
operator|->
name|dclass
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* is it new? if revocation bit set, find the unrevoked key */
if|if
condition|(
operator|!
name|find_key
argument_list|(
name|tp
argument_list|,
name|ntohs
argument_list|(
name|dnskey_rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|,
operator|&
name|ta
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ta
condition|)
block|{
name|ta
operator|=
name|add_key
argument_list|(
name|tp
argument_list|,
operator|(
name|uint32_t
operator|)
name|dd
operator|->
name|rr_ttl
index|[
name|i
index|]
argument_list|,
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
expr_stmt|;
operator|*
name|changed
operator|=
literal|1
expr_stmt|;
comment|/* first time seen, do we have DSes? if match: VALID */
if|if
condition|(
name|ta
operator|&&
name|tp
operator|->
name|ds_rrset
operator|&&
name|key_matches_a_ds
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|i
argument_list|,
name|tp
operator|->
name|ds_rrset
argument_list|)
condition|)
block|{
name|verbose_key
argument_list|(
name|ta
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"verified by DS"
argument_list|)
expr_stmt|;
name|ta
operator|->
name|s
operator|=
name|AUTR_STATE_VALID
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ta
condition|)
block|{
return|return
literal|0
return|;
block|}
name|seen_trustanchor
argument_list|(
name|ta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|verbose_key
argument_list|(
name|ta
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"in DNS response"
argument_list|)
expr_stmt|;
block|}
name|set_tp_times
argument_list|(
name|tp
argument_list|,
name|min_expiry
argument_list|(
name|env
argument_list|,
name|dd
argument_list|)
argument_list|,
name|key_ttl
argument_list|(
name|dnskey_rrset
argument_list|)
argument_list|,
name|changed
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check if the holddown time has already exceeded  * setting: add-holddown: add holddown timer  * setting: del-holddown: del holddown timer  * @param env: environment with current time  * @param ta: trust anchor to check for.  * @param holddown: the timer value  * @return number of seconds the holddown has passed.  */
end_comment

begin_function
specifier|static
name|time_t
name|check_holddown
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|unsigned
name|int
name|holddown
parameter_list|)
block|{
name|time_t
name|elapsed
decl_stmt|;
if|if
condition|(
operator|*
name|env
operator|->
name|now
operator|<
name|ta
operator|->
name|last_change
condition|)
block|{
name|log_warn
argument_list|(
literal|"time goes backwards. delaying key holddown"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|elapsed
operator|=
operator|*
name|env
operator|->
name|now
operator|-
name|ta
operator|->
name|last_change
expr_stmt|;
if|if
condition|(
name|elapsed
operator|>
operator|(
name|time_t
operator|)
name|holddown
condition|)
block|{
return|return
name|elapsed
operator|-
operator|(
name|time_t
operator|)
name|holddown
return|;
block|}
name|verbose_key
argument_list|(
name|ta
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"holddown time "
name|ARG_LL
literal|"d seconds to go"
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
operator|(
name|time_t
operator|)
name|holddown
operator|-
name|elapsed
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Set last_change to now */
end_comment

begin_function
specifier|static
name|void
name|reset_holddown
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
name|ta
operator|->
name|last_change
operator|=
operator|*
name|env
operator|->
name|now
expr_stmt|;
operator|*
name|changed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Set the state for this trust anchor */
end_comment

begin_function
specifier|static
name|void
name|set_trustanchor_state
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|,
name|autr_state_t
name|s
parameter_list|)
block|{
name|verbose_key
argument_list|(
name|ta
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"update: %s to %s"
argument_list|,
name|trustanchor_state2str
argument_list|(
name|ta
operator|->
name|s
argument_list|)
argument_list|,
name|trustanchor_state2str
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ta
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|reset_holddown
argument_list|(
name|env
argument_list|,
name|ta
argument_list|,
name|changed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Event: NewKey */
end_comment

begin_function
specifier|static
name|void
name|do_newkey
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_START
condition|)
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_ADDPEND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Event: AddTime */
end_comment

begin_function
specifier|static
name|void
name|do_addtime
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
comment|/* This not according to RFC, this is 30 days, but the RFC demands  	 * MAX(30days, TTL expire time of first DNSKEY set with this key), 	 * The value may be too small if a very large TTL was used. */
name|time_t
name|exceeded
init|=
name|check_holddown
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|env
operator|->
name|cfg
operator|->
name|add_holddown
argument_list|)
decl_stmt|;
if|if
condition|(
name|exceeded
operator|&&
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_ADDPEND
condition|)
block|{
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"add-holddown time exceeded "
name|ARG_LL
literal|"d seconds ago, and pending-count %d"
argument_list|,
operator|(
name|long
name|long
operator|)
name|exceeded
argument_list|,
name|anchor
operator|->
name|pending_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
operator|->
name|pending_count
operator|>=
name|MIN_PENDINGCOUNT
condition|)
block|{
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_VALID
argument_list|)
expr_stmt|;
name|anchor
operator|->
name|pending_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"add-holddown time sanity check "
literal|"failed (pending count: %d)"
argument_list|,
name|anchor
operator|->
name|pending_count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Event: RemTime */
end_comment

begin_function
specifier|static
name|void
name|do_remtime
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|time_t
name|exceeded
init|=
name|check_holddown
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|env
operator|->
name|cfg
operator|->
name|del_holddown
argument_list|)
decl_stmt|;
if|if
condition|(
name|exceeded
operator|&&
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_REVOKED
condition|)
block|{
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"del-holddown time exceeded "
name|ARG_LL
literal|"d seconds ago"
argument_list|,
operator|(
name|long
name|long
operator|)
name|exceeded
argument_list|)
expr_stmt|;
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_REMOVED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Event: KeyRem */
end_comment

begin_function
specifier|static
name|void
name|do_keyrem
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_ADDPEND
condition|)
block|{
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_START
argument_list|)
expr_stmt|;
name|anchor
operator|->
name|pending_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_VALID
condition|)
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_MISSING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Event: KeyPres */
end_comment

begin_function
specifier|static
name|void
name|do_keypres
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_MISSING
condition|)
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_VALID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Event: Revoked */
end_comment

begin_function
specifier|static
name|void
name|do_revoked
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_VALID
operator|||
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_MISSING
condition|)
block|{
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|,
name|AUTR_STATE_REVOKED
argument_list|)
expr_stmt|;
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"old id, prior to revocation"
argument_list|)
expr_stmt|;
name|revoke_dnskey
argument_list|(
name|anchor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"new id, after revocation"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Do statestable transition matrix for anchor */
end_comment

begin_function
specifier|static
name|void
name|anchor_state_update
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|autr_ta
modifier|*
name|anchor
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|log_assert
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|anchor
operator|->
name|s
condition|)
block|{
comment|/* START */
case|case
name|AUTR_STATE_START
case|:
comment|/* NewKey: ADDPEND */
if|if
condition|(
name|anchor
operator|->
name|fetched
condition|)
name|do_newkey
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
comment|/* ADDPEND */
case|case
name|AUTR_STATE_ADDPEND
case|:
comment|/* KeyRem: START */
if|if
condition|(
operator|!
name|anchor
operator|->
name|fetched
condition|)
name|do_keyrem
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* AddTime: VALID */
else|else
name|do_addtime
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
comment|/* VALID */
case|case
name|AUTR_STATE_VALID
case|:
comment|/* RevBit: REVOKED */
if|if
condition|(
name|anchor
operator|->
name|revoked
condition|)
name|do_revoked
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* KeyRem: MISSING */
elseif|else
if|if
condition|(
operator|!
name|anchor
operator|->
name|fetched
condition|)
name|do_keyrem
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|anchor
operator|->
name|last_change
condition|)
block|{
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"first seen"
argument_list|)
expr_stmt|;
name|reset_holddown
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* MISSING */
case|case
name|AUTR_STATE_MISSING
case|:
comment|/* RevBit: REVOKED */
if|if
condition|(
name|anchor
operator|->
name|revoked
condition|)
name|do_revoked
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* KeyPres */
elseif|else
if|if
condition|(
name|anchor
operator|->
name|fetched
condition|)
name|do_keypres
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
comment|/* REVOKED */
case|case
name|AUTR_STATE_REVOKED
case|:
if|if
condition|(
name|anchor
operator|->
name|fetched
condition|)
name|reset_holddown
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* RemTime: REMOVED */
else|else
name|do_remtime
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
comment|/* REMOVED */
case|case
name|AUTR_STATE_REMOVED
case|:
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/** if ZSK init then trust KSKs */
end_comment

begin_function
specifier|static
name|int
name|init_zsk_to_ksk
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
comment|/* search for VALID ZSKs */
name|struct
name|autr_ta
modifier|*
name|anchor
decl_stmt|;
name|int
name|validzsk
init|=
literal|0
decl_stmt|;
name|int
name|validksk
init|=
literal|0
decl_stmt|;
for|for
control|(
name|anchor
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|anchor
condition|;
name|anchor
operator|=
name|anchor
operator|->
name|next
control|)
block|{
comment|/* last_change test makes sure it was manually configured */
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|anchor
operator|->
name|rr
argument_list|,
name|anchor
operator|->
name|rr_len
argument_list|,
name|anchor
operator|->
name|dname_len
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNSKEY
operator|&&
name|anchor
operator|->
name|last_change
operator|==
literal|0
operator|&&
operator|!
name|ta_is_dnskey_sep
argument_list|(
name|anchor
argument_list|)
operator|&&
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_VALID
condition|)
name|validzsk
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|validzsk
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|anchor
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|anchor
condition|;
name|anchor
operator|=
name|anchor
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ta_is_dnskey_sep
argument_list|(
name|anchor
argument_list|)
operator|&&
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_ADDPEND
condition|)
block|{
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"trust KSK from "
literal|"ZSK(config)"
argument_list|)
expr_stmt|;
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|changed
argument_list|,
name|AUTR_STATE_VALID
argument_list|)
expr_stmt|;
name|validksk
operator|++
expr_stmt|;
block|}
block|}
return|return
name|validksk
return|;
block|}
end_function

begin_comment
comment|/** Remove missing trustanchors so the list does not grow forever */
end_comment

begin_function
specifier|static
name|void
name|remove_missing_trustanchors
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|anchor
decl_stmt|;
name|time_t
name|exceeded
decl_stmt|;
name|int
name|valid
init|=
literal|0
decl_stmt|;
comment|/* see if we have anchors that are valid */
for|for
control|(
name|anchor
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|anchor
condition|;
name|anchor
operator|=
name|anchor
operator|->
name|next
control|)
block|{
comment|/* Only do KSKs */
if|if
condition|(
operator|!
name|ta_is_dnskey_sep
argument_list|(
name|anchor
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_VALID
condition|)
name|valid
operator|++
expr_stmt|;
block|}
comment|/* if there are no SEP Valid anchors, see if we started out with 	 * a ZSK (last-change=0) anchor, which is VALID and there are KSKs 	 * now that can be made valid.  Do this immediately because there 	 * is no guarantee that the ZSKs get announced long enough.  Usually 	 * this is immediately after init with a ZSK trusted, unless the domain 	 * was not advertising any KSKs at all.  In which case we perfectly 	 * track the zero number of KSKs. */
if|if
condition|(
name|valid
operator|==
literal|0
condition|)
block|{
name|valid
operator|=
name|init_zsk_to_ksk
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|==
literal|0
condition|)
return|return;
block|}
for|for
control|(
name|anchor
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|anchor
condition|;
name|anchor
operator|=
name|anchor
operator|->
name|next
control|)
block|{
comment|/* ignore ZSKs if newly added */
if|if
condition|(
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_START
condition|)
continue|continue;
comment|/* remove ZSKs if a KSK is present */
if|if
condition|(
operator|!
name|ta_is_dnskey_sep
argument_list|(
name|anchor
argument_list|)
condition|)
block|{
if|if
condition|(
name|valid
operator|>
literal|0
condition|)
block|{
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"remove ZSK "
literal|"[%d key(s) VALID]"
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|changed
argument_list|,
name|AUTR_STATE_REMOVED
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Only do MISSING keys */
if|if
condition|(
name|anchor
operator|->
name|s
operator|!=
name|AUTR_STATE_MISSING
condition|)
continue|continue;
if|if
condition|(
name|env
operator|->
name|cfg
operator|->
name|keep_missing
operator|==
literal|0
condition|)
continue|continue;
comment|/* keep forever */
name|exceeded
operator|=
name|check_holddown
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|env
operator|->
name|cfg
operator|->
name|keep_missing
argument_list|)
expr_stmt|;
comment|/* If keep_missing has exceeded and we still have more than  		 * one valid KSK: remove missing trust anchor */
if|if
condition|(
name|exceeded
operator|&&
name|valid
operator|>
literal|0
condition|)
block|{
name|verbose_key
argument_list|(
name|anchor
argument_list|,
name|VERB_ALGO
argument_list|,
literal|"keep-missing time "
literal|"exceeded "
name|ARG_LL
literal|"d seconds ago, [%d key(s) VALID]"
argument_list|,
operator|(
name|long
name|long
operator|)
name|exceeded
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|set_trustanchor_state
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|changed
argument_list|,
name|AUTR_STATE_REMOVED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** Do the statetable from RFC5011 transition matrix */
end_comment

begin_function
specifier|static
name|int
name|do_statetable
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|changed
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|anchor
decl_stmt|;
for|for
control|(
name|anchor
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|anchor
condition|;
name|anchor
operator|=
name|anchor
operator|->
name|next
control|)
block|{
comment|/* Only do KSKs */
if|if
condition|(
operator|!
name|ta_is_dnskey_sep
argument_list|(
name|anchor
argument_list|)
condition|)
continue|continue;
name|anchor_state_update
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|changed
argument_list|)
expr_stmt|;
block|}
name|remove_missing_trustanchors
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
name|changed
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** See if time alone makes ADDPEND to VALID transition */
end_comment

begin_function
specifier|static
name|void
name|autr_holddown_exceed
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|anchor
decl_stmt|;
for|for
control|(
name|anchor
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|anchor
condition|;
name|anchor
operator|=
name|anchor
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ta_is_dnskey_sep
argument_list|(
name|anchor
argument_list|)
operator|&&
name|anchor
operator|->
name|s
operator|==
name|AUTR_STATE_ADDPEND
condition|)
name|do_addtime
argument_list|(
name|env
argument_list|,
name|anchor
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** cleanup key list */
end_comment

begin_function
specifier|static
name|void
name|autr_cleanup_keys
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|prevp
decl_stmt|;
name|prevp
operator|=
operator|&
name|tp
operator|->
name|autr
operator|->
name|keys
expr_stmt|;
name|p
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
comment|/* do we want to remove this key? */
if|if
condition|(
name|p
operator|->
name|s
operator|==
name|AUTR_STATE_START
operator|||
name|p
operator|->
name|s
operator|==
name|AUTR_STATE_REMOVED
operator|||
name|sldns_wirerr_get_type
argument_list|(
name|p
operator|->
name|rr
argument_list|,
name|p
operator|->
name|rr_len
argument_list|,
name|p
operator|->
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
block|{
name|struct
name|autr_ta
modifier|*
name|np
init|=
name|p
operator|->
name|next
decl_stmt|;
comment|/* remove */
name|free
argument_list|(
name|p
operator|->
name|rr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* snip and go to next item */
operator|*
name|prevp
operator|=
name|np
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
continue|continue;
block|}
comment|/* remove pending counts if no longer pending */
if|if
condition|(
name|p
operator|->
name|s
operator|!=
name|AUTR_STATE_ADDPEND
condition|)
name|p
operator|->
name|pending_count
operator|=
literal|0
expr_stmt|;
name|prevp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** calculate next probe time */
end_comment

begin_function
specifier|static
name|time_t
name|calc_next_probe
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|time_t
name|wait
parameter_list|)
block|{
comment|/* make it random, 90-100% */
name|time_t
name|rnd
decl_stmt|,
name|rest
decl_stmt|;
if|if
condition|(
operator|!
name|autr_permit_small_holddown
condition|)
block|{
if|if
condition|(
name|wait
operator|<
literal|3600
condition|)
name|wait
operator|=
literal|3600
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
name|wait
operator|=
literal|1
expr_stmt|;
block|}
name|rnd
operator|=
name|wait
operator|/
literal|10
expr_stmt|;
name|rest
operator|=
name|wait
operator|-
name|rnd
expr_stmt|;
name|rnd
operator|=
operator|(
name|time_t
operator|)
name|ub_random_max
argument_list|(
name|env
operator|->
name|rnd
argument_list|,
operator|(
name|long
name|int
operator|)
name|rnd
argument_list|)
expr_stmt|;
return|return
call|(
name|time_t
call|)
argument_list|(
operator|*
name|env
operator|->
name|now
operator|+
name|rest
operator|+
name|rnd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** what is first probe time (anchors must be locked) */
end_comment

begin_function
specifier|static
name|time_t
name|wait_probe_time
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|rbnode_t
modifier|*
name|t
init|=
name|rbtree_first
argument_list|(
operator|&
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|RBTREE_NULL
condition|)
return|return
operator|(
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|t
operator|->
name|key
operator|)
operator|->
name|autr
operator|->
name|next_probe_time
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** reset worker timer */
end_comment

begin_function
specifier|static
name|void
name|reset_worker_timer
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|time_t
name|next
init|=
operator|(
name|time_t
operator|)
name|wait_probe_time
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
decl_stmt|;
comment|/* in case this is libunbound, no timer */
if|if
condition|(
operator|!
name|env
operator|->
name|probe_timer
condition|)
return|return;
if|if
condition|(
name|next
operator|>
operator|*
name|env
operator|->
name|now
condition|)
name|tv
operator|.
name|tv_sec
operator|=
call|(
name|time_t
call|)
argument_list|(
name|next
operator|-
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
else|else
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|comm_timer_set
argument_list|(
name|env
operator|->
name|probe_timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"scheduled next probe in "
name|ARG_LL
literal|"d sec"
argument_list|,
operator|(
name|long
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** set next probe for trust anchor */
end_comment

begin_function
specifier|static
name|int
name|set_next_probe
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|)
block|{
name|struct
name|trust_anchor
name|key
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|time_t
name|mold
decl_stmt|,
name|mnew
decl_stmt|;
comment|/* use memory allocated in rrset for temporary name storage */
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_labels
argument_list|(
name|key
operator|.
name|name
argument_list|)
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|tp
operator|->
name|dclass
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* fetch tp again and lock anchors, so that we can modify the trees */
name|lock_basic_lock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tp2
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|rbtree_search
argument_list|(
name|env
operator|->
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp2
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"trustpoint was deleted in set_next_probe"
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|tp
operator|==
name|tp2
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* schedule */
name|mold
operator|=
name|wait_probe_time
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|=
name|calc_next_probe
argument_list|(
name|env
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|query_interval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
operator|&
name|tp
operator|->
name|autr
operator|->
name|pnode
argument_list|)
expr_stmt|;
name|mnew
operator|=
name|wait_probe_time
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"next probe set in %d seconds"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|-
operator|(
name|int
operator|)
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|mold
operator|!=
name|mnew
condition|)
block|{
name|reset_worker_timer
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Revoke and Delete a trust point */
end_comment

begin_function
specifier|static
name|void
name|autr_tp_remove
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|del_tp
decl_stmt|;
name|struct
name|trust_anchor
name|key
decl_stmt|;
name|struct
name|autr_point_data
name|pd
decl_stmt|;
name|time_t
name|mold
decl_stmt|,
name|mnew
decl_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_OPS
argument_list|,
literal|"trust point was revoked"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|tp
operator|->
name|dclass
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|revoked
operator|=
literal|1
expr_stmt|;
comment|/* use space allocated for dnskey_rrset to save name of anchor */
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|autr
operator|=
operator|&
name|pd
expr_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|pd
operator|.
name|pnode
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|pd
operator|.
name|next_probe_time
operator|=
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|tp
operator|->
name|namelen
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|tp
operator|->
name|namelabs
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|tp
operator|->
name|dclass
expr_stmt|;
comment|/* unlock */
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* take from tree. It could be deleted by someone else,hence (void). */
name|lock_basic_lock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|del_tp
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|rbtree_delete
argument_list|(
name|env
operator|->
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|mold
operator|=
name|wait_probe_time
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|mnew
operator|=
name|wait_probe_time
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
expr_stmt|;
name|anchors_init_parents_locked
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* if !del_tp then the trust point is no longer present in the tree, 	 * it was deleted by someone else, who will write the zonefile and 	 * clean up the structure */
if|if
condition|(
name|del_tp
condition|)
block|{
comment|/* save on disk */
name|del_tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|=
literal|0
expr_stmt|;
comment|/* no more probing for it */
name|autr_write_file
argument_list|(
name|env
argument_list|,
name|del_tp
argument_list|)
expr_stmt|;
comment|/* delete */
name|autr_point_delete
argument_list|(
name|del_tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mold
operator|!=
name|mnew
condition|)
block|{
name|reset_worker_timer
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|autr_process_prime
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|log_assert
argument_list|(
name|tp
operator|&&
name|tp
operator|->
name|autr
argument_list|)
expr_stmt|;
comment|/* autotrust update trust anchors */
comment|/* the tp is locked, and stays locked unless it is deleted */
comment|/* we could just catch the anchor here while another thread 	 * is busy deleting it. Just unlock and let the other do its job */
if|if
condition|(
name|tp
operator|->
name|autr
operator|->
name|revoked
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust not processed, "
literal|"trust point revoked"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|tp
operator|->
name|dclass
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* it is revoked */
block|}
comment|/* query_dnskeys(): */
name|tp
operator|->
name|autr
operator|->
name|last_queried
operator|=
operator|*
name|env
operator|->
name|now
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust process for"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|tp
operator|->
name|dclass
argument_list|)
expr_stmt|;
comment|/* see if time alone makes some keys valid */
name|autr_holddown_exceed
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: morekeys, reassemble"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autr_assemble
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure assembling autotrust keys"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unchanged */
block|}
block|}
comment|/* did we get any data? */
if|if
condition|(
operator|!
name|dnskey_rrset
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: no dnskey rrset"
argument_list|)
expr_stmt|;
comment|/* no update of query_failed, because then we would have 		 * to write to disk. But we cannot because we maybe are 		 * still 'initialising' with DS records, that we cannot write 		 * in the full format (which only contains KSKs). */
return|return
literal|1
return|;
comment|/* trust point exists */
block|}
comment|/* check for revoked keys to remove immediately */
name|check_contains_revoked
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|tp
argument_list|,
name|dnskey_rrset
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: revokedkeys, reassemble"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autr_assemble
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure assembling autotrust keys"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unchanged */
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|ds_rrset
operator|&&
operator|!
name|tp
operator|->
name|dnskey_rrset
condition|)
block|{
comment|/* no more keys, all are revoked */
comment|/* this is a success for this probe attempt */
name|tp
operator|->
name|autr
operator|->
name|last_success
operator|=
operator|*
name|env
operator|->
name|now
expr_stmt|;
name|autr_tp_remove
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
name|dnskey_rrset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* trust point removed */
block|}
block|}
comment|/* verify the dnskey rrset and see if it is valid. */
if|if
condition|(
operator|!
name|verify_dnskey
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|tp
argument_list|,
name|dnskey_rrset
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: dnskey did not verify."
argument_list|)
expr_stmt|;
comment|/* only increase failure count if this is not the first prime, 		 * this means there was a previous successful probe */
if|if
condition|(
name|tp
operator|->
name|autr
operator|->
name|last_success
condition|)
block|{
name|tp
operator|->
name|autr
operator|->
name|query_failed
operator|+=
literal|1
expr_stmt|;
name|autr_write_file
argument_list|(
name|env
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* trust point exists */
block|}
name|tp
operator|->
name|autr
operator|->
name|last_success
operator|=
operator|*
name|env
operator|->
name|now
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|query_failed
operator|=
literal|0
expr_stmt|;
comment|/* Add new trust anchors to the data structure 	 * - note which trust anchors are seen this probe. 	 * Set trustpoint query_interval and retry_time. 	 * - find minimum rrsig expiration interval 	 */
if|if
condition|(
operator|!
name|update_events
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|tp
argument_list|,
name|dnskey_rrset
argument_list|,
operator|&
name|changed
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in autotrust update_events. "
literal|"trust point unchanged."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* trust point unchanged, so exists */
block|}
comment|/* - for every SEP key do the 5011 statetable. 	 * - remove missing trustanchors (if veryold and we have new anchors). 	 */
if|if
condition|(
operator|!
name|do_statetable
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
operator|&
name|changed
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in autotrust do_statetable. "
literal|"trust point unchanged."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* trust point unchanged, so exists */
block|}
name|autr_cleanup_keys
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_next_probe
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
name|dnskey_rrset
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* trust point does not exist */
name|autr_write_file
argument_list|(
name|env
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: changed, reassemble"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autr_assemble
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure assembling autotrust keys"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unchanged */
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|ds_rrset
operator|&&
operator|!
name|tp
operator|->
name|dnskey_rrset
condition|)
block|{
comment|/* no more keys, all are revoked */
name|autr_tp_remove
argument_list|(
name|env
argument_list|,
name|tp
argument_list|,
name|dnskey_rrset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* trust point removed */
block|}
block|}
else|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust: no changes"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* trust point exists */
block|}
end_function

begin_comment
comment|/** debug print a trust anchor key */
end_comment

begin_function
specifier|static
name|void
name|autr_debug_print_ta
parameter_list|(
name|struct
name|autr_ta
modifier|*
name|ta
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|sldns_wire2str_rr
argument_list|(
name|ta
operator|->
name|rr
argument_list|,
name|ta
operator|->
name|rr_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|log_info
argument_list|(
literal|"out of memory in debug_print_ta"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|str
operator|&&
name|str
index|[
literal|0
index|]
condition|)
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|ctime_r
argument_list|(
operator|&
name|ta
operator|->
name|last_change
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|log_info
argument_list|(
literal|"[%s] %s ;;state:%d ;;pending_count:%d%s%s last:%s"
argument_list|,
name|trustanchor_state2str
argument_list|(
name|ta
operator|->
name|s
argument_list|)
argument_list|,
name|str
argument_list|,
name|ta
operator|->
name|s
argument_list|,
name|ta
operator|->
name|pending_count
argument_list|,
name|ta
operator|->
name|fetched
condition|?
literal|" fetched"
else|:
literal|""
argument_list|,
name|ta
operator|->
name|revoked
condition|?
literal|" revoked"
else|:
literal|""
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** debug print a trust point */
end_comment

begin_function
specifier|static
name|void
name|autr_debug_print_tp
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|autr_ta
modifier|*
name|ta
decl_stmt|;
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|autr
condition|)
return|return;
name|dname_str
argument_list|(
name|tp
operator|->
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"trust point %s : %d"
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|dclass
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"assembled %d DS and %d DNSKEYs"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|numDS
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|numDNSKEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ds_rrset
condition|)
block|{
name|log_packed_rrset
argument_list|(
literal|0
argument_list|,
literal|"DS:"
argument_list|,
name|tp
operator|->
name|ds_rrset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|dnskey_rrset
condition|)
block|{
name|log_packed_rrset
argument_list|(
literal|0
argument_list|,
literal|"DNSKEY:"
argument_list|,
name|tp
operator|->
name|dnskey_rrset
argument_list|)
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"file %s"
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|file
argument_list|)
expr_stmt|;
name|ctime_r
argument_list|(
operator|&
name|tp
operator|->
name|autr
operator|->
name|last_queried
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|log_info
argument_list|(
literal|"last_queried: %u %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|tp
operator|->
name|autr
operator|->
name|last_queried
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ctime_r
argument_list|(
operator|&
name|tp
operator|->
name|autr
operator|->
name|last_success
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|log_info
argument_list|(
literal|"last_success: %u %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|tp
operator|->
name|autr
operator|->
name|last_success
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ctime_r
argument_list|(
operator|&
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove newline */
name|log_info
argument_list|(
literal|"next_probe_time: %u %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"query_interval: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|tp
operator|->
name|autr
operator|->
name|query_interval
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"retry_time: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|tp
operator|->
name|autr
operator|->
name|retry_time
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"query_failed: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|tp
operator|->
name|autr
operator|->
name|query_failed
argument_list|)
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|tp
operator|->
name|autr
operator|->
name|keys
init|;
name|ta
condition|;
name|ta
operator|=
name|ta
operator|->
name|next
control|)
block|{
name|autr_debug_print_ta
argument_list|(
name|ta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|autr_debug_print
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|tp
argument_list|,
argument|struct trust_anchor*
argument_list|,
argument|anchors->tree
argument_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|autr_debug_print_tp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|probe_answer_cb
argument_list|(
name|void
operator|*
name|arg
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|rcode
argument_list|)
argument_list|,
name|sldns_buffer
operator|*
name|ATTR_UNUSED
argument_list|(
name|buf
argument_list|)
argument_list|,
expr|enum
name|sec_status
name|ATTR_UNUSED
argument_list|(
name|sec
argument_list|)
argument_list|,
name|char
operator|*
name|ATTR_UNUSED
argument_list|(
name|why_bogus
argument_list|)
argument_list|)
block|{
comment|/* retry was set before the query was done, 	 * re-querytime is set when query succeeded, but that may not 	 * have reset this timer because the query could have been 	 * handled by another thread. In that case, this callback would 	 * get called after the original timeout is done.  	 * By not resetting the timer, it may probe more often, but not 	 * less often. 	 * Unless the new lookup resulted in smaller TTLs and thus smaller 	 * timeout values. In that case one old TTL could be mistakenly done. 	 */
name|struct
name|module_env
modifier|*
name|env
init|=
operator|(
expr|struct
name|module_env
operator|*
operator|)
name|arg
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust probe answer cb"
argument_list|)
expr_stmt|;
name|reset_worker_timer
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/** probe a trust anchor DNSKEY and unlocks tp */
end_comment

begin_function
specifier|static
name|void
name|probe_anchor
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|uint16_t
name|qflags
init|=
name|BIT_RD
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|sldns_buffer
modifier|*
name|buf
init|=
name|env
operator|->
name|scratch_buffer
decl_stmt|;
name|qinfo
operator|.
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
operator|->
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinfo
operator|.
name|qname
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory making 5011 probe"
argument_list|)
expr_stmt|;
return|return;
block|}
name|qinfo
operator|.
name|qname_len
operator|=
name|tp
operator|->
name|namelen
expr_stmt|;
name|qinfo
operator|.
name|qtype
operator|=
name|LDNS_RR_TYPE_DNSKEY
expr_stmt|;
name|qinfo
operator|.
name|qclass
operator|=
name|tp
operator|->
name|dclass
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust probe"
argument_list|,
operator|&
name|qinfo
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"retry probe set in %d seconds"
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|-
operator|(
name|int
operator|)
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
name|edns
operator|.
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|.
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|.
name|edns_version
operator|=
literal|0
expr_stmt|;
name|edns
operator|.
name|bits
operator|=
name|EDNS_DO
expr_stmt|;
name|edns
operator|.
name|opt_list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sldns_buffer_capacity
argument_list|(
name|buf
argument_list|)
operator|<
literal|65535
condition|)
name|edns
operator|.
name|udp_size
operator|=
operator|(
name|uint16_t
operator|)
name|sldns_buffer_capacity
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|edns
operator|.
name|udp_size
operator|=
literal|65535
expr_stmt|;
comment|/* can't hold the lock while mesh_run is processing */
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* delete the DNSKEY from rrset and key cache so an active probe 	 * is done. First the rrset so another thread does not use it 	 * to recreate the key entry in a race condition. */
name|rrset_cache_remove
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|qinfo
operator|.
name|qname
argument_list|,
name|qinfo
operator|.
name|qname_len
argument_list|,
name|qinfo
operator|.
name|qtype
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key_cache_remove
argument_list|(
name|env
operator|->
name|key_cache
argument_list|,
name|qinfo
operator|.
name|qname
argument_list|,
name|qinfo
operator|.
name|qname_len
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mesh_new_callback
argument_list|(
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|qinfo
argument_list|,
name|qflags
argument_list|,
operator|&
name|edns
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|probe_answer_cb
argument_list|,
name|env
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory making 5011 probe"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** fetch first to-probe trust-anchor and lock it and set retrytime */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|todo_probe
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|time_t
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
decl_stmt|;
name|rbnode_t
modifier|*
name|el
decl_stmt|;
comment|/* get first one */
name|lock_basic_lock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|el
operator|=
name|rbtree_first
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|)
operator|)
operator|==
name|RBTREE_NULL
condition|)
block|{
comment|/* in case of revoked anchors */
name|lock_basic_unlock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* signal that there are no anchors to probe */
operator|*
name|next
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tp
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|el
operator|->
name|key
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* is it eligible? */
if|if
condition|(
operator|(
name|time_t
operator|)
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|>
operator|*
name|env
operator|->
name|now
condition|)
block|{
comment|/* no more to probe */
operator|*
name|next
operator|=
operator|(
name|time_t
operator|)
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|-
operator|*
name|env
operator|->
name|now
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* reset its next probe time */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|autr
operator|->
name|next_probe_time
operator|=
name|calc_next_probe
argument_list|(
name|env
argument_list|,
name|tp
operator|->
name|autr
operator|->
name|retry_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|autr
operator|->
name|probe
argument_list|,
operator|&
name|tp
operator|->
name|autr
operator|->
name|pnode
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|env
operator|->
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_function
name|time_t
name|autr_probe_timer
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|tp
decl_stmt|;
name|time_t
name|next_probe
init|=
literal|3600
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|autr_permit_small_holddown
condition|)
name|next_probe
operator|=
literal|1
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust probe timer callback"
argument_list|)
expr_stmt|;
comment|/* while there are still anchors to probe */
while|while
condition|(
operator|(
name|tp
operator|=
name|todo_probe
argument_list|(
name|env
argument_list|,
operator|&
name|next_probe
argument_list|)
operator|)
condition|)
block|{
comment|/* make a probe for this anchor */
name|probe_anchor
argument_list|(
name|env
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
name|regional_free_all
argument_list|(
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_probe
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no trust points to probe */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"autotrust probe timer %d callbacks done"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|next_probe
return|;
block|}
end_function

end_unit

