begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/validator.c - secure validator DNS query response module  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains a module that performs validation of DNS queries.  * According to RFC 4034.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"validator/validator.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kcache.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kentry.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_utils.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec3.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_neg.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_sigcrypt.h"
end_include

begin_include
include|#
directive|include
file|"validator/autotrust.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_comment
comment|/* forward decl for cache response and normal super inform calls of a DS */
end_comment

begin_function_decl
specifier|static
name|void
name|process_ds_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|sock_list
modifier|*
name|origin
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** fill up nsec3 key iterations config entry */
end_comment

begin_function
specifier|static
name|int
name|fill_nsec3_iter
parameter_list|(
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|ve
operator|->
name|nsec3_keysize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ve
operator|->
name|nsec3_maxiter
argument_list|)
expr_stmt|;
name|ve
operator|->
name|nsec3_keysize
operator|=
operator|(
name|size_t
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|c
argument_list|)
expr_stmt|;
name|ve
operator|->
name|nsec3_maxiter
operator|=
operator|(
name|size_t
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ve
operator|->
name|nsec3_keysize
operator|||
operator|!
name|ve
operator|->
name|nsec3_maxiter
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
index|]
operator|=
operator|(
name|size_t
operator|)
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
name|e
expr_stmt|;
name|ve
operator|->
name|nsec3_maxiter
index|[
name|i
index|]
operator|=
operator|(
name|size_t
operator|)
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
index|]
condition|)
block|{
name|log_err
argument_list|(
literal|"nsec3 key iterations not ascending: %d %d"
argument_list|,
operator|(
name|int
operator|)
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator nsec3cfg keysz %d mxiter %d"
argument_list|,
operator|(
name|int
operator|)
name|ve
operator|->
name|nsec3_keysize
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|)
name|ve
operator|->
name|nsec3_maxiter
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** apply config settings to validator */
end_comment

begin_function
specifier|static
name|int
name|val_apply_cfg
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|val_env
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|val_env
operator|->
name|bogus_ttl
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|bogus_ttl
expr_stmt|;
name|val_env
operator|->
name|clean_additional
operator|=
name|cfg
operator|->
name|val_clean_additional
expr_stmt|;
name|val_env
operator|->
name|permissive_mode
operator|=
name|cfg
operator|->
name|val_permissive_mode
expr_stmt|;
if|if
condition|(
operator|!
name|env
operator|->
name|anchors
condition|)
name|env
operator|->
name|anchors
operator|=
name|anchors_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|env
operator|->
name|anchors
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|val_env
operator|->
name|kcache
condition|)
name|val_env
operator|->
name|kcache
operator|=
name|key_cache_create
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val_env
operator|->
name|kcache
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|env
operator|->
name|key_cache
operator|=
name|val_env
operator|->
name|kcache
expr_stmt|;
if|if
condition|(
operator|!
name|anchors_apply_cfg
argument_list|(
name|env
operator|->
name|anchors
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"validator: error in trustanchors config"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val_env
operator|->
name|date_override
operator|=
name|cfg
operator|->
name|val_date_override
expr_stmt|;
name|val_env
operator|->
name|skew_min
operator|=
name|cfg
operator|->
name|val_sig_skew_min
expr_stmt|;
name|val_env
operator|->
name|skew_max
operator|=
name|cfg
operator|->
name|val_sig_skew_max
expr_stmt|;
name|c
operator|=
name|cfg_count_numbers
argument_list|(
name|cfg
operator|->
name|val_nsec3_key_iterations
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|1
operator|||
operator|(
name|c
operator|&
literal|1
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"validator: unparseable or odd nsec3 key "
literal|"iterations: %s"
argument_list|,
name|cfg
operator|->
name|val_nsec3_key_iterations
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val_env
operator|->
name|nsec3_keyiter_count
operator|=
name|c
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|fill_nsec3_iter
argument_list|(
name|val_env
argument_list|,
name|cfg
operator|->
name|val_nsec3_key_iterations
argument_list|,
name|c
operator|/
literal|2
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"validator: cannot apply nsec3 key iterations"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|val_env
operator|->
name|neg_cache
condition|)
name|val_env
operator|->
name|neg_cache
operator|=
name|val_neg_create
argument_list|(
name|cfg
argument_list|,
name|val_env
operator|->
name|nsec3_maxiter
index|[
name|val_env
operator|->
name|nsec3_keyiter_count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val_env
operator|->
name|neg_cache
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|env
operator|->
name|neg_cache
operator|=
name|val_env
operator|->
name|neg_cache
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|val_init
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|val_env
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|val_env
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|val_env
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|val_env
expr_stmt|;
name|env
operator|->
name|need_to_validate
operator|=
literal|1
expr_stmt|;
name|val_env
operator|->
name|permissive_mode
operator|=
literal|0
expr_stmt|;
name|lock_basic_init
argument_list|(
operator|&
name|val_env
operator|->
name|bogus_lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|val_env
operator|->
name|bogus_lock
argument_list|,
operator|&
name|val_env
operator|->
name|num_rrset_bogus
argument_list|,
sizeof|sizeof
argument_list|(
name|val_env
operator|->
name|num_rrset_bogus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val_apply_cfg
argument_list|(
name|env
argument_list|,
name|val_env
argument_list|,
name|env
operator|->
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"validator: could not apply configuration settings."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|val_deinit
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|val_env
decl_stmt|;
if|if
condition|(
operator|!
name|env
operator|||
operator|!
name|env
operator|->
name|modinfo
index|[
name|id
index|]
condition|)
return|return;
name|val_env
operator|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
expr_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|val_env
operator|->
name|bogus_lock
argument_list|)
expr_stmt|;
name|anchors_delete
argument_list|(
name|env
operator|->
name|anchors
argument_list|)
expr_stmt|;
name|env
operator|->
name|anchors
operator|=
name|NULL
expr_stmt|;
name|key_cache_delete
argument_list|(
name|val_env
operator|->
name|kcache
argument_list|)
expr_stmt|;
name|neg_cache_delete
argument_list|(
name|val_env
operator|->
name|neg_cache
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_env
operator|->
name|nsec3_keysize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_env
operator|->
name|nsec3_maxiter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_env
argument_list|)
expr_stmt|;
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/** fill in message structure */
end_comment

begin_function
specifier|static
name|struct
name|val_qstate
modifier|*
name|val_new_getmsg
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qstate
operator|->
name|return_msg
operator|||
name|qstate
operator|->
name|return_rcode
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
comment|/* create a message to verify */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"constructing reply for validation"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|orig_msg
condition|)
return|return
name|NULL
return|;
name|vq
operator|->
name|orig_msg
operator|->
name|qinfo
operator|=
name|qstate
operator|->
name|qinfo
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|orig_msg
operator|->
name|rep
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
argument_list|)
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|flags
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|qstate
operator|->
name|return_rcode
operator|&
literal|0xf
argument_list|)
operator||
name|BIT_QR
operator||
name|BIT_RA
operator||
operator|(
name|qstate
operator|->
name|query_flags
operator||
operator|(
name|BIT_CD
operator||
name|BIT_RD
operator|)
operator|)
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|qdcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vq
operator|->
name|orig_msg
operator|=
name|qstate
operator|->
name|return_msg
expr_stmt|;
block|}
name|vq
operator|->
name|qchase
operator|=
name|qstate
operator|->
name|qinfo
expr_stmt|;
comment|/* chase reply will be an edited (sub)set of the orig msg rrset ptrs */
name|vq
operator|->
name|chase_reply
operator|=
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|chase_reply
condition|)
return|return
name|NULL
return|;
name|vq
operator|->
name|chase_reply
operator|->
name|rrsets
operator|=
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|chase_reply
operator|->
name|rrsets
condition|)
return|return
name|NULL
return|;
name|vq
operator|->
name|rrset_skip
operator|=
literal|0
expr_stmt|;
return|return
name|vq
return|;
block|}
end_function

begin_comment
comment|/** allocate new validator query state */
end_comment

begin_function
specifier|static
name|struct
name|val_qstate
modifier|*
name|val_new
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|val_qstate
modifier|*
name|vq
init|=
operator|(
expr|struct
name|val_qstate
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vq
argument_list|)
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
operator|!
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|vq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vq
argument_list|)
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|vq
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
return|return
name|val_new_getmsg
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Exit validation with an error status  *   * @param qstate: query state  * @param id: validator id.  * @return false, for use by caller to return to stop processing.  */
end_comment

begin_function
specifier|static
name|int
name|val_error
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_error
expr_stmt|;
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * Check to see if a given response needs to go through the validation  * process. Typical reasons for this routine to return false are: CD bit was  * on in the original request, or the response is a kind of message that   * is unvalidatable (i.e., SERVFAIL, REFUSED, etc.)  *  * @param qstate: query state.  * @param ret_rc: rcode for this message (if noerror - examine ret_msg).  * @param ret_msg: return msg, can be NULL; look at rcode instead.  * @return true if the response could use validation (although this does not  *         mean we can actually validate this response).  */
end_comment

begin_function
specifier|static
name|int
name|needs_validation
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|ret_rc
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|ret_msg
parameter_list|)
block|{
name|int
name|rcode
decl_stmt|;
comment|/* If the CD bit is on in the original request, then we don't bother to 	 * validate anything.*/
if|if
condition|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"not validating response due to CD bit"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ret_rc
operator|!=
name|LDNS_RCODE_NOERROR
operator|||
operator|!
name|ret_msg
condition|)
name|rcode
operator|=
name|ret_rc
expr_stmt|;
else|else
name|rcode
operator|=
operator|(
name|int
operator|)
name|FLAGS_GET_RCODE
argument_list|(
name|ret_msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|LDNS_RCODE_NOERROR
operator|&&
name|rcode
operator|!=
name|LDNS_RCODE_NXDOMAIN
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
block|{
name|char
name|rc
index|[
literal|16
index|]
decl_stmt|;
name|rc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sldns_wire2str_rcode_buf
argument_list|(
name|rcode
argument_list|,
name|rc
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cannot validate non-answer, rcode %s"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* cannot validate positive RRSIG response. (negatives can) */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|&&
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
name|ret_msg
operator|&&
name|ret_msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|>
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cannot validate RRSIG, no sigs on sigs."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check to see if the response has already been validated.  * @param ret_msg: return msg, can be NULL  * @return true if the response has already been validated  */
end_comment

begin_function
specifier|static
name|int
name|already_validated
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|ret_msg
parameter_list|)
block|{
comment|/* validate unchecked, and re-validate bogus messages */
if|if
condition|(
name|ret_msg
operator|&&
name|ret_msg
operator|->
name|rep
operator|->
name|security
operator|>
name|sec_status_bogus
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"response has already been validated: %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|ret_msg
operator|->
name|rep
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Generate a request for DNS data.  *  * @param qstate: query state that is the parent.  * @param id: module id.  * @param name: what name to query for.  * @param namelen: length of name.  * @param qtype: query type.  * @param qclass: query class.  * @param flags: additional flags, such as the CD bit (BIT_CD), or 0.  * @return false on alloc failure.  */
end_comment

begin_function
specifier|static
name|int
name|generate_request
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|struct
name|val_qstate
modifier|*
name|vq
init|=
operator|(
expr|struct
name|val_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|newq
decl_stmt|;
name|struct
name|query_info
name|ask
decl_stmt|;
name|ask
operator|.
name|qname
operator|=
name|name
expr_stmt|;
name|ask
operator|.
name|qname_len
operator|=
name|namelen
expr_stmt|;
name|ask
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|ask
operator|.
name|qclass
operator|=
name|qclass
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"generate request"
argument_list|,
operator|&
name|ask
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_attach_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|attach_sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|attach_sub
call|)
argument_list|(
name|qstate
argument_list|,
operator|&
name|ask
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|BIT_RD
operator||
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|newq
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not generate request: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* newq; validator does not need state created for that 	 * query, and its a 'normal' for iterator as well */
if|if
condition|(
name|newq
condition|)
block|{
comment|/* add our blacklist to the query blacklist */
name|sock_list_merge
argument_list|(
operator|&
name|newq
operator|->
name|blacklist
argument_list|,
name|newq
operator|->
name|region
argument_list|,
name|vq
operator|->
name|chain_blacklist
argument_list|)
expr_stmt|;
block|}
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Prime trust anchor for use.  * Generate and dispatch a priming query for the given trust anchor.  * The trust anchor can be DNSKEY or DS and does not have to be signed.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param id: module id.  * @param toprime: what to prime.  * @return false on a processing error.  */
end_comment

begin_function
specifier|static
name|int
name|prime_trust_anchor
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|toprime
parameter_list|)
block|{
name|int
name|ret
init|=
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|toprime
operator|->
name|name
argument_list|,
name|toprime
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|toprime
operator|->
name|dclass
argument_list|,
name|BIT_CD
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not prime trust anchor: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ignore newq; validator does not need state created for that 	 * query, and its a 'normal' for iterator as well */
name|vq
operator|->
name|wait_prime_ta
operator|=
literal|1
expr_stmt|;
comment|/* to elicit PRIME_RESP_STATE processing  		from the validator inform_super() routine */
comment|/* store trust anchor name for later lookup when prime returns */
name|vq
operator|->
name|trust_anchor_name
operator|=
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|toprime
operator|->
name|name
argument_list|,
name|toprime
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|vq
operator|->
name|trust_anchor_len
operator|=
name|toprime
operator|->
name|namelen
expr_stmt|;
name|vq
operator|->
name|trust_anchor_labs
operator|=
name|toprime
operator|->
name|namelabs
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|trust_anchor_name
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not prime trust anchor: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Validate if the ANSWER and AUTHORITY sections contain valid rrsets.  * They must be validly signed with the given key.  * Tries to validate ADDITIONAL rrsets as well, but only to check them.  * Allows unsigned CNAME after a DNAME that expands the DNAME.  *   * Note that by the time this method is called, the process of finding the  * trusted DNSKEY rrset that signs this response must already have been  * completed.  *   * @param qstate: query state.  * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to validate.  * @param key_entry: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  * @return false if any of the rrsets in the an or ns sections of the message   * 	fail to verify. The message is then set to bogus.  */
end_comment

begin_function
specifier|static
name|int
name|validate_msg_signatures
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|key_entry
parameter_list|)
block|{
name|uint8_t
modifier|*
name|sname
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|slen
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
name|int
name|dname_seen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
comment|/* validate the ANSWER section */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip the CNAME following a (validated) DNAME. 		 * Because of the normalization routines in the iterator,  		 * there will always be an unsigned CNAME following a DNAME  		 * (unless qtype=DNAME). */
if|if
condition|(
name|dname_seen
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
name|dname_seen
operator|=
literal|0
expr_stmt|;
comment|/* CNAME was synthesized by our own iterator */
comment|/* since the DNAME verified, mark the CNAME as secure */
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|s
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|s
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|trust
operator|=
name|rrset_trust_validated
expr_stmt|;
continue|continue;
block|}
comment|/* Verify the answer rrset */
name|sec
operator|=
name|val_verify_rrset_entry
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|s
argument_list|,
name|key_entry
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
comment|/* If the (answer) rrset failed to validate, then this  		 * message is BAD. */
if|if
condition|(
name|sec
operator|!=
name|sec_status_secure
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"validator: response "
literal|"has failed ANSWER rrset:"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"for CNAME"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
condition|)
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"for DNAME"
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Notice a DNAME that should be followed by an unsigned  		 * CNAME. */
if|if
condition|(
name|qchase
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DNAME
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
condition|)
block|{
name|dname_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* validate the AUTHORITY section */
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|sec
operator|=
name|val_verify_rrset_entry
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|s
argument_list|,
name|key_entry
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
comment|/* If anything in the authority section fails to be secure,  		 * we have a bad message. */
if|if
condition|(
name|sec
operator|!=
name|sec_status_secure
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"validator: response "
literal|"has failed AUTHORITY rrset:"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|errinf_rrset
argument_list|(
name|qstate
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* attempt to validate the ADDITIONAL section rrsets */
if|if
condition|(
operator|!
name|ve
operator|->
name|clean_additional
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* only validate rrs that have signatures with the key */
comment|/* leave others unchecked, those get removed later on too */
name|val_find_rrset_signer
argument_list|(
name|s
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|&&
name|query_dname_compare
argument_list|(
name|sname
argument_list|,
name|key_entry
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|val_verify_rrset_entry
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|s
argument_list|,
name|key_entry
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
comment|/* the additional section can fail to be secure,  		 * it is optional, check signature in case we need 		 * to clean the additional section later. */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Detect wrong truncated response (say from BIND 9.6.1 that is forwarding  * and saw the NS record without signatures from a referral).  * The positive response has a mangled authority section.  * Remove that authority section and the additional section.  * @param rep: reply  * @return true if a wrongly truncated response.  */
end_comment

begin_function
specifier|static
name|int
name|detect_wrongly_truncated
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* only NS in authority, and it is bogus */
if|if
condition|(
name|rep
operator|->
name|ns_numrrsets
operator|!=
literal|1
operator|||
name|rep
operator|->
name|an_numrrsets
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|rep
operator|->
name|an_numrrsets
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NS
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|rep
operator|->
name|an_numrrsets
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
return|return
literal|0
return|;
comment|/* answer section is present and secure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"truncating to minimal response"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Given a "positive" response -- a response that contains an answer to the  * question, and no CNAME chain, validate this response.   *  * The answer and authority RRsets must already be verified as secure.  *   * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to that query to validate.  * @param kkey: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  */
end_comment

begin_function
specifier|static
name|void
name|validate_positive_response
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
name|uint8_t
modifier|*
name|wc
init|=
name|NULL
decl_stmt|;
name|int
name|wc_NSEC_ok
init|=
literal|0
decl_stmt|;
name|int
name|nsec3s_seen
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
comment|/* validate the ANSWER section - this will be the answer itself */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* Check to see if the rrset is the result of a wildcard  		 * expansion. If so, an additional check will need to be  		 * made in the authority section. */
if|if
condition|(
operator|!
name|val_rrset_wildcard
argument_list|(
name|s
argument_list|,
operator|&
name|wc
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Positive response has "
literal|"inconsistent wildcard sigs:"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
block|}
comment|/* validate the AUTHORITY section as well - this will generally be  	 * the NS rrset (which could be missing, no problem) */
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* If this is a positive wildcard response, and we have a  		 * (just verified) NSEC record, try to use it to 1) prove  		 * that qname doesn't exist and 2) that the correct wildcard  		 * was used. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
if|if
condition|(
name|val_nsec_proves_positive_wildcard
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|,
name|wc
argument_list|)
condition|)
block|{
name|wc_NSEC_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if not, continue looking for proof */
block|}
comment|/* Otherwise, if this is a positive wildcard response and  		 * we have NSEC3 records */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|nsec3s_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this was a positive wildcard response that we haven't already 	 * proven, and we have NSEC3 records, try to prove it using the NSEC3 	 * records. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
operator|!
name|wc_NSEC_ok
operator|&&
name|nsec3s_seen
condition|)
block|{
name|enum
name|sec_status
name|sec
init|=
name|nsec3_prove_wildcard
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|chase_reply
operator|->
name|rrsets
operator|+
name|chase_reply
operator|->
name|an_numrrsets
argument_list|,
name|chase_reply
operator|->
name|ns_numrrsets
argument_list|,
name|qchase
argument_list|,
name|kkey
argument_list|,
name|wc
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Positive wildcard response is "
literal|"insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
name|wc_NSEC_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If after all this, we still haven't proven the positive wildcard 	 * response, fail. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
operator|!
name|wc_NSEC_ok
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"positive response was wildcard "
literal|"expansion and did not prove original data "
literal|"did not exist"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Successfully validated positive response"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Validate a NOERROR/NODATA signed response -- a response that has a  * NOERROR Rcode but no ANSWER section RRsets. This consists of making   * certain that the authority section NSEC/NSEC3s proves that the qname   * does exist and the qtype doesn't.  *  * The answer and authority RRsets must already be verified as secure.  *  * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to that query to validate.  * @param kkey: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  */
end_comment

begin_function
specifier|static
name|void
name|validate_nodata_response
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
comment|/* Since we are here, there must be nothing in the ANSWER section to 	 * validate. */
comment|/* (Note: CNAME/DNAME responses will not directly get here -- 	 * instead, they are chased down into indiviual CNAME validations, 	 * and at the end of the cname chain a POSITIVE, or CNAME_NOANSWER  	 * validation.) */
comment|/* validate the AUTHORITY section */
name|int
name|has_valid_nsec
init|=
literal|0
decl_stmt|;
comment|/* If true, then the NODATA has been proven.*/
name|uint8_t
modifier|*
name|ce
init|=
name|NULL
decl_stmt|;
comment|/* for wildcard nodata responses. This is the  				proven closest encloser. */
name|uint8_t
modifier|*
name|wc
init|=
name|NULL
decl_stmt|;
comment|/* for wildcard nodata responses. wildcard nsec */
name|int
name|nsec3s_seen
init|=
literal|0
decl_stmt|;
comment|/* nsec3s seen */
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* If we encounter an NSEC record, try to use it to prove  		 * NODATA. 		 * This needs to handle the ENT NODATA case. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
if|if
condition|(
name|nsec_proves_nodata
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|,
operator|&
name|wc
argument_list|)
condition|)
block|{
name|has_valid_nsec
operator|=
literal|1
expr_stmt|;
comment|/* sets wc-encloser if wildcard applicable */
block|}
if|if
condition|(
name|val_nsec_proves_name_error
argument_list|(
name|s
argument_list|,
name|qchase
operator|->
name|qname
argument_list|)
condition|)
block|{
name|ce
operator|=
name|nsec_closest_encloser
argument_list|(
name|qchase
operator|->
name|qname
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val_nsec_proves_insecuredelegation
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"delegation is insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|nsec3s_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* check to see if we have a wildcard NODATA proof. */
comment|/* The wildcard NODATA is 1 NSEC proving that qname does not exist  	 * (and also proving what the closest encloser is), and 1 NSEC  	 * showing the matching wildcard, which must be *.closest_encloser. */
if|if
condition|(
name|wc
operator|&&
operator|!
name|ce
condition|)
name|has_valid_nsec
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|&&
name|ce
condition|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|wc
argument_list|,
name|ce
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|has_valid_nsec
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|has_valid_nsec
operator|&&
name|nsec3s_seen
condition|)
block|{
name|enum
name|sec_status
name|sec
init|=
name|nsec3_prove_nodata
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|chase_reply
operator|->
name|rrsets
operator|+
name|chase_reply
operator|->
name|an_numrrsets
argument_list|,
name|chase_reply
operator|->
name|ns_numrrsets
argument_list|,
name|qchase
argument_list|,
name|kkey
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"NODATA response is insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
name|has_valid_nsec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_valid_nsec
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"NODATA response failed to prove NODATA "
literal|"status with NSEC/NSEC3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"Failed NODATA"
argument_list|,
name|qchase
argument_list|,
name|chase_reply
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"successfully validated NODATA response."
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Validate a NAMEERROR signed response -- a response that has a NXDOMAIN  * Rcode.   * This consists of making certain that the authority section NSEC proves   * that the qname doesn't exist and the covering wildcard also doesn't exist..  *   * The answer and authority RRsets must have already been verified as secure.  *  * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to that query to validate.  * @param kkey: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  * @param rcode: adjusted RCODE, in case of RCODE/proof mismatch leniency.  */
end_comment

begin_function
specifier|static
name|void
name|validate_nameerror_response
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|int
modifier|*
name|rcode
parameter_list|)
block|{
name|int
name|has_valid_nsec
init|=
literal|0
decl_stmt|;
name|int
name|has_valid_wnsec
init|=
literal|0
decl_stmt|;
name|int
name|nsec3s_seen
init|=
literal|0
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
if|if
condition|(
name|val_nsec_proves_name_error
argument_list|(
name|s
argument_list|,
name|qchase
operator|->
name|qname
argument_list|)
condition|)
name|has_valid_nsec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val_nsec_proves_no_wc
argument_list|(
name|s
argument_list|,
name|qchase
operator|->
name|qname
argument_list|,
name|qchase
operator|->
name|qname_len
argument_list|)
condition|)
name|has_valid_wnsec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val_nsec_proves_insecuredelegation
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"delegation is insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
name|nsec3s_seen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|has_valid_nsec
operator|||
operator|!
name|has_valid_wnsec
operator|)
operator|&&
name|nsec3s_seen
condition|)
block|{
comment|/* use NSEC3 proof, both answer and auth rrsets, in case 		 * NSEC3s end up in the answer (due to qtype=NSEC3 or so) */
name|chase_reply
operator|->
name|security
operator|=
name|nsec3_prove_nameerror
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|chase_reply
operator|->
name|rrsets
argument_list|,
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
argument_list|,
name|qchase
argument_list|,
name|kkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_reply
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"NameError response failed nsec, "
literal|"nsec3 proof was %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|has_valid_nsec
operator|=
literal|1
expr_stmt|;
name|has_valid_wnsec
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the message fails to prove either condition, it is bogus. */
if|if
condition|(
operator|!
name|has_valid_nsec
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"NameError response has failed to prove: "
literal|"qname does not exist"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
comment|/* Be lenient with RCODE in NSEC NameError responses */
name|validate_nodata_response
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|qchase
argument_list|,
name|chase_reply
argument_list|,
name|kkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_reply
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
operator|*
name|rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|has_valid_wnsec
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"NameError response has failed to prove: "
literal|"covering wildcard does not exist"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
comment|/* Be lenient with RCODE in NSEC NameError responses */
name|validate_nodata_response
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|qchase
argument_list|,
name|chase_reply
argument_list|,
name|kkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_reply
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
operator|*
name|rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, we consider the message secure. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"successfully validated NAME ERROR response."
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Given a referral response, validate rrsets and take least trusted rrset  * as the current validation status.  *   * Note that by the time this method is called, the process of finding the  * trusted DNSKEY rrset that signs this response must already have been  * completed.  *   * @param chase_reply: answer to validate.  */
end_comment

begin_function
specifier|static
name|void
name|validate_referral_response
parameter_list|(
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|enum
name|sec_status
name|s
decl_stmt|;
comment|/* message security equals lowest rrset security */
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chase_reply
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|chase_reply
operator|->
name|security
condition|)
name|chase_reply
operator|->
name|security
operator|=
name|s
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validated part of referral response as %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Given an "ANY" response -- a response that contains an answer to a  * qtype==ANY question, with answers. This does no checking that all   * types are present.  *   * NOTE: it may be possible to get parent-side delegation point records  * here, which won't all be signed. Right now, this routine relies on the  * upstream iterative resolver to not return these responses -- instead  * treating them as referrals.  *   * NOTE: RFC 4035 is silent on this issue, so this may change upon  * clarification. Clarification draft -05 says to not check all types are  * present.  *   * Note that by the time this method is called, the process of finding the  * trusted DNSKEY rrset that signs this response must already have been  * completed.  *   * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to that query to validate.  * @param kkey: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  */
end_comment

begin_function
specifier|static
name|void
name|validate_any_response
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
comment|/* all answer and auth rrsets already verified */
comment|/* but check if a wildcard response is given, then check NSEC/NSEC3 	 * for qname denial to see if wildcard is applicable */
name|uint8_t
modifier|*
name|wc
init|=
name|NULL
decl_stmt|;
name|int
name|wc_NSEC_ok
init|=
literal|0
decl_stmt|;
name|int
name|nsec3s_seen
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|qchase
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_ANY
condition|)
block|{
name|log_err
argument_list|(
literal|"internal error: ANY validation called for non-ANY"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
comment|/* validate the ANSWER section - this will be the answer itself */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* Check to see if the rrset is the result of a wildcard  		 * expansion. If so, an additional check will need to be  		 * made in the authority section. */
if|if
condition|(
operator|!
name|val_rrset_wildcard
argument_list|(
name|s
argument_list|,
operator|&
name|wc
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Positive ANY response"
literal|" has inconsistent wildcard sigs:"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
block|}
comment|/* if it was a wildcard, check for NSEC/NSEC3s in both answer 	 * and authority sections (NSEC may be moved to the ANSWER section) */
if|if
condition|(
name|wc
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* If this is a positive wildcard response, and we have a  		 * (just verified) NSEC record, try to use it to 1) prove  		 * that qname doesn't exist and 2) that the correct wildcard  		 * was used. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
if|if
condition|(
name|val_nsec_proves_positive_wildcard
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|,
name|wc
argument_list|)
condition|)
block|{
name|wc_NSEC_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if not, continue looking for proof */
block|}
comment|/* Otherwise, if this is a positive wildcard response and  		 * we have NSEC3 records */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|nsec3s_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this was a positive wildcard response that we haven't already 	 * proven, and we have NSEC3 records, try to prove it using the NSEC3 	 * records. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
operator|!
name|wc_NSEC_ok
operator|&&
name|nsec3s_seen
condition|)
block|{
comment|/* look both in answer and auth section for NSEC3s */
name|enum
name|sec_status
name|sec
init|=
name|nsec3_prove_wildcard
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|chase_reply
operator|->
name|rrsets
argument_list|,
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
argument_list|,
name|qchase
argument_list|,
name|kkey
argument_list|,
name|wc
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Positive ANY wildcard response is "
literal|"insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
name|wc_NSEC_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If after all this, we still haven't proven the positive wildcard 	 * response, fail. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
operator|!
name|wc_NSEC_ok
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"positive ANY response was wildcard "
literal|"expansion and did not prove original data "
literal|"did not exist"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Successfully validated positive ANY response"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Validate CNAME response, or DNAME+CNAME.  * This is just like a positive proof, except that this is about a   * DNAME+CNAME. Possible wildcard proof.  * Difference with positive proof is that this routine refuses   * wildcarded DNAMEs.  *   * The answer and authority rrsets must already be verified as secure.  *   * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to that query to validate.  * @param kkey: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  */
end_comment

begin_function
specifier|static
name|void
name|validate_cname_response
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
name|uint8_t
modifier|*
name|wc
init|=
name|NULL
decl_stmt|;
name|int
name|wc_NSEC_ok
init|=
literal|0
decl_stmt|;
name|int
name|nsec3s_seen
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
comment|/* validate the ANSWER section - this will be the CNAME (+DNAME) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* Check to see if the rrset is the result of a wildcard  		 * expansion. If so, an additional check will need to be  		 * made in the authority section. */
if|if
condition|(
operator|!
name|val_rrset_wildcard
argument_list|(
name|s
argument_list|,
operator|&
name|wc
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Cname response has "
literal|"inconsistent wildcard sigs:"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
comment|/* Refuse wildcarded DNAMEs rfc 4597.  		 * Do not follow a wildcarded DNAME because  		 * its synthesized CNAME expansion is underdefined */
if|if
condition|(
name|qchase
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DNAME
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
operator|&&
name|wc
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"cannot validate a "
literal|"wildcarded DNAME:"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
comment|/* If we have found a CNAME, stop looking for one. 		 * The iterator has placed the CNAME chain in correct 		 * order. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
break|break;
block|}
block|}
comment|/* AUTHORITY section */
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* If this is a positive wildcard response, and we have a  		 * (just verified) NSEC record, try to use it to 1) prove  		 * that qname doesn't exist and 2) that the correct wildcard  		 * was used. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
if|if
condition|(
name|val_nsec_proves_positive_wildcard
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|,
name|wc
argument_list|)
condition|)
block|{
name|wc_NSEC_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if not, continue looking for proof */
block|}
comment|/* Otherwise, if this is a positive wildcard response and  		 * we have NSEC3 records */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|nsec3s_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this was a positive wildcard response that we haven't already 	 * proven, and we have NSEC3 records, try to prove it using the NSEC3 	 * records. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
operator|!
name|wc_NSEC_ok
operator|&&
name|nsec3s_seen
condition|)
block|{
name|enum
name|sec_status
name|sec
init|=
name|nsec3_prove_wildcard
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|chase_reply
operator|->
name|rrsets
operator|+
name|chase_reply
operator|->
name|an_numrrsets
argument_list|,
name|chase_reply
operator|->
name|ns_numrrsets
argument_list|,
name|qchase
argument_list|,
name|kkey
argument_list|,
name|wc
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"wildcard CNAME response is "
literal|"insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
name|wc_NSEC_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If after all this, we still haven't proven the positive wildcard 	 * response, fail. */
if|if
condition|(
name|wc
operator|!=
name|NULL
operator|&&
operator|!
name|wc_NSEC_ok
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"CNAME response was wildcard "
literal|"expansion and did not prove original data "
literal|"did not exist"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Successfully validated CNAME response"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Validate CNAME NOANSWER response, no more data after a CNAME chain.  * This can be a NODATA or a NAME ERROR case, but not both at the same time.  * We don't know because the rcode has been set to NOERROR by the CNAME.  *   * The answer and authority rrsets must already be verified as secure.  *   * @param env: module env for verify.  * @param ve: validator env for verify.  * @param qchase: query that was made.  * @param chase_reply: answer to that query to validate.  * @param kkey: the key entry, which is trusted, and which matches  * 	the signer of the answer. The key entry isgood().  */
end_comment

begin_function
specifier|static
name|void
name|validate_cname_noanswer_response
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qchase
parameter_list|,
name|struct
name|reply_info
modifier|*
name|chase_reply
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|)
block|{
name|int
name|nodata_valid_nsec
init|=
literal|0
decl_stmt|;
comment|/* If true, then NODATA has been proven.*/
name|uint8_t
modifier|*
name|ce
init|=
name|NULL
decl_stmt|;
comment|/* for wildcard nodata responses. This is the  				proven closest encloser. */
name|uint8_t
modifier|*
name|wc
init|=
name|NULL
decl_stmt|;
comment|/* for wildcard nodata responses. wildcard nsec */
name|int
name|nxdomain_valid_nsec
init|=
literal|0
decl_stmt|;
comment|/* if true, namerror has been proven */
name|int
name|nxdomain_valid_wnsec
init|=
literal|0
decl_stmt|;
name|int
name|nsec3s_seen
init|=
literal|0
decl_stmt|;
comment|/* nsec3s seen */
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* the AUTHORITY section */
for|for
control|(
name|i
operator|=
name|chase_reply
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|chase_reply
operator|->
name|an_numrrsets
operator|+
name|chase_reply
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chase_reply
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* If we encounter an NSEC record, try to use it to prove  		 * NODATA. This needs to handle the ENT NODATA case.  		 * Also try to prove NAMEERROR, and absence of a wildcard */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
if|if
condition|(
name|nsec_proves_nodata
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|,
operator|&
name|wc
argument_list|)
condition|)
block|{
name|nodata_valid_nsec
operator|=
literal|1
expr_stmt|;
comment|/* set wc encloser if wildcard applicable */
block|}
if|if
condition|(
name|val_nsec_proves_name_error
argument_list|(
name|s
argument_list|,
name|qchase
operator|->
name|qname
argument_list|)
condition|)
block|{
name|ce
operator|=
name|nsec_closest_encloser
argument_list|(
name|qchase
operator|->
name|qname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|nxdomain_valid_nsec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val_nsec_proves_no_wc
argument_list|(
name|s
argument_list|,
name|qchase
operator|->
name|qname
argument_list|,
name|qchase
operator|->
name|qname_len
argument_list|)
condition|)
name|nxdomain_valid_wnsec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val_nsec_proves_insecuredelegation
argument_list|(
name|s
argument_list|,
name|qchase
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"delegation is insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|nsec3s_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* check to see if we have a wildcard NODATA proof. */
comment|/* The wildcard NODATA is 1 NSEC proving that qname does not exists  	 * (and also proving what the closest encloser is), and 1 NSEC  	 * showing the matching wildcard, which must be *.closest_encloser. */
if|if
condition|(
name|wc
operator|&&
operator|!
name|ce
condition|)
name|nodata_valid_nsec
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|&&
name|ce
condition|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|wc
argument_list|,
name|ce
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nodata_valid_nsec
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nxdomain_valid_nsec
operator|&&
operator|!
name|nxdomain_valid_wnsec
condition|)
block|{
comment|/* name error is missing wildcard denial proof */
name|nxdomain_valid_nsec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nodata_valid_nsec
operator|&&
name|nxdomain_valid_nsec
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"CNAMEchain to noanswer proves that name "
literal|"exists and not exists, bogus"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|nodata_valid_nsec
operator|&&
operator|!
name|nxdomain_valid_nsec
operator|&&
name|nsec3s_seen
condition|)
block|{
name|int
name|nodata
decl_stmt|;
name|enum
name|sec_status
name|sec
init|=
name|nsec3_prove_nxornodata
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|chase_reply
operator|->
name|rrsets
operator|+
name|chase_reply
operator|->
name|an_numrrsets
argument_list|,
name|chase_reply
operator|->
name|ns_numrrsets
argument_list|,
name|qchase
argument_list|,
name|kkey
argument_list|,
operator|&
name|nodata
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"CNAMEchain to noanswer response "
literal|"is insecure"
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
if|if
condition|(
name|nodata
condition|)
name|nodata_valid_nsec
operator|=
literal|1
expr_stmt|;
else|else
name|nxdomain_valid_nsec
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nodata_valid_nsec
operator|&&
operator|!
name|nxdomain_valid_nsec
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"CNAMEchain to noanswer response failed "
literal|"to prove status with NSEC/NSEC3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"Failed CNAMEnoanswer"
argument_list|,
name|qchase
argument_list|,
name|chase_reply
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nodata_valid_nsec
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"successfully validated CNAME chain to a "
literal|"NODATA response."
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"successfully validated CNAME chain to a "
literal|"NAMEERROR response."
argument_list|)
expr_stmt|;
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_secure
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Process init state for validator.  * Process the INIT state. First tier responses start in the INIT state.  * This is where they are vetted for validation suitability, and the initial  * key search is done.  *   * Currently, events the come through this routine will be either promoted  * to FINISHED/CNAME_RESP (no validation needed), FINDKEY (next step to  * validation), or will be (temporarily) retired and a new priming request  * event will be generated.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param ve: validator shared global environment.  * @param id: module id.  * @return true if the event should be processed further on return, false if  *         not.  */
end_comment

begin_function
specifier|static
name|int
name|processInit
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|lookup_name
decl_stmt|;
name|size_t
name|lookup_len
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|anchor
decl_stmt|;
name|enum
name|val_classification
name|subtype
init|=
name|val_classify_response
argument_list|(
name|qstate
operator|->
name|query_flags
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|rrset_skip
argument_list|)
decl_stmt|;
if|if
condition|(
name|vq
operator|->
name|restart_count
operator|>
name|VAL_MAX_RESTART_COUNT
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"restart count exceeded"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator classification %s"
argument_list|,
name|val_classification_to_string
argument_list|(
name|subtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_REFERRAL
operator|&&
name|vq
operator|->
name|rrset_skip
operator|<
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrset_count
condition|)
block|{
comment|/* referral uses the rrset name as qchase, to find keys for 		 * that rrset */
name|vq
operator|->
name|qchase
operator|.
name|qname
operator|=
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|vq
operator|->
name|rrset_skip
index|]
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|vq
operator|->
name|qchase
operator|.
name|qname_len
operator|=
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|vq
operator|->
name|rrset_skip
index|]
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
name|vq
operator|->
name|qchase
operator|.
name|qtype
operator|=
name|ntohs
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|vq
operator|->
name|rrset_skip
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
expr_stmt|;
name|vq
operator|->
name|qchase
operator|.
name|qclass
operator|=
name|ntohs
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|vq
operator|->
name|rrset_skip
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
expr_stmt|;
block|}
name|lookup_name
operator|=
name|vq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
name|lookup_len
operator|=
name|vq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
comment|/* for type DS look at the parent side for keys/trustanchor */
comment|/* also for NSEC not at apex */
if|if
condition|(
name|vq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|||
operator|(
name|vq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_NSEC
operator|&&
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrset_count
operator|>
name|vq
operator|->
name|rrset_skip
operator|&&
name|ntohs
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|vq
operator|->
name|rrset_skip
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|&&
operator|!
operator|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|vq
operator|->
name|rrset_skip
index|]
operator|->
name|rk
operator|.
name|flags
operator|&
name|PACKED_RRSET_NSEC_AT_APEX
operator|)
operator|)
condition|)
block|{
name|dname_remove_label
argument_list|(
operator|&
name|lookup_name
argument_list|,
operator|&
name|lookup_len
argument_list|)
expr_stmt|;
block|}
name|val_mark_indeterminate
argument_list|(
name|vq
operator|->
name|chase_reply
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|qstate
operator|->
name|env
argument_list|)
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|empty_DS_name
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|ds_rrset
operator|=
literal|0
expr_stmt|;
name|anchor
operator|=
name|anchors_lookup
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|anchors
argument_list|,
name|lookup_name
argument_list|,
name|lookup_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
comment|/* Determine the signer/lookup name */
name|val_find_signer
argument_list|(
name|subtype
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|rrset_skip
argument_list|,
operator|&
name|vq
operator|->
name|signer_name
argument_list|,
operator|&
name|vq
operator|->
name|signer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|signer_name
operator|!=
name|NULL
operator|&&
operator|!
name|dname_subdomain_c
argument_list|(
name|lookup_name
argument_list|,
name|vq
operator|->
name|signer_name
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"this signer name is not a parent "
literal|"of lookupname, omitted"
argument_list|,
name|vq
operator|->
name|signer_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vq
operator|->
name|signer_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vq
operator|->
name|signer_name
operator|==
name|NULL
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no signer, using"
argument_list|,
name|lookup_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lookup_name
operator|=
name|vq
operator|->
name|signer_name
expr_stmt|;
name|lookup_len
operator|=
name|vq
operator|->
name|signer_len
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"signer is"
argument_list|,
name|lookup_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* for NXDOMAIN it could be signed by a parent of the trust anchor */
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_NAMEERROR
operator|&&
name|vq
operator|->
name|signer_name
operator|&&
name|anchor
operator|&&
name|dname_strict_subdomain_c
argument_list|(
name|anchor
operator|->
name|name
argument_list|,
name|lookup_name
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchor
operator|->
name|lock
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|anchors_lookup
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|anchors
argument_list|,
name|lookup_name
argument_list|,
name|lookup_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
comment|/* unsigned parent denies anchor*/
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"unsigned parent zone denies"
literal|" trust anchor, indeterminate"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_indeterminate
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"trust anchor NXDOMAIN by signed parent"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_POSITIVE
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DNSKEY
operator|&&
name|query_dname_compare
argument_list|(
name|lookup_name
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* is a DNSKEY so lookup a bit higher since we want to 		 * get it from a parent or from trustanchor */
name|dname_remove_label
argument_list|(
operator|&
name|lookup_name
argument_list|,
operator|&
name|lookup_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vq
operator|->
name|rrset_skip
operator|>
literal|0
operator|||
name|subtype
operator|==
name|VAL_CLASS_CNAME
operator|||
name|subtype
operator|==
name|VAL_CLASS_REFERRAL
condition|)
block|{
comment|/* extract this part of orig_msg into chase_reply for 		 * the eventual VALIDATE stage */
name|val_fill_reply
argument_list|(
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|rrset_skip
argument_list|,
name|lookup_name
argument_list|,
name|lookup_len
argument_list|,
name|vq
operator|->
name|signer_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"chased extract"
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|)
expr_stmt|;
block|}
name|vq
operator|->
name|key_entry
operator|=
name|key_cache_obtain
argument_list|(
name|ve
operator|->
name|kcache
argument_list|,
name|lookup_name
argument_list|,
name|lookup_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
comment|/* there is no key(from DLV) and no trust anchor */
if|if
condition|(
name|vq
operator|->
name|key_entry
operator|==
name|NULL
operator|&&
name|anchor
operator|==
name|NULL
condition|)
block|{
comment|/*response isn't under a trust anchor, so we cannot validate.*/
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_indeterminate
expr_stmt|;
comment|/* go to finished state to cache this result */
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* if not key, or if keyentry is *above* the trustanchor, i.e. 	 * the keyentry is based on another (higher) trustanchor */
elseif|else
if|if
condition|(
name|vq
operator|->
name|key_entry
operator|==
name|NULL
operator|||
operator|(
name|anchor
operator|&&
name|dname_strict_subdomain_c
argument_list|(
name|anchor
operator|->
name|name
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
comment|/* trust anchor is an 'unsigned' trust anchor */
if|if
condition|(
name|anchor
operator|&&
name|anchor
operator|->
name|numDS
operator|==
literal|0
operator|&&
name|anchor
operator|->
name|numDNSKEY
operator|==
literal|0
condition|)
block|{
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
name|val_mark_insecure
argument_list|(
name|vq
operator|->
name|chase_reply
argument_list|,
name|anchor
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|qstate
operator|->
name|env
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchor
operator|->
name|lock
argument_list|)
expr_stmt|;
name|vq
operator|->
name|dlv_checked
operator|=
literal|1
expr_stmt|;
comment|/* skip DLV check */
comment|/* go to finished state to cache this result */
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fire off a trust anchor priming query. */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"prime trust anchor"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prime_trust_anchor
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|anchor
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchor
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|anchor
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* and otherwise, don't continue processing this event. 		 * (it will be reactivated when the priming query returns). */
name|vq
operator|->
name|state
operator|=
name|VAL_FINDKEY_STATE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|anchor
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchor
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key_entry_isnull
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
comment|/* response is under a null key, so we cannot validate 		 * However, we do set the status to INSECURE, since it is  		 * essentially proven insecure. */
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
name|val_mark_insecure
argument_list|(
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|qstate
operator|->
name|env
argument_list|)
expr_stmt|;
comment|/* go to finished state to cache this result */
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|key_entry_isbad
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
comment|/* key is bad, chain is bad, reply is bogus */
name|errinf_dname
argument_list|(
name|qstate
argument_list|,
literal|"key for validation"
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"is marked as invalid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_entry_get_reason
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"because of a previous"
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|key_entry_get_reason
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* no retries, stop bothering the authority until timeout */
name|vq
operator|->
name|restart_count
operator|=
name|VAL_MAX_RESTART_COUNT
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* otherwise, we have our "closest" cached key -- continue  	 * processing in the next state. */
name|vq
operator|->
name|state
operator|=
name|VAL_FINDKEY_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Process the FINDKEY state. Generally this just calculates the next name  * to query and either issues a DS or a DNSKEY query. It will check to see  * if the correct key has already been reached, in which case it will  * advance the event to the next state.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param id: module id.  * @return true if the event should be processed further on return, false if  *         not.  */
end_comment

begin_function
specifier|static
name|int
name|processFindKey
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|target_key_name
decl_stmt|,
modifier|*
name|current_key_name
decl_stmt|;
name|size_t
name|target_key_len
decl_stmt|;
name|int
name|strip_lab
decl_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: FindKey"
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|)
expr_stmt|;
comment|/* We know that state.key_entry is not 0 or bad key -- if it were, 	 * then previous processing should have directed this event to  	 * a different state.  	 * It could be an isnull key, which signals that a DLV was just 	 * done and the DNSKEY after the DLV failed with dnssec-retry state 	 * and the DNSKEY has to be performed again. */
name|log_assert
argument_list|(
name|vq
operator|->
name|key_entry
operator|&&
operator|!
name|key_entry_isbad
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_entry_isnull
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|BIT_CD
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mem error generating DNSKEY request"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
name|target_key_name
operator|=
name|vq
operator|->
name|signer_name
expr_stmt|;
name|target_key_len
operator|=
name|vq
operator|->
name|signer_len
expr_stmt|;
if|if
condition|(
operator|!
name|target_key_name
condition|)
block|{
name|target_key_name
operator|=
name|vq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
name|target_key_len
operator|=
name|vq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
block|}
name|current_key_name
operator|=
name|vq
operator|->
name|key_entry
operator|->
name|name
expr_stmt|;
comment|/* If our current key entry matches our target, then we are done. */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|target_key_name
argument_list|,
name|current_key_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|vq
operator|->
name|empty_DS_name
condition|)
block|{
comment|/* if the last empty nonterminal/emptyDS name we detected is 		 * below the current key, use that name to make progress 		 * along the chain of trust */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|target_key_name
argument_list|,
name|vq
operator|->
name|empty_DS_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* do not query for empty_DS_name again */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Cannot retrieve DS for signature"
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no signatures"
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
name|current_key_name
operator|=
name|vq
operator|->
name|empty_DS_name
expr_stmt|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"current keyname"
argument_list|,
name|current_key_name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"target keyname"
argument_list|,
name|target_key_name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
comment|/* assert we are walking down the DNS tree */
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|target_key_name
argument_list|,
name|current_key_name
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"bad signer name"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* so this value is>= -1 */
name|strip_lab
operator|=
name|dname_count_labels
argument_list|(
name|target_key_name
argument_list|)
operator|-
name|dname_count_labels
argument_list|(
name|current_key_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|log_assert
argument_list|(
name|strip_lab
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"striplab %d"
argument_list|,
name|strip_lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_lab
operator|>
literal|0
condition|)
block|{
name|dname_remove_labels
argument_list|(
operator|&
name|target_key_name
argument_list|,
operator|&
name|target_key_len
argument_list|,
name|strip_lab
argument_list|)
expr_stmt|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"next keyname"
argument_list|,
name|target_key_name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
comment|/* The next step is either to query for the next DS, or to query  	 * for the next DNSKEY. */
if|if
condition|(
name|vq
operator|->
name|ds_rrset
condition|)
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DS RRset"
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"No DS RRset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|ds_rrset
operator|&&
name|query_dname_compare
argument_list|(
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|BIT_CD
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mem error generating DNSKEY request"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|vq
operator|->
name|ds_rrset
operator|||
name|query_dname_compare
argument_list|(
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|target_key_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* check if there is a cache entry : pick up an NSEC if 		 * there is no DS, check if that NSEC has DS-bit unset, and 		 * thus can disprove the secure delagation we seek. 		 * We can then use that NSEC even in the absence of a SOA 		 * record that would be required by the iterator to supply 		 * a completely protocol-correct response.  		 * Uses negative cache for NSEC3 lookup of DS responses. */
comment|/* only if cache not blacklisted, of course */
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|qstate
operator|->
name|blacklist
operator|&&
operator|!
name|vq
operator|->
name|chain_blacklist
operator|&&
operator|(
name|msg
operator|=
name|val_find_DS
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|target_key_name
argument_list|,
name|target_key_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Process cached DS response"
argument_list|)
expr_stmt|;
name|process_ds_response
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_NOERROR
argument_list|,
name|msg
argument_list|,
operator|&
name|msg
operator|->
name|qinfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* continue processing ds-response results */
block|}
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|target_key_name
argument_list|,
name|target_key_len
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|BIT_CD
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mem error generating DS request"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Otherwise, it is time to query for the DNSKEY */
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|BIT_CD
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mem error generating DNSKEY request"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Process the VALIDATE stage, the init and findkey stages are finished,  * and the right keys are available to validate the response.  * Or, there are no keys available, in order to invalidate the response.  *  * After validation, the status is recorded in the message and rrsets,  * and finished state is started.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param ve: validator shared global environment.  * @param id: module id.  * @return true if the event should be processed further on return, false if  *         not.  */
end_comment

begin_function
specifier|static
name|int
name|processValidate
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|enum
name|val_classification
name|subtype
decl_stmt|;
name|int
name|rcode
decl_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|key_entry
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validate: no key entry, failed"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|/* This is the default next state. */
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
comment|/* Unsigned responses must be underneath a "null" key entry.*/
if|if
condition|(
name|key_entry_isnull
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Verified that %sresponse is INSECURE"
argument_list|,
name|vq
operator|->
name|signer_name
condition|?
literal|""
else|:
literal|"unsigned "
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
name|val_mark_insecure
argument_list|(
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|qstate
operator|->
name|env
argument_list|)
expr_stmt|;
name|key_cache_insert
argument_list|(
name|ve
operator|->
name|kcache
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
name|qstate
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|key_entry_isbad
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Could not establish a chain "
literal|"of trust to keys for"
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|vq
operator|->
name|key_entry
operator|->
name|key_class
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"while building chain of trust"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|restart_count
operator|>=
name|VAL_MAX_RESTART_COUNT
condition|)
name|key_cache_insert
argument_list|(
name|ve
operator|->
name|kcache
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
name|qstate
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* signerName being null is the indicator that this response was  	 * unsigned */
if|if
condition|(
name|vq
operator|->
name|signer_name
operator|==
name|NULL
condition|)
block|{
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processValidate: state has no "
literal|"signer name"
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Could not establish validation of "
literal|"INSECURE status of unsigned response."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no signatures"
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
return|return
literal|1
return|;
block|}
name|subtype
operator|=
name|val_classify_response
argument_list|(
name|qstate
operator|->
name|query_flags
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|rrset_skip
argument_list|)
expr_stmt|;
comment|/* check signatures in the message;  	 * answer and authority must be valid, additional is only checked. */
if|if
condition|(
operator|!
name|validate_msg_signatures
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
comment|/* workaround bad recursor out there that truncates (even 		 * with EDNS4k) to 512 by removing RRSIG from auth section 		 * for positive replies*/
if|if
condition|(
operator|(
name|subtype
operator|==
name|VAL_CLASS_POSITIVE
operator|||
name|subtype
operator|==
name|VAL_CLASS_ANY
operator|||
name|subtype
operator|==
name|VAL_CLASS_CNAME
operator|)
operator|&&
name|detect_wrongly_truncated
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|)
condition|)
block|{
comment|/* truncate the message some more */
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrset_count
operator|=
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|an_numrrsets
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|ns_numrrsets
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|rrset_count
operator|=
name|vq
operator|->
name|chase_reply
operator|->
name|an_numrrsets
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Validate: message contains "
literal|"bad rrsets"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|VAL_CLASS_POSITIVE
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a positive response"
argument_list|)
expr_stmt|;
name|validate_positive_response
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(positive): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_CLASS_NODATA
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a nodata response"
argument_list|)
expr_stmt|;
name|validate_nodata_response
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(nodata): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_CLASS_NAMEERROR
case|:
name|rcode
operator|=
operator|(
name|int
operator|)
name|FLAGS_GET_RCODE
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a nxdomain response"
argument_list|)
expr_stmt|;
name|validate_nameerror_response
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(nxdomain): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
name|FLAGS_SET_RCODE
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|flags
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
name|FLAGS_SET_RCODE
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|flags
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_CLASS_CNAME
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a cname response"
argument_list|)
expr_stmt|;
name|validate_cname_response
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(cname): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_CLASS_CNAMENOANSWER
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a cname noanswer "
literal|"response"
argument_list|)
expr_stmt|;
name|validate_cname_noanswer_response
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(cname_noanswer): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_CLASS_REFERRAL
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a referral response"
argument_list|)
expr_stmt|;
name|validate_referral_response
argument_list|(
name|vq
operator|->
name|chase_reply
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(referral): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_CLASS_ANY
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Validating a positive ANY "
literal|"response"
argument_list|)
expr_stmt|;
name|validate_any_response
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|chase_reply
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate(positive_any): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_err
argument_list|(
literal|"validate: unhandled response subtype: %d"
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_POSITIVE
condition|)
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"wildcard"
argument_list|)
expr_stmt|;
else|else
name|errinf
argument_list|(
name|qstate
argument_list|,
name|val_classification_to_string
argument_list|(
name|subtype
argument_list|)
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"proof failed"
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Init DLV check.  * Called when a query is determined by other trust anchors to be insecure  * (or indeterminate).  Then we look if there is a key in the DLV.  * Performs aggressive negative cache check to see if there is no key.  * Otherwise, spawns a DLV query, and changes to the DLV wait state.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param ve: validator shared global environment.  * @param id: module id.  * @return  true if there is no DLV.  * 	false: processing is finished for the validator operate().  * 	This function may exit in three ways:  *         o	no DLV (agressive cache), so insecure. (true)  *         o	error - stop processing (false)  *         o	DLV lookup was started, stop processing (false)  */
end_comment

begin_function
specifier|static
name|int
name|val_dlv_init
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|nm_len
decl_stmt|;
comment|/* there must be a DLV configured */
name|log_assert
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
argument_list|)
expr_stmt|;
comment|/* this bool is true to avoid looping in the DLV checks */
name|log_assert
argument_list|(
name|vq
operator|->
name|dlv_checked
argument_list|)
expr_stmt|;
comment|/* init the DLV lookup variables */
name|vq
operator|->
name|dlv_lookup_name
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|dlv_lookup_name_len
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|dlv_insecure_at
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|dlv_insecure_at_len
operator|=
literal|0
expr_stmt|;
comment|/* Determine the name for which we want to lookup DLV. 	 * This name is for the current message, or  	 * for the current RRset for CNAME, referral subtypes. 	 * If there is a signer, use that, otherwise the domain name */
if|if
condition|(
name|vq
operator|->
name|signer_name
condition|)
block|{
name|nm
operator|=
name|vq
operator|->
name|signer_name
expr_stmt|;
name|nm_len
operator|=
name|vq
operator|->
name|signer_len
expr_stmt|;
block|}
else|else
block|{
comment|/* use qchase */
name|nm
operator|=
name|vq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
name|nm_len
operator|=
name|vq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
condition|)
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nm_len
argument_list|)
expr_stmt|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV init look"
argument_list|,
name|nm
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|nm
operator|&&
name|nm_len
argument_list|)
expr_stmt|;
comment|/* sanity check: no DLV lookups below the DLV anchor itself. 	 * Like, an securely insecure delegation there makes no sense. */
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|nm
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV lookup within DLV repository denied"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* concat name (minus root label) + dlv name */
name|vq
operator|->
name|dlv_lookup_name_len
operator|=
name|nm_len
operator|-
literal|1
operator|+
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|namelen
expr_stmt|;
name|vq
operator|->
name|dlv_lookup_name
operator|=
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|dlv_lookup_name
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory preparing DLV lookup"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
name|memmove
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|nm
argument_list|,
name|nm_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
operator|+
name|nm_len
operator|-
literal|1
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV name"
argument_list|,
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|LDNS_RR_TYPE_DLV
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
comment|/* determine where the insecure point was determined, the DLV must  	 * be equal or below that to continue building the trust chain  	 * down. May be NULL if no trust chain was built yet */
name|nm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|key_entry
operator|&&
name|key_entry_isnull
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
name|nm
operator|=
name|vq
operator|->
name|key_entry
operator|->
name|name
expr_stmt|;
name|nm_len
operator|=
name|vq
operator|->
name|key_entry
operator|->
name|namelen
expr_stmt|;
block|}
if|if
condition|(
name|nm
condition|)
block|{
name|vq
operator|->
name|dlv_insecure_at_len
operator|=
name|nm_len
operator|-
literal|1
operator|+
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|namelen
expr_stmt|;
name|vq
operator|->
name|dlv_insecure_at
operator|=
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|dlv_insecure_at_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|dlv_insecure_at
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory preparing DLV lookup"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
name|memmove
argument_list|(
name|vq
operator|->
name|dlv_insecure_at
argument_list|,
name|nm
argument_list|,
name|nm_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|vq
operator|->
name|dlv_insecure_at
operator|+
name|nm_len
operator|-
literal|1
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"insecure_at"
argument_list|,
name|vq
operator|->
name|dlv_insecure_at
argument_list|,
literal|0
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
block|}
comment|/* If we can find the name in the aggressive negative cache, 	 * give up; insecure is the answer */
while|while
condition|(
name|val_neg_dlvlookup
argument_list|(
name|ve
operator|->
name|neg_cache
argument_list|,
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
condition|)
block|{
comment|/* go up */
name|dname_remove_label
argument_list|(
operator|&
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
operator|&
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|)
expr_stmt|;
comment|/* too high? */
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"ask above dlv repo"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Above the repo is insecure */
block|}
comment|/* above chain of trust? */
if|if
condition|(
name|vq
operator|->
name|dlv_insecure_at
operator|&&
operator|!
name|dname_subdomain_c
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|vq
operator|->
name|dlv_insecure_at
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"ask above insecure endpoint"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* perform a lookup for the DLV; with validation */
name|vq
operator|->
name|state
operator|=
name|VAL_DLVLOOKUP_STATE
expr_stmt|;
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|,
name|LDNS_RR_TYPE_DLV
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|/* Find the closest encloser DLV from the repository. 	 * then that is used to build another chain of trust  	 * This may first require a query 'too low' that has NSECs in 	 * the answer, from which we determine the closest encloser DLV.  	 * When determine the closest encloser, skip empty nonterminals, 	 * since we want a nonempty node in the DLV repository. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * The Finished state. The validation status (good or bad) has been determined.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param ve: validator shared global environment.  * @param id: module id.  * @return true if the event should be processed further on return, false if  *         not.  */
end_comment

begin_function
specifier|static
name|int
name|processFinished
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|enum
name|val_classification
name|subtype
init|=
name|val_classify_response
argument_list|(
name|qstate
operator|->
name|query_flags
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|rrset_skip
argument_list|)
decl_stmt|;
comment|/* if the result is insecure or indeterminate and we have not  	 * checked the DLV yet, check the DLV */
if|if
condition|(
operator|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|==
name|sec_status_insecure
operator|||
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|==
name|sec_status_indeterminate
operator|)
operator|&&
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|&&
operator|!
name|vq
operator|->
name|dlv_checked
condition|)
block|{
name|vq
operator|->
name|dlv_checked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|val_dlv_init
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* store overall validation result in orig_msg */
if|if
condition|(
name|vq
operator|->
name|rrset_skip
operator|==
literal|0
condition|)
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|=
name|vq
operator|->
name|chase_reply
operator|->
name|security
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|!=
name|VAL_CLASS_REFERRAL
operator|||
name|vq
operator|->
name|rrset_skip
operator|<
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|ns_numrrsets
condition|)
block|{
comment|/* ignore sec status of additional section if a referral  		 * type message skips there and 		 * use the lowest security status as end result. */
if|if
condition|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|<
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
condition|)
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|=
name|vq
operator|->
name|chase_reply
operator|->
name|security
expr_stmt|;
block|}
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_REFERRAL
condition|)
block|{
comment|/* for a referral, move to next unchecked rrset and check it*/
name|vq
operator|->
name|rrset_skip
operator|=
name|val_next_unchecked
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|rrset_skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|rrset_skip
operator|<
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|rrset_count
condition|)
block|{
comment|/* and restart for this rrset */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: go to next rrset"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
name|vq
operator|->
name|dlv_checked
operator|=
literal|0
expr_stmt|;
comment|/* can do DLV for this RR */
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* referral chase is done */
block|}
if|if
condition|(
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|!=
name|sec_status_bogus
operator|&&
name|subtype
operator|==
name|VAL_CLASS_CNAME
condition|)
block|{
comment|/* chase the CNAME; process next part of the message */
if|if
condition|(
operator|!
name|val_chase_cname
argument_list|(
operator|&
name|vq
operator|->
name|qchase
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
operator|&
name|vq
operator|->
name|rrset_skip
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: failed to chase CNAME"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
block|}
else|else
block|{
comment|/* restart process for new qchase at rrset_skip */
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: chased to"
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|)
expr_stmt|;
name|vq
operator|->
name|chase_reply
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
name|vq
operator|->
name|dlv_checked
operator|=
literal|0
expr_stmt|;
comment|/* can do DLV for this RR */
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
block|{
comment|/* If the message is secure, check that all rrsets are 		 * secure (i.e. some inserted RRset for CNAME chain with 		 * a different signer name). And drop additional rrsets 		 * that are not secure (if clean-additional option is set) */
comment|/* this may cause the msg to be marked bogus */
name|val_check_nonsecure
argument_list|(
name|ve
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
block|{
name|log_query_info
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validation success"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the result is bogus - set message ttl to bogus ttl to avoid 	 * endless bogus revalidation */
if|if
condition|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
comment|/* see if we can try again to fetch data */
if|if
condition|(
name|vq
operator|->
name|restart_count
operator|<
name|VAL_MAX_RESTART_COUNT
condition|)
block|{
name|int
name|restart_count
init|=
name|vq
operator|->
name|restart_count
operator|+
literal|1
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validation failed, "
literal|"blacklist and retry to fetch data"
argument_list|)
expr_stmt|;
name|val_blacklist
argument_list|(
operator|&
name|qstate
operator|->
name|blacklist
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|reply_origin
operator|=
name|NULL
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|vq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vq
argument_list|)
argument_list|)
expr_stmt|;
name|vq
operator|->
name|restart_count
operator|=
name|restart_count
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"pass back to next module"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_restart_next
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|ttl
operator|=
name|ve
operator|->
name|bogus_ttl
expr_stmt|;
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|val_log_level
operator|>=
literal|1
operator|&&
operator|!
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|val_log_squelch
condition|)
block|{
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|val_log_level
operator|<
literal|2
condition|)
name|log_query_info
argument_list|(
literal|0
argument_list|,
literal|"validation failure"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|err
init|=
name|errinf_to_str
argument_list|(
name|qstate
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
name|log_info
argument_list|(
literal|"%s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are in permissive mode, bogus gets indeterminate */
if|if
condition|(
name|ve
operator|->
name|permissive_mode
condition|)
name|vq
operator|->
name|orig_msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_indeterminate
expr_stmt|;
block|}
comment|/* store results in cache */
if|if
condition|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
condition|)
block|{
comment|/* if secure, this will override cache anyway, no need 		 * to check if from parentNS */
if|if
condition|(
operator|!
name|dns_cache_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|vq
operator|->
name|orig_msg
operator|->
name|qinfo
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|prefetch_leeway
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory caching validator results"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* for a referral, store the verified RRsets */
comment|/* and this does not get prefetched, so no leeway */
if|if
condition|(
operator|!
name|dns_cache_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|vq
operator|->
name|orig_msg
operator|->
name|qinfo
argument_list|,
name|vq
operator|->
name|orig_msg
operator|->
name|rep
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory caching validator results"
argument_list|)
expr_stmt|;
block|}
block|}
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|vq
operator|->
name|orig_msg
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * The DLVLookup state. Process DLV lookups.  *  * @param qstate: query state.  * @param vq: validator query state.  * @param ve: validator shared global environment.  * @param id: module id.  * @return true if the event should be processed further on return, false if  *         not.  */
end_comment

begin_function
specifier|static
name|int
name|processDLVLookup
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|int
name|id
parameter_list|)
block|{
comment|/* see if this we are ready to continue normal resolution */
comment|/* we may need more DLV lookups */
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_error
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV woke up with status dlv_error"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_success
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV woke up with status dlv_success"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_ask_higher
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV woke up with status dlv_ask_higher"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_there_is_no_dlv
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV woke up with status dlv_there_is_no_dlv"
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"DLV woke up with status unknown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_error
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"failed DLV lookup"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_success
condition|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
comment|/* chain continues with DNSKEY, continue in FINDKEY */
name|vq
operator|->
name|state
operator|=
name|VAL_FINDKEY_STATE
expr_stmt|;
comment|/* strip off the DLV suffix from the name; could result in . */
name|log_assert
argument_list|(
name|dname_subdomain_c
argument_list|(
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|nmlen
operator|=
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
operator|-
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|namelen
operator|+
literal|1
expr_stmt|;
name|nm
operator|=
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory in DLVLook"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
name|nm
index|[
name|nmlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
operator|=
name|nm
expr_stmt|;
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|nmlen
expr_stmt|;
comment|/* create a nullentry for the key so the dnskey lookup 		 * can be retried after a validation failure for it */
name|vq
operator|->
name|key_entry
operator|=
name|key_entry_create_null
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|key_entry
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory in DLVLook"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|BIT_CD
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mem error generating DNSKEY request"
argument_list|)
expr_stmt|;
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_there_is_no_dlv
condition|)
block|{
comment|/* continue with the insecure result we got */
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_assert
argument_list|(
name|vq
operator|->
name|dlv_status
operator|==
name|dlv_ask_higher
argument_list|)
expr_stmt|;
comment|/* ask higher, make sure we stay in DLV repo, below dlv_at */
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* just like, there is no DLV */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"ask above dlv repo"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|vq
operator|->
name|dlv_insecure_at
operator|&&
operator|!
name|dname_subdomain_c
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|vq
operator|->
name|dlv_insecure_at
argument_list|)
condition|)
block|{
comment|/* already checked a chain lower than dlv_lookup_name */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"ask above insecure endpoint"
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"enpt"
argument_list|,
name|vq
operator|->
name|dlv_insecure_at
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_FINISHED_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* check negative cache before making new request */
if|if
condition|(
name|val_neg_dlvlookup
argument_list|(
name|ve
operator|->
name|neg_cache
argument_list|,
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
condition|)
block|{
comment|/* does not exist, go up one (go higher). */
name|dname_remove_label
argument_list|(
operator|&
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
operator|&
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|)
expr_stmt|;
comment|/* limit number of labels, limited number of recursion */
return|return
name|processDLVLookup
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|generate_request
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|,
name|LDNS_RR_TYPE_DLV
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|val_error
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * Handle validator state.  * If a method returns true, the next state is started. If false, then  * processing will stop.  * @param qstate: query state.  * @param vq: validator query state.  * @param ve: validator shared global environment.  * @param id: module id.  */
end_comment

begin_function
specifier|static
name|void
name|val_handle
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|cont
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cont
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"val handle processing q with state %s"
argument_list|,
name|val_state_to_string
argument_list|(
name|vq
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vq
operator|->
name|state
condition|)
block|{
case|case
name|VAL_INIT_STATE
case|:
name|cont
operator|=
name|processInit
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_FINDKEY_STATE
case|:
name|cont
operator|=
name|processFindKey
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_VALIDATE_STATE
case|:
name|cont
operator|=
name|processValidate
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_FINISHED_STATE
case|:
name|cont
operator|=
name|processFinished
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAL_DLVLOOKUP_STATE
case|:
name|cont
operator|=
name|processDLVLookup
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_warn
argument_list|(
literal|"validator: invalid state %d"
argument_list|,
name|vq
operator|->
name|state
argument_list|)
expr_stmt|;
name|cont
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|val_operate
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|enum
name|module_ev
name|event
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|outbound
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|val_qstate
modifier|*
name|vq
init|=
operator|(
expr|struct
name|val_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"validator[module %d] operate: extstate:%s "
literal|"event:%s"
argument_list|,
name|id
argument_list|,
name|strextstate
argument_list|(
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
argument_list|)
argument_list|,
name|strmodulevent
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"validator operate: query"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qname
operator|!=
name|vq
operator|->
name|qchase
operator|.
name|qname
condition|)
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"validator operate: chased to"
argument_list|,
operator|&
name|vq
operator|->
name|qchase
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|outbound
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|module_event_new
operator|||
operator|(
name|event
operator|==
name|module_event_pass
operator|&&
name|vq
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* pass request to next module, to get it */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: pass to next module"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_module
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|event
operator|==
name|module_event_moddone
condition|)
block|{
comment|/* check if validation is needed */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: nextmodule returned"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_validation
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|return_rcode
argument_list|,
name|qstate
operator|->
name|return_msg
argument_list|)
condition|)
block|{
comment|/* no need to validate this */
if|if
condition|(
name|qstate
operator|->
name|return_msg
condition|)
name|qstate
operator|->
name|return_msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_indeterminate
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|already_validated
argument_list|(
name|qstate
operator|->
name|return_msg
argument_list|)
condition|)
block|{
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return;
block|}
comment|/* qclass ANY should have validation result from spawned  		 * queries. If we get here, it is bogus or an internal error */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
operator|==
name|LDNS_RR_CLASS_ANY
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cannot validate classANY: bogus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|return_msg
condition|)
name|qstate
operator|->
name|return_msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_bogus
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return;
block|}
comment|/* create state to start validation */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_error
expr_stmt|;
comment|/* override this */
if|if
condition|(
operator|!
name|vq
condition|)
block|{
name|vq
operator|=
name|val_new
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
condition|)
block|{
name|log_err
argument_list|(
literal|"validator: malloc failure"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_error
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|vq
operator|->
name|orig_msg
condition|)
block|{
if|if
condition|(
operator|!
name|val_new_getmsg
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"validator: malloc failure"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_error
expr_stmt|;
return|return;
block|}
block|}
name|val_handle
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|event
operator|==
name|module_event_pass
condition|)
block|{
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_error
expr_stmt|;
comment|/* override this */
comment|/* continue processing, since val_env exists */
name|val_handle
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|ve
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_err
argument_list|(
literal|"validator: bad event %s"
argument_list|,
name|strmodulevent
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_error
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Evaluate the response to a priming request.  *  * @param dnskey_rrset: DNSKEY rrset (can be NULL if none) in prime reply.  * 	(this rrset is allocated in the wrong region, not the qstate).  * @param ta: trust anchor.  * @param qstate: qstate that needs key.  * @param id: module id.  * @return new key entry or NULL on allocation failure.  *	The key entry will either contain a validated DNSKEY rrset, or  *	represent a Null key (query failed, but validation did not), or a  *	Bad key (validation failed).  */
end_comment

begin_function
specifier|static
name|struct
name|key_entry_key
modifier|*
name|primeResponseToKE
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|struct
name|trust_anchor
modifier|*
name|ta
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|key_entry_key
modifier|*
name|kkey
init|=
name|NULL
decl_stmt|;
name|enum
name|sec_status
name|sec
init|=
name|sec_status_unchecked
decl_stmt|;
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|int
name|downprot
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|dnskey_rrset
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_OPS
argument_list|,
literal|"failed to prime trust anchor -- "
literal|"could not fetch DNSKEY rrset"
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|harden_dnssec_stripped
condition|)
block|{
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no DNSKEY rrset"
argument_list|)
expr_stmt|;
name|kkey
operator|=
name|key_entry_create_bad
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|ta
operator|->
name|namelen
argument_list|,
name|ta
operator|->
name|dclass
argument_list|,
name|BOGUS_KEY_TTL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
else|else
name|kkey
operator|=
name|key_entry_create_null
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|ta
operator|->
name|namelen
argument_list|,
name|ta
operator|->
name|dclass
argument_list|,
name|NULL_KEY_TTL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kkey
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory: allocate fail prime key"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|kkey
return|;
block|}
comment|/* attempt to verify with trust anchor DS and DNSKEY */
name|kkey
operator|=
name|val_verify_new_DNSKEYs_with_ta
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey_rrset
argument_list|,
name|ta
operator|->
name|ds_rrset
argument_list|,
name|ta
operator|->
name|dnskey_rrset
argument_list|,
name|downprot
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kkey
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory: verifying prime TA"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|key_entry_isgood
argument_list|(
name|kkey
argument_list|)
condition|)
name|sec
operator|=
name|sec_status_secure
expr_stmt|;
else|else
name|sec
operator|=
name|sec_status_bogus
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validate keys with anchor(DS): %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|sec_status_secure
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_OPS
argument_list|,
literal|"failed to prime trust anchor -- "
literal|"DNSKEY rrset is not secure"
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
comment|/* NOTE: in this case, we should probably reject the trust  		 * anchor for longer, perhaps forever. */
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|harden_dnssec_stripped
condition|)
block|{
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|kkey
operator|=
name|key_entry_create_bad
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|ta
operator|->
name|namelen
argument_list|,
name|ta
operator|->
name|dclass
argument_list|,
name|BOGUS_KEY_TTL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
else|else
name|kkey
operator|=
name|key_entry_create_null
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|ta
operator|->
name|namelen
argument_list|,
name|ta
operator|->
name|dclass
argument_list|,
name|NULL_KEY_TTL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kkey
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory: allocate null prime key"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|kkey
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Successfully primed trust anchor"
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
return|return
name|kkey
return|;
block|}
end_function

begin_comment
comment|/**  * In inform supers, with the resulting message and rcode and the current  * keyset in the super state, validate the DS response, returning a KeyEntry.  *  * @param qstate: query state that is validating and asked for a DS.  * @param vq: validator query state  * @param id: module id.  * @param rcode: rcode result value.  * @param msg: result message (if rcode is OK).  * @param qinfo: from the sub query state, query info.  * @param ke: the key entry to return. It returns  *	is_bad if the DS response fails to validate, is_null if the  *	DS response indicated an end to secure space, is_good if the DS  *	validated. It returns ke=NULL if the DS response indicated that the  *	request wasn't a delegation point.  * @return 0 on servfail error (malloc failure).  */
end_comment

begin_function
specifier|static
name|int
name|ds_response_to_ke
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|key_entry_key
modifier|*
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|enum
name|val_classification
name|subtype
decl_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
name|char
name|rc
index|[
literal|16
index|]
decl_stmt|;
name|rc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sldns_wire2str_rcode_buf
argument_list|(
name|rcode
argument_list|,
name|rc
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* errors here pretty much break validation */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"DS response was error, thus bogus"
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no DS"
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
name|subtype
operator|=
name|val_classify_response
argument_list|(
name|BIT_RD
argument_list|,
name|qinfo
argument_list|,
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_POSITIVE
condition|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
name|ds
operator|=
name|reply_find_answer_rrset
argument_list|(
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|)
expr_stmt|;
comment|/* If there was no DS rrset, then we have mis-classified  		 * this message. */
if|if
condition|(
operator|!
name|ds
condition|)
block|{
name|log_warn
argument_list|(
literal|"internal error: POSITIVE DS response was "
literal|"missing DS."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no DS record"
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
comment|/* Verify only returns BOGUS or SECURE. If the rrset is  		 * bogus, then we are done. */
name|sec
operator|=
name|val_verify_rrset_entry
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|ds
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|sec_status_secure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"DS rrset in DS response did "
literal|"not verify"
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
comment|/* If the DS rrset validates, we still have to make sure  		 * that they are usable. */
if|if
condition|(
operator|!
name|val_dsset_isusable
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* If they aren't usable, then we treat it like  			 * there was no DS. */
operator|*
name|ke
operator|=
name|key_entry_create_null
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|ub_packed_rrset_ttl
argument_list|(
name|ds
argument_list|)
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|ke
operator|)
operator|!=
name|NULL
return|;
block|}
comment|/* Otherwise, we return the positive response. */
name|log_query_info
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validated DS"
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
operator|*
name|ke
operator|=
name|key_entry_create_rrset
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|ds
argument_list|,
name|NULL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|ke
operator|)
operator|!=
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_NODATA
operator|||
name|subtype
operator|==
name|VAL_CLASS_NAMEERROR
condition|)
block|{
comment|/* NODATA means that the qname exists, but that there was  		 * no DS.  This is a pretty normal case. */
name|time_t
name|proof_ttl
init|=
literal|0
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
comment|/* make sure there are NSECs or NSEC3s with signatures */
if|if
condition|(
operator|!
name|val_has_signed_nsecs
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
operator|&
name|reason
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no NSECs: %s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
comment|/* For subtype Name Error. 		 * attempt ANS 2.8.1.0 compatibility where it sets rcode 		 * to nxdomain, but really this is an Nodata/Noerror response. 		 * Find and prove the empty nonterminal in that case */
comment|/* Try to prove absence of the DS with NSEC */
name|sec
operator|=
name|val_nsec_prove_nodata_dsreply
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
operator|&
name|proof_ttl
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
name|sec_status_secure
case|:
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"NSEC RRset for the "
literal|"referral proved no DS."
argument_list|)
expr_stmt|;
operator|*
name|ke
operator|=
name|key_entry_create_null
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|proof_ttl
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|ke
operator|)
operator|!=
name|NULL
return|;
case|case
name|sec_status_insecure
case|:
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"NSEC RRset for the "
literal|"referral proved not a delegation point"
argument_list|)
expr_stmt|;
operator|*
name|ke
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
case|case
name|sec_status_bogus
case|:
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"NSEC RRset for the "
literal|"referral did not prove no DS."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
case|case
name|sec_status_unchecked
case|:
default|default:
comment|/* NSEC proof did not work, try next */
break|break;
block|}
name|sec
operator|=
name|nsec3_prove_nods
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
argument_list|,
name|qinfo
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
name|sec_status_insecure
case|:
comment|/* case insecure also continues to unsigned 				 * space.  If nsec3-iter-count too high or 				 * optout, then treat below as unsigned */
case|case
name|sec_status_secure
case|:
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"NSEC3s for the "
literal|"referral proved no DS."
argument_list|)
expr_stmt|;
operator|*
name|ke
operator|=
name|key_entry_create_null
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|proof_ttl
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|ke
operator|)
operator|!=
name|NULL
return|;
case|case
name|sec_status_indeterminate
case|:
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"NSEC3s for the "
literal|"referral proved no delegation"
argument_list|)
expr_stmt|;
operator|*
name|ke
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
case|case
name|sec_status_bogus
case|:
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"NSEC3s for the "
literal|"referral did not prove no DS."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
case|case
name|sec_status_unchecked
case|:
default|default:
comment|/* NSEC3 proof did not work */
break|break;
block|}
comment|/* Apparently, no available NSEC/NSEC3 proved NODATA, so  		 * this is BOGUS. */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"DS %s ran out of options, so return "
literal|"bogus"
argument_list|,
name|val_classification_to_string
argument_list|(
name|subtype
argument_list|)
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no DS but also no proof of that"
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|VAL_CLASS_CNAME
operator|||
name|subtype
operator|==
name|VAL_CLASS_CNAMENOANSWER
condition|)
block|{
comment|/* if the CNAME matches the exact name we want and is signed 		 * properly, then also, we are sure that no DS exists there, 		 * much like a NODATA proof */
name|enum
name|sec_status
name|sec
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|cname
decl_stmt|;
name|cname
operator|=
name|reply_find_rrset_section_an
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cname
condition|)
block|{
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"validator classified CNAME but no "
literal|"CNAME of the queried name for DS"
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|cname
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|rrsig_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|!=
literal|0
operator|&&
name|ntohs
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
condition|)
block|{
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"DS got DNAME answer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"DS got unsigned CNAME answer"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|return_bogus
goto|;
block|}
name|sec
operator|=
name|val_verify_rrset_entry
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|cname
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"CNAME validated, "
literal|"proof that DS does not exist"
argument_list|)
expr_stmt|;
comment|/* and that it is not a referral point */
operator|*
name|ke
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"CNAME in DS response was not secure."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Encountered an unhandled type of "
literal|"DS response, thus bogus."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"no DS and"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
name|char
name|rc
index|[
literal|16
index|]
decl_stmt|;
name|rc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sldns_wire2str_rcode_buf
argument_list|(
operator|(
name|int
operator|)
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
argument_list|,
name|rc
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
name|errinf
argument_list|(
name|qstate
argument_list|,
name|val_classification_to_string
argument_list|(
name|subtype
argument_list|)
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"message fails to prove that"
argument_list|)
expr_stmt|;
goto|goto
name|return_bogus
goto|;
block|}
name|return_bogus
label|:
operator|*
name|ke
operator|=
name|key_entry_create_bad
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|BOGUS_KEY_TTL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|ke
operator|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Process DS response. Called from inform_supers.  * Because it is in inform_supers, the mesh itself is busy doing callbacks  * for a state that is to be deleted soon; don't touch the mesh; instead  * set a state in the super, as the super will be reactivated soon.  * Perform processing to determine what state to set in the super.  *  * @param qstate: query state that is validating and asked for a DS.  * @param vq: validator query state  * @param id: module id.  * @param rcode: rcode result value.  * @param msg: result message (if rcode is OK).  * @param qinfo: from the sub query state, query info.  * @param origin: the origin of msg.  */
end_comment

begin_function
specifier|static
name|void
name|process_ds_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|sock_list
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|key_entry_key
modifier|*
name|dske
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|olds
init|=
name|vq
operator|->
name|empty_DS_name
decl_stmt|;
name|vq
operator|->
name|empty_DS_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ds_response_to_ke
argument_list|(
name|qstate
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|rcode
argument_list|,
name|msg
argument_list|,
name|qinfo
argument_list|,
operator|&
name|dske
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in process_ds_response"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|NULL
expr_stmt|;
comment|/* make it error */
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dske
operator|==
name|NULL
condition|)
block|{
name|vq
operator|->
name|empty_DS_name
operator|=
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|empty_DS_name
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in empty_DS_name"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|NULL
expr_stmt|;
comment|/* make it error */
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|empty_DS_len
operator|=
name|qinfo
operator|->
name|qname_len
expr_stmt|;
name|vq
operator|->
name|chain_blacklist
operator|=
name|NULL
expr_stmt|;
comment|/* ds response indicated that we aren't on a delegation point. 		 * Keep the forState.state on FINDKEY. */
block|}
elseif|else
if|if
condition|(
name|key_entry_isgood
argument_list|(
name|dske
argument_list|)
condition|)
block|{
name|vq
operator|->
name|ds_rrset
operator|=
name|key_entry_get_rrset
argument_list|(
name|dske
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|ds_rrset
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in process DS"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|NULL
expr_stmt|;
comment|/* make it error */
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|chain_blacklist
operator|=
name|NULL
expr_stmt|;
comment|/* fresh blacklist for next part*/
comment|/* Keep the forState.state on FINDKEY. */
block|}
elseif|else
if|if
condition|(
name|key_entry_isbad
argument_list|(
name|dske
argument_list|)
operator|&&
name|vq
operator|->
name|restart_count
operator|<
name|VAL_MAX_RESTART_COUNT
condition|)
block|{
name|vq
operator|->
name|empty_DS_name
operator|=
name|olds
expr_stmt|;
name|val_blacklist
argument_list|(
operator|&
name|vq
operator|->
name|chain_blacklist
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|origin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|restart_count
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key_entry_isbad
argument_list|(
name|dske
argument_list|)
condition|)
block|{
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|errinf_dname
argument_list|(
name|qstate
argument_list|,
literal|"for DS"
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE: the reason for the DS to be not good (that is,  		 * either bad or null) should have been logged by  		 * dsResponseToKE. */
name|vq
operator|->
name|key_entry
operator|=
name|dske
expr_stmt|;
comment|/* The FINDKEY phase has ended, so move on. */
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Process DNSKEY response. Called from inform_supers.  * Sets the key entry in the state.  * Because it is in inform_supers, the mesh itself is busy doing callbacks  * for a state that is to be deleted soon; don't touch the mesh; instead  * set a state in the super, as the super will be reactivated soon.  * Perform processing to determine what state to set in the super.  *  * @param qstate: query state that is validating and asked for a DNSKEY.  * @param vq: validator query state  * @param id: module id.  * @param rcode: rcode result value.  * @param msg: result message (if rcode is OK).  * @param qinfo: from the sub query state, query info.  * @param origin: the origin of msg.  */
end_comment

begin_function
specifier|static
name|void
name|process_dnskey_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|sock_list
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|key_entry_key
modifier|*
name|old
init|=
name|vq
operator|->
name|key_entry
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey
init|=
name|NULL
decl_stmt|;
name|int
name|downprot
decl_stmt|;
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
condition|)
name|dnskey
operator|=
name|reply_find_answer_rrset
argument_list|(
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnskey
operator|==
name|NULL
condition|)
block|{
comment|/* bad response */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Missing DNSKEY RRset in response to "
literal|"DNSKEY query."
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|restart_count
operator|<
name|VAL_MAX_RESTART_COUNT
condition|)
block|{
name|val_blacklist
argument_list|(
operator|&
name|vq
operator|->
name|chain_blacklist
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|origin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|restart_count
operator|++
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|key_entry
operator|=
name|key_entry_create_bad
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|BOGUS_KEY_TTL
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|key_entry
condition|)
block|{
name|log_err
argument_list|(
literal|"alloc failure in missing dnskey response"
argument_list|)
expr_stmt|;
comment|/* key_entry is NULL for failure in Validate */
block|}
name|errinf
argument_list|(
name|qstate
argument_list|,
literal|"No DNSKEY record"
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|errinf_dname
argument_list|(
name|qstate
argument_list|,
literal|"for key"
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|vq
operator|->
name|ds_rrset
condition|)
block|{
name|log_err
argument_list|(
literal|"internal error: no DS rrset for new DNSKEY response"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
name|downprot
operator|=
literal|1
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|val_verify_new_DNSKEYs
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|dnskey
argument_list|,
name|vq
operator|->
name|ds_rrset
argument_list|,
name|downprot
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|key_entry
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in verify new DNSKEYs"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
comment|/* If the key entry isBad or isNull, then we can move on to the next 	 * state. */
if|if
condition|(
operator|!
name|key_entry_isgood
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|key_entry_isbad
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|vq
operator|->
name|restart_count
operator|<
name|VAL_MAX_RESTART_COUNT
condition|)
block|{
name|val_blacklist
argument_list|(
operator|&
name|vq
operator|->
name|chain_blacklist
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|origin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|restart_count
operator|++
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|old
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Did not match a DS to a DNSKEY, "
literal|"thus bogus."
argument_list|)
expr_stmt|;
name|errinf
argument_list|(
name|qstate
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|errinf_dname
argument_list|(
name|qstate
argument_list|,
literal|"for key"
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
expr_stmt|;
block|}
name|vq
operator|->
name|chain_blacklist
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|chain_blacklist
operator|=
name|NULL
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
comment|/* The DNSKEY validated, so cache it as a trusted key rrset. */
name|key_cache_insert
argument_list|(
name|ve
operator|->
name|kcache
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
name|qstate
argument_list|)
expr_stmt|;
comment|/* If good, we stay in the FINDKEY state. */
name|log_query_info
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"validated DNSKEY"
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Process prime response  * Sets the key entry in the state.  *  * @param qstate: query state that is validating and primed a trust anchor.  * @param vq: validator query state  * @param id: module id.  * @param rcode: rcode result value.  * @param msg: result message (if rcode is OK).  * @param origin: the origin of msg.  */
end_comment

begin_function
specifier|static
name|void
name|process_prime_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|sock_list
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
init|=
name|NULL
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|ta
init|=
name|anchor_find
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|anchors
argument_list|,
name|vq
operator|->
name|trust_anchor_name
argument_list|,
name|vq
operator|->
name|trust_anchor_labs
argument_list|,
name|vq
operator|->
name|trust_anchor_len
argument_list|,
name|vq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
block|{
comment|/* trust anchor revoked, restart with less anchors */
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|trust_anchor_name
condition|)
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
comment|/* break a loop */
name|vq
operator|->
name|trust_anchor_name
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Fetch and validate the keyEntry that corresponds to the  	 * current trust anchor. */
if|if
condition|(
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
condition|)
block|{
name|dnskey_rrset
operator|=
name|reply_find_rrset_section_an
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|ta
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ta
operator|->
name|autr
condition|)
block|{
if|if
condition|(
operator|!
name|autr_process_prime
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ve
argument_list|,
name|ta
argument_list|,
name|dnskey_rrset
argument_list|)
condition|)
block|{
comment|/* trust anchor revoked, restart with less anchors */
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
name|vq
operator|->
name|trust_anchor_name
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
name|vq
operator|->
name|key_entry
operator|=
name|primeResponseToKE
argument_list|(
name|dnskey_rrset
argument_list|,
name|ta
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|key_entry
condition|)
block|{
if|if
condition|(
name|key_entry_isbad
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
operator|&&
name|vq
operator|->
name|restart_count
operator|<
name|VAL_MAX_RESTART_COUNT
condition|)
block|{
name|val_blacklist
argument_list|(
operator|&
name|vq
operator|->
name|chain_blacklist
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|origin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|errinf
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|restart_count
operator|++
expr_stmt|;
name|vq
operator|->
name|key_entry
operator|=
name|NULL
expr_stmt|;
name|vq
operator|->
name|state
operator|=
name|VAL_INIT_STATE
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|chain_blacklist
operator|=
name|NULL
expr_stmt|;
name|errinf_origin
argument_list|(
name|qstate
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|errinf_dname
argument_list|(
name|qstate
argument_list|,
literal|"for trust anchor"
argument_list|,
name|ta
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* store the freshly primed entry in the cache */
name|key_cache_insert
argument_list|(
name|ve
operator|->
name|kcache
argument_list|,
name|vq
operator|->
name|key_entry
argument_list|,
name|qstate
argument_list|)
expr_stmt|;
block|}
comment|/* If the result of the prime is a null key, skip the FINDKEY state.*/
if|if
condition|(
operator|!
name|vq
operator|->
name|key_entry
operator|||
name|key_entry_isnull
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
operator|||
name|key_entry_isbad
argument_list|(
name|vq
operator|->
name|key_entry
argument_list|)
condition|)
block|{
name|vq
operator|->
name|state
operator|=
name|VAL_VALIDATE_STATE
expr_stmt|;
block|}
comment|/* the qstate will be reactivated after inform_super is done */
block|}
end_function

begin_comment
comment|/**  * Process DLV response. Called from inform_supers.  * Because it is in inform_supers, the mesh itself is busy doing callbacks  * for a state that is to be deleted soon; don't touch the mesh; instead  * set a state in the super, as the super will be reactivated soon.  * Perform processing to determine what state to set in the super.  *  * @param qstate: query state that is validating and asked for a DLV.  * @param vq: validator query state  * @param id: module id.  * @param rcode: rcode result value.  * @param msg: result message (if rcode is OK).  * @param qinfo: from the sub query state, query info.  */
end_comment

begin_function
specifier|static
name|void
name|process_dlv_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|val_qstate
modifier|*
name|vq
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"process dlv response to super"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
comment|/* lookup failed, set in vq to give up */
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_error
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"response is error"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
operator|->
name|rep
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
block|{
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_error
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"response is not secure, %s"
argument_list|,
name|sec_status_to_string
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|security
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* was the lookup a success? validated DLV? */
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|==
literal|1
operator|&&
name|msg
operator|->
name|rep
operator|->
name|security
operator|==
name|sec_status_secure
operator|&&
name|ntohs
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DLV
operator|&&
name|ntohs
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|qinfo
operator|->
name|qclass
operator|&&
name|query_dname_compare
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|dlv_lookup_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* yay! it is just like a DS */
name|vq
operator|->
name|ds_rrset
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vq
operator|->
name|ds_rrset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|ds_rrset
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in process_dlv"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|ds_rrset
operator|->
name|entry
operator|.
name|key
operator|=
name|vq
operator|->
name|ds_rrset
expr_stmt|;
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|ds_rrset
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in process_dlv"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_error
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|ds_rrset
operator|->
name|entry
operator|.
name|data
operator|=
name|regional_alloc_init
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|vq
operator|->
name|ds_rrset
operator|->
name|entry
operator|.
name|data
argument_list|,
name|packed_rrset_sizeof
argument_list|(
name|vq
operator|->
name|ds_rrset
operator|->
name|entry
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
operator|->
name|ds_rrset
operator|->
name|entry
operator|.
name|data
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in process_dlv"
argument_list|)
expr_stmt|;
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_error
expr_stmt|;
return|return;
block|}
name|packed_rrset_ptr_fixup
argument_list|(
name|vq
operator|->
name|ds_rrset
operator|->
name|entry
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* make vq do a DNSKEY query next up */
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_success
expr_stmt|;
return|return;
block|}
comment|/* store NSECs into negative cache */
name|val_neg_addreply
argument_list|(
name|ve
operator|->
name|neg_cache
argument_list|,
name|msg
operator|->
name|rep
argument_list|)
expr_stmt|;
comment|/* was the lookup a failure?  	 *   if we have to go up into the DLV for a higher DLV anchor 	 *   then set this in the vq, so it can make queries when activated. 	 * See if the NSECs indicate that we should look for higher DLV 	 * or, that there is no DLV securely */
if|if
condition|(
operator|!
name|val_nsec_check_dlv
argument_list|(
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|,
operator|&
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
operator|&
name|vq
operator|->
name|dlv_lookup_name_len
argument_list|)
condition|)
block|{
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_error
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"nsec error"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|vq
operator|->
name|dlv_lookup_name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|anchors
operator|->
name|dlv_anchor
operator|->
name|name
argument_list|)
condition|)
block|{
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_there_is_no_dlv
expr_stmt|;
return|return;
block|}
name|vq
operator|->
name|dlv_status
operator|=
name|dlv_ask_higher
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * inform validator super.  *   * @param qstate: query state that finished.  * @param id: module id.  * @param super: the qstate to inform.  */
end_comment

begin_function
name|void
name|val_inform_super
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|super
parameter_list|)
block|{
name|struct
name|val_qstate
modifier|*
name|vq
init|=
operator|(
expr|struct
name|val_qstate
operator|*
operator|)
name|super
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"validator: inform_super, sub is"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"super is"
argument_list|,
operator|&
name|super
operator|->
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vq
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"super: has no validator state"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vq
operator|->
name|wait_prime_ta
condition|)
block|{
name|vq
operator|->
name|wait_prime_ta
operator|=
literal|0
expr_stmt|;
name|process_prime_response
argument_list|(
name|super
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|qstate
operator|->
name|return_rcode
argument_list|,
name|qstate
operator|->
name|return_msg
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
condition|)
block|{
name|process_ds_response
argument_list|(
name|super
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|qstate
operator|->
name|return_rcode
argument_list|,
name|qstate
operator|->
name|return_msg
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DNSKEY
condition|)
block|{
name|process_dnskey_response
argument_list|(
name|super
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|qstate
operator|->
name|return_rcode
argument_list|,
name|qstate
operator|->
name|return_msg
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|reply_origin
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DLV
condition|)
block|{
name|process_dlv_response
argument_list|(
name|super
argument_list|,
name|vq
argument_list|,
name|id
argument_list|,
name|qstate
operator|->
name|return_rcode
argument_list|,
name|qstate
operator|->
name|return_msg
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_err
argument_list|(
literal|"internal error in validator: no inform_supers possible"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|val_clear
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qstate
condition|)
return|return;
comment|/* everything is allocated in the region, so assign NULL */
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|val_get_mem
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|val_env
modifier|*
name|ve
init|=
operator|(
expr|struct
name|val_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ve
condition|)
return|return
literal|0
return|;
return|return
sizeof|sizeof
argument_list|(
operator|*
name|ve
argument_list|)
operator|+
name|key_cache_get_mem
argument_list|(
name|ve
operator|->
name|kcache
argument_list|)
operator|+
name|val_neg_get_mem
argument_list|(
name|ve
operator|->
name|neg_cache
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|2
operator|*
name|ve
operator|->
name|nsec3_keyiter_count
return|;
block|}
end_function

begin_comment
comment|/**  * The validator function block   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|module_func_block
name|val_block
init|=
block|{
literal|"validator"
block|,
operator|&
name|val_init
block|,
operator|&
name|val_deinit
block|,
operator|&
name|val_operate
block|,
operator|&
name|val_inform_super
block|,
operator|&
name|val_clear
block|,
operator|&
name|val_get_mem
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|module_func_block
modifier|*
name|val_get_funcblock
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|val_block
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|val_state_to_string
parameter_list|(
name|enum
name|val_state
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|VAL_INIT_STATE
case|:
return|return
literal|"VAL_INIT_STATE"
return|;
case|case
name|VAL_FINDKEY_STATE
case|:
return|return
literal|"VAL_FINDKEY_STATE"
return|;
case|case
name|VAL_VALIDATE_STATE
case|:
return|return
literal|"VAL_VALIDATE_STATE"
return|;
case|case
name|VAL_FINISHED_STATE
case|:
return|return
literal|"VAL_FINISHED_STATE"
return|;
case|case
name|VAL_DLVLOOKUP_STATE
case|:
return|return
literal|"VAL_DLVLOOKUP_STATE"
return|;
block|}
return|return
literal|"UNKNOWN VALIDATOR STATE"
return|;
block|}
end_function

end_unit

