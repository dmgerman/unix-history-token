begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_nsec.c - validator NSEC denial of existance functions.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  * The functions help with NSEC checking, the different NSEC proofs  * for denial of existance, and proofs for presence of types.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_utils.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_comment
comment|/** get ttl of rrset */
end_comment

begin_function
specifier|static
name|uint32_t
name|rrset_get_ttl
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
return|return
name|d
operator|->
name|ttl
return|;
block|}
end_function

begin_function
name|int
name|nsecbitmap_has_type_rdata
parameter_list|(
name|uint8_t
modifier|*
name|bitmap
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
comment|/* Check type present in NSEC typemap with bitmap arg */
comment|/* bitmasks for determining type-lowerbits presence */
name|uint8_t
name|masks
index|[
literal|8
index|]
init|=
block|{
literal|0x80
block|,
literal|0x40
block|,
literal|0x20
block|,
literal|0x10
block|,
literal|0x08
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x01
block|}
decl_stmt|;
name|uint8_t
name|type_window
init|=
name|type
operator|>>
literal|8
decl_stmt|;
name|uint8_t
name|type_low
init|=
name|type
operator|&
literal|0xff
decl_stmt|;
name|uint8_t
name|win
decl_stmt|,
name|winlen
decl_stmt|;
comment|/* read each of the type bitmap windows and see if the searched 	 * type is amongst it */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|3
condition|)
comment|/* bad window, at least window# winlen bitmap */
return|return
literal|0
return|;
name|win
operator|=
operator|*
name|bitmap
operator|++
expr_stmt|;
name|winlen
operator|=
operator|*
name|bitmap
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|winlen
operator|||
name|winlen
operator|<
literal|1
operator|||
name|winlen
operator|>
literal|32
condition|)
return|return
literal|0
return|;
comment|/* bad window length */
if|if
condition|(
name|win
operator|==
name|type_window
condition|)
block|{
comment|/* search window bitmap for the correct byte */
comment|/* mybyte is 0 if we need the first byte */
name|size_t
name|mybyte
init|=
name|type_low
operator|>>
literal|3
decl_stmt|;
if|if
condition|(
name|winlen
operator|<=
name|mybyte
condition|)
return|return
literal|0
return|;
comment|/* window too short */
return|return
call|(
name|int
call|)
argument_list|(
name|bitmap
index|[
name|mybyte
index|]
operator|&
name|masks
index|[
name|type_low
operator|&
literal|0x7
index|]
argument_list|)
return|;
block|}
else|else
block|{
comment|/* not the window we are looking for */
name|bitmap
operator|+=
name|winlen
expr_stmt|;
name|len
operator|-=
name|winlen
expr_stmt|;
block|}
block|}
comment|/* end of bitmap reached, no type found */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nsec_has_type
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nsec
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|count
operator|==
literal|0
operator|||
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|<
literal|2
operator|+
literal|1
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|dname_valid
argument_list|(
name|d
operator|->
name|rr_data
index|[
literal|0
index|]
operator|+
literal|2
argument_list|,
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|0
return|;
return|return
name|nsecbitmap_has_type_rdata
argument_list|(
name|d
operator|->
name|rr_data
index|[
literal|0
index|]
operator|+
literal|2
operator|+
name|len
argument_list|,
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|-
literal|2
operator|-
name|len
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Get next owner name from nsec record  * @param nsec: the nsec RRset.  *	If there are multiple RRs, then this will only return one of them.  * @param nm: the next name is returned.  * @param ln: length of nm is returned.  * @return false on a bad NSEC RR (too short, malformed dname).  */
end_comment

begin_function
specifier|static
name|int
name|nsec_get_next
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|size_t
modifier|*
name|ln
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nsec
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|count
operator|==
literal|0
operator|||
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|<
literal|2
operator|+
literal|1
condition|)
block|{
operator|*
name|nm
operator|=
literal|0
expr_stmt|;
operator|*
name|ln
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|nm
operator|=
name|d
operator|->
name|rr_data
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
operator|*
name|ln
operator|=
name|dname_valid
argument_list|(
operator|*
name|nm
argument_list|,
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ln
condition|)
block|{
operator|*
name|nm
operator|=
literal|0
expr_stmt|;
operator|*
name|ln
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * For an NSEC that matches the DS queried for, check absence of DS type.  *  * @param nsec: NSEC for proof, must be trusted.  * @param qinfo: what is queried for.  * @return if secure the nsec proves that no DS is present, or   *	insecure if it proves it is not a delegation point.  *	or bogus if something was wrong.  */
end_comment

begin_function
specifier|static
name|enum
name|sec_status
name|val_nsec_proves_no_ds
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|log_assert
argument_list|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|ntohs
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
operator|&&
name|qinfo
operator|->
name|qname_len
operator|!=
literal|1
condition|)
block|{
comment|/* SOA present means that this is the NSEC from the child,  		 * not the parent (so it is the wrong one). */
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
condition|)
block|{
comment|/* DS present means that there should have been a positive  		 * response to the DS query, so there is something wrong. */
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
operator|!
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
condition|)
block|{
comment|/* If there is no NS at this point at all, then this  		 * doesn't prove anything one way or the other. */
return|return
name|sec_status_insecure
return|;
block|}
comment|/* Otherwise, this proves no DS. */
return|return
name|sec_status_secure
return|;
block|}
end_function

begin_comment
comment|/** check security status from cache or verify rrset, returns true if secure */
end_comment

begin_function
specifier|static
name|int
name|nsec_verify_rrset
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nsec
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
return|return
literal|1
return|;
name|rrset_check_sec_status
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|nsec
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
return|return
literal|1
return|;
name|d
operator|->
name|security
operator|=
name|val_verify_rrset_entry
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|nsec
argument_list|,
name|kkey
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
block|{
name|rrset_update_sec_status
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|nsec
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|val_nsec_prove_nodata_dsreply
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|key_entry_key
modifier|*
name|kkey
parameter_list|,
name|time_t
modifier|*
name|proof_ttl
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
init|=
name|reply_find_rrset_section_ns
argument_list|(
name|rep
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|)
decl_stmt|;
name|enum
name|sec_status
name|sec
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|wc
init|=
name|NULL
decl_stmt|,
modifier|*
name|ce
init|=
name|NULL
decl_stmt|;
name|int
name|valid_nsec
init|=
literal|0
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|wc_nsec
init|=
name|NULL
decl_stmt|;
comment|/* If we have a NSEC at the same name, it must prove one  	 * of two things 	 * -- 	 * 1) this is a delegation point and there is no DS 	 * 2) this is not a delegation point */
if|if
condition|(
name|nsec
condition|)
block|{
if|if
condition|(
operator|!
name|nsec_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|nsec
argument_list|,
name|kkey
argument_list|,
name|reason
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"NSEC RRset for the "
literal|"referral did not verify."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|sec
operator|=
name|val_nsec_proves_no_ds
argument_list|(
name|nsec
argument_list|,
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
comment|/* something was wrong. */
operator|*
name|reason
operator|=
literal|"NSEC does not prove absence of DS"
expr_stmt|;
return|return
name|sec
return|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_insecure
condition|)
block|{
comment|/* this wasn't a delegation point. */
return|return
name|sec
return|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
comment|/* this proved no DS. */
operator|*
name|proof_ttl
operator|=
name|ub_packed_rrset_ttl
argument_list|(
name|nsec
argument_list|)
expr_stmt|;
return|return
name|sec
return|;
block|}
comment|/* if unchecked, fall through to next proof */
block|}
comment|/* Otherwise, there is no NSEC at qname. This could be an ENT.  	 * (ENT=empty non terminal). If not, this is broken. */
comment|/* verify NSEC rrsets in auth section */
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
operator|!=
name|htons
argument_list|(
name|LDNS_RR_TYPE_NSEC
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|nsec_verify_rrset
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|kkey
argument_list|,
name|reason
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"NSEC for empty non-terminal "
literal|"did not verify."
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|nsec_proves_nodata
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|qinfo
argument_list|,
operator|&
name|wc
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"NSEC for empty non-terminal "
literal|"proved no DS."
argument_list|)
expr_stmt|;
operator|*
name|proof_ttl
operator|=
name|rrset_get_ttl
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|&&
name|dname_is_wild
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
name|wc_nsec
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|valid_nsec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val_nsec_proves_name_error
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
block|{
name|ce
operator|=
name|nsec_closest_encloser
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wc
operator|&&
operator|!
name|ce
condition|)
name|valid_nsec
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|&&
name|ce
condition|)
block|{
comment|/* ce and wc must match */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|wc
argument_list|,
name|ce
argument_list|)
operator|!=
literal|0
condition|)
name|valid_nsec
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wc_nsec
condition|)
name|valid_nsec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|valid_nsec
condition|)
block|{
if|if
condition|(
name|wc
condition|)
block|{
comment|/* check if this is a delegation */
operator|*
name|reason
operator|=
literal|"NSEC for wildcard does not prove absence of DS"
expr_stmt|;
return|return
name|val_nsec_proves_no_ds
argument_list|(
name|wc_nsec
argument_list|,
name|qinfo
argument_list|)
return|;
block|}
comment|/* valid nsec proves empty nonterminal */
return|return
name|sec_status_insecure
return|;
block|}
comment|/* NSEC proof did not conlusively point to DS or no DS */
return|return
name|sec_status_unchecked
return|;
block|}
end_function

begin_function
name|int
name|nsec_proves_nodata
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|wc
parameter_list|)
block|{
name|log_assert
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|ln
decl_stmt|;
comment|/* empty-non-terminal checking.  		 * Done before wildcard, because this is an exact match, 		 * and would prevent a wildcard from matching. */
comment|/* If the nsec is proving that qname is an ENT, the nsec owner  		 * will be less than qname, and the next name will be a child  		 * domain of the qname. */
if|if
condition|(
operator|!
name|nsec_get_next
argument_list|(
name|nsec
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|ln
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* bad nsec */
if|if
condition|(
name|dname_strict_subdomain_c
argument_list|(
name|nm
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
operator|&&
name|dname_canonical_compare
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|/* proves ENT */
block|}
comment|/* wildcard checking. */
comment|/* If this is a wildcard NSEC, make sure that a) it was  		 * possible to have generated qname from the wildcard and  		 * b) the type map does not contain qtype. Note that this  		 * does NOT prove that this wildcard was the applicable  		 * wildcard. */
if|if
condition|(
name|dname_is_wild
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
comment|/* the purported closest encloser. */
name|uint8_t
modifier|*
name|ce
init|=
name|nsec
operator|->
name|rk
operator|.
name|dname
decl_stmt|;
name|size_t
name|ce_len
init|=
name|nsec
operator|->
name|rk
operator|.
name|dname_len
decl_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|ce
argument_list|,
operator|&
name|ce_len
argument_list|)
expr_stmt|;
comment|/* The qname must be a strict subdomain of the  			 * closest encloser, for the wildcard to apply  			 */
if|if
condition|(
name|dname_strict_subdomain_c
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|ce
argument_list|)
condition|)
block|{
comment|/* here we have a matching NSEC for the qname, 				 * perform matching NSEC checks */
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|)
condition|)
block|{
comment|/* should have gotten the wildcard CNAME */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
comment|/* wrong parentside (wildcard) NSEC used */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
operator|*
name|wc
operator|=
name|ce
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Otherwise, this NSEC does not prove ENT and is not a  		 * wildcard, so it does not prove NODATA. */
return|return
literal|0
return|;
block|}
comment|/* If the qtype exists, then we should have gotten it. */
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* if the name is a CNAME node, then we should have gotten the CNAME*/
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If an NS set exists at this name, and NOT a SOA (so this is a  	 * zone cut, not a zone apex), then we should have gotten a  	 * referral (or we just got the wrong NSEC).  	 * The reverse of this check is used when qtype is DS, since that 	 * must use the NSEC from above the zone cut. */
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
operator|&&
operator|!
name|dname_is_root
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|val_nsec_proves_name_error
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|)
block|{
name|uint8_t
modifier|*
name|owner
init|=
name|nsec
operator|->
name|rk
operator|.
name|dname
decl_stmt|;
name|uint8_t
modifier|*
name|next
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
if|if
condition|(
operator|!
name|nsec_get_next
argument_list|(
name|nsec
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|nlen
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If NSEC owner == qname, then this NSEC proves that qname exists. */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|qname
argument_list|,
name|owner
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If NSEC is a parent of qname, we need to check the type map 	 * If the parent name has a DNAME or is a delegation point, then  	 * this NSEC is being misused. */
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|qname
argument_list|,
name|owner
argument_list|)
operator|&&
operator|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_DNAME
argument_list|)
operator|||
operator|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|query_dname_compare
argument_list|(
name|owner
argument_list|,
name|next
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* this nsec is the only nsec */
comment|/* zone.name NSEC zone.name, disproves everything else */
comment|/* but only for subdomains of that zone */
if|if
condition|(
name|dname_strict_subdomain_c
argument_list|(
name|qname
argument_list|,
name|next
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|dname_canonical_compare
argument_list|(
name|owner
argument_list|,
name|next
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* this is the last nsec, ....(bigger) NSEC zonename(smaller) */
comment|/* the names after the last (owner) name do not exist  		 * there are no names before the zone name in the zone  		 * but the qname must be a subdomain of the zone name(next). */
if|if
condition|(
name|dname_canonical_compare
argument_list|(
name|owner
argument_list|,
name|qname
argument_list|)
operator|<
literal|0
operator|&&
name|dname_strict_subdomain_c
argument_list|(
name|qname
argument_list|,
name|next
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* regular NSEC, (smaller) NSEC (larger) */
if|if
condition|(
name|dname_canonical_compare
argument_list|(
name|owner
argument_list|,
name|qname
argument_list|)
operator|<
literal|0
operator|&&
name|dname_canonical_compare
argument_list|(
name|qname
argument_list|,
name|next
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|val_nsec_proves_insecuredelegation
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
if|if
condition|(
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
operator|&&
operator|!
name|nsec_has_type
argument_list|(
name|nsec
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
comment|/* see if nsec signals an insecure delegation */
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
condition|)
block|{
comment|/* if type is DS and qname is equal to nsec, then it 			 * is an exact match nsec, result not insecure */
if|if
condition|(
name|dname_strict_subdomain_c
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|nsec_closest_encloser
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|)
block|{
name|uint8_t
modifier|*
name|next
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
name|uint8_t
modifier|*
name|common1
decl_stmt|,
modifier|*
name|common2
decl_stmt|;
if|if
condition|(
operator|!
name|nsec_get_next
argument_list|(
name|nsec
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|nlen
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* longest common with owner or next name */
name|common1
operator|=
name|dname_get_shared_topdomain
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|common2
operator|=
name|dname_get_shared_topdomain
argument_list|(
name|next
argument_list|,
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname_count_labels
argument_list|(
name|common1
argument_list|)
operator|>
name|dname_count_labels
argument_list|(
name|common2
argument_list|)
condition|)
return|return
name|common1
return|;
return|return
name|common2
return|;
block|}
end_function

begin_function
name|int
name|val_nsec_proves_positive_wildcard
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|uint8_t
modifier|*
name|wc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ce
decl_stmt|;
comment|/*  1) prove that qname doesn't exist and  	 *  2) that the correct wildcard was used 	 *  nsec has been verified already. */
if|if
condition|(
operator|!
name|val_nsec_proves_name_error
argument_list|(
name|nsec
argument_list|,
name|qinf
operator|->
name|qname
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* check wildcard name */
name|ce
operator|=
name|nsec_closest_encloser
argument_list|(
name|qinf
operator|->
name|qname
argument_list|,
name|nsec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|wc
argument_list|,
name|ce
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|val_nsec_proves_no_wc
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|)
block|{
comment|/* Determine if a NSEC record proves the non-existence of a  	 * wildcard that could have produced qname. */
name|int
name|labs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|ce
init|=
name|nsec_closest_encloser
argument_list|(
name|qname
argument_list|,
name|nsec
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|strip
decl_stmt|;
name|size_t
name|striplen
decl_stmt|;
name|uint8_t
name|buf
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
literal|0
return|;
comment|/* we can subtract the closest encloser count - since that is the 	 * largest shared topdomain with owner and next NSEC name, 	 * because the NSEC is no proof for names shorter than the owner  	 * and next names. */
name|labs
operator|=
name|dname_count_labels
argument_list|(
name|qname
argument_list|)
operator|-
name|dname_count_labels
argument_list|(
name|ce
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|labs
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* i is number of labels to strip off qname, prepend * wild */
name|strip
operator|=
name|qname
expr_stmt|;
name|striplen
operator|=
name|qnamelen
expr_stmt|;
name|dname_remove_labels
argument_list|(
operator|&
name|strip
argument_list|,
operator|&
name|striplen
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|striplen
operator|>
name|LDNS_MAX_DOMAINLEN
operator|-
literal|2
condition|)
continue|continue;
comment|/* too long to prepend wildcard */
name|buf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|uint8_t
operator|)
literal|'*'
expr_stmt|;
name|memmove
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|strip
argument_list|,
name|striplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|val_nsec_proves_name_error
argument_list|(
name|nsec
argument_list|,
name|buf
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Find shared topdomain that exists  */
end_comment

begin_function
specifier|static
name|void
name|dlv_topdomain
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|size_t
modifier|*
name|nm_len
parameter_list|)
block|{
comment|/* make sure reply is part of nm */
comment|/* take shared topdomain with left of NSEC. */
comment|/* because, if empty nonterminal, then right is subdomain of qname. 	 * and any shared topdomain would be empty nonterminals. 	 *  	 * If nxdomain, then the right is bigger, and could have an  	 * interesting shared topdomain, but if it does have one, it is 	 * an empty nonterminal. An empty nonterminal shared with the left 	 * one. */
name|int
name|n
decl_stmt|;
name|uint8_t
modifier|*
name|common
init|=
name|dname_get_shared_topdomain
argument_list|(
name|qname
argument_list|,
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|)
decl_stmt|;
name|n
operator|=
name|dname_count_labels
argument_list|(
operator|*
name|nm
argument_list|)
operator|-
name|dname_count_labels
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|dname_remove_labels
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|val_nsec_check_dlv
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|size_t
modifier|*
name|nm_len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|next
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|nlen
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* we should now have a NOERROR/NODATA or NXDOMAIN message */
if|if
condition|(
name|rep
operator|->
name|an_numrrsets
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* is this NOERROR ? */
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|rep
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
condition|)
block|{
comment|/* it can be a plain NSEC match - go up one more level. */
comment|/* or its an empty nonterminal - go up to nonempty level */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|htons
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC
operator|||
operator|!
name|nsec_get_next
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|nlen
argument_list|)
condition|)
continue|continue;
name|c
operator|=
name|dname_canonical_compare
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* plain match */
if|if
condition|(
name|nsec_has_type
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|LDNS_RR_TYPE_DLV
argument_list|)
condition|)
return|return
literal|0
return|;
name|dname_remove_label
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|dname_strict_subdomain_c
argument_list|(
name|next
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
block|{
comment|/* ENT */
name|dlv_topdomain
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|nm
argument_list|,
name|nm_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* is this NXDOMAIN ? */
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|rep
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
condition|)
block|{
comment|/* find the qname denial NSEC record. It can tell us 		 * a closest encloser name; or that we not need bother */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|htons
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC
condition|)
continue|continue;
if|if
condition|(
name|val_nsec_proves_name_error
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"topdomain on"
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dlv_topdomain
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|nm
argument_list|,
name|nm_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

