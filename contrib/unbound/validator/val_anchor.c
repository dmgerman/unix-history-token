begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_anchor.c - validator trust anchor storage.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains storage for the trust anchors for the validator.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_sigcrypt.h"
end_include

begin_include
include|#
directive|include
file|"validator/autotrust.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/str2wire.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GLOB_H
end_ifdef

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|anchor_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|int
name|m
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|n1
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|k1
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|n2
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|k2
decl_stmt|;
comment|/* no need to ntohs(class) because sort order is irrelevant */
if|if
condition|(
name|n1
operator|->
name|dclass
operator|!=
name|n2
operator|->
name|dclass
condition|)
block|{
if|if
condition|(
name|n1
operator|->
name|dclass
operator|<
name|n2
operator|->
name|dclass
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|dname_lab_cmp
argument_list|(
name|n1
operator|->
name|name
argument_list|,
name|n1
operator|->
name|namelabs
argument_list|,
name|n2
operator|->
name|name
argument_list|,
name|n2
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|val_anchors
modifier|*
name|anchors_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|val_anchors
modifier|*
name|a
init|=
operator|(
expr|struct
name|val_anchors
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
name|a
operator|->
name|tree
operator|=
name|rbtree_create
argument_list|(
name|anchor_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|tree
condition|)
block|{
name|anchors_delete
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|a
operator|->
name|autr
operator|=
name|autr_global_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|autr
condition|)
block|{
name|anchors_delete
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_basic_init
argument_list|(
operator|&
name|a
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|a
operator|->
name|lock
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|a
operator|->
name|lock
argument_list|,
name|a
operator|->
name|autr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
operator|->
name|autr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/** delete assembled rrset */
end_comment

begin_function
specifier|static
name|void
name|assembled_rrset_delete
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|pkey
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pkey
condition|)
return|return;
if|if
condition|(
name|pkey
operator|->
name|entry
operator|.
name|data
condition|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|pd
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|pkey
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|free
argument_list|(
name|pd
operator|->
name|rr_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
operator|->
name|rr_ttl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
operator|->
name|rr_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pkey
operator|->
name|rk
operator|.
name|dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** destroy locks in tree and delete autotrust anchors */
end_comment

begin_function
specifier|static
name|void
name|anchors_delfunc
parameter_list|(
name|rbnode_t
modifier|*
name|elem
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|elem
decl_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
return|return;
if|if
condition|(
name|ta
operator|->
name|autr
condition|)
block|{
name|autr_point_delete
argument_list|(
name|ta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ta_key
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ta
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|ta
operator|->
name|keylist
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|assembled_rrset_delete
argument_list|(
name|ta
operator|->
name|ds_rrset
argument_list|)
expr_stmt|;
name|assembled_rrset_delete
argument_list|(
name|ta
operator|->
name|dnskey_rrset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|anchors_delete
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
if|if
condition|(
operator|!
name|anchors
condition|)
return|return;
name|lock_unprotect
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|,
name|anchors
operator|->
name|autr
argument_list|)
expr_stmt|;
name|lock_unprotect
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|,
name|anchors
argument_list|)
expr_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchors
operator|->
name|tree
condition|)
name|traverse_postorder
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
name|anchors_delfunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|anchors
operator|->
name|tree
argument_list|)
expr_stmt|;
name|autr_global_delete
argument_list|(
name|anchors
operator|->
name|autr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|anchors_init_parents_locked
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|m
decl_stmt|;
comment|/* nobody else can grab locks because we hold the main lock. 	 * Thus the previous items, after unlocked, are not deleted */
name|RBTREE_FOR
argument_list|(
argument|node
argument_list|,
argument|struct trust_anchor*
argument_list|,
argument|anchors->tree
argument_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|node
operator|->
name|lock
argument_list|)
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
name|prev
operator|->
name|dclass
operator|!=
name|node
operator|->
name|dclass
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|node
operator|->
name|lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|prev
operator|->
name|name
argument_list|,
name|prev
operator|->
name|namelabs
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* we know prev is smaller */
comment|/* sort order like: . com. bla.com. zwb.com. net. */
comment|/* find the previous, or parent-parent-parent */
for|for
control|(
name|p
operator|=
name|prev
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
comment|/* looking for name with few labels, a parent */
if|if
condition|(
name|p
operator|->
name|namelabs
operator|<=
name|m
condition|)
block|{
comment|/* ==: since prev matched m, this is closest*/
comment|/*<: prev matches more, but is not a parent, 			 	* this one is a (grand)parent */
name|node
operator|->
name|parent
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|node
operator|->
name|lock
argument_list|)
expr_stmt|;
name|prev
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** initialise parent pointers in the tree */
end_comment

begin_function
specifier|static
name|void
name|init_parents
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|anchors_init_parents_locked
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|trust_anchor
modifier|*
name|anchor_find
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|int
name|namelabs
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|trust_anchor
name|key
decl_stmt|;
name|rbnode_t
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|namelabs
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|dclass
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|rbtree_search
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|n
operator|->
name|key
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|n
operator|->
name|key
return|;
block|}
end_function

begin_comment
comment|/** create new trust anchor object */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|anchor_new_ta
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|int
name|namelabs
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|int
name|lockit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|rbnode_t
modifier|*
name|r
decl_stmt|;
endif|#
directive|endif
name|struct
name|trust_anchor
modifier|*
name|ta
init|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trust_anchor
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|ta
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ta
argument_list|)
argument_list|)
expr_stmt|;
name|ta
operator|->
name|node
operator|.
name|key
operator|=
name|ta
expr_stmt|;
name|ta
operator|->
name|name
operator|=
name|memdup
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|ta
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ta
operator|->
name|namelabs
operator|=
name|namelabs
expr_stmt|;
name|ta
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|ta
operator|->
name|dclass
operator|=
name|dclass
expr_stmt|;
name|lock_basic_init
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockit
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|r
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|ta
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockit
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|log_assert
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/** find trustanchor key by exact data match */
end_comment

begin_function
specifier|static
name|struct
name|ta_key
modifier|*
name|anchor_find_key
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|ta
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|ta_key
modifier|*
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|ta
operator|->
name|keylist
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|next
control|)
block|{
if|if
condition|(
name|k
operator|->
name|type
operator|==
name|type
operator|&&
name|k
operator|->
name|len
operator|==
name|rdata_len
operator|&&
name|memcmp
argument_list|(
name|k
operator|->
name|data
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|k
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** create new trustanchor key */
end_comment

begin_function
specifier|static
name|struct
name|ta_key
modifier|*
name|anchor_new_ta_key
parameter_list|(
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|ta_key
modifier|*
name|k
init|=
operator|(
expr|struct
name|ta_key
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|data
operator|=
name|memdup
argument_list|(
name|rdata
argument_list|,
name|rdata_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|k
operator|->
name|len
operator|=
name|rdata_len
expr_stmt|;
name|k
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/**  * This routine adds a new RR to a trust anchor. The trust anchor may not  * exist yet, and is created if not. The RR can be DS or DNSKEY.  * This routine will also remove duplicates; storing them only once.  * @param anchors: anchor storage.  * @param name: name of trust anchor (wireformat)  * @param type: type or RR  * @param dclass: class of RR  * @param rdata: rdata wireformat, starting with rdlength.  *	If NULL, nothing is stored, but an entry is created.  * @param rdata_len: length of rdata including rdlength.  * @return: NULL on error, else the trust anchor.  */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|anchor_store_new_key
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|)
block|{
name|struct
name|ta_key
modifier|*
name|k
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
name|int
name|namelabs
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|name
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
name|type
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
block|{
name|log_err
argument_list|(
literal|"Bad type for trust anchor"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* lookup or create trustanchor */
name|ta
operator|=
name|anchor_find
argument_list|(
name|anchors
argument_list|,
name|name
argument_list|,
name|namelabs
argument_list|,
name|namelen
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
block|{
name|ta
operator|=
name|anchor_new_ta
argument_list|(
name|anchors
argument_list|,
name|name
argument_list|,
name|namelabs
argument_list|,
name|namelen
argument_list|,
name|dclass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
return|return
name|NULL
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rdata
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
comment|/* look for duplicates */
if|if
condition|(
name|anchor_find_key
argument_list|(
name|ta
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
name|k
operator|=
name|anchor_new_ta_key
argument_list|(
name|rdata
argument_list|,
name|rdata_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* add new key */
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_DS
condition|)
name|ta
operator|->
name|numDS
operator|++
expr_stmt|;
else|else
name|ta
operator|->
name|numDNSKEY
operator|++
expr_stmt|;
name|k
operator|->
name|next
operator|=
name|ta
operator|->
name|keylist
expr_stmt|;
name|ta
operator|->
name|keylist
operator|=
name|k
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/**  * Add new RR. It converts ldns RR to wire format.  * @param anchors: anchor storage.  * @param rr: the wirerr.  * @param rl: length of rr.  * @param dl: length of dname.  * @return NULL on error, else the trust anchor.  */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|anchor_store_new_rr
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|rr
parameter_list|,
name|size_t
name|rl
parameter_list|,
name|size_t
name|dl
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ta
operator|=
name|anchor_store_new_key
argument_list|(
name|anchors
argument_list|,
name|rr
argument_list|,
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rl
argument_list|,
name|dl
argument_list|)
argument_list|,
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rl
argument_list|,
name|dl
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatawl
argument_list|(
name|rr
argument_list|,
name|rl
argument_list|,
name|dl
argument_list|)
argument_list|,
name|sldns_wirerr_get_rdatalen
argument_list|(
name|rr
argument_list|,
name|rl
argument_list|,
name|dl
argument_list|)
operator|+
literal|2
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"adding trusted key"
argument_list|,
name|rr
argument_list|,
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rl
argument_list|,
name|dl
argument_list|)
argument_list|,
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rl
argument_list|,
name|dl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/**  * Insert insecure anchor  * @param anchors: anchor storage.  * @param str: the domain name.  * @return NULL on error, Else last trust anchor point  */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|anchor_insert_insecure
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
name|size_t
name|dname_len
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|sldns_str2wire_dname
argument_list|(
name|str
argument_list|,
operator|&
name|dname_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
block|{
name|log_err
argument_list|(
literal|"parse error in domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ta
operator|=
name|anchor_store_new_key
argument_list|(
name|anchors
argument_list|,
name|nm
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
name|ta
return|;
block|}
end_function

begin_function
name|struct
name|trust_anchor
modifier|*
name|anchor_store_str
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
name|uint8_t
modifier|*
name|rr
init|=
name|sldns_buffer_begin
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|sldns_buffer_capacity
argument_list|(
name|buffer
argument_list|)
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
name|sldns_str2wire_rr_buf
argument_list|(
name|str
argument_list|,
name|rr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|dname_len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"error parsing trust anchor %s: at %d: %s"
argument_list|,
name|str
argument_list|,
name|LDNS_WIREPARSE_OFFSET
argument_list|(
name|status
argument_list|)
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ta
operator|=
name|anchor_store_new_rr
argument_list|(
name|anchors
argument_list|,
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/**  * Read a file with trust anchors  * @param anchors: anchor storage.  * @param buffer: parsing buffer.  * @param fname: string.  * @param onlyone: only one trust anchor allowed in file.  * @return NULL on error. Else last trust-anchor point.  */
end_comment

begin_function
specifier|static
name|struct
name|trust_anchor
modifier|*
name|anchor_read_file
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|onlyone
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
init|=
name|NULL
decl_stmt|,
modifier|*
name|tanew
decl_stmt|;
name|struct
name|sldns_file_parse_state
name|pst
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|dname_len
decl_stmt|;
name|uint8_t
modifier|*
name|rr
init|=
name|sldns_buffer_begin
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|log_err
argument_list|(
literal|"error opening file %s: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
operator|&
name|pst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pst
argument_list|)
argument_list|)
expr_stmt|;
name|pst
operator|.
name|default_ttl
operator|=
literal|3600
expr_stmt|;
name|pst
operator|.
name|lineno
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|len
operator|=
name|sldns_buffer_capacity
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dname_len
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|sldns_fp2wire_rr_buf
argument_list|(
name|in
argument_list|,
name|rr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|dname_len
argument_list|,
operator|&
name|pst
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
comment|/* empty, $TTL, $ORIGIN */
continue|continue;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"parse error in %s:%d:%d : %s"
argument_list|,
name|fname
argument_list|,
name|pst
operator|.
name|lineno
argument_list|,
name|LDNS_WIREPARSE_OFFSET
argument_list|(
name|status
argument_list|)
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|tanew
operator|=
name|anchor_store_new_rr
argument_list|(
name|anchors
argument_list|,
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mem error at %s line %d"
argument_list|,
name|fname
argument_list|,
name|pst
operator|.
name|lineno
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|onlyone
operator|&&
name|ta
operator|&&
name|ta
operator|!=
name|tanew
condition|)
block|{
name|log_err
argument_list|(
literal|"error at %s line %d: no multiple anchor "
literal|"domains allowed (you can have multiple "
literal|"keys, but they must have the same name)."
argument_list|,
name|fname
argument_list|,
name|pst
operator|.
name|lineno
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ta
operator|=
name|tanew
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|NULL
return|;
comment|/* empty file is OK when multiple anchors are allowed */
if|if
condition|(
operator|!
name|onlyone
operator|&&
operator|!
name|ta
condition|)
return|return
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
literal|1
return|;
return|return
name|ta
return|;
block|}
end_function

begin_comment
comment|/** skip file to end of line */
end_comment

begin_function
specifier|static
name|void
name|skip_to_eol
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/** true for special characters in bind configs */
end_comment

begin_function
specifier|static
name|int
name|is_bind_special
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'"'
case|:
case|case
literal|';'
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * Read a keyword skipping bind comments; spaces, specials, restkeywords.   * The file is split into the following tokens:  *	* special characters, on their own, rdlen=1, { } doublequote ;  *	* whitespace becomes a single ' ' or tab. Newlines become spaces.  *	* other words ('keywords')  *	* comments are skipped if desired  *		/ / C++ style comment to end of line  *		# to end of line  *		/ * C style comment * /  * @param in: file to read from.  * @param buf: buffer, what is read is stored after current buffer position.  *	Space is left in the buffer to write a terminating 0.  * @param line: line number is increased per line, for error reports.  * @param comments: if 0, comments are not possible and become text.  *	if 1, comments are skipped entirely.  *	In BIND files, this is when reading quoted strings, for example  *	" base 64 text with / / in there "  * @return the number of character written to the buffer.   *	0 on end of file.  */
end_comment

begin_function
specifier|static
name|int
name|readkeyword_bindfile
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|line
parameter_list|,
name|int
name|comments
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|numdone
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|comments
operator|&&
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/*   # blabla   */
name|skip_to_eol
argument_list|(
name|in
argument_list|)
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|comments
operator|&&
name|c
operator|==
literal|'/'
operator|&&
name|numdone
operator|>
literal|0
operator|&&
comment|/* /_/ bla*/
name|sldns_buffer_read_u8_at
argument_list|(
name|buf
argument_list|,
name|sldns_buffer_position
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|sldns_buffer_skip
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numdone
operator|--
expr_stmt|;
name|skip_to_eol
argument_list|(
name|in
argument_list|)
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|comments
operator|&&
name|c
operator|==
literal|'*'
operator|&&
name|numdone
operator|>
literal|0
operator|&&
comment|/* /_* bla *_/ */
name|sldns_buffer_read_u8_at
argument_list|(
name|buf
argument_list|,
name|sldns_buffer_position
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|sldns_buffer_skip
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numdone
operator|--
expr_stmt|;
comment|/* skip to end of comment */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|==
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* not a comment, complete the keyword */
if|if
condition|(
name|numdone
operator|>
literal|0
condition|)
block|{
comment|/* check same type */
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
name|numdone
return|;
block|}
if|if
condition|(
name|is_bind_special
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
name|numdone
return|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
literal|' '
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
block|}
comment|/* space for 1 char + 0 string terminator */
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|buf
argument_list|)
operator|<
literal|2
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"trusted-keys, %d, string too long"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_write_u8
argument_list|(
name|buf
argument_list|,
operator|(
name|uint8_t
operator|)
name|c
argument_list|)
expr_stmt|;
name|numdone
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* collate whitespace into ' ' */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|in
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|numdone
return|;
block|}
if|if
condition|(
name|is_bind_special
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|numdone
return|;
block|}
return|return
name|numdone
return|;
block|}
end_function

begin_comment
comment|/** skip through file to { or ; */
end_comment

begin_function
specifier|static
name|int
name|skip_to_special
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|line
parameter_list|,
name|int
name|spec
parameter_list|)
block|{
name|int
name|rdlen
decl_stmt|;
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rdlen
operator|=
name|readkeyword_bindfile
argument_list|(
name|in
argument_list|,
name|buf
argument_list|,
name|line
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rdlen
operator|==
literal|1
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rdlen
operator|!=
literal|1
operator|||
operator|*
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
operator|!=
operator|(
name|uint8_t
operator|)
name|spec
condition|)
block|{
name|sldns_buffer_write_u8
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"trusted-keys, line %d, expected %c"
argument_list|,
operator|*
name|line
argument_list|,
name|spec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"trusted-keys, line %d, expected %c got EOF"
argument_list|,
operator|*
name|line
argument_list|,
name|spec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * read contents of trusted-keys{ ... ; clauses and insert keys into storage.  * @param anchors: where to store keys  * @param buf: buffer to use  * @param line: line number in file  * @param in: file to read from.  * @return 0 on error.  */
end_comment

begin_function
specifier|static
name|int
name|process_bind_contents
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|line
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
comment|/* loop over contents, collate strings before ; */
comment|/* contents is (numbered): 0   1    2  3 4   5  6 7 8    */
comment|/*                           name. 257 3 5 base64 base64 */
comment|/* quoted value:           0 "111"  0  0 0   0  0 0 0    */
comment|/* comments value:         1 "000"  1  1  1 "0  0 0 0"  1 */
name|int
name|contnum
init|=
literal|0
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|int
name|comments
init|=
literal|1
decl_stmt|;
name|int
name|rdlen
decl_stmt|;
name|char
modifier|*
name|str
init|=
literal|0
decl_stmt|;
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rdlen
operator|=
name|readkeyword_bindfile
argument_list|(
name|in
argument_list|,
name|buf
argument_list|,
name|line
argument_list|,
name|comments
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rdlen
operator|==
literal|1
operator|&&
name|sldns_buffer_position
argument_list|(
name|buf
argument_list|)
operator|==
literal|1
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
comment|/* starting whitespace is removed */
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rdlen
operator|==
literal|1
operator|&&
name|sldns_buffer_current
argument_list|(
name|buf
argument_list|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
comment|/* remove " from the string */
if|if
condition|(
name|contnum
operator|==
literal|0
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
name|comments
operator|=
literal|0
expr_stmt|;
block|}
name|sldns_buffer_skip
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|contnum
operator|>
literal|0
operator|&&
name|quoted
condition|)
block|{
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|buf
argument_list|)
operator|<
literal|8
operator|+
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"line %d, too long"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
literal|" DNSKEY "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|comments
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contnum
operator|>
literal|0
condition|)
name|comments
operator|=
operator|!
name|comments
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rdlen
operator|==
literal|1
operator|&&
name|sldns_buffer_current
argument_list|(
name|buf
argument_list|)
index|[
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|contnum
operator|<
literal|5
condition|)
block|{
name|sldns_buffer_write_u8
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"line %d, bad key"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_skip
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u8
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|log_err
argument_list|(
literal|"line %d, allocation failure"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|anchor_store_str
argument_list|(
name|anchors
argument_list|,
name|buf
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"line %d, bad key"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|contnum
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|comments
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rdlen
operator|==
literal|1
operator|&&
name|sldns_buffer_current
argument_list|(
name|buf
argument_list|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
name|contnum
operator|>
literal|0
condition|)
block|{
name|sldns_buffer_write_u8
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"line %d, bad key before }"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rdlen
operator|==
literal|1
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|sldns_buffer_current
argument_list|(
name|buf
argument_list|)
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* leave whitespace here */
block|}
else|else
block|{
comment|/* not space or whatnot, so actual content */
name|contnum
operator|++
expr_stmt|;
if|if
condition|(
name|contnum
operator|==
literal|1
operator|&&
operator|!
name|quoted
condition|)
block|{
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|buf
argument_list|)
operator|<
literal|8
operator|+
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"line %d, too long"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
literal|" DNSKEY "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|log_err
argument_list|(
literal|"line %d, EOF before }"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Read a BIND9 like file with trust anchors in named.conf format.  * @param anchors: anchor storage.  * @param buffer: parsing buffer.  * @param fname: string.  * @return false on error.  */
end_comment

begin_function
specifier|static
name|int
name|anchor_read_bind_file
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|line_nr
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|rdlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|log_err
argument_list|(
literal|"error opening file %s: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"reading in bind-compat-mode: '%s'"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* scan for  trusted-keys  keyword, ignore everything else */
name|sldns_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rdlen
operator|=
name|readkeyword_bindfile
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
operator|&
name|line_nr
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rdlen
operator|!=
literal|12
operator|||
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"trusted-keys"
argument_list|,
literal|12
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sldns_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* ignore everything but trusted-keys */
continue|continue;
block|}
if|if
condition|(
operator|!
name|skip_to_special
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
operator|&
name|line_nr
argument_list|,
literal|'{'
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error in trusted key: \"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* process contents */
if|if
condition|(
operator|!
name|process_bind_contents
argument_list|(
name|anchors
argument_list|,
name|buffer
argument_list|,
operator|&
name|line_nr
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error in trusted key: \"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|skip_to_special
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
operator|&
name|line_nr
argument_list|,
literal|';'
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error in trusted key: \"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Read a BIND9 like files with trust anchors in named.conf format.  * Performs wildcard processing of name.  * @param anchors: anchor storage.  * @param buffer: parsing buffer.  * @param pat: pattern string. (can be wildcarded)  * @return false on error.  */
end_comment

begin_function
specifier|static
name|int
name|anchor_read_bind_file_wild
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GLOB
name|glob_t
name|g
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|r
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'*'
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'?'
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'['
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'{'
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'~'
argument_list|)
condition|)
block|{
return|return
name|anchor_read_bind_file
argument_list|(
name|anchors
argument_list|,
name|buffer
argument_list|,
name|pat
argument_list|)
return|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"wildcard found, processing %s"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
ifdef|#
directive|ifdef
name|GLOB_ERR
operator||
name|GLOB_ERR
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GLOB_NOSORT
operator||
name|GLOB_NOSORT
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GLOB_BRACE
operator||
name|GLOB_BRACE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GLOB_TILDE
operator||
name|GLOB_TILDE
endif|#
directive|endif
expr_stmt|;
name|memset
argument_list|(
operator|&
name|g
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|glob
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* some error */
if|if
condition|(
name|r
operator|==
name|GLOB_NOMATCH
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"trusted-keys-file: "
literal|"no matches for %s"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|GLOB_NOSPACE
condition|)
block|{
name|log_err
argument_list|(
literal|"wildcard trusted-keys-file %s: "
literal|"pattern out of memory"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|GLOB_ABORTED
condition|)
block|{
name|log_err
argument_list|(
literal|"wildcard trusted-keys-file %s: expansion "
literal|"aborted (%s)"
argument_list|,
name|pat
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
literal|"wildcard trusted-keys-file %s: expansion "
literal|"failed (%s)"
argument_list|,
name|pat
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ignore globs that yield no files */
return|return
literal|1
return|;
block|}
comment|/* process files found, if any */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|g
operator|.
name|gl_pathc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|anchor_read_bind_file
argument_list|(
name|anchors
argument_list|,
name|buffer
argument_list|,
name|g
operator|.
name|gl_pathv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error reading wildcard "
literal|"trusted-keys-file: %s"
argument_list|,
name|g
operator|.
name|gl_pathv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|globfree
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|globfree
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
comment|/* not HAVE_GLOB */
return|return
name|anchor_read_bind_file
argument_list|(
name|anchors
argument_list|,
name|buffer
argument_list|,
name|pat
argument_list|)
return|;
endif|#
directive|endif
comment|/* HAVE_GLOB */
block|}
end_function

begin_comment
comment|/**   * Assemble an rrset structure for the type   * @param ta: trust anchor.  * @param num: number of items to fetch from list.  * @param type: fetch only items of this type.  * @return rrset or NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|assemble_it
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|ta
parameter_list|,
name|size_t
name|num
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|pkey
init|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pkey
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|ta_key
modifier|*
name|tk
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pkey
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|pkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|pkey
operator|->
name|rk
operator|.
name|dname
operator|=
name|memdup
argument_list|(
name|ta
operator|->
name|name
argument_list|,
name|ta
operator|->
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pkey
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|ta
operator|->
name|namelen
expr_stmt|;
name|pkey
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pkey
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
comment|/* The rrset is build in an uncompressed way. This means it 	 * cannot be copied in the normal way. */
name|pd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
block|{
name|free
argument_list|(
name|pkey
operator|->
name|rk
operator|.
name|dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|pd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|->
name|count
operator|=
name|num
expr_stmt|;
name|pd
operator|->
name|trust
operator|=
name|rrset_trust_ultimate
expr_stmt|;
name|pd
operator|->
name|rr_len
operator|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
operator|->
name|rr_len
condition|)
block|{
name|free
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
operator|->
name|rk
operator|.
name|dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pd
operator|->
name|rr_ttl
operator|=
operator|(
name|time_t
operator|*
operator|)
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
operator|->
name|rr_ttl
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|rr_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
operator|->
name|rk
operator|.
name|dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pd
operator|->
name|rr_data
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
operator|->
name|rr_data
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|rr_ttl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
operator|->
name|rr_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
operator|->
name|rk
operator|.
name|dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* fill in rrs */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tk
operator|=
name|ta
operator|->
name|keylist
init|;
name|tk
condition|;
name|tk
operator|=
name|tk
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tk
operator|->
name|type
operator|!=
name|type
condition|)
continue|continue;
name|pd
operator|->
name|rr_len
index|[
name|i
index|]
operator|=
name|tk
operator|->
name|len
expr_stmt|;
comment|/* reuse data ptr to allocation in talist */
name|pd
operator|->
name|rr_data
index|[
name|i
index|]
operator|=
name|tk
operator|->
name|data
expr_stmt|;
name|pd
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|pkey
operator|->
name|entry
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
return|return
name|pkey
return|;
block|}
end_function

begin_comment
comment|/**  * Assemble structures for the trust DS and DNSKEY rrsets.  * @param ta: trust anchor  * @return: false on error.  */
end_comment

begin_function
specifier|static
name|int
name|anchors_assemble
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|ta
parameter_list|)
block|{
if|if
condition|(
name|ta
operator|->
name|numDS
operator|>
literal|0
condition|)
block|{
name|ta
operator|->
name|ds_rrset
operator|=
name|assemble_it
argument_list|(
name|ta
argument_list|,
name|ta
operator|->
name|numDS
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
operator|->
name|ds_rrset
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ta
operator|->
name|numDNSKEY
operator|>
literal|0
condition|)
block|{
name|ta
operator|->
name|dnskey_rrset
operator|=
name|assemble_it
argument_list|(
name|ta
argument_list|,
name|ta
operator|->
name|numDNSKEY
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
operator|->
name|dnskey_rrset
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check DS algos for support, warn if not.  * @param ta: trust anchor  * @return number of DS anchors with unsupported algorithms.  */
end_comment

begin_function
specifier|static
name|size_t
name|anchors_ds_unsupported
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|ta
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ta
operator|->
name|numDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ds_digest_algo_is_supported
argument_list|(
name|ta
operator|->
name|ds_rrset
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|ds_key_algo_is_supported
argument_list|(
name|ta
operator|->
name|ds_rrset
argument_list|,
name|i
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/**  * Check DNSKEY algos for support, warn if not.  * @param ta: trust anchor  * @return number of DNSKEY anchors with unsupported algorithms.  */
end_comment

begin_function
specifier|static
name|size_t
name|anchors_dnskey_unsupported
parameter_list|(
name|struct
name|trust_anchor
modifier|*
name|ta
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ta
operator|->
name|numDNSKEY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dnskey_algo_is_supported
argument_list|(
name|ta
operator|->
name|dnskey_rrset
argument_list|,
name|i
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/**  * Assemble the rrsets in the anchors, ready for use by validator.  * @param anchors: trust anchor storage.  * @return: false on error.  */
end_comment

begin_function
specifier|static
name|int
name|anchors_assemble_rrsets
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|next
decl_stmt|;
name|size_t
name|nods
decl_stmt|,
name|nokey
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ta
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|rbtree_first
argument_list|(
name|anchors
operator|->
name|tree
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rbnode_t
operator|*
operator|)
name|ta
operator|!=
name|RBTREE_NULL
condition|)
block|{
name|next
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|rbtree_next
argument_list|(
operator|&
name|ta
operator|->
name|node
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|autr
operator|||
operator|(
name|ta
operator|->
name|numDS
operator|==
literal|0
operator|&&
name|ta
operator|->
name|numDNSKEY
operator|==
literal|0
operator|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ta
operator|=
name|next
expr_stmt|;
comment|/* skip */
continue|continue;
block|}
if|if
condition|(
operator|!
name|anchors_assemble
argument_list|(
name|ta
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nods
operator|=
name|anchors_ds_unsupported
argument_list|(
name|ta
argument_list|)
expr_stmt|;
name|nokey
operator|=
name|anchors_dnskey_unsupported
argument_list|(
name|ta
argument_list|)
expr_stmt|;
if|if
condition|(
name|nods
condition|)
block|{
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"warning: unsupported "
literal|"algorithm for trust anchor"
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nokey
condition|)
block|{
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"warning: unsupported "
literal|"algorithm for trust anchor"
argument_list|,
name|ta
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|ta
operator|->
name|dclass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nods
operator|==
name|ta
operator|->
name|numDS
operator|&&
name|nokey
operator|==
name|ta
operator|->
name|numDNSKEY
condition|)
block|{
name|char
name|b
index|[
literal|257
index|]
decl_stmt|;
name|dname_str
argument_list|(
name|ta
operator|->
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"trust anchor %s has no supported algorithms,"
literal|" the anchor is ignored (check if you need to"
literal|" upgrade unbound and openssl)"
argument_list|,
name|b
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|ta
operator|->
name|node
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
name|anchors_delfunc
argument_list|(
operator|&
name|ta
operator|->
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ta
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ta
operator|=
name|next
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|anchors_apply_cfg
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|config_strlist
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|sldns_buffer
modifier|*
name|parsebuf
init|=
name|sldns_buffer_new
argument_list|(
literal|65535
argument_list|)
decl_stmt|;
for|for
control|(
name|f
operator|=
name|cfg
operator|->
name|domain_insecure
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|str
operator|||
name|f
operator|->
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* empty "" */
continue|continue;
if|if
condition|(
operator|!
name|anchor_insert_insecure
argument_list|(
name|anchors
argument_list|,
name|f
operator|->
name|str
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error in domain-insecure: %s"
argument_list|,
name|f
operator|->
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|f
operator|=
name|cfg
operator|->
name|trust_anchor_file_list
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|str
operator|||
name|f
operator|->
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* empty "" */
continue|continue;
name|nm
operator|=
name|f
operator|->
name|str
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|nm
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nm
operator|+=
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_read_file
argument_list|(
name|anchors
argument_list|,
name|parsebuf
argument_list|,
name|nm
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error reading trust-anchor-file: %s"
argument_list|,
name|f
operator|->
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|f
operator|=
name|cfg
operator|->
name|trusted_keys_file_list
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|str
operator|||
name|f
operator|->
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* empty "" */
continue|continue;
name|nm
operator|=
name|f
operator|->
name|str
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|nm
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nm
operator|+=
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_read_bind_file_wild
argument_list|(
name|anchors
argument_list|,
name|parsebuf
argument_list|,
name|nm
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error reading trusted-keys-file: %s"
argument_list|,
name|f
operator|->
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|f
operator|=
name|cfg
operator|->
name|trust_anchor_list
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|str
operator|||
name|f
operator|->
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* empty "" */
continue|continue;
if|if
condition|(
operator|!
name|anchor_store_str
argument_list|(
name|anchors
argument_list|,
name|parsebuf
argument_list|,
name|f
operator|->
name|str
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error in trust-anchor: \"%s\""
argument_list|,
name|f
operator|->
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|cfg
operator|->
name|dlv_anchor_file
operator|&&
name|cfg
operator|->
name|dlv_anchor_file
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|struct
name|trust_anchor
modifier|*
name|dlva
decl_stmt|;
name|nm
operator|=
name|cfg
operator|->
name|dlv_anchor_file
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|nm
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nm
operator|+=
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dlva
operator|=
name|anchor_read_file
argument_list|(
name|anchors
argument_list|,
name|parsebuf
argument_list|,
name|nm
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error reading dlv-anchor-file: %s"
argument_list|,
name|cfg
operator|->
name|dlv_anchor_file
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|anchors
operator|->
name|dlv_anchor
operator|=
name|dlva
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|f
operator|=
name|cfg
operator|->
name|dlv_anchor_list
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|struct
name|trust_anchor
modifier|*
name|dlva
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|str
operator|||
name|f
operator|->
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* empty "" */
continue|continue;
if|if
condition|(
operator|!
operator|(
name|dlva
operator|=
name|anchor_store_str
argument_list|(
name|anchors
argument_list|,
name|parsebuf
argument_list|,
name|f
operator|->
name|str
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error in dlv-anchor: \"%s\""
argument_list|,
name|f
operator|->
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|anchors
operator|->
name|dlv_anchor
operator|=
name|dlva
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* do autr last, so that it sees what anchors are filled by other 	 * means can can print errors about double config for the name */
for|for
control|(
name|f
operator|=
name|cfg
operator|->
name|auto_trust_anchor_file_list
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|str
operator|||
name|f
operator|->
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* empty "" */
continue|continue;
name|nm
operator|=
name|f
operator|->
name|str
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|nm
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nm
operator|+=
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autr_read_file
argument_list|(
name|anchors
argument_list|,
name|nm
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"error reading auto-trust-anchor-file: %s"
argument_list|,
name|f
operator|->
name|str
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* first assemble, since it may delete useless anchors */
name|anchors_assemble_rrsets
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
name|init_parents
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|parsebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|autr_debug_print
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|trust_anchor
modifier|*
name|anchors_lookup
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qname_len
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|struct
name|trust_anchor
name|key
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|result
decl_stmt|;
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|qname
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_labels
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|qname_len
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|qclass
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact */
name|result
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|res
expr_stmt|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|dclass
operator|!=
name|qclass
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* count number of labels matched */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|result
operator|->
name|namelabs
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until qname is subdomain of stub */
if|if
condition|(
name|result
operator|->
name|namelabs
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|result
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|size_t
name|anchors_get_mem
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
operator|*
name|anchors
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|anchors
condition|)
return|return
literal|0
return|;
name|RBTREE_FOR
argument_list|(
argument|ta
argument_list|,
argument|struct trust_anchor*
argument_list|,
argument|anchors->tree
argument_list|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ta
argument_list|)
operator|+
name|ta
operator|->
name|namelen
expr_stmt|;
comment|/* keys and so on */
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|anchors_add_insecure
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
name|struct
name|trust_anchor
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|nm
argument_list|,
operator|&
name|key
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|c
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtree_search
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* nothing to do, already an anchor or insecure point */
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|anchor_new_ta
argument_list|(
name|anchors
argument_list|,
name|nm
argument_list|,
name|key
operator|.
name|namelabs
argument_list|,
name|key
operator|.
name|namelen
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* no other contents in new ta, because it is insecure point */
name|anchors_init_parents_locked
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|anchors_delete_insecure
parameter_list|(
name|struct
name|val_anchors
modifier|*
name|anchors
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
name|struct
name|trust_anchor
name|key
decl_stmt|;
name|struct
name|trust_anchor
modifier|*
name|ta
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|nm
argument_list|,
operator|&
name|key
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|c
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ta
operator|=
operator|(
expr|struct
name|trust_anchor
operator|*
operator|)
name|rbtree_search
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
operator|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* nothing there */
return|return;
block|}
comment|/* lock it to drive away other threads that use it */
name|lock_basic_lock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* see if its really an insecure point */
if|if
condition|(
name|ta
operator|->
name|keylist
operator|||
name|ta
operator|->
name|autr
operator|||
name|ta
operator|->
name|numDS
operator|||
name|ta
operator|->
name|numDNSKEY
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* its not an insecure point, do not remove it */
return|return;
block|}
comment|/* remove from tree */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|anchors
operator|->
name|tree
argument_list|,
operator|&
name|ta
operator|->
name|node
argument_list|)
expr_stmt|;
name|anchors_init_parents_locked
argument_list|(
name|anchors
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|anchors
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* actual free of data */
name|lock_basic_unlock
argument_list|(
operator|&
name|ta
operator|->
name|lock
argument_list|)
expr_stmt|;
name|anchors_delfunc
argument_list|(
operator|&
name|ta
operator|->
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

