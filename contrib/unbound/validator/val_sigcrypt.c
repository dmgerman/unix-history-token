begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_sigcrypt.c - validator signature crypto functions.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  * The functions help with signature verification and checking, the  * bridging between RR wireformat data and crypto calls.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_sigcrypt.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_secalgo.h"
end_include

begin_include
include|#
directive|include
file|"validator/validator.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/rbtree.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"ldns/keyraw.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"ldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SSL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"Need crypto library to do digital signature cryptography"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_RAND_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_CONF_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ENGINE_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** return number of rrs in an rrset */
end_comment

begin_function
specifier|static
name|size_t
name|rrset_get_count
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|count
return|;
block|}
end_function

begin_comment
comment|/**  * Get RR signature count  */
end_comment

begin_function
specifier|static
name|size_t
name|rrset_get_sigcount
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
return|return
name|d
operator|->
name|rrsig_count
return|;
block|}
end_function

begin_comment
comment|/**  * Get signature keytag value  * @param k: rrset (with signatures)  * @param sig_idx: signature index.  * @return keytag or 0 if malformed rrsig.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|rrset_get_sig_keytag
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|sig_idx
parameter_list|)
block|{
name|uint16_t
name|t
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|sig_idx
operator|<
name|d
operator|->
name|rrsig_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|d
operator|->
name|count
operator|+
name|sig_idx
index|]
operator|<
literal|2
operator|+
literal|18
condition|)
return|return
literal|0
return|;
name|memmove
argument_list|(
operator|&
name|t
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|d
operator|->
name|count
operator|+
name|sig_idx
index|]
operator|+
literal|2
operator|+
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|ntohs
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Get signature signing algorithm value  * @param k: rrset (with signatures)  * @param sig_idx: signature index.  * @return algo or 0 if malformed rrsig.  */
end_comment

begin_function
specifier|static
name|int
name|rrset_get_sig_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|sig_idx
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|sig_idx
operator|<
name|d
operator|->
name|rrsig_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|d
operator|->
name|count
operator|+
name|sig_idx
index|]
operator|<
literal|2
operator|+
literal|3
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|d
operator|->
name|rr_data
index|[
name|d
operator|->
name|count
operator|+
name|sig_idx
index|]
index|[
literal|2
operator|+
literal|2
index|]
return|;
block|}
end_function

begin_comment
comment|/** get rdata pointer and size */
end_comment

begin_function
specifier|static
name|void
name|rrset_get_rdata
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rdata
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|d
operator|&&
name|idx
operator|<
operator|(
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
operator|)
argument_list|)
expr_stmt|;
operator|*
name|rdata
operator|=
name|d
operator|->
name|rr_data
index|[
name|idx
index|]
expr_stmt|;
operator|*
name|len
operator|=
name|d
operator|->
name|rr_len
index|[
name|idx
index|]
expr_stmt|;
block|}
end_function

begin_function
name|uint16_t
name|dnskey_get_flags
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|uint16_t
name|f
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|2
condition|)
return|return
literal|0
return|;
name|memmove
argument_list|(
operator|&
name|f
argument_list|,
name|rdata
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|f
operator|=
name|ntohs
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/**  * Get DNSKEY protocol value from rdata  * @param k: DNSKEY rrset.  * @param idx: which key.  * @return protocol octet value  */
end_comment

begin_function
specifier|static
name|int
name|dnskey_get_protocol
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|4
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|rdata
index|[
literal|2
operator|+
literal|2
index|]
return|;
block|}
end_function

begin_function
name|int
name|dnskey_get_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|4
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|rdata
index|[
literal|2
operator|+
literal|3
index|]
return|;
block|}
end_function

begin_comment
comment|/** get public key rdata field from a dnskey RR and do some checks */
end_comment

begin_function
specifier|static
name|void
name|dnskey_get_pubkey
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|pk
parameter_list|,
name|unsigned
name|int
modifier|*
name|pklen
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|5
condition|)
block|{
operator|*
name|pk
operator|=
name|NULL
expr_stmt|;
operator|*
name|pklen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
operator|*
name|pk
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rdata
operator|+
literal|2
operator|+
literal|4
expr_stmt|;
operator|*
name|pklen
operator|=
operator|(
name|unsigned
operator|)
name|len
operator|-
literal|2
operator|-
literal|4
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ds_get_key_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|3
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|rdata
index|[
literal|2
operator|+
literal|2
index|]
return|;
block|}
end_function

begin_function
name|int
name|ds_get_digest_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|4
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|rdata
index|[
literal|2
operator|+
literal|3
index|]
return|;
block|}
end_function

begin_function
name|uint16_t
name|ds_get_keytag
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|size_t
name|ds_idx
parameter_list|)
block|{
name|uint16_t
name|t
decl_stmt|;
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|2
condition|)
return|return
literal|0
return|;
name|memmove
argument_list|(
operator|&
name|t
argument_list|,
name|rdata
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|ntohs
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return pointer to the digest in a DS RR.  * @param k: DS rrset.  * @param idx: which DS.  * @param digest: digest data is returned.  *	on error, this is NULL.  * @param len: length of digest is returned.  *	on error, the length is 0.  */
end_comment

begin_function
specifier|static
name|void
name|ds_get_sigdata
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|digest
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|rdlen
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|k
argument_list|,
name|idx
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|rdlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdlen
operator|<
literal|2
operator|+
literal|5
condition|)
block|{
operator|*
name|digest
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
operator|*
name|digest
operator|=
name|rdata
operator|+
literal|2
operator|+
literal|4
expr_stmt|;
operator|*
name|len
operator|=
name|rdlen
operator|-
literal|2
operator|-
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return size of DS digest according to its hash algorithm.  * @param k: DS rrset.  * @param idx: which DS.  * @return size in bytes of digest, or 0 if not supported.   */
end_comment

begin_function
specifier|static
name|size_t
name|ds_digest_size_algo
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|size_t
name|idx
parameter_list|)
block|{
return|return
name|ds_digest_size_supported
argument_list|(
name|ds_get_digest_algo
argument_list|(
name|k
argument_list|,
name|idx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Create a DS digest for a DNSKEY entry.  *  * @param env: module environment. Uses scratch space.  * @param dnskey_rrset: DNSKEY rrset.  * @param dnskey_idx: index of RR in rrset.  * @param ds_rrset: DS rrset  * @param ds_idx: index of RR in DS rrset.  * @param digest: digest is returned in here (must be correctly sized).  * @return false on error.  */
end_comment

begin_function
specifier|static
name|int
name|ds_create_dnskey_digest
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|size_t
name|dnskey_idx
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|size_t
name|ds_idx
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|sldns_buffer
modifier|*
name|b
init|=
name|env
operator|->
name|scratch_buffer
decl_stmt|;
name|uint8_t
modifier|*
name|dnskey_rdata
decl_stmt|;
name|size_t
name|dnskey_len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|dnskey_rrset
argument_list|,
name|dnskey_idx
argument_list|,
operator|&
name|dnskey_rdata
argument_list|,
operator|&
name|dnskey_len
argument_list|)
expr_stmt|;
comment|/* create digest source material in buffer  	 * digest = digest_algorithm( DNSKEY owner name | DNSKEY RDATA); 	 *	DNSKEY RDATA = Flags | Protocol | Algorithm | Public Key. */
name|sldns_buffer_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|b
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dnskey_rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|b
argument_list|,
name|dnskey_rdata
operator|+
literal|2
argument_list|,
name|dnskey_len
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* skip rdatalen*/
name|sldns_buffer_flip
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|secalgo_ds_digest
argument_list|(
name|ds_get_digest_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|b
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ds_digest_match_dnskey
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|size_t
name|dnskey_idx
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|size_t
name|ds_idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ds
decl_stmt|;
comment|/* DS digest */
name|size_t
name|dslen
decl_stmt|;
name|uint8_t
modifier|*
name|digest
decl_stmt|;
comment|/* generated digest */
name|size_t
name|digestlen
init|=
name|ds_digest_size_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DS fail: not supported, or DS RR "
literal|"format error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* not supported, or DS RR format error */
block|}
comment|/* check digest length in DS with length from hash function */
name|ds_get_sigdata
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|,
operator|&
name|ds
argument_list|,
operator|&
name|dslen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ds
operator|||
name|dslen
operator|!=
name|digestlen
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DS fail: DS RR algo and digest do not "
literal|"match each other"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* DS algorithm and digest do not match */
block|}
name|digest
operator|=
name|regional_alloc
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|digest
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DS fail: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* mem error */
block|}
if|if
condition|(
operator|!
name|ds_create_dnskey_digest
argument_list|(
name|env
argument_list|,
name|dnskey_rrset
argument_list|,
name|dnskey_idx
argument_list|,
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|,
name|digest
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DS fail: could not calc key digest"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* digest algo failed */
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|digest
argument_list|,
name|ds
argument_list|,
name|dslen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"DS fail: digest is different"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* digest different */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ds_digest_algo_is_supported
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|size_t
name|ds_idx
parameter_list|)
block|{
return|return
operator|(
name|ds_digest_size_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ds_key_algo_is_supported
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds_rrset
parameter_list|,
name|size_t
name|ds_idx
parameter_list|)
block|{
return|return
name|dnskey_algo_id_is_supported
argument_list|(
name|ds_get_key_algo
argument_list|(
name|ds_rrset
argument_list|,
name|ds_idx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|dnskey_calc_keytag
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|size_t
name|dnskey_idx
parameter_list|)
block|{
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|dnskey_rrset
argument_list|,
name|dnskey_idx
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* do not pass rdatalen to ldns */
return|return
name|sldns_calc_keytag_raw
argument_list|(
name|data
operator|+
literal|2
argument_list|,
name|len
operator|-
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|dnskey_algo_is_supported
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey_rrset
parameter_list|,
name|size_t
name|dnskey_idx
parameter_list|)
block|{
return|return
name|dnskey_algo_id_is_supported
argument_list|(
name|dnskey_get_algo
argument_list|(
name|dnskey_rrset
argument_list|,
name|dnskey_idx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|algo_needs_init_dnskey_add
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|)
block|{
name|uint8_t
name|algo
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|total
init|=
name|n
operator|->
name|num
decl_stmt|;
name|size_t
name|num
init|=
name|rrset_get_count
argument_list|(
name|dnskey
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
operator|(
name|uint8_t
operator|)
name|dnskey_get_algo
argument_list|(
name|dnskey
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dnskey_algo_id_is_supported
argument_list|(
operator|(
name|int
operator|)
name|algo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|==
literal|0
condition|)
block|{
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|=
literal|1
expr_stmt|;
name|sigalg
index|[
name|total
index|]
operator|=
name|algo
expr_stmt|;
name|total
operator|++
expr_stmt|;
block|}
block|}
name|sigalg
index|[
name|total
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|num
operator|=
name|total
expr_stmt|;
block|}
end_function

begin_function
name|void
name|algo_needs_init_list
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|)
block|{
name|uint8_t
name|algo
decl_stmt|;
name|size_t
name|total
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|n
operator|->
name|needs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|ALGO_NEEDS_MAX
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|algo
operator|=
operator|*
name|sigalg
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|log_assert
argument_list|(
name|dnskey_algo_id_is_supported
argument_list|(
operator|(
name|int
operator|)
name|algo
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|=
literal|1
expr_stmt|;
name|total
operator|++
expr_stmt|;
block|}
name|n
operator|->
name|num
operator|=
name|total
expr_stmt|;
block|}
end_function

begin_function
name|void
name|algo_needs_init_ds
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ds
parameter_list|,
name|int
name|fav_ds_algo
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|)
block|{
name|uint8_t
name|algo
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|size_t
name|num
init|=
name|rrset_get_count
argument_list|(
name|ds
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|n
operator|->
name|needs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|ALGO_NEEDS_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ds_get_digest_algo
argument_list|(
name|ds
argument_list|,
name|i
argument_list|)
operator|!=
name|fav_ds_algo
condition|)
continue|continue;
name|algo
operator|=
operator|(
name|uint8_t
operator|)
name|ds_get_key_algo
argument_list|(
name|ds
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dnskey_algo_id_is_supported
argument_list|(
operator|(
name|int
operator|)
name|algo
argument_list|)
condition|)
continue|continue;
name|log_assert
argument_list|(
name|algo
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* we do not support 0 and is EOS */
if|if
condition|(
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|==
literal|0
condition|)
block|{
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|=
literal|1
expr_stmt|;
name|sigalg
index|[
name|total
index|]
operator|=
name|algo
expr_stmt|;
name|total
operator|++
expr_stmt|;
block|}
block|}
name|sigalg
index|[
name|total
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|num
operator|=
name|total
expr_stmt|;
block|}
end_function

begin_function
name|int
name|algo_needs_set_secure
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|,
name|uint8_t
name|algo
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|needs
index|[
name|algo
index|]
condition|)
block|{
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|num
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|num
operator|==
literal|0
condition|)
comment|/* done! */
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|algo_needs_set_bogus
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|,
name|uint8_t
name|algo
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|needs
index|[
name|algo
index|]
condition|)
name|n
operator|->
name|needs
index|[
name|algo
index|]
operator|=
literal|2
expr_stmt|;
comment|/* need it, but bogus */
block|}
end_function

begin_function
name|size_t
name|algo_needs_num_missing
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|)
block|{
return|return
name|n
operator|->
name|num
return|;
block|}
end_function

begin_function
name|int
name|algo_needs_missing
parameter_list|(
name|struct
name|algo_needs
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* first check if a needed algo was bogus - report that */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALGO_NEEDS_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|needs
index|[
name|i
index|]
operator|==
literal|2
condition|)
return|return
literal|0
return|;
comment|/* now check which algo is missing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALGO_NEEDS_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|needs
index|[
name|i
index|]
operator|==
literal|1
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|dnskeyset_verify_rrset
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey
parameter_list|,
name|uint8_t
modifier|*
name|sigalg
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num
decl_stmt|;
name|rbtree_t
modifier|*
name|sortree
init|=
name|NULL
decl_stmt|;
comment|/* make sure that for all DNSKEY algorithms there are valid sigs */
name|struct
name|algo_needs
name|needs
decl_stmt|;
name|int
name|alg
decl_stmt|;
name|num
operator|=
name|rrset_get_sigcount
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"rrset failed to verify due to a lack of "
literal|"signatures"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"no signatures"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|sigalg
condition|)
block|{
name|algo_needs_init_list
argument_list|(
operator|&
name|needs
argument_list|,
name|sigalg
argument_list|)
expr_stmt|;
if|if
condition|(
name|algo_needs_num_missing
argument_list|(
operator|&
name|needs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"zone has no known algorithms"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"zone has no known algorithms"
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|sec
operator|=
name|dnskeyset_verify_rrset_sig
argument_list|(
name|env
argument_list|,
name|ve
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
name|rrset
argument_list|,
name|dnskey
argument_list|,
name|i
argument_list|,
operator|&
name|sortree
argument_list|,
name|reason
argument_list|)
expr_stmt|;
comment|/* see which algorithm has been fixed up */
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
if|if
condition|(
operator|!
name|sigalg
condition|)
return|return
name|sec
return|;
comment|/* done! */
elseif|else
if|if
condition|(
name|algo_needs_set_secure
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|rrset_get_sig_algo
argument_list|(
name|rrset
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|sec
return|;
comment|/* done! */
block|}
elseif|else
if|if
condition|(
name|sigalg
operator|&&
name|sec
operator|==
name|sec_status_bogus
condition|)
block|{
name|algo_needs_set_bogus
argument_list|(
operator|&
name|needs
argument_list|,
operator|(
name|uint8_t
operator|)
name|rrset_get_sig_algo
argument_list|(
name|rrset
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sigalg
operator|&&
operator|(
name|alg
operator|=
name|algo_needs_missing
argument_list|(
operator|&
name|needs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"rrset failed to verify: "
literal|"no valid signatures for %d algorithms"
argument_list|,
operator|(
name|int
operator|)
name|algo_needs_num_missing
argument_list|(
operator|&
name|needs
argument_list|)
argument_list|)
expr_stmt|;
name|algo_needs_reason
argument_list|(
name|env
argument_list|,
name|alg
argument_list|,
name|reason
argument_list|,
literal|"no signatures"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"rrset failed to verify: "
literal|"no valid signatures"
argument_list|)
expr_stmt|;
block|}
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_function
name|void
name|algo_needs_reason
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|alg
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sldns_lookup_table
modifier|*
name|t
init|=
name|sldns_lookup_by_id
argument_list|(
name|sldns_algorithms
argument_list|,
name|alg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|name
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s with algorithm %s"
argument_list|,
name|s
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s with algorithm ALG%u"
argument_list|,
name|s
argument_list|,
operator|(
name|unsigned
operator|)
name|alg
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
name|regional_strdup
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|reason
condition|)
operator|*
name|reason
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|dnskey_verify_rrset
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey
parameter_list|,
name|size_t
name|dnskey_idx
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num
decl_stmt|,
name|numchecked
init|=
literal|0
decl_stmt|;
name|rbtree_t
modifier|*
name|sortree
init|=
name|NULL
decl_stmt|;
name|int
name|buf_canon
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tag
init|=
name|dnskey_calc_keytag
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|)
decl_stmt|;
name|int
name|algo
init|=
name|dnskey_get_algo
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|)
decl_stmt|;
name|num
operator|=
name|rrset_get_sigcount
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"rrset failed to verify due to a lack of "
literal|"signatures"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"no signatures"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* see if sig matches keytag and algo */
if|if
condition|(
name|algo
operator|!=
name|rrset_get_sig_algo
argument_list|(
name|rrset
argument_list|,
name|i
argument_list|)
operator|||
name|tag
operator|!=
name|rrset_get_sig_keytag
argument_list|(
name|rrset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|buf_canon
operator|=
literal|0
expr_stmt|;
name|sec
operator|=
name|dnskey_verify_rrset_sig
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|env
operator|->
name|scratch_buffer
argument_list|,
name|ve
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
name|rrset
argument_list|,
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|,
name|i
argument_list|,
operator|&
name|sortree
argument_list|,
operator|&
name|buf_canon
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
return|return
name|sec
return|;
name|numchecked
operator|++
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"rrset failed to verify: all signatures are bogus"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numchecked
condition|)
operator|*
name|reason
operator|=
literal|"signature missing"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_function
name|enum
name|sec_status
name|dnskeyset_verify_rrset_sig
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey
parameter_list|,
name|size_t
name|sig_idx
parameter_list|,
name|struct
name|rbtree_t
modifier|*
modifier|*
name|sortree
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* find matching keys and check them */
name|enum
name|sec_status
name|sec
init|=
name|sec_status_bogus
decl_stmt|;
name|uint16_t
name|tag
init|=
name|rrset_get_sig_keytag
argument_list|(
name|rrset
argument_list|,
name|sig_idx
argument_list|)
decl_stmt|;
name|int
name|algo
init|=
name|rrset_get_sig_algo
argument_list|(
name|rrset
argument_list|,
name|sig_idx
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num
init|=
name|rrset_get_count
argument_list|(
name|dnskey
argument_list|)
decl_stmt|;
name|size_t
name|numchecked
init|=
literal|0
decl_stmt|;
name|int
name|buf_canon
init|=
literal|0
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"verify sig %d %d"
argument_list|,
operator|(
name|int
operator|)
name|tag
argument_list|,
name|algo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dnskey_algo_id_is_supported
argument_list|(
name|algo
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify sig: unknown algorithm"
argument_list|)
expr_stmt|;
return|return
name|sec_status_insecure
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* see if key matches keytag and algo */
if|if
condition|(
name|algo
operator|!=
name|dnskey_get_algo
argument_list|(
name|dnskey
argument_list|,
name|i
argument_list|)
operator|||
name|tag
operator|!=
name|dnskey_calc_keytag
argument_list|(
name|dnskey
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|numchecked
operator|++
expr_stmt|;
comment|/* see if key verifies */
name|sec
operator|=
name|dnskey_verify_rrset_sig
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|env
operator|->
name|scratch_buffer
argument_list|,
name|ve
argument_list|,
name|now
argument_list|,
name|rrset
argument_list|,
name|dnskey
argument_list|,
name|i
argument_list|,
name|sig_idx
argument_list|,
name|sortree
argument_list|,
operator|&
name|buf_canon
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
return|return
name|sec
return|;
block|}
if|if
condition|(
name|numchecked
operator|==
literal|0
condition|)
block|{
operator|*
name|reason
operator|=
literal|"signatures from unknown keys"
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: could not find appropriate key"
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_comment
comment|/**  * RR entries in a canonical sorted tree of RRs  */
end_comment

begin_struct
struct|struct
name|canon_rr
block|{
comment|/** rbtree node, key is this structure */
name|rbnode_t
name|node
decl_stmt|;
comment|/** rrset the RR is in */
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
comment|/** which RR in the rrset */
name|size_t
name|rr_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Compare two RR for canonical order, in a field-style sweep.  * @param d: rrset data  * @param desc: ldns wireformat descriptor.  * @param i: first RR to compare  * @param j: first RR to compare  * @return comparison code.  */
end_comment

begin_function
specifier|static
name|int
name|canonical_compare_byfield
parameter_list|(
name|struct
name|packed_rrset_data
modifier|*
name|d
parameter_list|,
specifier|const
name|sldns_rr_descriptor
modifier|*
name|desc
parameter_list|,
name|size_t
name|i
parameter_list|,
name|size_t
name|j
parameter_list|)
block|{
comment|/* sweep across rdata, keep track of some state: 	 * 	which rr field, and bytes left in field. 	 * 	current position in rdata, length left. 	 * 	are we in a dname, length left in a label. 	 */
name|int
name|wfi
init|=
operator|-
literal|1
decl_stmt|;
comment|/* current wireformat rdata field (rdf) */
name|int
name|wfj
init|=
operator|-
literal|1
decl_stmt|;
name|uint8_t
modifier|*
name|di
init|=
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
decl_stmt|;
comment|/* ptr to current rdata byte */
name|uint8_t
modifier|*
name|dj
init|=
name|d
operator|->
name|rr_data
index|[
name|j
index|]
operator|+
literal|2
decl_stmt|;
name|size_t
name|ilen
init|=
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
decl_stmt|;
comment|/* length left in rdata */
name|size_t
name|jlen
init|=
name|d
operator|->
name|rr_len
index|[
name|j
index|]
operator|-
literal|2
decl_stmt|;
name|int
name|dname_i
init|=
literal|0
decl_stmt|;
comment|/* true if these bytes are part of a name */
name|int
name|dname_j
init|=
literal|0
decl_stmt|;
name|size_t
name|lablen_i
init|=
literal|0
decl_stmt|;
comment|/* 0 for label length byte,for first byte of rdf*/
name|size_t
name|lablen_j
init|=
literal|0
decl_stmt|;
comment|/* otherwise remaining length of rdf or label */
name|int
name|dname_num_i
init|=
operator|(
name|int
operator|)
name|desc
operator|->
name|_dname_count
decl_stmt|;
comment|/* decreased at root label */
name|int
name|dname_num_j
init|=
operator|(
name|int
operator|)
name|desc
operator|->
name|_dname_count
decl_stmt|;
comment|/* loop while there are rdata bytes available for both rrs, 	 * and still some lowercasing needs to be done; either the dnames 	 * have not been reached yet, or they are currently being processed */
while|while
condition|(
name|ilen
operator|>
literal|0
operator|&&
name|jlen
operator|>
literal|0
operator|&&
operator|(
name|dname_num_i
operator|>
literal|0
operator|||
name|dname_num_j
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* compare these two bytes */
comment|/* lowercase if in a dname and not a label length byte */
if|if
condition|(
operator|(
operator|(
name|dname_i
operator|&&
name|lablen_i
operator|)
condition|?
operator|(
name|uint8_t
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|di
argument_list|)
else|:
operator|*
name|di
operator|)
operator|!=
operator|(
operator|(
name|dname_j
operator|&&
name|lablen_j
operator|)
condition|?
operator|(
name|uint8_t
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|dj
argument_list|)
else|:
operator|*
name|dj
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dname_i
operator|&&
name|lablen_i
operator|)
condition|?
operator|(
name|uint8_t
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|di
argument_list|)
else|:
operator|*
name|di
operator|)
operator|<
operator|(
operator|(
name|dname_j
operator|&&
name|lablen_j
operator|)
condition|?
operator|(
name|uint8_t
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|dj
argument_list|)
else|:
operator|*
name|dj
operator|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
name|ilen
operator|--
expr_stmt|;
name|jlen
operator|--
expr_stmt|;
comment|/* bytes are equal */
comment|/* advance field i */
comment|/* lablen 0 means that this byte is the first byte of the 		 * next rdata field; inspect this rdata field and setup 		 * to process the rest of this rdata field. 		 * The reason to first read the byte, then setup the rdf, 		 * is that we are then sure the byte is available and short 		 * rdata is handled gracefully (even if it is a formerr). */
if|if
condition|(
name|lablen_i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dname_i
condition|)
block|{
comment|/* scan this dname label */
comment|/* capture length to lowercase */
name|lablen_i
operator|=
operator|(
name|size_t
operator|)
operator|*
name|di
expr_stmt|;
if|if
condition|(
name|lablen_i
operator|==
literal|0
condition|)
block|{
comment|/* end root label */
name|dname_i
operator|=
literal|0
expr_stmt|;
name|dname_num_i
operator|--
expr_stmt|;
comment|/* if dname num is 0, then the 					 * remainder is binary only */
if|if
condition|(
name|dname_num_i
operator|==
literal|0
condition|)
name|lablen_i
operator|=
name|ilen
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* scan this rdata field */
name|wfi
operator|++
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|_wireformat
index|[
name|wfi
index|]
operator|==
name|LDNS_RDF_TYPE_DNAME
condition|)
block|{
name|dname_i
operator|=
literal|1
expr_stmt|;
name|lablen_i
operator|=
operator|(
name|size_t
operator|)
operator|*
name|di
expr_stmt|;
if|if
condition|(
name|lablen_i
operator|==
literal|0
condition|)
block|{
name|dname_i
operator|=
literal|0
expr_stmt|;
name|dname_num_i
operator|--
expr_stmt|;
if|if
condition|(
name|dname_num_i
operator|==
literal|0
condition|)
name|lablen_i
operator|=
name|ilen
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|desc
operator|->
name|_wireformat
index|[
name|wfi
index|]
operator|==
name|LDNS_RDF_TYPE_STR
condition|)
name|lablen_i
operator|=
operator|(
name|size_t
operator|)
operator|*
name|di
expr_stmt|;
else|else
name|lablen_i
operator|=
name|get_rdf_size
argument_list|(
name|desc
operator|->
name|_wireformat
index|[
name|wfi
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|lablen_i
operator|--
expr_stmt|;
comment|/* advance field j; same as for i */
if|if
condition|(
name|lablen_j
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dname_j
condition|)
block|{
name|lablen_j
operator|=
operator|(
name|size_t
operator|)
operator|*
name|dj
expr_stmt|;
if|if
condition|(
name|lablen_j
operator|==
literal|0
condition|)
block|{
name|dname_j
operator|=
literal|0
expr_stmt|;
name|dname_num_j
operator|--
expr_stmt|;
if|if
condition|(
name|dname_num_j
operator|==
literal|0
condition|)
name|lablen_j
operator|=
name|jlen
expr_stmt|;
block|}
block|}
else|else
block|{
name|wfj
operator|++
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|_wireformat
index|[
name|wfj
index|]
operator|==
name|LDNS_RDF_TYPE_DNAME
condition|)
block|{
name|dname_j
operator|=
literal|1
expr_stmt|;
name|lablen_j
operator|=
operator|(
name|size_t
operator|)
operator|*
name|dj
expr_stmt|;
if|if
condition|(
name|lablen_j
operator|==
literal|0
condition|)
block|{
name|dname_j
operator|=
literal|0
expr_stmt|;
name|dname_num_j
operator|--
expr_stmt|;
if|if
condition|(
name|dname_num_j
operator|==
literal|0
condition|)
name|lablen_j
operator|=
name|jlen
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|desc
operator|->
name|_wireformat
index|[
name|wfj
index|]
operator|==
name|LDNS_RDF_TYPE_STR
condition|)
name|lablen_j
operator|=
operator|(
name|size_t
operator|)
operator|*
name|dj
expr_stmt|;
else|else
name|lablen_j
operator|=
name|get_rdf_size
argument_list|(
name|desc
operator|->
name|_wireformat
index|[
name|wfj
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|lablen_j
operator|--
expr_stmt|;
name|di
operator|++
expr_stmt|;
name|dj
operator|++
expr_stmt|;
block|}
comment|/* end of the loop; because we advanced byte by byte; now we have 	 * that the rdata has ended, or that there is a binary remainder */
comment|/* shortest first */
if|if
condition|(
name|ilen
operator|==
literal|0
operator|&&
name|jlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ilen
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|jlen
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* binary remainder, capture comparison in wfi variable */
if|if
condition|(
operator|(
name|wfi
operator|=
name|memcmp
argument_list|(
name|di
argument_list|,
name|dj
argument_list|,
operator|(
name|ilen
operator|<
name|jlen
operator|)
condition|?
name|ilen
else|:
name|jlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|wfi
return|;
if|if
condition|(
name|ilen
operator|<
name|jlen
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|jlen
operator|<
name|ilen
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Compare two RRs in the same RRset and determine their relative  * canonical order.  * @param rrset: the rrset in which to perform compares.  * @param i: first RR to compare  * @param j: first RR to compare  * @return 0 if RR i== RR j, -1 if<, +1 if>.  */
end_comment

begin_function
specifier|static
name|int
name|canonical_compare
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|size_t
name|i
parameter_list|,
name|size_t
name|j
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
specifier|const
name|sldns_rr_descriptor
modifier|*
name|desc
decl_stmt|;
name|uint16_t
name|type
init|=
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
decl_stmt|;
name|size_t
name|minlen
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
return|return
literal|0
return|;
comment|/* in case rdata-len is to be compared for canonical order 	c = memcmp(d->rr_data[i], d->rr_data[j], 2); 	if(c != 0) 		return c; */
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* These RR types have only a name as RDATA.  		 * This name has to be canonicalized.*/
case|case
name|LDNS_RR_TYPE_NS
case|:
case|case
name|LDNS_RR_TYPE_MD
case|:
case|case
name|LDNS_RR_TYPE_MF
case|:
case|case
name|LDNS_RR_TYPE_CNAME
case|:
case|case
name|LDNS_RR_TYPE_MB
case|:
case|case
name|LDNS_RR_TYPE_MG
case|:
case|case
name|LDNS_RR_TYPE_MR
case|:
case|case
name|LDNS_RR_TYPE_PTR
case|:
case|case
name|LDNS_RR_TYPE_DNAME
case|:
comment|/* the wireread function has already checked these 			 * dname's for correctness, and this double checks */
if|if
condition|(
operator|!
name|dname_valid
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
operator|||
operator|!
name|dname_valid
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|j
index|]
operator|+
literal|2
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|j
index|]
operator|-
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|query_dname_compare
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|j
index|]
operator|+
literal|2
argument_list|)
return|;
comment|/* These RR types have STR and fixed size rdata fields 		 * before one or more name fields that need canonicalizing, 		 * and after that a byte-for byte remainder can be compared. 		 */
comment|/* type starts with the name; remainder is binary compared */
case|case
name|LDNS_RR_TYPE_NXT
case|:
comment|/* use rdata field formats */
case|case
name|LDNS_RR_TYPE_MINFO
case|:
case|case
name|LDNS_RR_TYPE_RP
case|:
case|case
name|LDNS_RR_TYPE_SOA
case|:
case|case
name|LDNS_RR_TYPE_RT
case|:
case|case
name|LDNS_RR_TYPE_AFSDB
case|:
case|case
name|LDNS_RR_TYPE_KX
case|:
case|case
name|LDNS_RR_TYPE_MX
case|:
case|case
name|LDNS_RR_TYPE_SIG
case|:
comment|/* RRSIG signer name has to be downcased */
case|case
name|LDNS_RR_TYPE_RRSIG
case|:
case|case
name|LDNS_RR_TYPE_PX
case|:
case|case
name|LDNS_RR_TYPE_NAPTR
case|:
case|case
name|LDNS_RR_TYPE_SRV
case|:
name|desc
operator|=
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* this holds for the types that need canonicalizing */
name|log_assert
argument_list|(
name|desc
operator|->
name|_minimum
operator|==
name|desc
operator|->
name|_maximum
argument_list|)
expr_stmt|;
return|return
name|canonical_compare_byfield
argument_list|(
name|d
argument_list|,
name|desc
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
return|;
case|case
name|LDNS_RR_TYPE_HINFO
case|:
comment|/* no longer downcased */
case|case
name|LDNS_RR_TYPE_NSEC
case|:
default|default:
comment|/* For unknown RR types, or types not listed above, 		 * no canonicalization is needed, do binary compare */
comment|/* byte for byte compare, equal means shortest first*/
name|minlen
operator|=
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|minlen
operator|>
name|d
operator|->
name|rr_len
index|[
name|j
index|]
operator|-
literal|2
condition|)
name|minlen
operator|=
name|d
operator|->
name|rr_len
index|[
name|j
index|]
operator|-
literal|2
expr_stmt|;
name|c
operator|=
name|memcmp
argument_list|(
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|j
index|]
operator|+
literal|2
argument_list|,
name|minlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|/* rdata equal, shortest is first */
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|<
name|d
operator|->
name|rr_len
index|[
name|j
index|]
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|>
name|d
operator|->
name|rr_len
index|[
name|j
index|]
condition|)
return|return
literal|1
return|;
comment|/* rdata equal, length equal */
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|canonical_tree_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|struct
name|canon_rr
modifier|*
name|r1
init|=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|k1
decl_stmt|;
name|struct
name|canon_rr
modifier|*
name|r2
init|=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|k2
decl_stmt|;
name|log_assert
argument_list|(
name|r1
operator|->
name|rrset
operator|==
name|r2
operator|->
name|rrset
argument_list|)
expr_stmt|;
return|return
name|canonical_compare
argument_list|(
name|r1
operator|->
name|rrset
argument_list|,
name|r1
operator|->
name|rr_idx
argument_list|,
name|r2
operator|->
name|rr_idx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Sort RRs for rrset in canonical order.  * Does not actually canonicalize the RR rdatas.  * Does not touch rrsigs.  * @param rrset: to sort.  * @param d: rrset data.  * @param sortree: tree to sort into.  * @param rrs: rr storage.  */
end_comment

begin_function
specifier|static
name|void
name|canonical_sort
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|d
parameter_list|,
name|rbtree_t
modifier|*
name|sortree
parameter_list|,
name|struct
name|canon_rr
modifier|*
name|rrs
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* insert into rbtree to sort and detect duplicates */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rrs
index|[
name|i
index|]
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|rrs
index|[
name|i
index|]
expr_stmt|;
name|rrs
index|[
name|i
index|]
operator|.
name|rrset
operator|=
name|rrset
expr_stmt|;
name|rrs
index|[
name|i
index|]
operator|.
name|rr_idx
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|sortree
argument_list|,
operator|&
name|rrs
index|[
name|i
index|]
operator|.
name|node
argument_list|)
condition|)
block|{
comment|/* this was a duplicate */
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Inser canonical owner name into buffer.  * @param buf: buffer to insert into at current position.  * @param k: rrset with its owner name.  * @param sig: signature with signer name and label count.  * 	must be length checked, at least 18 bytes long.  * @param can_owner: position in buffer returned for future use.  * @param can_owner_len: length of canonical owner name.  */
end_comment

begin_function
specifier|static
name|void
name|insert_can_owner
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|uint8_t
modifier|*
name|sig
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|can_owner
parameter_list|,
name|size_t
modifier|*
name|can_owner_len
parameter_list|)
block|{
name|int
name|rrsig_labels
init|=
operator|(
name|int
operator|)
name|sig
index|[
literal|3
index|]
decl_stmt|;
name|int
name|fqdn_labels
init|=
name|dname_signame_label_count
argument_list|(
name|k
operator|->
name|rk
operator|.
name|dname
argument_list|)
decl_stmt|;
operator|*
name|can_owner
operator|=
name|sldns_buffer_current
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrsig_labels
operator|==
name|fqdn_labels
condition|)
block|{
comment|/* no change */
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|k
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
operator|*
name|can_owner
argument_list|)
expr_stmt|;
operator|*
name|can_owner_len
operator|=
name|k
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
return|return;
block|}
name|log_assert
argument_list|(
name|rrsig_labels
operator|<
name|fqdn_labels
argument_list|)
expr_stmt|;
comment|/* *. | fqdn(rightmost rrsig_labels) */
if|if
condition|(
name|rrsig_labels
operator|<
name|fqdn_labels
condition|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|k
operator|->
name|rk
operator|.
name|dname
decl_stmt|;
name|size_t
name|len
init|=
name|k
operator|->
name|rk
operator|.
name|dname_len
decl_stmt|;
comment|/* so skip fqdn_labels-rrsig_labels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fqdn_labels
operator|-
name|rrsig_labels
condition|;
name|i
operator|++
control|)
block|{
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
operator|*
name|can_owner_len
operator|=
name|len
operator|+
literal|2
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\001*"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
operator|*
name|can_owner
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Canonicalize Rdata in buffer.  * @param buf: buffer at position just after the rdata.  * @param rrset: rrset with type.  * @param len: length of the rdata (including rdatalen uint16).  */
end_comment

begin_function
specifier|static
name|void
name|canonicalize_rdata
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|datstart
init|=
name|sldns_buffer_current
argument_list|(
name|buf
argument_list|)
operator|-
name|len
operator|+
literal|2
decl_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
condition|)
block|{
case|case
name|LDNS_RR_TYPE_NXT
case|:
case|case
name|LDNS_RR_TYPE_NS
case|:
case|case
name|LDNS_RR_TYPE_MD
case|:
case|case
name|LDNS_RR_TYPE_MF
case|:
case|case
name|LDNS_RR_TYPE_CNAME
case|:
case|case
name|LDNS_RR_TYPE_MB
case|:
case|case
name|LDNS_RR_TYPE_MG
case|:
case|case
name|LDNS_RR_TYPE_MR
case|:
case|case
name|LDNS_RR_TYPE_PTR
case|:
case|case
name|LDNS_RR_TYPE_DNAME
case|:
comment|/* type only has a single argument, the name */
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
return|return;
case|case
name|LDNS_RR_TYPE_MINFO
case|:
case|case
name|LDNS_RR_TYPE_RP
case|:
case|case
name|LDNS_RR_TYPE_SOA
case|:
comment|/* two names after another */
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|datstart
operator|+
name|dname_valid
argument_list|(
name|datstart
argument_list|,
name|len
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|LDNS_RR_TYPE_RT
case|:
case|case
name|LDNS_RR_TYPE_AFSDB
case|:
case|case
name|LDNS_RR_TYPE_KX
case|:
case|case
name|LDNS_RR_TYPE_MX
case|:
comment|/* skip fixed part */
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|2
operator|+
literal|1
condition|)
comment|/* rdlen, skiplen, 1byteroot */
return|return;
name|datstart
operator|+=
literal|2
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
return|return;
case|case
name|LDNS_RR_TYPE_SIG
case|:
comment|/* downcase the RRSIG, compat with BIND (kept it from SIG) */
case|case
name|LDNS_RR_TYPE_RRSIG
case|:
comment|/* skip fixed part */
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|18
operator|+
literal|1
condition|)
return|return;
name|datstart
operator|+=
literal|18
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
return|return;
case|case
name|LDNS_RR_TYPE_PX
case|:
comment|/* skip, then two names after another */
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|2
operator|+
literal|1
condition|)
return|return;
name|datstart
operator|+=
literal|2
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|datstart
operator|+
name|dname_valid
argument_list|(
name|datstart
argument_list|,
name|len
operator|-
literal|2
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|LDNS_RR_TYPE_NAPTR
case|:
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|4
condition|)
return|return;
name|len
operator|-=
literal|2
operator|+
literal|4
expr_stmt|;
name|datstart
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
condition|)
comment|/* skip text field */
return|return;
name|len
operator|-=
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|datstart
operator|+=
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
condition|)
comment|/* skip text field */
return|return;
name|len
operator|-=
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|datstart
operator|+=
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
condition|)
comment|/* skip text field */
return|return;
name|len
operator|-=
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|datstart
operator|+=
operator|(
name|size_t
operator|)
name|datstart
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
comment|/* check name is at least 1 byte*/
return|return;
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
return|return;
case|case
name|LDNS_RR_TYPE_SRV
case|:
comment|/* skip fixed part */
if|if
condition|(
name|len
operator|<
literal|2
operator|+
literal|6
operator|+
literal|1
condition|)
return|return;
name|datstart
operator|+=
literal|6
expr_stmt|;
name|query_dname_tolower
argument_list|(
name|datstart
argument_list|)
expr_stmt|;
return|return;
comment|/* do not canonicalize NSEC rdata name, compat with  		 * from bind 9.4 signer, where it does not do so */
case|case
name|LDNS_RR_TYPE_NSEC
case|:
comment|/* type starts with the name */
case|case
name|LDNS_RR_TYPE_HINFO
case|:
comment|/* not downcased */
comment|/* A6 not supported */
default|default:
comment|/* nothing to do for unknown types */
return|return;
block|}
block|}
end_function

begin_function
name|int
name|rrset_canonical_equal
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k1
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k2
parameter_list|)
block|{
name|struct
name|rbtree_t
name|sortree1
decl_stmt|,
name|sortree2
decl_stmt|;
name|struct
name|canon_rr
modifier|*
name|rrs1
decl_stmt|,
modifier|*
name|rrs2
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d1
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k1
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d2
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k2
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|struct
name|ub_packed_rrset_key
name|fk
decl_stmt|;
name|struct
name|packed_rrset_data
name|fd
decl_stmt|;
name|size_t
name|flen
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|fdata
index|[
literal|2
index|]
decl_stmt|;
comment|/* basic compare */
if|if
condition|(
name|k1
operator|->
name|rk
operator|.
name|dname_len
operator|!=
name|k2
operator|->
name|rk
operator|.
name|dname_len
operator|||
name|k1
operator|->
name|rk
operator|.
name|flags
operator|!=
name|k2
operator|->
name|rk
operator|.
name|flags
operator|||
name|k1
operator|->
name|rk
operator|.
name|type
operator|!=
name|k2
operator|->
name|rk
operator|.
name|type
operator|||
name|k1
operator|->
name|rk
operator|.
name|rrset_class
operator|!=
name|k2
operator|->
name|rk
operator|.
name|rrset_class
operator|||
name|query_dname_compare
argument_list|(
name|k1
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|k2
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d1
operator|->
name|ttl
operator|!=
name|d2
operator|->
name|ttl
operator|||
name|d1
operator|->
name|count
operator|!=
name|d2
operator|->
name|count
operator|||
name|d1
operator|->
name|rrsig_count
operator|!=
name|d2
operator|->
name|rrsig_count
operator|||
name|d1
operator|->
name|trust
operator|!=
name|d2
operator|->
name|trust
operator|||
name|d1
operator|->
name|security
operator|!=
name|d2
operator|->
name|security
condition|)
return|return
literal|0
return|;
comment|/* init */
name|memset
argument_list|(
operator|&
name|fk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|fk
operator|.
name|entry
operator|.
name|data
operator|=
operator|&
name|fd
expr_stmt|;
name|fd
operator|.
name|count
operator|=
literal|2
expr_stmt|;
name|fd
operator|.
name|rr_len
operator|=
name|flen
expr_stmt|;
name|fd
operator|.
name|rr_data
operator|=
name|fdata
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|sortree1
argument_list|,
operator|&
name|canonical_tree_compare
argument_list|)
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|sortree2
argument_list|,
operator|&
name|canonical_tree_compare
argument_list|)
expr_stmt|;
name|rrs1
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|canon_rr
argument_list|)
operator|*
name|d1
operator|->
name|count
argument_list|)
expr_stmt|;
name|rrs2
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|canon_rr
argument_list|)
operator|*
name|d2
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrs1
operator|||
operator|!
name|rrs2
condition|)
return|return
literal|1
return|;
comment|/* alloc failure */
comment|/* sort */
name|canonical_sort
argument_list|(
name|k1
argument_list|,
name|d1
argument_list|,
operator|&
name|sortree1
argument_list|,
name|rrs1
argument_list|)
expr_stmt|;
name|canonical_sort
argument_list|(
name|k2
argument_list|,
name|d2
argument_list|,
operator|&
name|sortree2
argument_list|,
name|rrs2
argument_list|)
expr_stmt|;
comment|/* compare canonical-sorted RRs for canonical-equality */
if|if
condition|(
name|sortree1
operator|.
name|count
operator|!=
name|sortree2
operator|.
name|count
condition|)
return|return
literal|0
return|;
name|p1
operator|=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|rbtree_first
argument_list|(
operator|&
name|sortree1
argument_list|)
expr_stmt|;
name|p2
operator|=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|rbtree_first
argument_list|(
operator|&
name|sortree2
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|RBTREE_NULL
operator|&&
name|p2
operator|!=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|RBTREE_NULL
condition|)
block|{
name|flen
index|[
literal|0
index|]
operator|=
name|d1
operator|->
name|rr_len
index|[
name|p1
operator|->
name|rr_idx
index|]
expr_stmt|;
name|flen
index|[
literal|1
index|]
operator|=
name|d2
operator|->
name|rr_len
index|[
name|p2
operator|->
name|rr_idx
index|]
expr_stmt|;
name|fdata
index|[
literal|0
index|]
operator|=
name|d1
operator|->
name|rr_data
index|[
name|p1
operator|->
name|rr_idx
index|]
expr_stmt|;
name|fdata
index|[
literal|1
index|]
operator|=
name|d2
operator|->
name|rr_data
index|[
name|p2
operator|->
name|rr_idx
index|]
expr_stmt|;
if|if
condition|(
name|canonical_compare
argument_list|(
operator|&
name|fk
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|p1
operator|=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|rbtree_next
argument_list|(
operator|&
name|p1
operator|->
name|node
argument_list|)
expr_stmt|;
name|p2
operator|=
operator|(
expr|struct
name|canon_rr
operator|*
operator|)
name|rbtree_next
argument_list|(
operator|&
name|p2
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Create canonical form of rrset in the scratch buffer.  * @param region: temporary region.  * @param buf: the buffer to use.  * @param k: the rrset to insert.  * @param sig: RRSIG rdata to include.  * @param siglen: RRSIG rdata len excluding signature field, but inclusive  * 	signer name length.  * @param sortree: if NULL is passed a new sorted rrset tree is built.  * 	Otherwise it is reused.  * @return false on alloc error.  */
end_comment

begin_function
specifier|static
name|int
name|rrset_canonical
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|uint8_t
modifier|*
name|sig
parameter_list|,
name|size_t
name|siglen
parameter_list|,
name|struct
name|rbtree_t
modifier|*
modifier|*
name|sortree
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|can_owner
init|=
name|NULL
decl_stmt|;
name|size_t
name|can_owner_len
init|=
literal|0
decl_stmt|;
name|struct
name|canon_rr
modifier|*
name|walk
decl_stmt|;
name|struct
name|canon_rr
modifier|*
name|rrs
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|sortree
condition|)
block|{
operator|*
name|sortree
operator|=
operator|(
expr|struct
name|rbtree_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rbtree_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sortree
condition|)
return|return
literal|0
return|;
name|rrs
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|canon_rr
argument_list|)
operator|*
name|d
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrs
condition|)
block|{
operator|*
name|sortree
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rbtree_init
argument_list|(
operator|*
name|sortree
argument_list|,
operator|&
name|canonical_tree_compare
argument_list|)
expr_stmt|;
name|canonical_sort
argument_list|(
name|k
argument_list|,
name|d
argument_list|,
operator|*
name|sortree
argument_list|,
name|rrs
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
comment|/* canonicalize signer name */
name|query_dname_tolower
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
operator|+
literal|18
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|walk
argument_list|,
argument|struct canon_rr*
argument_list|,
argument|(*sortree)
argument_list|)
block|{
comment|/* see if there is enough space left in the buffer */
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|buf
argument_list|)
operator|<
name|can_owner_len
operator|+
literal|2
operator|+
literal|2
operator|+
literal|4
operator|+
name|d
operator|->
name|rr_len
index|[
name|walk
operator|->
name|rr_idx
index|]
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: failed to canonicalize, "
literal|"rrset too big"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* determine canonical owner name */
if|if
condition|(
name|can_owner
condition|)
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|can_owner
argument_list|,
name|can_owner_len
argument_list|)
expr_stmt|;
else|else
name|insert_can_owner
argument_list|(
name|buf
argument_list|,
name|k
argument_list|,
name|sig
argument_list|,
operator|&
name|can_owner
argument_list|,
operator|&
name|can_owner_len
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
operator|&
name|k
operator|->
name|rk
operator|.
name|type
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
operator|&
name|k
operator|->
name|rk
operator|.
name|rrset_class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|sig
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|walk
operator|->
name|rr_idx
index|]
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|walk
operator|->
name|rr_idx
index|]
argument_list|)
expr_stmt|;
name|canonicalize_rdata
argument_list|(
name|buf
argument_list|,
name|k
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|walk
operator|->
name|rr_idx
index|]
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** pretty print rrsig error with dates */
end_comment

begin_function
specifier|static
name|void
name|sigdate_error
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int32_t
name|expi
parameter_list|,
name|int32_t
name|incep
parameter_list|,
name|int32_t
name|now
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|char
name|expi_buf
index|[
literal|16
index|]
decl_stmt|;
name|char
name|incep_buf
index|[
literal|16
index|]
decl_stmt|;
name|char
name|now_buf
index|[
literal|16
index|]
decl_stmt|;
name|time_t
name|te
decl_stmt|,
name|ti
decl_stmt|,
name|tn
decl_stmt|;
if|if
condition|(
name|verbosity
operator|<
name|VERB_QUERY
condition|)
return|return;
name|te
operator|=
operator|(
name|time_t
operator|)
name|expi
expr_stmt|;
name|ti
operator|=
operator|(
name|time_t
operator|)
name|incep
expr_stmt|;
name|tn
operator|=
operator|(
name|time_t
operator|)
name|now
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmtime_r
argument_list|(
operator|&
name|te
argument_list|,
operator|&
name|tm
argument_list|)
operator|&&
name|strftime
argument_list|(
name|expi_buf
argument_list|,
literal|15
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
operator|&&
name|gmtime_r
argument_list|(
operator|&
name|ti
argument_list|,
operator|&
name|tm
argument_list|)
operator|&&
name|strftime
argument_list|(
name|incep_buf
argument_list|,
literal|15
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
operator|&&
name|gmtime_r
argument_list|(
operator|&
name|tn
argument_list|,
operator|&
name|tm
argument_list|)
operator|&&
name|strftime
argument_list|(
name|now_buf
argument_list|,
literal|15
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"%s expi=%s incep=%s now=%s"
argument_list|,
name|str
argument_list|,
name|expi_buf
argument_list|,
name|incep_buf
argument_list|,
name|now_buf
argument_list|)
expr_stmt|;
block|}
else|else
name|log_info
argument_list|(
literal|"%s expi=%u incep=%u now=%u"
argument_list|,
name|str
argument_list|,
operator|(
name|unsigned
operator|)
name|expi
argument_list|,
operator|(
name|unsigned
operator|)
name|incep
argument_list|,
operator|(
name|unsigned
operator|)
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** check rrsig dates */
end_comment

begin_function
specifier|static
name|int
name|check_dates
parameter_list|(
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|uint32_t
name|unow
parameter_list|,
name|uint8_t
modifier|*
name|expi_p
parameter_list|,
name|uint8_t
modifier|*
name|incep_p
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* read out the dates */
name|int32_t
name|expi
decl_stmt|,
name|incep
decl_stmt|,
name|now
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|expi
argument_list|,
name|expi_p
argument_list|,
sizeof|sizeof
argument_list|(
name|expi
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|incep
argument_list|,
name|incep_p
argument_list|,
sizeof|sizeof
argument_list|(
name|incep
argument_list|)
argument_list|)
expr_stmt|;
name|expi
operator|=
name|ntohl
argument_list|(
name|expi
argument_list|)
expr_stmt|;
name|incep
operator|=
name|ntohl
argument_list|(
name|incep
argument_list|)
expr_stmt|;
comment|/* get current date */
if|if
condition|(
name|ve
operator|->
name|date_override
condition|)
block|{
if|if
condition|(
name|ve
operator|->
name|date_override
operator|==
operator|-
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"date override: ignore date"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|now
operator|=
name|ve
operator|->
name|date_override
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"date override option %d"
argument_list|,
operator|(
name|int
operator|)
name|now
argument_list|)
expr_stmt|;
block|}
else|else
name|now
operator|=
operator|(
name|int32_t
operator|)
name|unow
expr_stmt|;
comment|/* check them */
if|if
condition|(
name|incep
operator|-
name|expi
operator|>
literal|0
condition|)
block|{
name|sigdate_error
argument_list|(
literal|"verify: inception after expiration, "
literal|"signature bad"
argument_list|,
name|expi
argument_list|,
name|incep
argument_list|,
name|now
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature inception after expiration"
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|incep
operator|-
name|now
operator|>
literal|0
condition|)
block|{
comment|/* within skew ? (calc here to avoid calculation normally) */
name|int32_t
name|skew
init|=
operator|(
name|expi
operator|-
name|incep
operator|)
operator|/
literal|10
decl_stmt|;
if|if
condition|(
name|skew
operator|<
name|ve
operator|->
name|skew_min
condition|)
name|skew
operator|=
name|ve
operator|->
name|skew_min
expr_stmt|;
if|if
condition|(
name|skew
operator|>
name|ve
operator|->
name|skew_max
condition|)
name|skew
operator|=
name|ve
operator|->
name|skew_max
expr_stmt|;
if|if
condition|(
name|incep
operator|-
name|now
operator|>
name|skew
condition|)
block|{
name|sigdate_error
argument_list|(
literal|"verify: signature bad, current time is"
literal|" before inception date"
argument_list|,
name|expi
argument_list|,
name|incep
argument_list|,
name|now
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature before inception date"
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sigdate_error
argument_list|(
literal|"verify warning suspicious signature inception "
literal|" or bad local clock"
argument_list|,
name|expi
argument_list|,
name|incep
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|-
name|expi
operator|>
literal|0
condition|)
block|{
name|int32_t
name|skew
init|=
operator|(
name|expi
operator|-
name|incep
operator|)
operator|/
literal|10
decl_stmt|;
if|if
condition|(
name|skew
operator|<
name|ve
operator|->
name|skew_min
condition|)
name|skew
operator|=
name|ve
operator|->
name|skew_min
expr_stmt|;
if|if
condition|(
name|skew
operator|>
name|ve
operator|->
name|skew_max
condition|)
name|skew
operator|=
name|ve
operator|->
name|skew_max
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|expi
operator|>
name|skew
condition|)
block|{
name|sigdate_error
argument_list|(
literal|"verify: signature expired"
argument_list|,
name|expi
argument_list|,
name|incep
argument_list|,
name|now
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature expired"
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sigdate_error
argument_list|(
literal|"verify warning suspicious signature expiration "
literal|" or bad local clock"
argument_list|,
name|expi
argument_list|,
name|incep
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** adjust rrset TTL for verified rrset, compare to original TTL and expi */
end_comment

begin_function
specifier|static
name|void
name|adjust_ttl
parameter_list|(
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|uint32_t
name|unow
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
name|orig_p
parameter_list|,
name|uint8_t
modifier|*
name|expi_p
parameter_list|,
name|uint8_t
modifier|*
name|incep_p
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
comment|/* read out the dates */
name|int32_t
name|origttl
decl_stmt|,
name|expittl
decl_stmt|,
name|expi
decl_stmt|,
name|incep
decl_stmt|,
name|now
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|origttl
argument_list|,
name|orig_p
argument_list|,
sizeof|sizeof
argument_list|(
name|origttl
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|expi
argument_list|,
name|expi_p
argument_list|,
sizeof|sizeof
argument_list|(
name|expi
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|incep
argument_list|,
name|incep_p
argument_list|,
sizeof|sizeof
argument_list|(
name|incep
argument_list|)
argument_list|)
expr_stmt|;
name|expi
operator|=
name|ntohl
argument_list|(
name|expi
argument_list|)
expr_stmt|;
name|incep
operator|=
name|ntohl
argument_list|(
name|incep
argument_list|)
expr_stmt|;
name|origttl
operator|=
name|ntohl
argument_list|(
name|origttl
argument_list|)
expr_stmt|;
comment|/* get current date */
if|if
condition|(
name|ve
operator|->
name|date_override
condition|)
block|{
name|now
operator|=
name|ve
operator|->
name|date_override
expr_stmt|;
block|}
else|else
name|now
operator|=
operator|(
name|int32_t
operator|)
name|unow
expr_stmt|;
name|expittl
operator|=
name|expi
operator|-
name|now
expr_stmt|;
comment|/* so now: 	 * d->ttl: rrset ttl read from message or cache. May be reduced 	 * origttl: original TTL from signature, authoritative TTL max. 	 * expittl: TTL until the signature expires. 	 * 	 * Use the smallest of these. 	 */
if|if
condition|(
name|d
operator|->
name|ttl
operator|>
operator|(
name|time_t
operator|)
name|origttl
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"rrset TTL larger than original TTL,"
literal|" adjusting TTL downwards"
argument_list|)
expr_stmt|;
name|d
operator|->
name|ttl
operator|=
name|origttl
expr_stmt|;
block|}
if|if
condition|(
name|expittl
operator|>
literal|0
operator|&&
name|d
operator|->
name|ttl
operator|>
operator|(
name|time_t
operator|)
name|expittl
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"rrset TTL larger than sig expiration ttl,"
literal|" adjusting TTL downwards"
argument_list|)
expr_stmt|;
name|d
operator|->
name|ttl
operator|=
name|expittl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|sec_status
name|dnskey_verify_rrset_sig
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|val_env
modifier|*
name|ve
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dnskey
parameter_list|,
name|size_t
name|dnskey_idx
parameter_list|,
name|size_t
name|sig_idx
parameter_list|,
name|struct
name|rbtree_t
modifier|*
modifier|*
name|sortree
parameter_list|,
name|int
modifier|*
name|buf_canon
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|enum
name|sec_status
name|sec
decl_stmt|;
name|uint8_t
modifier|*
name|sig
decl_stmt|;
comment|/* RRSIG rdata */
name|size_t
name|siglen
decl_stmt|;
name|size_t
name|rrnum
init|=
name|rrset_get_count
argument_list|(
name|rrset
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|signer
decl_stmt|;
comment|/* rrsig signer name */
name|size_t
name|signer_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sigblock
decl_stmt|;
comment|/* signature rdata field */
name|unsigned
name|int
name|sigblock_len
decl_stmt|;
name|uint16_t
name|ktag
decl_stmt|;
comment|/* DNSKEY key tag */
name|unsigned
name|char
modifier|*
name|key
decl_stmt|;
comment|/* public key rdata field */
name|unsigned
name|int
name|keylen
decl_stmt|;
name|rrset_get_rdata
argument_list|(
name|rrset
argument_list|,
name|rrnum
operator|+
name|sig_idx
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|siglen
argument_list|)
expr_stmt|;
comment|/* min length of rdatalen, fixed rrsig, root signer, 1 byte sig */
if|if
condition|(
name|siglen
operator|<
literal|2
operator|+
literal|20
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: signature too short"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature too short"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|dnskey_get_flags
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|)
operator|&
name|DNSKEY_BIT_ZSK
operator|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: dnskey without ZSK flag"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"dnskey without ZSK flag"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|dnskey_get_protocol
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|)
operator|!=
name|LDNS_DNSSEC_KEYPROTO
condition|)
block|{
comment|/* RFC 4034 says DNSKEY PROTOCOL MUST be 3 */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: dnskey has wrong key protocol"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"dnskey has wrong protocolnumber"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* verify as many fields in rrsig as possible */
name|signer
operator|=
name|sig
operator|+
literal|2
operator|+
literal|18
expr_stmt|;
name|signer_len
operator|=
name|dname_valid
argument_list|(
name|signer
argument_list|,
name|siglen
operator|-
literal|2
operator|-
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signer_len
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: malformed signer name"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signer name malformed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
comment|/* signer name invalid */
block|}
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|signer
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: signer name is off-tree"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signer name off-tree"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
comment|/* signer name offtree */
block|}
name|sigblock
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|signer
operator|+
name|signer_len
expr_stmt|;
if|if
condition|(
name|siglen
operator|<
literal|2
operator|+
literal|18
operator|+
name|signer_len
operator|+
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: too short, no signature data"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature too short, no signature data"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
comment|/* sig rdf is< 1 byte */
block|}
name|sigblock_len
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|siglen
operator|-
literal|2
operator|-
literal|18
operator|-
name|signer_len
argument_list|)
expr_stmt|;
comment|/* verify key dname == sig signer name */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|signer
argument_list|,
name|dnskey
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: wrong key for rrsig"
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"RRSIG signername is"
argument_list|,
name|signer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"the key name is"
argument_list|,
name|dnskey
operator|->
name|rk
operator|.
name|dname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signer name mismatches key name"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* verify covered type */
comment|/* memcmp works because type is in network format for rrset */
if|if
condition|(
name|memcmp
argument_list|(
name|sig
operator|+
literal|2
argument_list|,
operator|&
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: wrong type covered"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature covers wrong type"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* verify keytag and sig algo (possibly again) */
if|if
condition|(
operator|(
name|int
operator|)
name|sig
index|[
literal|2
operator|+
literal|2
index|]
operator|!=
name|dnskey_get_algo
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: wrong algorithm"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature has wrong algorithm"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|ktag
operator|=
name|htons
argument_list|(
name|dnskey_calc_keytag
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|sig
operator|+
literal|2
operator|+
literal|16
argument_list|,
operator|&
name|ktag
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: wrong keytag"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature has wrong keytag"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* verify labels is in a valid range */
if|if
condition|(
operator|(
name|int
operator|)
name|sig
index|[
literal|2
operator|+
literal|3
index|]
operator|>
name|dname_signame_label_count
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: labelcount out of range"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature labelcount out of range"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* original ttl, always ok */
if|if
condition|(
operator|!
operator|*
name|buf_canon
condition|)
block|{
comment|/* create rrset canonical format in buffer, ready for  		 * signature */
if|if
condition|(
operator|!
name|rrset_canonical
argument_list|(
name|region
argument_list|,
name|buf
argument_list|,
name|rrset
argument_list|,
name|sig
operator|+
literal|2
argument_list|,
literal|18
operator|+
name|signer_len
argument_list|,
name|sortree
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: failed due to alloc error"
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
operator|*
name|buf_canon
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check that dnskey is available */
name|dnskey_get_pubkey
argument_list|(
name|dnskey
argument_list|,
name|dnskey_idx
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: short DNSKEY RR"
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
comment|/* verify */
name|sec
operator|=
name|verify_canonrrset
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|sig
index|[
literal|2
operator|+
literal|2
index|]
argument_list|,
name|sigblock
argument_list|,
name|sigblock_len
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sec_status_secure
condition|)
block|{
comment|/* check if TTL is too high - reduce if so */
name|adjust_ttl
argument_list|(
name|ve
argument_list|,
name|now
argument_list|,
name|rrset
argument_list|,
name|sig
operator|+
literal|2
operator|+
literal|4
argument_list|,
name|sig
operator|+
literal|2
operator|+
literal|8
argument_list|,
name|sig
operator|+
literal|2
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* verify inception, expiration dates  		 * Do this last so that if you ignore expired-sigs the 		 * rest is sure to be OK. */
if|if
condition|(
operator|!
name|check_dates
argument_list|(
name|ve
argument_list|,
name|now
argument_list|,
name|sig
operator|+
literal|2
operator|+
literal|8
argument_list|,
name|sig
operator|+
literal|2
operator|+
literal|12
argument_list|,
name|reason
argument_list|)
condition|)
block|{
return|return
name|sec_status_bogus
return|;
block|}
block|}
return|return
name|sec
return|;
block|}
end_function

end_unit

