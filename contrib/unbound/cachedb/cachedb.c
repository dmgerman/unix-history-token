begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cachedb/cachedb.c - cache from a database external to the program module  *  * Copyright (c) 2016, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains a module that uses an external database to cache  * dns responses.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CACHEDB
end_ifdef

begin_include
include|#
directive|include
file|"cachedb/cachedb.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_neg.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_secalgo.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_utils.h"
end_include

begin_include
include|#
directive|include
file|"sldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|"sldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_define
define|#
directive|define
name|CACHEDB_HASHSIZE
value|256
end_define

begin_comment
comment|/* bit hash */
end_comment

begin_comment
comment|/** the unit test testframe for cachedb, its module state contains  * a cache for a couple queries (in memory). */
end_comment

begin_struct
struct|struct
name|testframe_moddata
block|{
comment|/** key for single stored data element, NULL if none */
name|char
modifier|*
name|stored_key
decl_stmt|;
comment|/** data for single stored data element, NULL if none */
name|uint8_t
modifier|*
name|stored_data
decl_stmt|;
comment|/** length of stored data */
name|size_t
name|stored_datalen
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|testframe_init
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
parameter_list|)
block|{
operator|(
name|void
operator|)
name|env
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"testframe_init"
argument_list|)
expr_stmt|;
name|cachedb_env
operator|->
name|backend_data
operator|=
operator|(
name|void
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|testframe_moddata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cachedb_env
operator|->
name|backend_data
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|testframe_deinit
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
parameter_list|)
block|{
name|struct
name|testframe_moddata
modifier|*
name|d
init|=
operator|(
expr|struct
name|testframe_moddata
operator|*
operator|)
name|cachedb_env
operator|->
name|backend_data
decl_stmt|;
operator|(
name|void
operator|)
name|env
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"testframe_deinit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|free
argument_list|(
name|d
operator|->
name|stored_key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|stored_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|testframe_lookup
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|struct
name|sldns_buffer
modifier|*
name|result_buffer
parameter_list|)
block|{
name|struct
name|testframe_moddata
modifier|*
name|d
init|=
operator|(
expr|struct
name|testframe_moddata
operator|*
operator|)
name|cachedb_env
operator|->
name|backend_data
decl_stmt|;
operator|(
name|void
operator|)
name|env
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"testframe_lookup of %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stored_key
operator|&&
name|strcmp
argument_list|(
name|d
operator|->
name|stored_key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|stored_datalen
operator|>
name|sldns_buffer_capacity
argument_list|(
name|result_buffer
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* too large */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"testframe_lookup found %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|stored_datalen
argument_list|)
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|result_buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|result_buffer
argument_list|,
name|d
operator|->
name|stored_data
argument_list|,
name|d
operator|->
name|stored_datalen
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|result_buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|testframe_store
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|)
block|{
name|struct
name|testframe_moddata
modifier|*
name|d
init|=
operator|(
expr|struct
name|testframe_moddata
operator|*
operator|)
name|cachedb_env
operator|->
name|backend_data
decl_stmt|;
operator|(
name|void
operator|)
name|env
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"testframe_store %s (%d bytes)"
argument_list|,
name|key
argument_list|,
operator|(
name|int
operator|)
name|data_len
argument_list|)
expr_stmt|;
comment|/* free old data element (if any) */
name|free
argument_list|(
name|d
operator|->
name|stored_key
argument_list|)
expr_stmt|;
name|d
operator|->
name|stored_key
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|stored_data
argument_list|)
expr_stmt|;
name|d
operator|->
name|stored_data
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|stored_datalen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|stored_data
operator|=
name|memdup
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|stored_data
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|stored_datalen
operator|=
name|data_len
expr_stmt|;
name|d
operator|->
name|stored_key
operator|=
name|strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|stored_key
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|stored_data
argument_list|)
expr_stmt|;
name|d
operator|->
name|stored_data
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|stored_datalen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* (key,data) successfully stored */
block|}
end_function

begin_comment
comment|/** The testframe backend is for unit tests */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cachedb_backend
name|testframe_backend
init|=
block|{
literal|"testframe"
block|,
name|testframe_init
block|,
name|testframe_deinit
block|,
name|testframe_lookup
block|,
name|testframe_store
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** find a particular backend from possible backends */
end_comment

begin_function
specifier|static
name|struct
name|cachedb_backend
modifier|*
name|cachedb_find_backend
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|testframe_backend
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|testframe_backend
return|;
comment|/* TODO add more backends here */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** apply configuration to cachedb module 'global' state */
end_comment

begin_function
specifier|static
name|int
name|cachedb_apply_cfg
parameter_list|(
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|backend_str
init|=
literal|"testframe"
decl_stmt|;
comment|/* TODO get from cfg */
if|if
condition|(
name|backend_str
operator|&&
name|backend_str
index|[
literal|0
index|]
condition|)
block|{
name|cachedb_env
operator|->
name|backend
operator|=
name|cachedb_find_backend
argument_list|(
name|backend_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cachedb_env
operator|->
name|backend
condition|)
block|{
name|log_err
argument_list|(
literal|"cachedb: cannot find backend name '%s"
argument_list|,
name|backend_str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* TODO see if more configuration needs to be applied or not */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|cachedb_init
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
init|=
operator|(
expr|struct
name|cachedb_env
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cachedb_env
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cachedb_env
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|cachedb_env
expr_stmt|;
if|if
condition|(
operator|!
name|cachedb_apply_cfg
argument_list|(
name|cachedb_env
argument_list|,
name|env
operator|->
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"cachedb: could not apply configuration settings."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* see if a backend is selected */
if|if
condition|(
operator|!
name|cachedb_env
operator|->
name|backend
operator|||
operator|!
name|cachedb_env
operator|->
name|backend
operator|->
name|name
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|cachedb_env
operator|->
name|backend
operator|->
name|init
call|)
argument_list|(
name|env
argument_list|,
name|cachedb_env
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"cachedb: could not init %s backend"
argument_list|,
name|cachedb_env
operator|->
name|backend
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cachedb_env
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|cachedb_deinit
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|cachedb_env
modifier|*
name|cachedb_env
decl_stmt|;
if|if
condition|(
operator|!
name|env
operator|||
operator|!
name|env
operator|->
name|modinfo
index|[
name|id
index|]
condition|)
return|return;
name|cachedb_env
operator|=
operator|(
expr|struct
name|cachedb_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
expr_stmt|;
comment|/* free contents */
comment|/* TODO */
if|if
condition|(
name|cachedb_env
operator|->
name|enabled
condition|)
block|{
call|(
modifier|*
name|cachedb_env
operator|->
name|backend
operator|->
name|deinit
call|)
argument_list|(
name|env
argument_list|,
name|cachedb_env
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cachedb_env
argument_list|)
expr_stmt|;
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/** new query for cachedb */
end_comment

begin_function
specifier|static
name|int
name|cachedb_new
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|cachedb_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|cachedb_qstate
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cachedb_qstate
argument_list|)
argument_list|)
decl_stmt|;
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|iq
expr_stmt|;
if|if
condition|(
operator|!
name|iq
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|iq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialise it */
comment|/* TODO */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Return an error  * @param qstate: our query state  * @param id: module id  * @param rcode: error code (DNS errcode).  * @return: 0 for use by caller, to make notation easy, like:  * 	return error_response(..).   */
end_comment

begin_function
specifier|static
name|int
name|error_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"return error response %s"
argument_list|,
name|sldns_lookup_by_id
argument_list|(
name|sldns_rcodes
argument_list|,
name|rcode
argument_list|)
condition|?
name|sldns_lookup_by_id
argument_list|(
name|sldns_rcodes
argument_list|,
name|rcode
argument_list|)
operator|->
name|name
else|:
literal|"??"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|return_rcode
operator|=
name|rcode
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|NULL
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Hash the query name, type, class and dbacess-secret into lookup buffer.  * @param qstate: query state with query info  * 	and env->cfg with secret.  * @param buf: returned buffer with hash to lookup  * @param len: length of the buffer.  */
end_comment

begin_function
specifier|static
name|void
name|calc_hash
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint8_t
name|clear
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|clen
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hash
index|[
name|CACHEDB_HASHSIZE
operator|/
literal|8
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
specifier|const
name|char
modifier|*
name|secret
init|=
literal|"default"
decl_stmt|;
comment|/* TODO: from qstate->env->cfg */
name|size_t
name|i
decl_stmt|;
comment|/* copy the hash info into the clear buffer */
if|if
condition|(
name|clen
operator|+
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
operator|<
sizeof|sizeof
argument_list|(
name|clear
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
name|clear
operator|+
name|clen
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|+
literal|4
operator|<
sizeof|sizeof
argument_list|(
name|clear
argument_list|)
condition|)
block|{
name|uint16_t
name|t
init|=
name|htons
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
argument_list|)
decl_stmt|;
name|uint16_t
name|c
init|=
name|htons
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|clear
operator|+
name|clen
argument_list|,
operator|&
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|clear
operator|+
name|clen
operator|+
literal|2
argument_list|,
operator|&
name|c
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clen
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|secret
operator|&&
name|secret
index|[
literal|0
index|]
operator|&&
name|clen
operator|+
name|strlen
argument_list|(
name|secret
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|clear
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
name|clear
operator|+
name|clen
argument_list|,
name|secret
argument_list|,
name|strlen
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|strlen
argument_list|(
name|secret
argument_list|)
expr_stmt|;
block|}
comment|/* hash the buffer */
name|secalgo_hash_sha256
argument_list|(
name|clear
argument_list|,
name|clen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|clear
argument_list|,
literal|0
argument_list|,
name|clen
argument_list|)
expr_stmt|;
comment|/* hex encode output for portability (some online dbs need 	 * no nulls, no control characters, and so on) */
name|log_assert
argument_list|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|i
operator|*
literal|2
index|]
operator|=
name|hex
index|[
operator|(
name|hash
index|[
name|i
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|buf
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|hex
index|[
name|hash
index|[
name|i
index|]
operator|&
literal|0x0f
index|]
expr_stmt|;
block|}
name|buf
index|[
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
operator|*
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/** convert data from return_msg into the data buffer */
end_comment

begin_function
specifier|static
name|int
name|prep_data
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|sldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|uint64_t
name|timestamp
decl_stmt|,
name|expiry
decl_stmt|;
name|size_t
name|oldlim
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|memset
argument_list|(
operator|&
name|edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|edns
argument_list|)
argument_list|)
expr_stmt|;
name|edns
operator|.
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|.
name|bits
operator|=
name|EDNS_DO
expr_stmt|;
name|edns
operator|.
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|.
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|qstate
operator|->
name|return_msg
operator|||
operator|!
name|qstate
operator|->
name|return_msg
operator|->
name|rep
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"cachedb encoding"
argument_list|,
operator|&
name|qstate
operator|->
name|return_msg
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply_info_answer_encode
argument_list|(
operator|&
name|qstate
operator|->
name|return_msg
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|query_flags
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|,
literal|65535
argument_list|,
operator|&
name|edns
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* TTLs in the return_msg are relative to time(0) so we have to 	 * store that, we also store the smallest ttl in the packet+time(0) 	 * as the packet expiry time */
comment|/* qstate->return_msg->rep->ttl contains that relative shortest ttl */
name|timestamp
operator|=
operator|(
name|uint64_t
operator|)
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
expr_stmt|;
name|expiry
operator|=
name|timestamp
operator|+
operator|(
name|uint64_t
operator|)
name|qstate
operator|->
name|return_msg
operator|->
name|rep
operator|->
name|ttl
expr_stmt|;
name|timestamp
operator|=
name|htobe64
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|expiry
operator|=
name|htobe64
argument_list|(
name|expiry
argument_list|)
expr_stmt|;
name|oldlim
operator|=
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlim
operator|+
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
operator|>=
name|sldns_buffer_capacity
argument_list|(
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* doesn't fit. */
name|sldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
name|oldlim
operator|+
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|buf
argument_list|,
name|oldlim
argument_list|,
operator|&
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|buf
argument_list|,
name|oldlim
operator|+
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|,
operator|&
name|expiry
argument_list|,
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** check expiry, return true if matches OK */
end_comment

begin_function
specifier|static
name|int
name|good_expiry_and_qinfo
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|sldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|uint64_t
name|expiry
decl_stmt|;
comment|/* the expiry time is the last bytes of the buffer */
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
condition|)
return|return
literal|0
return|;
name|sldns_buffer_read_at
argument_list|(
name|buf
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
argument_list|,
operator|&
name|expiry
argument_list|,
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
name|expiry
operator|=
name|be64toh
argument_list|(
name|expiry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|time_t
operator|)
name|expiry
operator|<
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** convert dns message in buffer to return_msg */
end_comment

begin_function
specifier|static
name|int
name|parse_data
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|sldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|msg_parse
modifier|*
name|prs
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|uint64_t
name|timestamp
decl_stmt|,
name|expiry
decl_stmt|;
name|time_t
name|adjust
decl_stmt|;
name|size_t
name|lim
init|=
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|lim
operator|<
name|LDNS_HEADER_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* too short */
comment|/* remove timestamp and expiry from end */
name|sldns_buffer_read_at
argument_list|(
name|buf
argument_list|,
name|lim
operator|-
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
argument_list|,
operator|&
name|expiry
argument_list|,
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_read_at
argument_list|(
name|buf
argument_list|,
name|lim
operator|-
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|,
operator|&
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|expiry
operator|=
name|be64toh
argument_list|(
name|expiry
argument_list|)
expr_stmt|;
name|timestamp
operator|=
name|be64toh
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
comment|/* parse DNS packet */
name|regional_free_all
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|prs
operator|=
operator|(
expr|struct
name|msg_parse
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msg_parse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prs
condition|)
return|return
literal|0
return|;
comment|/* out of memory */
name|memset
argument_list|(
name|prs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prs
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|edns
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
name|lim
operator|-
sizeof|sizeof
argument_list|(
name|expiry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_packet
argument_list|(
name|buf
argument_list|,
name|prs
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
name|sldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parse_extract_edns
argument_list|(
name|prs
argument_list|,
operator|&
name|edns
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
name|sldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|qstate
operator|->
name|return_msg
operator|=
name|dns_alloc_msg
argument_list|(
name|buf
argument_list|,
name|prs
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
name|sldns_buffer_set_limit
argument_list|(
name|buf
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qstate
operator|->
name|return_msg
condition|)
return|return
literal|0
return|;
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
comment|/* see how much of the TTL expired, and remove it */
name|adjust
operator|=
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
operator|-
operator|(
name|time_t
operator|)
name|timestamp
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cachedb msg adjusted down by %d"
argument_list|,
operator|(
name|int
operator|)
name|adjust
argument_list|)
expr_stmt|;
comment|/*adjust_msg(qstate->return_msg, adjust);*/
comment|/* TODO: 		msg->rep->ttl = r->ttl - adjust; 		msg->rep->prefetch_ttl = PREFETCH_TTL_CALC(msg->rep->ttl); 		for(i=0; i<d->count + d->rrsig_count; i++) { 			if(d->rr_ttl[i]< adjust) 				d->rr_ttl[i] = 0; 			else    d->rr_ttl[i] -= adjust; 		} 		if(d->ttl< adjust) 			d->ttl = 0; 		else    d->ttl -= adjust; 		*/
comment|/* TODO */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Lookup the qstate.qinfo in extcache, store in qstate.return_msg.  * return true if lookup was successful.  */
end_comment

begin_function
specifier|static
name|int
name|cachedb_extcache_lookup
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|cachedb_env
modifier|*
name|ie
parameter_list|)
block|{
name|char
name|key
index|[
operator|(
name|CACHEDB_HASHSIZE
operator|/
literal|8
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|calc_hash
argument_list|(
name|qstate
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* call backend to fetch data for key into scratch buffer */
if|if
condition|(
operator|!
call|(
modifier|*
name|ie
operator|->
name|backend
operator|->
name|lookup
call|)
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ie
argument_list|,
name|key
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* check expiry date and check if query-data matches */
if|if
condition|(
operator|!
name|good_expiry_and_qinfo
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* parse dns message into return_msg */
if|if
condition|(
operator|!
name|parse_data
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Store the qstate.return_msg in extcache for key qstate.info  */
end_comment

begin_function
specifier|static
name|void
name|cachedb_extcache_store
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|cachedb_env
modifier|*
name|ie
parameter_list|)
block|{
name|char
name|key
index|[
operator|(
name|CACHEDB_HASHSIZE
operator|/
literal|8
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|calc_hash
argument_list|(
name|qstate
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prepare data in scratch buffer */
if|if
condition|(
operator|!
name|prep_data
argument_list|(
name|qstate
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
condition|)
return|return;
comment|/* call backend */
call|(
modifier|*
name|ie
operator|->
name|backend
operator|->
name|store
call|)
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|ie
argument_list|,
name|key
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * See if unbound's internal cache can answer the query  */
end_comment

begin_function
specifier|static
name|int
name|cachedb_intcache_lookup
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|dns_cache_lookup
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|query_flags
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|&&
name|qstate
operator|->
name|env
operator|->
name|neg_cache
condition|)
block|{
comment|/* lookup in negative cache; may result in  		 * NOERROR/NODATA or NXDOMAIN answers that need validation */
name|msg
operator|=
name|val_neg_getmsg
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|neg_cache
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|,
literal|1
comment|/*add SOA*/
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msg
condition|)
return|return
literal|0
return|;
comment|/* this is the returned msg */
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|msg
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Store query into the internal cache of unbound.  */
end_comment

begin_function
specifier|static
name|void
name|cachedb_intcache_store
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qstate
operator|->
name|return_msg
condition|)
return|return;
operator|(
name|void
operator|)
name|dns_cache_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|prefetch_leeway
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|query_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Handle a cachedb module event with a query  * @param qstate: query state (from the mesh), passed between modules.  * 	contains qstate->env module environment with global caches and so on.  * @param iq: query state specific for this module.  per-query.  * @param ie: environment specific for this module.  global.  * @param id: module id.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cachedb_handle_query
argument_list|(
expr|struct
name|module_qstate
operator|*
name|qstate
argument_list|,
expr|struct
name|cachedb_qstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|iq
argument_list|)
argument_list|,
expr|struct
name|cachedb_env
operator|*
name|ie
argument_list|,
name|int
name|id
argument_list|)
block|{
comment|/* check if we are enabled, and skip if so */
if|if
condition|(
operator|!
name|ie
operator|->
name|enabled
condition|)
block|{
comment|/* pass request to next module */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_module
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qstate
operator|->
name|blacklist
condition|)
block|{
comment|/* cache is blacklisted */
comment|/* pass request to next module */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_module
expr_stmt|;
return|return;
block|}
comment|/* lookup inside unbound's internal cache */
if|if
condition|(
name|cachedb_intcache_lookup
argument_list|(
name|qstate
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"cachedb internal cache lookup"
argument_list|,
operator|&
name|qstate
operator|->
name|return_msg
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
comment|/* we are done with the query */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return;
block|}
comment|/* ask backend cache to see if we have data */
if|if
condition|(
name|cachedb_extcache_lookup
argument_list|(
name|qstate
argument_list|,
name|ie
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
name|ie
operator|->
name|backend
operator|->
name|name
argument_list|,
operator|&
name|qstate
operator|->
name|return_msg
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
comment|/* store this result in internal cache */
name|cachedb_intcache_store
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
comment|/* we are done with the query */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return;
block|}
comment|/* no cache fetches */
comment|/* pass request to next module */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_module
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/**  * Handle a cachedb module event with a response from the iterator.  * @param qstate: query state (from the mesh), passed between modules.  * 	contains qstate->env module environment with global caches and so on.  * @param iq: query state specific for this module.  per-query.  * @param ie: environment specific for this module.  global.  * @param id: module id.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cachedb_handle_response
argument_list|(
expr|struct
name|module_qstate
operator|*
name|qstate
argument_list|,
expr|struct
name|cachedb_qstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|iq
argument_list|)
argument_list|,
expr|struct
name|cachedb_env
operator|*
name|ie
argument_list|,
name|int
name|id
argument_list|)
block|{
comment|/* check if we are enabled, and skip if not */
if|if
condition|(
operator|!
name|ie
operator|->
name|enabled
condition|)
block|{
comment|/* we are done with the query */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return;
block|}
comment|/* store the item into the backend cache */
name|cachedb_extcache_store
argument_list|(
name|qstate
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* we are done with the query */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|cachedb_operate
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|enum
name|module_ev
name|event
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|outbound
parameter_list|)
block|{
name|struct
name|cachedb_env
modifier|*
name|ie
init|=
operator|(
expr|struct
name|cachedb_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|cachedb_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|cachedb_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"cachedb[module %d] operate: extstate:%s event:%s"
argument_list|,
name|id
argument_list|,
name|strextstate
argument_list|(
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
argument_list|)
argument_list|,
name|strmodulevent
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
condition|)
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"cachedb operate: query"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
comment|/* perform cachedb state machine */
if|if
condition|(
operator|(
name|event
operator|==
name|module_event_new
operator|||
name|event
operator|==
name|module_event_pass
operator|)
operator|&&
name|iq
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|cachedb_new
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|iq
operator|=
operator|(
expr|struct
name|cachedb_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|&&
operator|(
name|event
operator|==
name|module_event_pass
operator|||
name|event
operator|==
name|module_event_new
operator|)
condition|)
block|{
name|cachedb_handle_query
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iq
operator|&&
operator|(
name|event
operator|==
name|module_event_moddone
operator|)
condition|)
block|{
name|cachedb_handle_response
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iq
operator|&&
name|outbound
condition|)
block|{
comment|/* cachedb does not need to process responses at this time 		 * ignore it. 		cachedb_process_response(qstate, iq, ie, id, outbound, event); 		*/
return|return;
block|}
if|if
condition|(
name|event
operator|==
name|module_event_error
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"got called with event error, giving up"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_err
argument_list|(
literal|"bad event for cachedb"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cachedb_inform_super
argument_list|(
expr|struct
name|module_qstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|qstate
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|id
argument_list|)
argument_list|,
expr|struct
name|module_qstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|super
argument_list|)
argument_list|)
block|{
comment|/* cachedb does not use subordinate requests at this time */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cachedb inform_super was called"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|cachedb_clear
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|cachedb_qstate
modifier|*
name|iq
decl_stmt|;
if|if
condition|(
operator|!
name|qstate
condition|)
return|return;
name|iq
operator|=
operator|(
expr|struct
name|cachedb_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|iq
condition|)
block|{
comment|/* free contents of iq */
comment|/* TODO */
block|}
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|cachedb_get_mem
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|cachedb_env
modifier|*
name|ie
init|=
operator|(
expr|struct
name|cachedb_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ie
condition|)
return|return
literal|0
return|;
return|return
sizeof|sizeof
argument_list|(
operator|*
name|ie
argument_list|)
return|;
comment|/* TODO - more mem */
block|}
end_function

begin_comment
comment|/**  * The cachedb function block   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|module_func_block
name|cachedb_block
init|=
block|{
literal|"cachedb"
block|,
operator|&
name|cachedb_init
block|,
operator|&
name|cachedb_deinit
block|,
operator|&
name|cachedb_operate
block|,
operator|&
name|cachedb_inform_super
block|,
operator|&
name|cachedb_clear
block|,
operator|&
name|cachedb_get_mem
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|module_func_block
modifier|*
name|cachedb_get_funcblock
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|cachedb_block
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CACHEDB */
end_comment

end_unit

