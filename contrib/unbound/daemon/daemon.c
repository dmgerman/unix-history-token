begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * daemon/daemon.c - collection of workers that handles requests.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * The daemon consists of global settings and a number of workers.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_RAND_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_CONF_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ENGINE_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS
end_ifdef

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"nss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"daemon/daemon.h"
end_include

begin_include
include|#
directive|include
file|"daemon/worker.h"
end_include

begin_include
include|#
directive|include
file|"daemon/remote.h"
end_include

begin_include
include|#
directive|include
file|"daemon/acl_list.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/lookup3.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"services/modstack.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/tube.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"ldns/keyraw.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/** How many quit requests happened. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sig_record_quit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** How many reload requests happened. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sig_record_reload
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_DECL_SSL_COMP_GET_COMPRESSION_METHODS
end_if

begin_comment
comment|/** cleaner ssl memory freeup */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|comp_meth
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LEX_HAS_YYLEX_DESTROY
end_ifdef

begin_comment
comment|/** remove buffers for parsing and init */
end_comment

begin_function_decl
name|int
name|ub_c_lex_destroy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** used when no other sighandling happens, so we don't die   * when multiple signals in quick succession are sent to us.    * @param sig: signal number.   * @return signal handler return type (void or int).   */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|record_sigh
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LIBEVENT_SIGNAL_PROBLEM
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"quit on signal, no cleanup and statistics, "
literal|"because installed libevent version is not threadsafe"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGTERM
case|:
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBREAK
case|case
name|SIGBREAK
case|:
endif|#
directive|endif
case|case
name|SIGINT
case|:
name|sig_record_quit
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SIGHUP
case|case
name|SIGHUP
case|:
name|sig_record_reload
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
case|case
name|SIGPIPE
case|:
break|break;
endif|#
directive|endif
default|default:
name|log_err
argument_list|(
literal|"ignoring signal %d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**   * Signal handling during the time when netevent is disabled.  * Stores signals to replay later.  */
end_comment

begin_function
specifier|static
name|void
name|signal_handling_record
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|record_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|record_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBREAK
name|signal
argument_list|(
name|SIGBREAK
argument_list|,
name|record_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|record_sigh
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_ERR
operator|||
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|record_sigh
argument_list|)
operator|==
name|SIG_ERR
condition|)
name|log_err
argument_list|(
literal|"install sighandler: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Replay old signals.  * @param wrk: worker that handles signals.  */
end_comment

begin_function
specifier|static
name|void
name|signal_handling_playback
parameter_list|(
name|struct
name|worker
modifier|*
name|wrk
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|sig_record_reload
condition|)
name|worker_sighandler
argument_list|(
name|SIGHUP
argument_list|,
name|wrk
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sig_record_quit
condition|)
name|worker_sighandler
argument_list|(
name|SIGTERM
argument_list|,
name|wrk
argument_list|)
expr_stmt|;
name|sig_record_quit
operator|=
literal|0
expr_stmt|;
name|sig_record_reload
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|daemon
modifier|*
name|daemon_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|daemon
modifier|*
name|daemon
init|=
operator|(
expr|struct
name|daemon
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|daemon
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|int
name|r
decl_stmt|;
name|WSADATA
name|wsa_data
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|daemon
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|r
operator|=
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"could not init winsock. WSAStartup: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_WINSOCK */
name|signal_handling_record
argument_list|()
expr_stmt|;
name|checklock_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|ERR_load_SSL_strings
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_CONFIG
name|OPENSSL_config
argument_list|(
literal|"unbound"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_GOST
operator|(
name|void
operator|)
name|sldns_key_EVP_load_gost_id
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_DECL_SSL_COMP_GET_COMPRESSION_METHODS
comment|/* grab the COMP method ptr because openssl leaks it */
name|comp_meth
operator|=
operator|(
name|void
operator|*
operator|)
name|SSL_COMP_get_compression_methods
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|SSL_library_init
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SSL
argument_list|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_THREADS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|THREADS_DISABLED
argument_list|)
if|if
condition|(
operator|!
name|ub_openssl_lock_init
argument_list|()
condition|)
name|fatal_exit
argument_list|(
literal|"could not init openssl locks"
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
if|if
condition|(
name|NSS_NoDB_Init
argument_list|(
name|NULL
argument_list|)
operator|!=
name|SECSuccess
condition|)
name|fatal_exit
argument_list|(
literal|"could not init NSS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SSL or HAVE_NSS */
ifdef|#
directive|ifdef
name|HAVE_TZSET
comment|/* init timezone info while we are not chrooted yet */
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* open /dev/random if needed */
name|ub_systemseed
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
operator|^
literal|0xe67
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|need_to_exit
operator|=
literal|0
expr_stmt|;
name|modstack_init
argument_list|(
operator|&
name|daemon
operator|->
name|mods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|env
operator|=
operator|(
expr|struct
name|module_env
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|daemon
operator|->
name|env
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|alloc_init
argument_list|(
operator|&
name|daemon
operator|->
name|superalloc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|acl
operator|=
name|acl_list_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|acl
condition|)
block|{
name|free
argument_list|(
name|daemon
operator|->
name|env
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|daemon
operator|->
name|time_boot
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|time_last_stat
operator|=
name|daemon
operator|->
name|time_boot
expr_stmt|;
return|return
name|daemon
return|;
block|}
end_function

begin_function
name|int
name|daemon_open_shared_ports
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|log_assert
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
if|if
condition|(
name|daemon
operator|->
name|cfg
operator|->
name|port
operator|!=
name|daemon
operator|->
name|listening_port
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|reuseport
init|=
literal|0
decl_stmt|;
name|struct
name|listen_port
modifier|*
name|p0
decl_stmt|;
comment|/* free and close old ports */
if|if
condition|(
name|daemon
operator|->
name|ports
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
name|listening_ports_free
argument_list|(
name|daemon
operator|->
name|ports
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|ports
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|ports
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* see if we want to reuseport */
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_REUSEPORT
argument_list|)
if|if
condition|(
name|daemon
operator|->
name|cfg
operator|->
name|so_reuseport
operator|&&
name|daemon
operator|->
name|cfg
operator|->
name|num_threads
operator|>
literal|0
condition|)
name|reuseport
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* try to use reuseport */
name|p0
operator|=
name|listening_ports_open
argument_list|(
name|daemon
operator|->
name|cfg
argument_list|,
operator|&
name|reuseport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p0
condition|)
block|{
name|listening_ports_free
argument_list|(
name|p0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|reuseport
condition|)
block|{
comment|/* reuseport was successful, allocate for it */
name|daemon
operator|->
name|num_ports
operator|=
operator|(
name|size_t
operator|)
name|daemon
operator|->
name|cfg
operator|->
name|num_threads
expr_stmt|;
block|}
else|else
block|{
comment|/* do the normal, singleportslist thing, 			 * reuseport not enabled or did not work */
name|daemon
operator|->
name|num_ports
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|ports
operator|=
operator|(
expr|struct
name|listen_port
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|daemon
operator|->
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|daemon
operator|->
name|ports
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|p0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|daemon
operator|->
name|ports
index|[
literal|0
index|]
operator|=
name|p0
expr_stmt|;
if|if
condition|(
name|reuseport
condition|)
block|{
comment|/* continue to use reuseport */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|daemon
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|ports
index|[
name|i
index|]
operator|=
name|listening_ports_open
argument_list|(
name|daemon
operator|->
name|cfg
argument_list|,
operator|&
name|reuseport
argument_list|)
operator|)
operator|||
operator|!
name|reuseport
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
name|listening_ports_free
argument_list|(
name|daemon
operator|->
name|ports
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|ports
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|ports
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|daemon
operator|->
name|listening_port
operator|=
name|daemon
operator|->
name|cfg
operator|->
name|port
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|daemon
operator|->
name|cfg
operator|->
name|remote_control_enable
operator|&&
name|daemon
operator|->
name|rc_port
condition|)
block|{
name|listening_ports_free
argument_list|(
name|daemon
operator|->
name|rc_ports
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|rc_ports
operator|=
name|NULL
expr_stmt|;
name|daemon
operator|->
name|rc_port
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|daemon
operator|->
name|cfg
operator|->
name|remote_control_enable
operator|&&
name|daemon
operator|->
name|cfg
operator|->
name|control_port
operator|!=
name|daemon
operator|->
name|rc_port
condition|)
block|{
name|listening_ports_free
argument_list|(
name|daemon
operator|->
name|rc_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|rc_ports
operator|=
name|daemon_remote_open_ports
argument_list|(
name|daemon
operator|->
name|cfg
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|daemon
operator|->
name|rc_port
operator|=
name|daemon
operator|->
name|cfg
operator|->
name|control_port
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Setup modules. setup module stack.  * @param daemon: the daemon  */
end_comment

begin_function
specifier|static
name|void
name|daemon_setup_modules
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|daemon
operator|->
name|env
operator|->
name|cfg
operator|=
name|daemon
operator|->
name|cfg
expr_stmt|;
name|daemon
operator|->
name|env
operator|->
name|alloc
operator|=
operator|&
name|daemon
operator|->
name|superalloc
expr_stmt|;
name|daemon
operator|->
name|env
operator|->
name|worker
operator|=
name|NULL
expr_stmt|;
name|daemon
operator|->
name|env
operator|->
name|need_to_validate
operator|=
literal|0
expr_stmt|;
comment|/* set by module init below */
if|if
condition|(
operator|!
name|modstack_setup
argument_list|(
operator|&
name|daemon
operator|->
name|mods
argument_list|,
name|daemon
operator|->
name|cfg
operator|->
name|module_conf
argument_list|,
name|daemon
operator|->
name|env
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"failed to setup modules"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Obtain allowed port numbers, concatenate the list, and shuffle them  * (ready to be handed out to threads).  * @param daemon: the daemon. Uses rand and cfg.  * @param shufport: the portlist output.  * @return number of ports available.  */
end_comment

begin_function
specifier|static
name|int
name|daemon_get_shufport
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|int
modifier|*
name|shufport
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|k
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|avail
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65536
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|daemon
operator|->
name|cfg
operator|->
name|outgoing_avail_ports
index|[
name|i
index|]
condition|)
block|{
name|shufport
index|[
name|avail
operator|++
index|]
operator|=
name|daemon
operator|->
name|cfg
operator|->
name|outgoing_avail_ports
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|avail
operator|==
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"no ports are permitted for UDP, add "
literal|"with outgoing-port-permit"
argument_list|)
expr_stmt|;
comment|/* Knuth shuffle */
name|n
operator|=
name|avail
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|ub_random_max
argument_list|(
name|daemon
operator|->
name|rand
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 0<= k<= n */
name|temp
operator|=
name|shufport
index|[
name|k
index|]
expr_stmt|;
name|shufport
index|[
name|k
index|]
operator|=
name|shufport
index|[
name|n
index|]
expr_stmt|;
name|shufport
index|[
name|n
index|]
operator|=
name|temp
expr_stmt|;
block|}
return|return
name|avail
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate empty worker structures. With backptr and thread-number,  * from 0..numthread initialised. Used as user arguments to new threads.  * Creates the daemon random generator if it does not exist yet.  * The random generator stays existing between reloads with a unique state.  * @param daemon: the daemon with (new) config settings.  */
end_comment

begin_function
specifier|static
name|void
name|daemon_create_workers
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|numport
decl_stmt|;
name|int
modifier|*
name|shufport
decl_stmt|;
name|log_assert
argument_list|(
name|daemon
operator|&&
name|daemon
operator|->
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|rand
condition|)
block|{
name|unsigned
name|int
name|seed
init|=
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|unsigned
name|int
operator|)
name|getpid
argument_list|()
operator|^
literal|0x438
decl_stmt|;
name|daemon
operator|->
name|rand
operator|=
name|ub_initstate
argument_list|(
name|seed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|rand
condition|)
name|fatal_exit
argument_list|(
literal|"could not init random generator"
argument_list|)
expr_stmt|;
block|}
name|hash_set_raninit
argument_list|(
operator|(
name|uint32_t
operator|)
name|ub_random
argument_list|(
name|daemon
operator|->
name|rand
argument_list|)
argument_list|)
expr_stmt|;
name|shufport
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|65536
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shufport
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory during daemon init"
argument_list|)
expr_stmt|;
name|numport
operator|=
name|daemon_get_shufport
argument_list|(
name|daemon
argument_list|,
name|shufport
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"total of %d outgoing ports available"
argument_list|,
name|numport
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|num
operator|=
operator|(
name|daemon
operator|->
name|cfg
operator|->
name|num_threads
condition|?
name|daemon
operator|->
name|cfg
operator|->
name|num_threads
else|:
literal|1
operator|)
expr_stmt|;
name|daemon
operator|->
name|workers
operator|=
operator|(
expr|struct
name|worker
operator|*
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|daemon
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|worker
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|=
name|worker_create
argument_list|(
name|daemon
argument_list|,
name|i
argument_list|,
name|shufport
operator|+
name|numport
operator|*
name|i
operator|/
name|daemon
operator|->
name|num
argument_list|,
name|numport
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
name|daemon
operator|->
name|num
operator|-
name|numport
operator|*
name|i
operator|/
name|daemon
operator|->
name|num
argument_list|)
operator|)
condition|)
comment|/* the above is not ports/numthr, due to rounding */
name|fatal_exit
argument_list|(
literal|"could not create worker"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shufport
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|THREADS_DISABLED
end_ifdef

begin_comment
comment|/**  * Close all pipes except for the numbered thread.  * @param daemon: daemon to close pipes in.  * @param thr: thread number 0..num-1 of thread to skip.  */
end_comment

begin_function
specifier|static
name|void
name|close_other_pipes
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|int
name|thr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|thr
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* only close read part, need to write stats */
name|tube_close_read
argument_list|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* complete close channel to others */
name|tube_delete
argument_list|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|cmd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* THREADS_DISABLED */
end_comment

begin_comment
comment|/**  * Function to start one thread.   * @param arg: user argument.  * @return: void* user return value could be used for thread_join results.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|thread_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|port_num
init|=
literal|0
decl_stmt|;
name|log_thread_set
argument_list|(
operator|&
name|worker
operator|->
name|thread_num
argument_list|)
expr_stmt|;
name|ub_thread_blocksigs
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|THREADS_DISABLED
comment|/* close pipe ends used by main */
name|tube_close_write
argument_list|(
name|worker
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|close_other_pipes
argument_list|(
name|worker
operator|->
name|daemon
argument_list|,
name|worker
operator|->
name|thread_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_REUSEPORT
argument_list|)
if|if
condition|(
name|worker
operator|->
name|daemon
operator|->
name|cfg
operator|->
name|so_reuseport
condition|)
name|port_num
operator|=
name|worker
operator|->
name|thread_num
expr_stmt|;
else|else
name|port_num
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|worker_init
argument_list|(
name|worker
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|cfg
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|ports
index|[
name|port_num
index|]
argument_list|,
literal|0
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not initialize thread"
argument_list|)
expr_stmt|;
name|worker_work
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Fork and init the other threads. Main thread returns for special handling.  * @param daemon: the daemon with other threads to fork.  */
end_comment

begin_function
specifier|static
name|void
name|daemon_start_others
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"start threads"
argument_list|)
expr_stmt|;
comment|/* skip i=0, is this thread */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|ub_thread_create
argument_list|(
operator|&
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|thr_id
argument_list|,
name|thread_start
argument_list|,
name|daemon
operator|->
name|workers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREADS_DISABLED
comment|/* close pipe end of child */
name|tube_close_read
argument_list|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no threads */
block|}
block|}
end_function

begin_comment
comment|/**  * Stop the other threads.  * @param daemon: the daemon with other threads.  */
end_comment

begin_function
specifier|static
name|void
name|daemon_stop_others
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"stop threads"
argument_list|)
expr_stmt|;
comment|/* skip i=0, is this thread */
comment|/* use i=0 buffer for sending cmds; because we are #0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|worker_send_cmd
argument_list|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
argument_list|,
name|worker_cmd_quit
argument_list|)
expr_stmt|;
block|}
comment|/* wait for them to quit */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* join it to make sure its dead */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"join %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ub_thread_join
argument_list|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|thr_id
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"join success %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|daemon_fork
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|log_assert
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acl_list_apply_cfg
argument_list|(
name|daemon
operator|->
name|acl
argument_list|,
name|daemon
operator|->
name|cfg
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not setup access control list"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|local_zones
operator|=
name|local_zones_create
argument_list|()
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not create local zones: out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_zones_apply_cfg
argument_list|(
name|daemon
operator|->
name|local_zones
argument_list|,
name|daemon
operator|->
name|cfg
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not set up local zones"
argument_list|)
expr_stmt|;
comment|/* setup modules */
name|daemon_setup_modules
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
comment|/* first create all the worker structures, so we can pass 	 * them to the newly created threads.  	 */
name|daemon_create_workers
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
comment|/* in libev the first inited base gets signals */
if|if
condition|(
operator|!
name|worker_init
argument_list|(
name|daemon
operator|->
name|workers
index|[
literal|0
index|]
argument_list|,
name|daemon
operator|->
name|cfg
argument_list|,
name|daemon
operator|->
name|ports
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not initialize main thread"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now create the threads and init the workers. 	 * By the way, this is thread #0 (the main thread). 	 */
name|daemon_start_others
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
comment|/* Special handling for the main thread. This is the thread 	 * that handles signals and remote control. 	 */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|)
comment|/* libevent has the last inited base get signals (or any base) */
if|if
condition|(
operator|!
name|worker_init
argument_list|(
name|daemon
operator|->
name|workers
index|[
literal|0
index|]
argument_list|,
name|daemon
operator|->
name|cfg
argument_list|,
name|daemon
operator|->
name|ports
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not initialize main thread"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal_handling_playback
argument_list|(
name|daemon
operator|->
name|workers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Start resolver service on main thread. */
name|log_info
argument_list|(
literal|"start of service (%s)."
argument_list|,
name|PACKAGE_STRING
argument_list|)
expr_stmt|;
name|worker_work
argument_list|(
name|daemon
operator|->
name|workers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"service stopped (%s)."
argument_list|,
name|PACKAGE_STRING
argument_list|)
expr_stmt|;
comment|/* we exited! a signal happened! Stop other threads */
name|daemon_stop_others
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|need_to_exit
operator|=
name|daemon
operator|->
name|workers
index|[
literal|0
index|]
operator|->
name|need_to_exit
expr_stmt|;
block|}
end_function

begin_function
name|void
name|daemon_cleanup
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
comment|/* before stopping main worker, handle signals ourselves, so we 	   don't die on multiple reload signals for example. */
name|signal_handling_record
argument_list|()
expr_stmt|;
name|log_thread_set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* clean up caches because 	 * a) RRset IDs will be recycled after a reload, causing collisions 	 * b) validation config can change, thus rrset, msg, keycache clear  	 * The infra cache is kept, the timing and edns info is still valid */
name|slabhash_clear
argument_list|(
operator|&
name|daemon
operator|->
name|env
operator|->
name|rrset_cache
operator|->
name|table
argument_list|)
expr_stmt|;
name|slabhash_clear
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
name|local_zones_delete
argument_list|(
name|daemon
operator|->
name|local_zones
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|local_zones
operator|=
name|NULL
expr_stmt|;
comment|/* key cache is cleared by module desetup during next daemon_init() */
name|daemon_remote_clear
argument_list|(
name|daemon
operator|->
name|rc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|worker_delete
argument_list|(
name|daemon
operator|->
name|workers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|workers
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|workers
operator|=
name|NULL
expr_stmt|;
name|daemon
operator|->
name|num
operator|=
literal|0
expr_stmt|;
name|daemon
operator|->
name|cfg
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|daemon_delete
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|daemon
condition|)
return|return;
name|modstack_desetup
argument_list|(
operator|&
name|daemon
operator|->
name|mods
argument_list|,
name|daemon
operator|->
name|env
argument_list|)
expr_stmt|;
name|daemon_remote_delete
argument_list|(
name|daemon
operator|->
name|rc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
name|listening_ports_free
argument_list|(
name|daemon
operator|->
name|ports
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|ports
argument_list|)
expr_stmt|;
name|listening_ports_free
argument_list|(
name|daemon
operator|->
name|rc_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|daemon
operator|->
name|env
condition|)
block|{
name|slabhash_delete
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
name|rrset_cache_delete
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|rrset_cache
argument_list|)
expr_stmt|;
name|infra_delete
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|infra_cache
argument_list|)
expr_stmt|;
block|}
name|ub_randfree
argument_list|(
name|daemon
operator|->
name|rand
argument_list|)
expr_stmt|;
name|alloc_clear
argument_list|(
operator|&
name|daemon
operator|->
name|superalloc
argument_list|)
expr_stmt|;
name|acl_list_delete
argument_list|(
name|daemon
operator|->
name|acl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|chroot
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|daemon
operator|->
name|env
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
name|SSL_CTX_free
argument_list|(
operator|(
name|SSL_CTX
operator|*
operator|)
name|daemon
operator|->
name|listen_sslctx
argument_list|)
expr_stmt|;
name|SSL_CTX_free
argument_list|(
operator|(
name|SSL_CTX
operator|*
operator|)
name|daemon
operator|->
name|connect_sslctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEX_HAS_YYLEX_DESTROY
comment|/* lex cleanup */
name|ub_c_lex_destroy
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* libcrypto cleanup */
ifdef|#
directive|ifdef
name|HAVE_SSL
if|#
directive|if
name|defined
argument_list|(
name|USE_GOST
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LDNS_KEY_EVP_UNLOAD_GOST
argument_list|)
name|sldns_key_EVP_unload_gost
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_DECL_SSL_COMP_GET_COMPRESSION_METHODS
operator|&&
name|HAVE_DECL_SK_SSL_COMP_POP_FREE
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|sk_SSL_COMP_pop_free
argument_list|(
name|comp_meth
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|CRYPTO_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_CONFIG
name|EVP_cleanup
argument_list|()
expr_stmt|;
name|ENGINE_cleanup
argument_list|()
expr_stmt|;
name|CONF_modules_free
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|CRYPTO_cleanup_all_ex_data
argument_list|()
expr_stmt|;
comment|/* safe, no more threads right now */
name|ERR_remove_state
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ERR_free_strings
argument_list|()
expr_stmt|;
name|RAND_cleanup
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SSL
argument_list|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_THREADS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|THREADS_DISABLED
argument_list|)
name|ub_openssl_lock_delete
argument_list|()
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
name|NSS_Shutdown
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SSL or HAVE_NSS */
name|checklock_stop
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
name|WSACleanup
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not WSACleanup: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|daemon_apply_cfg
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|daemon
operator|->
name|cfg
operator|=
name|cfg
expr_stmt|;
name|config_apply
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|env
operator|->
name|msg_cache
operator|||
name|cfg
operator|->
name|msg_cache_size
operator|!=
name|slabhash_get_size
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
operator|||
name|cfg
operator|->
name|msg_cache_slabs
operator|!=
name|daemon
operator|->
name|env
operator|->
name|msg_cache
operator|->
name|size
condition|)
block|{
name|slabhash_delete
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
name|daemon
operator|->
name|env
operator|->
name|msg_cache
operator|=
name|slabhash_create
argument_list|(
name|cfg
operator|->
name|msg_cache_slabs
argument_list|,
name|HASH_DEFAULT_STARTARRAY
argument_list|,
name|cfg
operator|->
name|msg_cache_size
argument_list|,
name|msgreply_sizefunc
argument_list|,
name|query_info_compare
argument_list|,
name|query_entry_delete
argument_list|,
name|reply_info_delete
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|env
operator|->
name|msg_cache
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"malloc failure updating config settings"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|daemon
operator|->
name|env
operator|->
name|rrset_cache
operator|=
name|rrset_cache_adjust
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|cfg
argument_list|,
operator|&
name|daemon
operator|->
name|superalloc
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"malloc failure updating config settings"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|daemon
operator|->
name|env
operator|->
name|infra_cache
operator|=
name|infra_adjust
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|infra_cache
argument_list|,
name|cfg
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"malloc failure updating config settings"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

