begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * daemon/remote.c - remote control for the unbound daemon.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the remote control functionality for the daemon.  * The remote control can be performed using either the commandline  * unbound-control tool, or a SSLv3/TLS capable web browser.   * The channel is secured using SSLv3 or TLSv1, and certificates.  * Both the server and the client(control tool) have their own keys.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"daemon/remote.h"
end_include

begin_include
include|#
directive|include
file|"daemon/worker.h"
end_include

begin_include
include|#
directive|include
file|"daemon/daemon.h"
end_include

begin_include
include|#
directive|include
file|"daemon/stats.h"
end_include

begin_include
include|#
directive|include
file|"daemon/cachedump.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"services/mesh.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"validator/validator.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kcache.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kentry.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iterator.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_hints.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"services/outbound_list.h"
end_include

begin_include
include|#
directive|include
file|"services/outside_network.h"
end_include

begin_include
include|#
directive|include
file|"ldns/str2wire.h"
end_include

begin_include
include|#
directive|include
file|"ldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* just for portability */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SQ
end_ifdef

begin_undef
undef|#
directive|undef
name|SQ
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** what to put on statistics lines between var and value, ": " or "=" */
end_comment

begin_define
define|#
directive|define
name|SQ
value|"="
end_define

begin_comment
comment|/** if true, inhibits a lot of =0 lines from the stats output */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|inhibit_zero
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** subtract timers and the values do not overflow or become negative */
end_comment

begin_function
specifier|static
name|void
name|timeval_subtract
parameter_list|(
name|struct
name|timeval
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|end
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|start
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|time_t
name|end_usec
init|=
name|end
operator|->
name|tv_usec
decl_stmt|;
name|d
operator|->
name|tv_sec
operator|=
name|end
operator|->
name|tv_sec
operator|-
name|start
operator|->
name|tv_sec
expr_stmt|;
if|if
condition|(
name|end_usec
operator|<
name|start
operator|->
name|tv_usec
condition|)
block|{
name|end_usec
operator|+=
literal|1000000
expr_stmt|;
name|d
operator|->
name|tv_sec
operator|--
expr_stmt|;
block|}
name|d
operator|->
name|tv_usec
operator|=
name|end_usec
operator|-
name|start
operator|->
name|tv_usec
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** divide sum of timers to get average */
end_comment

begin_function
specifier|static
name|void
name|timeval_divide
parameter_list|(
name|struct
name|timeval
modifier|*
name|avg
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|sum
parameter_list|,
name|size_t
name|d
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|size_t
name|leftover
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|avg
operator|->
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|avg
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|avg
operator|->
name|tv_sec
operator|=
name|sum
operator|->
name|tv_sec
operator|/
name|d
expr_stmt|;
name|avg
operator|->
name|tv_usec
operator|=
name|sum
operator|->
name|tv_usec
operator|/
name|d
expr_stmt|;
comment|/* handle fraction from seconds divide */
name|leftover
operator|=
name|sum
operator|->
name|tv_sec
operator|-
name|avg
operator|->
name|tv_sec
operator|*
name|d
expr_stmt|;
name|avg
operator|->
name|tv_usec
operator|+=
operator|(
name|leftover
operator|*
literal|1000000
operator|)
operator|/
name|d
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|daemon_remote
modifier|*
name|daemon_remote_create
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|char
modifier|*
name|s_cert
decl_stmt|;
name|char
modifier|*
name|s_key
decl_stmt|;
name|struct
name|daemon_remote
modifier|*
name|rc
init|=
operator|(
expr|struct
name|daemon_remote
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in daemon_remote_create"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rc
operator|->
name|max_active
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|remote_control_enable
condition|)
block|{
name|rc
operator|->
name|ctx
operator|=
name|NULL
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|->
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_server_method
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|ctx
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not SSL_CTX_new"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* no SSLv2 because has defects */
if|if
condition|(
operator|!
operator|(
name|SSL_CTX_set_options
argument_list|(
name|rc
operator|->
name|ctx
argument_list|,
name|SSL_OP_NO_SSLv2
argument_list|)
operator|&
name|SSL_OP_NO_SSLv2
operator|)
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not set SSL_OP_NO_SSLv2"
argument_list|)
expr_stmt|;
name|daemon_remote_delete
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s_cert
operator|=
name|fname_after_chroot
argument_list|(
name|cfg
operator|->
name|server_cert_file
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s_key
operator|=
name|fname_after_chroot
argument_list|(
name|cfg
operator|->
name|server_key_file
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_cert
operator|||
operator|!
name|s_key
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in remote control fname"
argument_list|)
expr_stmt|;
goto|goto
name|setup_error
goto|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"setup SSL certificates"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_CTX_use_certificate_file
argument_list|(
name|rc
operator|->
name|ctx
argument_list|,
name|s_cert
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Error for server-cert-file: %s"
argument_list|,
name|s_cert
argument_list|)
expr_stmt|;
name|log_crypto_err
argument_list|(
literal|"Error in SSL_CTX use_certificate_file"
argument_list|)
expr_stmt|;
goto|goto
name|setup_error
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_use_PrivateKey_file
argument_list|(
name|rc
operator|->
name|ctx
argument_list|,
name|s_key
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Error for server-key-file: %s"
argument_list|,
name|s_key
argument_list|)
expr_stmt|;
name|log_crypto_err
argument_list|(
literal|"Error in SSL_CTX use_PrivateKey_file"
argument_list|)
expr_stmt|;
goto|goto
name|setup_error
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_check_private_key
argument_list|(
name|rc
operator|->
name|ctx
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Error for server-key-file: %s"
argument_list|,
name|s_key
argument_list|)
expr_stmt|;
name|log_crypto_err
argument_list|(
literal|"Error in SSL_CTX check_private_key"
argument_list|)
expr_stmt|;
goto|goto
name|setup_error
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_load_verify_locations
argument_list|(
name|rc
operator|->
name|ctx
argument_list|,
name|s_cert
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"Error setting up SSL_CTX verify locations"
argument_list|)
expr_stmt|;
name|setup_error
label|:
name|free
argument_list|(
name|s_cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_key
argument_list|)
expr_stmt|;
name|daemon_remote_delete
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|SSL_CTX_set_client_CA_list
argument_list|(
name|rc
operator|->
name|ctx
argument_list|,
name|SSL_load_client_CA_file
argument_list|(
name|s_cert
argument_list|)
argument_list|)
expr_stmt|;
name|SSL_CTX_set_verify
argument_list|(
name|rc
operator|->
name|ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_key
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|daemon_remote_clear
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|)
block|{
name|struct
name|rc_state
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
return|return;
comment|/* but do not close the ports */
name|listen_list_delete
argument_list|(
name|rc
operator|->
name|accept_list
argument_list|)
expr_stmt|;
name|rc
operator|->
name|accept_list
operator|=
name|NULL
expr_stmt|;
comment|/* do close these sockets */
name|p
operator|=
name|rc
operator|->
name|busy_list
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ssl
condition|)
name|SSL_free
argument_list|(
name|p
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|p
operator|->
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|rc
operator|->
name|busy_list
operator|=
name|NULL
expr_stmt|;
name|rc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|worker
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|daemon_remote_delete
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rc
condition|)
return|return;
name|daemon_remote_clear
argument_list|(
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|ctx
condition|)
block|{
name|SSL_CTX_free
argument_list|(
name|rc
operator|->
name|ctx
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Add and open a new control port  * @param ip: ip str  * @param nr: port nr  * @param list: list head  * @param noproto_is_err: if lack of protocol support is an error.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|add_open
parameter_list|(
specifier|const
name|char
modifier|*
name|ip
parameter_list|,
name|int
name|nr
parameter_list|,
name|struct
name|listen_port
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|noproto_is_err
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|;
name|struct
name|listen_port
modifier|*
name|n
decl_stmt|;
name|int
name|noproto
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|;
name|char
name|port
index|[
literal|15
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|port
argument_list|,
sizeof|sizeof
argument_list|(
name|port
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|nr
argument_list|)
expr_stmt|;
name|port
index|[
sizeof|sizeof
argument_list|(
name|port
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
operator||
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|getaddrinfo
argument_list|(
name|ip
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|res
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
operator|!
name|noproto_is_err
operator|&&
name|r
operator|==
name|EAI_NONAME
condition|)
block|{
comment|/* tried to lookup the address as name */
return|return
literal|1
return|;
comment|/* return success, but do nothing */
block|}
endif|#
directive|endif
comment|/* USE_WINSOCK */
name|log_err
argument_list|(
literal|"control interface %s:%s getaddrinfo: %s %s"
argument_list|,
name|ip
condition|?
name|ip
else|:
literal|"default"
argument_list|,
name|port
argument_list|,
name|gai_strerror
argument_list|(
name|r
argument_list|)
argument_list|,
ifdef|#
directive|ifdef
name|EAI_SYSTEM
name|r
operator|==
name|EAI_SYSTEM
condition|?
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|""
else|#
directive|else
literal|""
endif|#
directive|endif
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* open fd */
name|fd
operator|=
name|create_tcp_accept_sock
argument_list|(
name|res
argument_list|,
literal|1
argument_list|,
operator|&
name|noproto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
name|noproto
condition|)
block|{
if|if
condition|(
operator|!
name|noproto_is_err
condition|)
return|return
literal|1
return|;
comment|/* return success, but do nothing */
name|log_err
argument_list|(
literal|"cannot open control interface %s %d : "
literal|"protocol not supported"
argument_list|,
name|ip
argument_list|,
name|nr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot open control interface %s %d"
argument_list|,
name|ip
argument_list|,
name|nr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* alloc */
name|n
operator|=
operator|(
expr|struct
name|listen_port
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|listen_port
modifier|*
name|daemon_remote_open_ports
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|listen_port
modifier|*
name|l
init|=
name|NULL
decl_stmt|;
name|log_assert
argument_list|(
name|cfg
operator|->
name|remote_control_enable
operator|&&
name|cfg
operator|->
name|control_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|control_ifs
condition|)
block|{
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|cfg
operator|->
name|control_ifs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|add_open
argument_list|(
name|p
operator|->
name|str
argument_list|,
name|cfg
operator|->
name|control_port
argument_list|,
operator|&
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* defaults */
if|if
condition|(
name|cfg
operator|->
name|do_ip6
operator|&&
operator|!
name|add_open
argument_list|(
literal|"::1"
argument_list|,
name|cfg
operator|->
name|control_port
argument_list|,
operator|&
name|l
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cfg
operator|->
name|do_ip4
operator|&&
operator|!
name|add_open
argument_list|(
literal|"127.0.0.1"
argument_list|,
name|cfg
operator|->
name|control_port
argument_list|,
operator|&
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/** open accept commpoint */
end_comment

begin_function
specifier|static
name|int
name|accept_open
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|listen_list
modifier|*
name|n
init|=
operator|(
expr|struct
name|listen_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n
operator|->
name|next
operator|=
name|rc
operator|->
name|accept_list
expr_stmt|;
name|rc
operator|->
name|accept_list
operator|=
name|n
expr_stmt|;
comment|/* open commpt */
name|n
operator|->
name|com
operator|=
name|comm_point_create_raw
argument_list|(
name|rc
operator|->
name|worker
operator|->
name|base
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|,
operator|&
name|remote_accept_callback
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|com
condition|)
return|return
literal|0
return|;
comment|/* keep this port open, its fd is kept in the rc portlist */
name|n
operator|->
name|com
operator|->
name|do_not_close
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|daemon_remote_open_accept
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|struct
name|listen_port
modifier|*
name|ports
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|listen_port
modifier|*
name|p
decl_stmt|;
name|rc
operator|->
name|worker
operator|=
name|worker
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ports
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|accept_open
argument_list|(
name|rc
argument_list|,
name|p
operator|->
name|fd
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create accept comm point"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|daemon_remote_stop_accept
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|)
block|{
name|struct
name|listen_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|rc
operator|->
name|accept_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|comm_point_stop_listening
argument_list|(
name|p
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|daemon_remote_start_accept
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|)
block|{
name|struct
name|listen_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|rc
operator|->
name|accept_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|comm_point_start_listening
argument_list|(
name|p
operator|->
name|com
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|remote_accept_callback
argument_list|(
expr|struct
name|comm_point
operator|*
name|c
argument_list|,
name|void
operator|*
name|arg
argument_list|,
name|int
name|err
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|rep
argument_list|)
argument_list|)
block|{
name|struct
name|daemon_remote
modifier|*
name|rc
init|=
operator|(
expr|struct
name|daemon_remote
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|int
name|newfd
decl_stmt|;
name|struct
name|rc_state
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
name|log_err
argument_list|(
literal|"error %d on remote_accept_callback"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* perform the accept */
name|newfd
operator|=
name|comm_point_perform_accept
argument_list|(
name|c
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* create new commpoint unless we are servicing already */
if|if
condition|(
name|rc
operator|->
name|active
operator|>=
name|rc
operator|->
name|max_active
condition|)
block|{
name|log_warn
argument_list|(
literal|"drop incoming remote control: too many connections"
argument_list|)
expr_stmt|;
name|close_exit
label|:
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* setup commpoint to service the remote control command */
name|n
operator|=
operator|(
expr|struct
name|rc_state
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|close_exit
goto|;
block|}
comment|/* start in reading state */
name|n
operator|->
name|c
operator|=
name|comm_point_create_raw
argument_list|(
name|rc
operator|->
name|worker
operator|->
name|base
argument_list|,
name|newfd
argument_list|,
literal|0
argument_list|,
operator|&
name|remote_control_callback
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|c
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|close_exit
goto|;
block|}
name|log_addr
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"new control connection from"
argument_list|,
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|n
operator|->
name|c
operator|->
name|do_not_close
operator|=
literal|0
expr_stmt|;
name|comm_point_stop_listening
argument_list|(
name|n
operator|->
name|c
argument_list|)
expr_stmt|;
name|comm_point_start_listening
argument_list|(
name|n
operator|->
name|c
argument_list|,
operator|-
literal|1
argument_list|,
name|REMOTE_CONTROL_TCP_TIMEOUT
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|n
operator|->
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|n
operator|->
name|c
operator|->
name|repinfo
operator|.
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|n
operator|->
name|shake_state
operator|=
name|rc_hs_read
expr_stmt|;
name|n
operator|->
name|ssl
operator|=
name|SSL_new
argument_list|(
name|rc
operator|->
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|ssl
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not SSL_new"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|n
operator|->
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|close_exit
goto|;
block|}
name|SSL_set_accept_state
argument_list|(
name|n
operator|->
name|ssl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_set_mode
argument_list|(
name|n
operator|->
name|ssl
argument_list|,
name|SSL_MODE_AUTO_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_set_fd
argument_list|(
name|n
operator|->
name|ssl
argument_list|,
name|newfd
argument_list|)
condition|)
block|{
name|log_crypto_err
argument_list|(
literal|"could not SSL_set_fd"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|n
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|n
operator|->
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|close_exit
goto|;
block|}
name|n
operator|->
name|rc
operator|=
name|rc
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|rc
operator|->
name|busy_list
expr_stmt|;
name|rc
operator|->
name|busy_list
operator|=
name|n
expr_stmt|;
name|rc
operator|->
name|active
operator|++
expr_stmt|;
comment|/* perform the first nonblocking read already, for windows,  	 * so it can return wouldblock. could be faster too. */
operator|(
name|void
operator|)
name|remote_control_callback
argument_list|(
name|n
operator|->
name|c
argument_list|,
name|n
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/** delete from list */
end_comment

begin_function
specifier|static
name|void
name|state_list_remove_elem
parameter_list|(
name|struct
name|rc_state
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|list
operator|)
operator|->
name|c
operator|==
name|c
condition|)
block|{
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
return|return;
block|}
name|list
operator|=
operator|&
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** decrease active count and remove commpoint from busy list */
end_comment

begin_function
specifier|static
name|void
name|clean_point
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|struct
name|rc_state
modifier|*
name|s
parameter_list|)
block|{
name|state_list_remove_elem
argument_list|(
operator|&
name|rc
operator|->
name|busy_list
argument_list|,
name|s
operator|->
name|c
argument_list|)
expr_stmt|;
name|rc
operator|->
name|active
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ssl
condition|)
block|{
name|SSL_shutdown
argument_list|(
name|s
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|s
operator|->
name|ssl
argument_list|)
expr_stmt|;
block|}
name|comm_point_delete
argument_list|(
name|s
operator|->
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ssl_print_text
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
return|return
literal|0
return|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|text
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"warning, in SSL_write, peer "
literal|"closed connection"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_crypto_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** print text over the ssl connection */
end_comment

begin_function
specifier|static
name|int
name|ssl_print_vmsg
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|vsnprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|ssl_print_text
argument_list|(
name|ssl
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** printf style printing to the ssl connection */
end_comment

begin_function
name|int
name|ssl_printf
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ssl_print_vmsg
argument_list|(
name|ssl
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ssl_read_line
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|len
operator|<
name|max
condition|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|buf
operator|+
name|len
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_crypto_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|buf
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* return string without \n */
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|len
operator|++
expr_stmt|;
block|}
name|buf
index|[
name|max
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|log_err
argument_list|(
literal|"control line too long (%d): %s"
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** skip whitespace, return new pointer into string */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipwhite
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
comment|/* EOS \0 is not a space */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/** send the OK to the control client */
end_comment

begin_function
specifier|static
name|void
name|send_ok
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the stop command */
end_comment

begin_function
specifier|static
name|void
name|do_stop
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|)
block|{
name|rc
operator|->
name|worker
operator|->
name|need_to_exit
operator|=
literal|1
expr_stmt|;
name|comm_base_exit
argument_list|(
name|rc
operator|->
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the reload command */
end_comment

begin_function
specifier|static
name|void
name|do_reload
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|)
block|{
name|rc
operator|->
name|worker
operator|->
name|need_to_exit
operator|=
literal|0
expr_stmt|;
name|comm_base_exit
argument_list|(
name|rc
operator|->
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the verbosity command */
end_comment

begin_function
specifier|static
name|void
name|do_verbosity
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|val
init|=
name|atoi
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error in verbosity number syntax: %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|verbosity
operator|=
name|val
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** print stats from statinfo */
end_comment

begin_function
specifier|static
name|int
name|print_stats
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|struct
name|stats_info
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|timeval
name|avg
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.num.queries"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|num_queries
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.num.cachehits"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|svr
operator|.
name|num_queries
operator|-
name|s
operator|->
name|svr
operator|.
name|num_queries_missed_cache
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.num.cachemiss"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|num_queries_missed_cache
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.num.prefetch"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|num_queries_prefetch
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.num.recursivereplies"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|mesh_replies_sent
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.requestlist.avg"
name|SQ
literal|"%g\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|s
operator|->
name|svr
operator|.
name|num_queries_missed_cache
operator|+
name|s
operator|->
name|svr
operator|.
name|num_queries_prefetch
operator|)
condition|?
operator|(
name|double
operator|)
name|s
operator|->
name|svr
operator|.
name|sum_query_list_size
operator|/
operator|(
name|s
operator|->
name|svr
operator|.
name|num_queries_missed_cache
operator|+
name|s
operator|->
name|svr
operator|.
name|num_queries_prefetch
operator|)
else|:
literal|0.0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.requestlist.max"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|max_query_list_size
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.requestlist.overwritten"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|mesh_jostled
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.requestlist.exceeded"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|mesh_dropped
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.requestlist.current.all"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|mesh_num_states
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.requestlist.current.user"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|mesh_num_reply_states
argument_list|)
condition|)
return|return
literal|0
return|;
name|timeval_divide
argument_list|(
operator|&
name|avg
argument_list|,
operator|&
name|s
operator|->
name|mesh_replies_sum_wait
argument_list|,
name|s
operator|->
name|mesh_replies_sent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
argument|ssl
argument_list|,
literal|"%s.recursion.time.avg"
argument|SQ ARG_LL
literal|"d.%6.6d\n"
argument_list|,
argument|nm
argument_list|,
argument|(long long)avg.tv_sec
argument_list|,
argument|(int)avg.tv_usec
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s.recursion.time.median"
name|SQ
literal|"%g\n"
argument_list|,
name|nm
argument_list|,
name|s
operator|->
name|mesh_time_median
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** print stats for one thread */
end_comment

begin_function
specifier|static
name|int
name|print_thread_stats
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
name|i
parameter_list|,
name|struct
name|stats_info
modifier|*
name|s
parameter_list|)
block|{
name|char
name|nm
index|[
literal|16
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"thread%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nm
index|[
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|print_stats
argument_list|(
name|ssl
argument_list|,
name|nm
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** print long number */
end_comment

begin_function
specifier|static
name|int
name|print_longnum
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
name|size_t
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|>
literal|1024
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
comment|/* more than a Gb */
name|size_t
name|front
init|=
name|x
operator|/
operator|(
name|size_t
operator|)
literal|1000000
decl_stmt|;
name|size_t
name|back
init|=
name|x
operator|%
operator|(
name|size_t
operator|)
literal|1000000
decl_stmt|;
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s%u%6.6u\n"
argument_list|,
name|desc
argument_list|,
operator|(
name|unsigned
operator|)
name|front
argument_list|,
operator|(
name|unsigned
operator|)
name|back
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s%u\n"
argument_list|,
name|desc
argument_list|,
operator|(
name|unsigned
operator|)
name|x
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/** print mem stats */
end_comment

begin_function
specifier|static
name|int
name|print_mem
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|)
block|{
name|int
name|m
decl_stmt|;
name|size_t
name|msg
decl_stmt|,
name|rrset
decl_stmt|,
name|val
decl_stmt|,
name|iter
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
specifier|extern
name|void
modifier|*
name|unbound_start_brk
decl_stmt|;
name|void
modifier|*
name|cur
init|=
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|print_longnum
argument_list|(
name|ssl
argument_list|,
literal|"mem.total.sbrk"
name|SQ
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
operator|-
operator|(
name|char
operator|*
operator|)
name|unbound_start_brk
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_SBRK */
name|msg
operator|=
name|slabhash_get_mem
argument_list|(
name|daemon
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
name|rrset
operator|=
name|slabhash_get_mem
argument_list|(
operator|&
name|daemon
operator|->
name|env
operator|->
name|rrset_cache
operator|->
name|table
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|iter
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|modstack_find
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
argument_list|,
literal|"validator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
operator|-
literal|1
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|m
index|]
operator|->
name|get_mem
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|*
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|m
index|]
operator|->
name|get_mem
operator|)
operator|(
operator|&
name|worker
operator|->
name|env
operator|,
name|m
operator|)
expr_stmt|;
block|}
name|m
operator|=
name|modstack_find
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
argument_list|,
literal|"iterator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
operator|-
literal|1
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|m
index|]
operator|->
name|get_mem
argument_list|)
argument_list|)
expr_stmt|;
name|iter
operator|=
operator|(
operator|*
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|m
index|]
operator|->
name|get_mem
operator|)
operator|(
operator|&
name|worker
operator|->
name|env
operator|,
name|m
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|print_longnum
argument_list|(
name|ssl
argument_list|,
literal|"mem.cache.rrset"
name|SQ
argument_list|,
name|rrset
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|print_longnum
argument_list|(
name|ssl
argument_list|,
literal|"mem.cache.message"
name|SQ
argument_list|,
name|msg
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|print_longnum
argument_list|(
name|ssl
argument_list|,
literal|"mem.mod.iterator"
name|SQ
argument_list|,
name|iter
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|print_longnum
argument_list|(
name|ssl
argument_list|,
literal|"mem.mod.validator"
name|SQ
argument_list|,
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** print uptime stats */
end_comment

begin_function
specifier|static
name|int
name|print_uptime
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|timeval
name|now
init|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now_tv
decl_stmt|;
name|struct
name|timeval
name|up
decl_stmt|,
name|dt
decl_stmt|;
name|timeval_subtract
argument_list|(
operator|&
name|up
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|worker
operator|->
name|daemon
operator|->
name|time_boot
argument_list|)
expr_stmt|;
name|timeval_subtract
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|worker
operator|->
name|daemon
operator|->
name|time_last_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
condition|)
name|worker
operator|->
name|daemon
operator|->
name|time_last_stat
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
argument|ssl
argument_list|,
literal|"time.now"
argument|SQ ARG_LL
literal|"d.%6.6d\n"
argument_list|,
argument|(long long)now.tv_sec
argument_list|,
argument|(unsigned)now.tv_usec
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
argument|ssl
argument_list|,
literal|"time.up"
argument|SQ ARG_LL
literal|"d.%6.6d\n"
argument_list|,
argument|(long long)up.tv_sec
argument_list|,
argument|(unsigned)up.tv_usec
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
argument|ssl
argument_list|,
literal|"time.elapsed"
argument|SQ ARG_LL
literal|"d.%6.6d\n"
argument_list|,
argument|(long long)dt.tv_sec
argument_list|,
argument|(unsigned)dt.tv_usec
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** print extended histogram */
end_comment

begin_function
specifier|static
name|int
name|print_hist
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|stats_info
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|timehist
modifier|*
name|hist
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|hist
operator|=
name|timehist_setup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hist
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|timehist_import
argument_list|(
name|hist
argument_list|,
name|s
operator|->
name|svr
operator|.
name|hist
argument_list|,
name|NUM_BUCKETS_HIST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hist
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"histogram.%6.6d.%6.6d.to.%6.6d.%6.6d=%u\n"
argument_list|,
operator|(
name|int
operator|)
name|hist
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lower
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|hist
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lower
operator|.
name|tv_usec
argument_list|,
operator|(
name|int
operator|)
name|hist
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|upper
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|hist
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|upper
operator|.
name|tv_usec
argument_list|,
operator|(
name|unsigned
operator|)
name|hist
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|count
argument_list|)
condition|)
block|{
name|timehist_delete
argument_list|(
name|hist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|timehist_delete
argument_list|(
name|hist
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** print extended stats */
end_comment

begin_function
specifier|static
name|int
name|print_ext
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|stats_info
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|nm
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|sldns_rr_descriptor
modifier|*
name|desc
decl_stmt|;
specifier|const
name|sldns_lookup_table
modifier|*
name|lt
decl_stmt|;
comment|/* TYPE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STATS_QTYPE_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inhibit_zero
operator|&&
name|s
operator|->
name|svr
operator|.
name|qtype
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|desc
operator|=
name|sldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|&&
name|desc
operator|->
name|_name
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|desc
operator|->
name|_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|LDNS_RR_TYPE_IXFR
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"IXFR"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|LDNS_RR_TYPE_AXFR
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"AXFR"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|LDNS_RR_TYPE_MAILA
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"MAILA"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|LDNS_RR_TYPE_MAILB
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"MAILB"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"ANY"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"TYPE%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.type.%s"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qtype
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|inhibit_zero
operator|||
name|s
operator|->
name|svr
operator|.
name|qtype_big
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.type.other"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qtype_big
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* CLASS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STATS_QCLASS_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inhibit_zero
operator|&&
name|s
operator|->
name|svr
operator|.
name|qclass
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lt
operator|=
name|sldns_lookup_by_id
argument_list|(
name|sldns_rr_classes
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|&&
name|lt
operator|->
name|name
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|lt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"CLASS%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.class.%s"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qclass
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|inhibit_zero
operator|||
name|s
operator|->
name|svr
operator|.
name|qclass_big
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.class.other"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qclass_big
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* OPCODE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STATS_OPCODE_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inhibit_zero
operator|&&
name|s
operator|->
name|svr
operator|.
name|qopcode
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lt
operator|=
name|sldns_lookup_by_id
argument_list|(
name|sldns_opcodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|&&
name|lt
operator|->
name|name
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|lt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"OPCODE%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.opcode.%s"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qopcode
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* transport */
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.tcp"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qtcp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.ipv6"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qipv6
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* flags */
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.QR"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_QR
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.AA"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_AA
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.TC"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_TC
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.RD"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_RD
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.RA"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_RA
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.Z"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_Z
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.AD"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_AD
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.flags.CD"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qbit_CD
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.edns.present"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qEDNS
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.query.edns.DO"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|qEDNS_DO
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* RCODE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STATS_RCODE_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inhibit_zero
operator|&&
name|s
operator|->
name|svr
operator|.
name|ans_rcode
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lt
operator|=
name|sldns_lookup_by_id
argument_list|(
name|sldns_rcodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|&&
name|lt
operator|->
name|name
condition|)
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|lt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"RCODE%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.answer.rcode.%s"
name|SQ
literal|"%u\n"
argument_list|,
name|nm
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|ans_rcode
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|inhibit_zero
operator|||
name|s
operator|->
name|svr
operator|.
name|ans_rcode_nodata
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.answer.rcode.nodata"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|ans_rcode_nodata
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* validation */
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.answer.secure"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|ans_secure
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.answer.bogus"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|ans_bogus
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"num.rrset.bogus"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|rrset_bogus
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* threat detection */
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"unwanted.queries"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|unwanted_queries
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"unwanted.replies"
name|SQ
literal|"%u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|s
operator|->
name|svr
operator|.
name|unwanted_replies
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** do the stats command */
end_comment

begin_function
specifier|static
name|void
name|do_stats
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|daemon
modifier|*
name|daemon
init|=
name|rc
operator|->
name|worker
operator|->
name|daemon
decl_stmt|;
name|struct
name|stats_info
name|total
decl_stmt|;
name|struct
name|stats_info
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|log_assert
argument_list|(
name|daemon
operator|->
name|num
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* gather all thread statistics in one place */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|server_stats_obtain
argument_list|(
name|rc
operator|->
name|worker
argument_list|,
name|daemon
operator|->
name|workers
index|[
name|i
index|]
argument_list|,
operator|&
name|s
argument_list|,
name|reset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|print_thread_stats
argument_list|(
name|ssl
argument_list|,
name|i
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|total
operator|=
name|s
expr_stmt|;
else|else
name|server_stats_add
argument_list|(
operator|&
name|total
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* print the thread statistics */
name|total
operator|.
name|mesh_time_median
operator|/=
operator|(
name|double
operator|)
name|daemon
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|print_stats
argument_list|(
name|ssl
argument_list|,
literal|"total"
argument_list|,
operator|&
name|total
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|print_uptime
argument_list|(
name|ssl
argument_list|,
name|rc
operator|->
name|worker
argument_list|,
name|reset
argument_list|)
condition|)
return|return;
if|if
condition|(
name|daemon
operator|->
name|cfg
operator|->
name|stat_extended
condition|)
block|{
if|if
condition|(
operator|!
name|print_mem
argument_list|(
name|ssl
argument_list|,
name|rc
operator|->
name|worker
argument_list|,
name|daemon
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|print_hist
argument_list|(
name|ssl
argument_list|,
operator|&
name|total
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|print_ext
argument_list|(
name|ssl
argument_list|,
operator|&
name|total
argument_list|)
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/** parse commandline argument domain name */
end_comment

begin_function
specifier|static
name|int
name|parse_arg_name
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|labs
parameter_list|)
block|{
name|uint8_t
name|nm
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
name|nmlen
init|=
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|labs
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|sldns_str2wire_dname_buf
argument_list|(
name|str
argument_list|,
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error cannot parse name %s at %d: %s\n"
argument_list|,
name|str
argument_list|,
name|LDNS_WIREPARSE_OFFSET
argument_list|(
name|status
argument_list|)
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|res
operator|=
name|memdup
argument_list|(
name|nm
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|res
condition|)
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|labs
operator|=
name|dname_count_size_labels
argument_list|(
operator|*
name|res
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** find second argument, modifies string */
end_comment

begin_function
specifier|static
name|int
name|find_arg2
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
modifier|*
name|arg2
parameter_list|)
block|{
name|char
modifier|*
name|as
init|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|char
modifier|*
name|at
init|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|as
operator|&&
name|at
condition|)
block|{
if|if
condition|(
name|at
operator|<
name|as
condition|)
name|as
operator|=
name|at
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|arg2
operator|=
name|skipwhite
argument_list|(
name|as
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|as
condition|)
block|{
name|as
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|arg2
operator|=
name|skipwhite
argument_list|(
name|as
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
condition|)
block|{
name|at
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|arg2
operator|=
name|skipwhite
argument_list|(
name|at
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error could not find next argument "
literal|"after %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Add a new zone */
end_comment

begin_function
specifier|static
name|void
name|do_zone_add
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|char
modifier|*
name|arg2
decl_stmt|;
name|enum
name|localzone_type
name|t
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|find_arg2
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|arg2
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|local_zone_str2type
argument_list|(
name|arg2
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error not a zone type. %s\n"
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
name|lock_rw_wrlock
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|local_zones_find
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
condition|)
block|{
comment|/* already present in tree */
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|->
name|type
operator|=
name|t
expr_stmt|;
comment|/* update type anyway */
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|local_zones_add_zone
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Remove a zone */
end_comment

begin_function
specifier|static
name|void
name|do_zone_remove
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
name|lock_rw_wrlock
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|local_zones_find
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
condition|)
block|{
comment|/* present in tree */
name|local_zones_del_zone
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Add new RR data */
end_comment

begin_function
specifier|static
name|void
name|do_data_add
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|local_zones_add_RR
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error in syntax or out of memory, %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Remove RR data */
end_comment

begin_function
specifier|static
name|void
name|do_data_remove
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
name|local_zones_del_data
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** cache lookup of nameservers */
end_comment

begin_function
specifier|static
name|void
name|do_lookup
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
operator|(
name|void
operator|)
name|print_deleg_lookup
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** flush something from rrset and msg caches */
end_comment

begin_function
specifier|static
name|void
name|do_cache_remove
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|uint16_t
name|t
parameter_list|,
name|uint16_t
name|c
parameter_list|)
block|{
name|hashvalue_t
name|h
decl_stmt|;
name|struct
name|query_info
name|k
decl_stmt|;
name|rrset_cache_remove
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
name|rrset_cache_remove
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
name|PACKED_RRSET_SOA_NEG
argument_list|)
expr_stmt|;
name|k
operator|.
name|qname
operator|=
name|nm
expr_stmt|;
name|k
operator|.
name|qname_len
operator|=
name|nmlen
expr_stmt|;
name|k
operator|.
name|qtype
operator|=
name|t
expr_stmt|;
name|k
operator|.
name|qclass
operator|=
name|c
expr_stmt|;
name|h
operator|=
name|query_info_hash
argument_list|(
operator|&
name|k
argument_list|)
expr_stmt|;
name|slabhash_remove
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|,
name|h
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** flush a type */
end_comment

begin_function
specifier|static
name|void
name|do_flush_type
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|char
modifier|*
name|arg2
decl_stmt|;
name|uint16_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|find_arg2
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|arg2
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
name|t
operator|=
name|sldns_get_rr_type_by_name
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|worker
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|t
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** flush statistics */
end_comment

begin_function
specifier|static
name|void
name|do_flush_stats
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|worker_stats_clear
argument_list|(
name|worker
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Local info for deletion functions  */
end_comment

begin_struct
struct|struct
name|del_info
block|{
comment|/** worker */
name|struct
name|worker
modifier|*
name|worker
decl_stmt|;
comment|/** name to delete */
name|uint8_t
modifier|*
name|name
decl_stmt|;
comment|/** length */
name|size_t
name|len
decl_stmt|;
comment|/** labels */
name|int
name|labs
decl_stmt|;
comment|/** now */
name|time_t
name|now
decl_stmt|;
comment|/** time to invalidate to */
name|time_t
name|expired
decl_stmt|;
comment|/** number of rrsets removed */
name|size_t
name|num_rrsets
decl_stmt|;
comment|/** number of msgs removed */
name|size_t
name|num_msgs
decl_stmt|;
comment|/** number of key entries removed */
name|size_t
name|num_keys
decl_stmt|;
comment|/** length of addr */
name|socklen_t
name|addrlen
decl_stmt|;
comment|/** socket address for host deletion */
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** callback to delete hosts in infra cache */
end_comment

begin_function
specifier|static
name|void
name|infra_del_host
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|infra_key
modifier|*
name|k
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|e
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|sockaddr_cmp
argument_list|(
operator|&
name|inf
operator|->
name|addr
argument_list|,
name|inf
operator|->
name|addrlen
argument_list|,
operator|&
name|k
operator|->
name|addr
argument_list|,
name|k
operator|->
name|addrlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|infra_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
name|d
operator|->
name|probedelay
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|timeout_A
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|timeout_AAAA
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|timeout_other
operator|=
literal|0
expr_stmt|;
name|rtt_init
argument_list|(
operator|&
name|d
operator|->
name|rtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|>=
name|inf
operator|->
name|now
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_keys
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** flush infra cache */
end_comment

begin_function
specifier|static
name|void
name|do_flush_infra
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|len
decl_stmt|;
name|struct
name|del_info
name|inf
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|slabhash_clear
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
operator|->
name|hosts
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ipstrtoaddr
argument_list|(
name|arg
argument_list|,
name|UNBOUND_DNS_PORT
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error parsing ip addr: '%s'\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* delete all entries from cache */
comment|/* what we do is to set them all expired */
name|inf
operator|.
name|worker
operator|=
name|worker
expr_stmt|;
name|inf
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|labs
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|now
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|inf
operator|.
name|expired
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|inf
operator|.
name|expired
operator|-=
literal|3
expr_stmt|;
comment|/* handle 3 seconds skew between threads */
name|inf
operator|.
name|num_rrsets
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|num_msgs
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|num_keys
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|addrlen
operator|=
name|len
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|inf
operator|.
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|slabhash_traverse
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
operator|->
name|hosts
argument_list|,
literal|1
argument_list|,
operator|&
name|infra_del_host
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** flush requestlist */
end_comment

begin_function
specifier|static
name|void
name|do_flush_requestlist
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|mesh_delete_all
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** callback to delete rrsets in a zone */
end_comment

begin_function
specifier|static
name|void
name|zone_del_rrset
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
init|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|e
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|k
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|inf
operator|->
name|name
argument_list|)
condition|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|>=
name|inf
operator|->
name|now
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_rrsets
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** callback to delete messages in a zone */
end_comment

begin_function
specifier|static
name|void
name|zone_del_msg
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|msgreply_entry
modifier|*
name|k
init|=
operator|(
expr|struct
name|msgreply_entry
operator|*
operator|)
name|e
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|k
operator|->
name|key
operator|.
name|qname
argument_list|,
name|inf
operator|->
name|name
argument_list|)
condition|)
block|{
name|struct
name|reply_info
modifier|*
name|d
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|>=
name|inf
operator|->
name|now
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_msgs
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** callback to delete keys in zone */
end_comment

begin_function
specifier|static
name|void
name|zone_del_kcache
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|key_entry_key
modifier|*
name|k
init|=
operator|(
expr|struct
name|key_entry_key
operator|*
operator|)
name|e
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|k
operator|->
name|name
argument_list|,
name|inf
operator|->
name|name
argument_list|)
condition|)
block|{
name|struct
name|key_entry_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|key_entry_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|>=
name|inf
operator|->
name|now
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_keys
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** remove all rrsets and keys from zone from cache */
end_comment

begin_function
specifier|static
name|void
name|do_flush_zone
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|struct
name|del_info
name|inf
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
comment|/* delete all RRs and key entries from zone */
comment|/* what we do is to set them all expired */
name|inf
operator|.
name|worker
operator|=
name|worker
expr_stmt|;
name|inf
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|inf
operator|.
name|len
operator|=
name|nmlen
expr_stmt|;
name|inf
operator|.
name|labs
operator|=
name|nmlabs
expr_stmt|;
name|inf
operator|.
name|now
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|inf
operator|.
name|expired
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|inf
operator|.
name|expired
operator|-=
literal|3
expr_stmt|;
comment|/* handle 3 seconds skew between threads */
name|inf
operator|.
name|num_rrsets
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|num_msgs
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|num_keys
operator|=
literal|0
expr_stmt|;
name|slabhash_traverse
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|rrset_cache
operator|->
name|table
argument_list|,
literal|1
argument_list|,
operator|&
name|zone_del_rrset
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
name|slabhash_traverse
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|,
literal|1
argument_list|,
operator|&
name|zone_del_msg
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
comment|/* and validator cache */
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|key_cache
condition|)
block|{
name|slabhash_traverse
argument_list|(
name|worker
operator|->
name|env
operator|.
name|key_cache
operator|->
name|slab
argument_list|,
literal|1
argument_list|,
operator|&
name|zone_del_kcache
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"ok removed %u rrsets, %u messages "
literal|"and %u key entries\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|inf
operator|.
name|num_rrsets
argument_list|,
operator|(
name|unsigned
operator|)
name|inf
operator|.
name|num_msgs
argument_list|,
operator|(
name|unsigned
operator|)
name|inf
operator|.
name|num_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** callback to delete bogus rrsets */
end_comment

begin_function
specifier|static
name|void
name|bogus_del_rrset
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_rrsets
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** callback to delete bogus messages */
end_comment

begin_function
specifier|static
name|void
name|bogus_del_msg
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|d
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_msgs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** callback to delete bogus keys */
end_comment

begin_function
specifier|static
name|void
name|bogus_del_kcache
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* entry is locked */
name|struct
name|del_info
modifier|*
name|inf
init|=
operator|(
expr|struct
name|del_info
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|key_entry_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|key_entry_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|isbad
condition|)
block|{
name|d
operator|->
name|ttl
operator|=
name|inf
operator|->
name|expired
expr_stmt|;
name|inf
operator|->
name|num_keys
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** remove all rrsets and keys from zone from cache */
end_comment

begin_function
specifier|static
name|void
name|do_flush_bogus
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|del_info
name|inf
decl_stmt|;
comment|/* what we do is to set them all expired */
name|inf
operator|.
name|worker
operator|=
name|worker
expr_stmt|;
name|inf
operator|.
name|now
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|inf
operator|.
name|expired
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|inf
operator|.
name|expired
operator|-=
literal|3
expr_stmt|;
comment|/* handle 3 seconds skew between threads */
name|inf
operator|.
name|num_rrsets
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|num_msgs
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|num_keys
operator|=
literal|0
expr_stmt|;
name|slabhash_traverse
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|rrset_cache
operator|->
name|table
argument_list|,
literal|1
argument_list|,
operator|&
name|bogus_del_rrset
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
name|slabhash_traverse
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|,
literal|1
argument_list|,
operator|&
name|bogus_del_msg
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
comment|/* and validator cache */
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|key_cache
condition|)
block|{
name|slabhash_traverse
argument_list|(
name|worker
operator|->
name|env
operator|.
name|key_cache
operator|->
name|slab
argument_list|,
literal|1
argument_list|,
operator|&
name|bogus_del_kcache
argument_list|,
operator|&
name|inf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"ok removed %u rrsets, %u messages "
literal|"and %u key entries\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|inf
operator|.
name|num_rrsets
argument_list|,
operator|(
name|unsigned
operator|)
name|inf
operator|.
name|num_msgs
argument_list|,
operator|(
name|unsigned
operator|)
name|inf
operator|.
name|num_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** remove name rrset from cache */
end_comment

begin_function
specifier|static
name|void
name|do_flush_name
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|w
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_DNAME
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_MX
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_PTR
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_SRV
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|do_cache_remove
argument_list|(
name|w
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_NAPTR
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** printout a delegation point info */
end_comment

begin_function
specifier|static
name|int
name|ssl_print_name_dp
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|;
name|int
name|f
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|str
condition|)
block|{
comment|/* print header for forward, stub */
name|char
modifier|*
name|c
init|=
name|sldns_wire2str_class
argument_list|(
name|dclass
argument_list|)
decl_stmt|;
name|dname_str
argument_list|(
name|nm
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s %s %s: "
argument_list|,
name|buf
argument_list|,
operator|(
name|c
condition|?
name|c
else|:
literal|"CLASS??"
operator|)
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
name|dname_str
argument_list|(
name|ns
operator|->
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|f
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
name|f
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
name|dp
operator|->
name|target_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next_target
control|)
block|{
name|addr_to_str
argument_list|(
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|f
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
name|f
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** print root forwards */
end_comment

begin_function
specifier|static
name|int
name|print_root_fwds
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|iter_forwards
modifier|*
name|fwds
parameter_list|,
name|uint8_t
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|forwards_lookup
argument_list|(
name|fwds
argument_list|,
name|root
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"off (using root hints)\n"
argument_list|)
return|;
comment|/* if dp is returned it must be the root */
name|log_assert
argument_list|(
name|query_dname_compare
argument_list|(
name|dp
operator|->
name|name
argument_list|,
name|root
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|ssl_print_name_dp
argument_list|(
name|ssl
argument_list|,
name|NULL
argument_list|,
name|root
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|dp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** parse args into delegpt */
end_comment

begin_function
specifier|static
name|struct
name|delegpt
modifier|*
name|parse_delegpt
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|int
name|allow_names
parameter_list|)
block|{
comment|/* parse args and add in */
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|todo
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|dp
init|=
name|delegpt_create_mlc
argument_list|(
name|nm
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|p
condition|)
block|{
name|todo
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* find next spot, if any */
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* end this spot */
name|p
operator|=
name|skipwhite
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* position at next spot */
block|}
comment|/* parse address */
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|todo
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|allow_names
condition|)
block|{
name|uint8_t
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|size_t
name|ln
decl_stmt|;
name|int
name|lb
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|todo
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|ln
argument_list|,
operator|&
name|lb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error cannot "
literal|"parse IP address or name "
literal|"'%s'\n"
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|delegpt_add_ns_mlc
argument_list|(
name|dp
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error cannot parse"
literal|" IP address '%s'\n"
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* add address */
if|if
condition|(
operator|!
name|delegpt_add_addr_mlc
argument_list|(
name|dp
argument_list|,
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
return|return
name|dp
return|;
block|}
end_function

begin_comment
comment|/** do the status command */
end_comment

begin_function
specifier|static
name|void
name|do_forward
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|iter_forwards
modifier|*
name|fwd
init|=
name|worker
operator|->
name|env
operator|.
name|fwds
decl_stmt|;
name|uint8_t
modifier|*
name|root
init|=
operator|(
name|uint8_t
operator|*
operator|)
literal|"\000"
decl_stmt|;
if|if
condition|(
operator|!
name|fwd
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error: structure not allocated\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
name|args
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|print_root_fwds
argument_list|(
name|ssl
argument_list|,
name|fwd
argument_list|,
name|root
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* set root forwards for this thread. since we are in remote control 	 * the actual mesh is not running, so we can freely edit it. */
comment|/* delete all the existing queries first */
name|mesh_delete_all
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|forwards_delete_zone
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
name|parse_delegpt
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
name|root
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|forwards_add_zone
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|dp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_fs_args
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|struct
name|delegpt
modifier|*
modifier|*
name|dp
parameter_list|,
name|int
modifier|*
name|insecure
parameter_list|,
name|int
modifier|*
name|prime
parameter_list|)
block|{
name|char
modifier|*
name|zonename
decl_stmt|;
name|char
modifier|*
name|rest
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
comment|/* parse all -x args */
while|while
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|find_arg2
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|&
name|rest
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
operator|(
operator|++
name|args
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|args
operator|==
literal|'i'
operator|&&
name|insecure
condition|)
operator|*
name|insecure
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'p'
operator|&&
name|prime
condition|)
operator|*
name|prime
operator|=
literal|1
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error: unknown option %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|args
operator|=
name|rest
expr_stmt|;
block|}
comment|/* parse name */
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
operator|!
name|find_arg2
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|&
name|rest
argument_list|)
condition|)
return|return
literal|0
return|;
name|zonename
operator|=
name|args
expr_stmt|;
name|args
operator|=
name|rest
expr_stmt|;
block|}
else|else
name|zonename
operator|=
name|args
expr_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|zonename
argument_list|,
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* parse dp */
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|dp
operator|=
name|parse_delegpt
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|*
name|nm
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|nm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** do the forward_add command */
end_comment

begin_function
specifier|static
name|void
name|do_forward_add
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|iter_forwards
modifier|*
name|fwd
init|=
name|worker
operator|->
name|env
operator|.
name|fwds
decl_stmt|;
name|int
name|insecure
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|parse_fs_args
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|dp
argument_list|,
operator|&
name|insecure
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|insecure
operator|&&
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
block|{
if|if
condition|(
operator|!
name|anchors_add_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|forwards_add_zone
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|dp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the forward_remove command */
end_comment

begin_function
specifier|static
name|void
name|do_forward_remove
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|iter_forwards
modifier|*
name|fwd
init|=
name|worker
operator|->
name|env
operator|.
name|fwds
decl_stmt|;
name|int
name|insecure
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|parse_fs_args
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|&
name|nm
argument_list|,
name|NULL
argument_list|,
operator|&
name|insecure
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|insecure
operator|&&
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
name|anchors_delete_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|forwards_delete_zone
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the stub_add command */
end_comment

begin_function
specifier|static
name|void
name|do_stub_add
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|iter_forwards
modifier|*
name|fwd
init|=
name|worker
operator|->
name|env
operator|.
name|fwds
decl_stmt|;
name|int
name|insecure
init|=
literal|0
decl_stmt|,
name|prime
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|parse_fs_args
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|dp
argument_list|,
operator|&
name|insecure
argument_list|,
operator|&
name|prime
argument_list|)
condition|)
return|return;
if|if
condition|(
name|insecure
operator|&&
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
block|{
if|if
condition|(
operator|!
name|anchors_add_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|forwards_add_stub_hole
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
condition|)
block|{
if|if
condition|(
name|insecure
operator|&&
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
name|anchors_delete_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|hints_add_stub
argument_list|(
name|worker
operator|->
name|env
operator|.
name|hints
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|dp
argument_list|,
operator|!
name|prime
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|forwards_delete_stub_hole
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|insecure
operator|&&
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
name|anchors_delete_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the stub_remove command */
end_comment

begin_function
specifier|static
name|void
name|do_stub_remove
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|iter_forwards
modifier|*
name|fwd
init|=
name|worker
operator|->
name|env
operator|.
name|fwds
decl_stmt|;
name|int
name|insecure
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|parse_fs_args
argument_list|(
name|ssl
argument_list|,
name|args
argument_list|,
operator|&
name|nm
argument_list|,
name|NULL
argument_list|,
operator|&
name|insecure
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|insecure
operator|&&
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
name|anchors_delete_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|forwards_delete_stub_hole
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|hints_delete_stub
argument_list|(
name|worker
operator|->
name|env
operator|.
name|hints
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the insecure_add command */
end_comment

begin_function
specifier|static
name|void
name|do_insecure_add
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|nmlen
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
block|{
if|if
condition|(
operator|!
name|anchors_add_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error out of memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the insecure_remove command */
end_comment

begin_function
specifier|static
name|void
name|do_insecure_remove
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|nmlen
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|parse_arg_name
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return;
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|anchors
condition|)
name|anchors_delete_insecure
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the status command */
end_comment

begin_function
specifier|static
name|void
name|do_status
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|time_t
name|uptime
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"version: %s\n"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"verbosity: %d\n"
argument_list|,
name|verbosity
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"threads: %d\n"
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"modules: %d ["
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|mods
operator|.
name|num
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|worker
operator|->
name|daemon
operator|->
name|mods
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|" %s"
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|" ]\n"
argument_list|)
condition|)
return|return;
name|uptime
operator|=
operator|(
name|time_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
operator|(
name|time_t
operator|)
name|worker
operator|->
name|daemon
operator|->
name|time_boot
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"uptime: "
name|ARG_LL
literal|"d seconds\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|uptime
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"unbound (pid %d) is running...\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
condition|)
return|return;
block|}
end_function

begin_comment
comment|/** get age for the mesh state */
end_comment

begin_function
specifier|static
name|void
name|get_mesh_age
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|reply_list
condition|)
block|{
name|struct
name|timeval
name|d
decl_stmt|;
name|struct
name|mesh_reply
modifier|*
name|r
init|=
name|m
operator|->
name|reply_list
decl_stmt|;
comment|/* last reply is the oldest */
while|while
condition|(
name|r
operator|&&
name|r
operator|->
name|next
condition|)
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|timeval_subtract
argument_list|(
operator|&
name|d
argument_list|,
name|env
operator|->
name|now_tv
argument_list|,
operator|&
name|r
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|ARG_LL
literal|"d.%6.6d"
argument_list|,
operator|(
name|long
name|long
operator|)
name|d
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|d
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** get status of a mesh state */
end_comment

begin_function
specifier|static
name|void
name|get_mesh_status
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|enum
name|module_ext_state
name|s
init|=
name|m
operator|->
name|s
operator|.
name|ext_state
index|[
name|m
operator|->
name|s
operator|.
name|curmod
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|modname
init|=
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|m
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|name
decl_stmt|;
name|size_t
name|l
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|modname
argument_list|,
literal|"iterator"
argument_list|)
operator|==
literal|0
operator|&&
name|s
operator|==
name|module_wait_reply
operator|&&
name|m
operator|->
name|s
operator|.
name|minfo
index|[
name|m
operator|->
name|s
operator|.
name|curmod
index|]
condition|)
block|{
comment|/* break into iterator to find out who its waiting for */
name|struct
name|iter_qstate
modifier|*
name|qstate
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|m
operator|->
name|s
operator|.
name|minfo
index|[
name|m
operator|->
name|s
operator|.
name|curmod
index|]
decl_stmt|;
name|struct
name|outbound_list
modifier|*
name|ol
init|=
operator|&
name|qstate
operator|->
name|outlist
decl_stmt|;
name|struct
name|outbound_entry
modifier|*
name|e
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s wait for"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
if|if
condition|(
name|ol
operator|->
name|first
operator|==
name|NULL
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|" (empty_list)"
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|ol
operator|->
name|first
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|addr_to_str
argument_list|(
operator|&
name|e
operator|->
name|qsent
operator|->
name|addr
argument_list|,
name|e
operator|->
name|qsent
operator|->
name|addrlen
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|module_wait_subquery
condition|)
block|{
comment|/* look in subs from mesh state to see what */
name|char
name|nm
index|[
literal|257
index|]
decl_stmt|;
name|struct
name|mesh_state_ref
modifier|*
name|sub
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s wants"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|sub_set
operator|.
name|count
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|" (empty_list)"
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|sub
argument_list|,
argument|struct mesh_state_ref*
argument_list|,
argument|&m->sub_set
argument_list|)
block|{
name|char
modifier|*
name|t
init|=
name|sldns_wire2str_type
argument_list|(
name|sub
operator|->
name|s
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qtype
argument_list|)
decl_stmt|;
name|char
modifier|*
name|c
init|=
name|sldns_wire2str_class
argument_list|(
name|sub
operator|->
name|s
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qclass
argument_list|)
decl_stmt|;
name|dname_str
argument_list|(
name|sub
operator|->
name|s
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|" %s %s %s"
argument_list|,
operator|(
name|t
condition|?
name|t
else|:
literal|"TYPE??"
operator|)
argument_list|,
operator|(
name|c
condition|?
name|c
else|:
literal|"CLASS??"
operator|)
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s is %s"
argument_list|,
name|modname
argument_list|,
name|strextstate
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** do the dump_requestlist command */
end_comment

begin_function
specifier|static
name|void
name|do_dump_requestlist
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|mesh_area
modifier|*
name|mesh
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|m
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
name|char
name|timebuf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|statbuf
index|[
literal|10240
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"thread #%d\n"
argument_list|,
name|worker
operator|->
name|thread_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"#   type cl name    seconds    module status\n"
argument_list|)
condition|)
return|return;
comment|/* show worker mesh contents */
name|mesh
operator|=
name|worker
operator|->
name|env
operator|.
name|mesh
expr_stmt|;
if|if
condition|(
operator|!
name|mesh
condition|)
return|return;
name|RBTREE_FOR
argument_list|(
argument|m
argument_list|,
argument|struct mesh_state*
argument_list|,
argument|&mesh->all
argument_list|)
block|{
name|char
modifier|*
name|t
init|=
name|sldns_wire2str_type
argument_list|(
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qtype
argument_list|)
decl_stmt|;
name|char
modifier|*
name|c
init|=
name|sldns_wire2str_class
argument_list|(
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qclass
argument_list|)
decl_stmt|;
name|dname_str
argument_list|(
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|get_mesh_age
argument_list|(
name|m
argument_list|,
name|timebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|timebuf
argument_list|)
argument_list|,
operator|&
name|worker
operator|->
name|env
argument_list|)
expr_stmt|;
name|get_mesh_status
argument_list|(
name|mesh
argument_list|,
name|m
argument_list|,
name|statbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|statbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%3d %4s %2s %s %s %s\n"
argument_list|,
name|num
argument_list|,
operator|(
name|t
condition|?
name|t
else|:
literal|"TYPE??"
operator|)
argument_list|,
operator|(
name|c
condition|?
name|c
else|:
literal|"CLASS??"
operator|)
argument_list|,
name|buf
argument_list|,
name|timebuf
argument_list|,
name|statbuf
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|++
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** structure for argument data for dump infra host */
end_comment

begin_struct
struct|struct
name|infra_arg
block|{
comment|/** the infra cache */
name|struct
name|infra_cache
modifier|*
name|infra
decl_stmt|;
comment|/** the SSL connection */
name|SSL
modifier|*
name|ssl
decl_stmt|;
comment|/** the time now */
name|time_t
name|now
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** callback for every host element in the infra cache */
end_comment

begin_function
specifier|static
name|void
name|dump_infra_host
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|infra_arg
modifier|*
name|a
init|=
operator|(
expr|struct
name|infra_arg
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|infra_key
modifier|*
name|k
init|=
operator|(
expr|struct
name|infra_key
operator|*
operator|)
name|e
operator|->
name|key
decl_stmt|;
name|struct
name|infra_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|infra_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
name|char
name|ip_str
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|name
index|[
literal|257
index|]
decl_stmt|;
name|addr_to_str
argument_list|(
operator|&
name|k
operator|->
name|addr
argument_list|,
name|k
operator|->
name|addrlen
argument_list|,
name|ip_str
argument_list|,
sizeof|sizeof
argument_list|(
name|ip_str
argument_list|)
argument_list|)
expr_stmt|;
name|dname_str
argument_list|(
name|k
operator|->
name|zonename
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* skip expired stuff (only backed off) */
if|if
condition|(
name|d
operator|->
name|ttl
operator|<
name|a
operator|->
name|now
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|rtt
operator|.
name|rto
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|a
operator|->
name|ssl
argument_list|,
literal|"%s %s expired rto %d\n"
argument_list|,
name|ip_str
argument_list|,
name|name
argument_list|,
name|d
operator|->
name|rtt
operator|.
name|rto
argument_list|)
condition|)
return|return;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|a
operator|->
name|ssl
argument_list|,
literal|"%s %s ttl %d ping %d var %d rtt %d rto %d "
literal|"tA %d tAAAA %d tother %d "
literal|"ednsknown %d edns %d delay %d lame dnssec %d rec %d A %d "
literal|"other %d\n"
argument_list|,
name|ip_str
argument_list|,
name|name
argument_list|,
call|(
name|int
call|)
argument_list|(
name|d
operator|->
name|ttl
operator|-
name|a
operator|->
name|now
argument_list|)
argument_list|,
name|d
operator|->
name|rtt
operator|.
name|srtt
argument_list|,
name|d
operator|->
name|rtt
operator|.
name|rttvar
argument_list|,
name|rtt_notimeout
argument_list|(
operator|&
name|d
operator|->
name|rtt
argument_list|)
argument_list|,
name|d
operator|->
name|rtt
operator|.
name|rto
argument_list|,
name|d
operator|->
name|timeout_A
argument_list|,
name|d
operator|->
name|timeout_AAAA
argument_list|,
name|d
operator|->
name|timeout_other
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|edns_lame_known
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|edns_version
argument_list|,
call|(
name|int
call|)
argument_list|(
name|a
operator|->
name|now
operator|<
name|d
operator|->
name|probedelay
condition|?
name|d
operator|->
name|probedelay
operator|-
name|a
operator|->
name|now
else|:
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|isdnsseclame
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|rec_lame
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|lame_type_A
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|lame_other
argument_list|)
condition|)
return|return;
block|}
end_function

begin_comment
comment|/** do the dump_infra command */
end_comment

begin_function
specifier|static
name|void
name|do_dump_infra
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|infra_arg
name|arg
decl_stmt|;
name|arg
operator|.
name|infra
operator|=
name|worker
operator|->
name|env
operator|.
name|infra_cache
expr_stmt|;
name|arg
operator|.
name|ssl
operator|=
name|ssl
expr_stmt|;
name|arg
operator|.
name|now
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|slabhash_traverse
argument_list|(
name|arg
operator|.
name|infra
operator|->
name|hosts
argument_list|,
literal|0
argument_list|,
operator|&
name|dump_infra_host
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the log_reopen command */
end_comment

begin_function
specifier|static
name|void
name|do_log_reopen
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|worker
operator|->
name|env
operator|.
name|cfg
decl_stmt|;
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|log_init
argument_list|(
name|cfg
operator|->
name|logfile
argument_list|,
name|cfg
operator|->
name|use_syslog
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the set_option command */
end_comment

begin_function
specifier|static
name|void
name|do_set_option
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|arg2
decl_stmt|;
if|if
condition|(
operator|!
name|find_arg2
argument_list|(
name|ssl
argument_list|,
name|arg
argument_list|,
operator|&
name|arg2
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|config_set_option
argument_list|(
name|worker
operator|->
name|env
operator|.
name|cfg
argument_list|,
name|arg
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error setting option\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* routine to printout option values over SSL */
end_comment

begin_function
name|void
name|remote_get_opt_ssl
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|SSL
modifier|*
name|ssl
init|=
operator|(
name|SSL
operator|*
operator|)
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the get_option command */
end_comment

begin_function
specifier|static
name|void
name|do_get_option
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|config_get_option
argument_list|(
name|worker
operator|->
name|env
operator|.
name|cfg
argument_list|,
name|arg
argument_list|,
name|remote_get_opt_ssl
argument_list|,
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error unknown option\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/** do the list_forwards command */
end_comment

begin_function
specifier|static
name|void
name|do_list_forwards
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
comment|/* since its a per-worker structure no locks needed */
name|struct
name|iter_forwards
modifier|*
name|fwds
init|=
name|worker
operator|->
name|env
operator|.
name|fwds
decl_stmt|;
name|struct
name|iter_forward_zone
modifier|*
name|z
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|z
argument_list|,
argument|struct iter_forward_zone*
argument_list|,
argument|fwds->tree
argument_list|)
block|{
if|if
condition|(
operator|!
name|z
operator|->
name|dp
condition|)
continue|continue;
comment|/* skip empty marker for stub */
if|if
condition|(
operator|!
name|ssl_print_name_dp
argument_list|(
name|ssl
argument_list|,
literal|"forward"
argument_list|,
name|z
operator|->
name|name
argument_list|,
name|z
operator|->
name|dclass
argument_list|,
name|z
operator|->
name|dp
argument_list|)
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/** do the list_stubs command */
end_comment

begin_function
specifier|static
name|void
name|do_list_stubs
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|iter_hints_stub
modifier|*
name|z
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|z
argument_list|,
argument|struct iter_hints_stub*
argument_list|,
argument|&worker->env.hints->tree
argument_list|)
block|{
if|if
condition|(
operator|!
name|ssl_print_name_dp
argument_list|(
name|ssl
argument_list|,
name|z
operator|->
name|noprime
condition|?
literal|"stub noprime"
else|:
literal|"stub prime"
argument_list|,
name|z
operator|->
name|node
operator|.
name|name
argument_list|,
name|z
operator|->
name|node
operator|.
name|dclass
argument_list|,
name|z
operator|->
name|dp
argument_list|)
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/** do the list_local_zones command */
end_comment

begin_function
specifier|static
name|void
name|do_list_local_zones
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|local_zones
modifier|*
name|zones
init|=
name|worker
operator|->
name|daemon
operator|->
name|local_zones
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|z
argument_list|,
argument|struct local_zone*
argument_list|,
argument|&zones->ztree
argument_list|)
block|{
name|lock_rw_rdlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dname_str
argument_list|(
name|z
operator|->
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s %s\n"
argument_list|,
name|buf
argument_list|,
name|local_zone_type2str
argument_list|(
name|z
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the list_local_data command */
end_comment

begin_function
specifier|static
name|void
name|do_list_local_data
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|local_zones
modifier|*
name|zones
init|=
name|worker
operator|->
name|daemon
operator|->
name|local_zones
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|struct
name|local_data
modifier|*
name|d
decl_stmt|;
name|struct
name|local_rrset
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
argument_list|)
decl_stmt|;
name|size_t
name|slen
init|=
name|sldns_buffer_capacity
argument_list|(
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
argument_list|)
decl_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|z
argument_list|,
argument|struct local_zone*
argument_list|,
argument|&zones->ztree
argument_list|)
block|{
name|lock_rw_rdlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|d
argument_list|,
argument|struct local_data*
argument_list|,
argument|&z->data
argument_list|)
block|{
for|for
control|(
name|p
operator|=
name|d
operator|->
name|rrsets
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|p
operator|->
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packed_rr_to_string
argument_list|(
name|p
operator|->
name|rrset
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"BADRR\n"
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
condition|)
return|return;
block|}
block|}
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** tell other processes to execute the command */
end_comment

begin_function
specifier|static
name|void
name|distribute_cmd
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|||
operator|!
name|ssl
condition|)
return|return;
comment|/* skip i=0 which is me */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rc
operator|->
name|worker
operator|->
name|daemon
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|worker_send_cmd
argument_list|(
name|rc
operator|->
name|worker
operator|->
name|daemon
operator|->
name|workers
index|[
name|i
index|]
argument_list|,
name|worker_cmd_remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tube_write_msg
argument_list|(
name|rc
operator|->
name|worker
operator|->
name|daemon
operator|->
name|workers
index|[
name|i
index|]
operator|->
name|cmd
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error could not distribute cmd\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/** check for name with end-of-string, space or tab after it */
end_comment

begin_function
specifier|static
name|int
name|cmdcmp
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|p
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|' '
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|'\t'
operator|)
return|;
block|}
end_function

begin_comment
comment|/** execute a remote control command */
end_comment

begin_function
specifier|static
name|void
name|execute_cmd
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|skipwhite
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
comment|/* compare command */
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"stop"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|do_stop
argument_list|(
name|ssl
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"reload"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|do_reload
argument_list|(
name|ssl
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"stats_noreset"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|do_stats
argument_list|(
name|ssl
argument_list|,
name|rc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"stats"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|do_stats
argument_list|(
name|ssl
argument_list|,
name|rc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"status"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|do_status
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"dump_cache"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dump_cache
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"load_cache"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
if|if
condition|(
name|load_cache
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
condition|)
name|send_ok
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"list_forwards"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|do_list_forwards
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"list_stubs"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_list_stubs
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"list_local_zones"
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|do_list_local_zones
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"list_local_data"
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|do_list_local_data
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"stub_add"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_stub_add
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|8
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"stub_remove"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_stub_remove
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|11
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"forward_add"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_forward_add
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|11
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"forward_remove"
argument_list|,
literal|14
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_forward_remove
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|14
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"insecure_add"
argument_list|,
literal|12
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_insecure_add
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|12
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"insecure_remove"
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_insecure_remove
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|15
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"forward"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_forward
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush_stats"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_flush_stats
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush_requestlist"
argument_list|,
literal|17
argument_list|)
condition|)
block|{
comment|/* must always distribute this cmd */
if|if
condition|(
name|rc
condition|)
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|do_flush_requestlist
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"lookup"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|do_lookup
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|6
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|THREADS_DISABLED
comment|/* other processes must execute the command as well */
comment|/* commands that should not be distributed, returned above. */
if|if
condition|(
name|rc
condition|)
block|{
comment|/* only if this thread is the master (rc) thread */
comment|/* done before the code below, which may split the string */
name|distribute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"verbosity"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|do_verbosity
argument_list|(
name|ssl
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"local_zone_remove"
argument_list|,
literal|17
argument_list|)
condition|)
block|{
name|do_zone_remove
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|17
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"local_zone"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_zone_add
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"local_data_remove"
argument_list|,
literal|17
argument_list|)
condition|)
block|{
name|do_data_remove
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|17
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"local_data"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_data_add
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush_zone"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_flush_zone
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush_type"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_flush_type
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush_infra"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|do_flush_infra
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|11
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|do_flush_name
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"dump_requestlist"
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|do_dump_requestlist
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"dump_infra"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_dump_infra
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"log_reopen"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_log_reopen
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"set_option"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_set_option
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"get_option"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|do_get_option
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|skipwhite
argument_list|(
name|p
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdcmp
argument_list|(
name|p
argument_list|,
literal|"flush_bogus"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|do_flush_bogus
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error unknown command '%s'\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|daemon_remote_exec
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
comment|/* read the cmd string */
name|uint8_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tube_read_msg
argument_list|(
name|worker
operator|->
name|cmd
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"daemon_remote_exec: tube_read_msg failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"remote exec distributed: %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
name|execute_cmd
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|worker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** handle remote control request */
end_comment

begin_function
specifier|static
name|void
name|handle_req
parameter_list|(
name|struct
name|daemon_remote
modifier|*
name|rc
parameter_list|,
name|struct
name|rc_state
modifier|*
name|s
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|char
name|pre
index|[
literal|10
index|]
decl_stmt|;
name|char
name|magic
index|[
literal|7
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
comment|/* makes it possible to set the socket blocking again. */
comment|/* basically removes it from winsock_event ... */
name|WSAEventSelect
argument_list|(
name|s
operator|->
name|c
operator|->
name|fd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd_set_block
argument_list|(
name|s
operator|->
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* try to read magic UBCT[version]_space_ string */
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|magic
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
return|return;
name|log_crypto_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
return|return;
block|}
name|magic
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|6
operator|||
name|strncmp
argument_list|(
name|magic
argument_list|,
literal|"UBCT"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"control connection has bad magic string"
argument_list|)
expr_stmt|;
comment|/* probably wrong tool connected, ignore it completely */
return|return;
block|}
comment|/* read the command line */
if|if
condition|(
operator|!
name|ssl_read_line
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
return|return;
block|}
name|snprintf
argument_list|(
name|pre
argument_list|,
sizeof|sizeof
argument_list|(
name|pre
argument_list|)
argument_list|,
literal|"UBCT%d "
argument_list|,
name|UNBOUND_CONTROL_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|magic
argument_list|,
name|pre
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"control connection had bad "
literal|"version %s, cmd: %s"
argument_list|,
name|magic
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"error version mismatch\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"control cmd: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* figure out what to do */
name|execute_cmd
argument_list|(
name|rc
argument_list|,
name|ssl
argument_list|,
name|buf
argument_list|,
name|rc
operator|->
name|worker
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|remote_control_callback
argument_list|(
expr|struct
name|comm_point
operator|*
name|c
argument_list|,
name|void
operator|*
name|arg
argument_list|,
name|int
name|err
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|rep
argument_list|)
argument_list|)
block|{
name|struct
name|rc_state
modifier|*
name|s
init|=
operator|(
expr|struct
name|rc_state
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|daemon_remote
modifier|*
name|rc
init|=
name|s
operator|->
name|rc
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|NETEVENT_TIMEOUT
condition|)
name|log_err
argument_list|(
literal|"remote control timed out"
argument_list|)
expr_stmt|;
name|clean_point
argument_list|(
name|rc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* (continue to) setup the SSL connection */
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|s
operator|->
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
block|{
name|int
name|r2
init|=
name|SSL_get_error
argument_list|(
name|s
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|shake_state
operator|==
name|rc_hs_read
condition|)
block|{
comment|/* try again later */
return|return
literal|0
return|;
block|}
name|s
operator|->
name|shake_state
operator|=
name|rc_hs_read
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|shake_state
operator|==
name|rc_hs_write
condition|)
block|{
comment|/* try again later */
return|return
literal|0
return|;
block|}
name|s
operator|->
name|shake_state
operator|=
name|rc_hs_write
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|log_err
argument_list|(
literal|"remote control connection closed prematurely"
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"failed connection from"
argument_list|,
operator|&
name|s
operator|->
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|s
operator|->
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
name|log_crypto_err
argument_list|(
literal|"remote control failed ssl"
argument_list|)
expr_stmt|;
name|clean_point
argument_list|(
name|rc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|s
operator|->
name|shake_state
operator|=
name|rc_none
expr_stmt|;
comment|/* once handshake has completed, check authentication */
if|if
condition|(
name|SSL_get_verify_result
argument_list|(
name|s
operator|->
name|ssl
argument_list|)
operator|==
name|X509_V_OK
condition|)
block|{
name|X509
modifier|*
name|x
init|=
name|SSL_get_peer_certificate
argument_list|(
name|s
operator|->
name|ssl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"remote control connection "
literal|"provided no client certificate"
argument_list|)
expr_stmt|;
name|clean_point
argument_list|(
name|rc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"remote control connection authenticated"
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"remote control connection failed to "
literal|"authenticate with client certificate"
argument_list|)
expr_stmt|;
name|clean_point
argument_list|(
name|rc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* if OK start to actually handle the request */
name|handle_req
argument_list|(
name|rc
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"remote control operation completed"
argument_list|)
expr_stmt|;
name|clean_point
argument_list|(
name|rc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

end_unit

