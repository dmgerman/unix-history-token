begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * daemon/unbound.c - main program for unbound DNS resolver daemon.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/**  * \file  *  * Main program to start the DNS resolver daemon.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"daemon/daemon.h"
end_include

begin_include
include|#
directive|include
file|"daemon/remote.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PWD_H
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GRP_H
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LOGIN_CAP_H
end_ifdef

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_include
include|#
directive|include
file|"util/winsock_event.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"util/mini_event.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<event.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
end_ifdef

begin_include
include|#
directive|include
file|"winrc/win_svc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS
end_ifdef

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"nss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SBRK
end_ifdef

begin_comment
comment|/** global debug value to keep track of heap memory allocation */
end_comment

begin_decl_stmt
name|void
modifier|*
name|unbound_start_brk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_EVENT_BASE_GET_METHOD
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ev_backend2str
parameter_list|(
name|int
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
name|EVBACKEND_SELECT
case|:
return|return
literal|"select"
return|;
case|case
name|EVBACKEND_POLL
case|:
return|return
literal|"poll"
return|;
case|case
name|EVBACKEND_EPOLL
case|:
return|return
literal|"epoll"
return|;
case|case
name|EVBACKEND_KQUEUE
case|:
return|return
literal|"kqueue"
return|;
case|case
name|EVBACKEND_DEVPOLL
case|:
return|return
literal|"devpoll"
return|;
case|case
name|EVBACKEND_PORT
case|:
return|return
literal|"evport"
return|;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** get the event system in use */
end_comment

begin_function
specifier|static
name|void
name|get_event_sys
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_WINSOCK
operator|*
name|n
operator|=
literal|"event"
expr_stmt|;
operator|*
name|s
operator|=
literal|"winsock"
expr_stmt|;
operator|*
name|m
operator|=
literal|"WSAWaitForMultipleEvents"
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|*
name|n
operator|=
literal|"mini-event"
expr_stmt|;
operator|*
name|s
operator|=
literal|"internal"
expr_stmt|;
operator|*
name|m
operator|=
literal|"select"
expr_stmt|;
else|#
directive|else
name|struct
name|event_base
modifier|*
name|b
decl_stmt|;
operator|*
name|s
operator|=
name|event_get_version
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_GET_METHOD
operator|*
name|n
operator|=
literal|"libevent"
expr_stmt|;
name|b
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
operator|*
name|m
operator|=
name|event_base_get_method
argument_list|(
name|b
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|*
name|n
operator|=
literal|"libev"
expr_stmt|;
name|b
operator|=
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|ev_default_loop
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|ev_backend2str
argument_list|(
name|ev_backend
argument_list|(
operator|(
expr|struct
name|ev_loop
operator|*
operator|)
name|b
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|n
operator|=
literal|"unknown"
expr_stmt|;
operator|*
name|m
operator|=
literal|"not obtainable"
expr_stmt|;
name|b
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_FREE
name|event_base_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** print usage. */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
specifier|const
name|char
modifier|*
modifier|*
name|m
decl_stmt|;
specifier|const
name|char
modifier|*
name|evnm
init|=
literal|"event"
decl_stmt|,
modifier|*
name|evsys
init|=
literal|""
decl_stmt|,
modifier|*
name|evmethod
init|=
literal|""
decl_stmt|;
name|printf
argument_list|(
literal|"usage:  unbound [options]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	start unbound daemon DNS resolver.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-h	this help\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-c file	config file to read instead of %s\n"
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	file format is described in unbound.conf(5).\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-d	do not fork into the background.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-v	verbose (more times to increase verbosity)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|printf
argument_list|(
literal|"-w opt	windows option: \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   	install, remove - manage the services entry\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   	service - used to start from services control panel\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
expr_stmt|;
name|get_event_sys
argument_list|(
operator|&
name|evnm
argument_list|,
operator|&
name|evsys
argument_list|,
operator|&
name|evmethod
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"linked libs: %s %s (it uses %s), ldns %s, %s\n"
argument_list|,
name|evnm
argument_list|,
name|evsys
argument_list|,
name|evmethod
argument_list|,
name|ldns_version
argument_list|()
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_SSL
name|SSLeay_version
argument_list|(
argument|SSLEAY_VERSION
argument_list|)
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
name|NSS_GetVersion
argument_list|()
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"linked modules:"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|module_list_avail
argument_list|()
init|;
operator|*
name|m
condition|;
name|m
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"configured for %s on %s with options:%s\n"
argument_list|,
name|CONFIGURE_TARGET
argument_list|,
name|CONFIGURE_DATE
argument_list|,
name|CONFIGURE_BUILD_WITH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BSD licensed, see LICENSE in source package for details.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Report bugs to %s\n"
argument_list|,
name|PACKAGE_BUGREPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|unbound_testbound
end_ifndef

begin_function
name|int
name|replay_var_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** check file descriptor count */
end_comment

begin_function
specifier|static
name|void
name|checkrlimits
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETRLIMIT
comment|/* list has number of ports to listen to, ifs number addresses */
name|int
name|list
init|=
operator|(
operator|(
name|cfg
operator|->
name|do_udp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|cfg
operator|->
name|do_tcp
condition|?
literal|1
operator|+
operator|(
name|int
operator|)
name|cfg
operator|->
name|incoming_num_tcp
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|size_t
name|listen_ifs
init|=
call|(
name|size_t
call|)
argument_list|(
name|cfg
operator|->
name|num_ifs
operator|==
literal|0
condition|?
operator|(
operator|(
name|cfg
operator|->
name|do_ip4
operator|&&
operator|!
name|cfg
operator|->
name|if_automatic
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|cfg
operator|->
name|do_ip6
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
else|:
name|cfg
operator|->
name|num_ifs
argument_list|)
decl_stmt|;
name|size_t
name|listen_num
init|=
name|list
operator|*
name|listen_ifs
decl_stmt|;
name|size_t
name|outudpnum
init|=
operator|(
name|size_t
operator|)
name|cfg
operator|->
name|outgoing_num_ports
decl_stmt|;
name|size_t
name|outtcpnum
init|=
name|cfg
operator|->
name|outgoing_num_tcp
decl_stmt|;
name|size_t
name|misc
init|=
literal|4
decl_stmt|;
comment|/* logfile, pidfile, stdout... */
name|size_t
name|perthread_noudp
init|=
name|listen_num
operator|+
name|outtcpnum
operator|+
literal|2
comment|/*cmdpipe*/
operator|+
literal|2
comment|/*libevent*/
operator|+
name|misc
decl_stmt|;
name|size_t
name|perthread
init|=
name|perthread_noudp
operator|+
name|outudpnum
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PTHREAD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SOLARIS_THREADS
argument_list|)
name|int
name|numthread
init|=
literal|1
decl_stmt|;
comment|/* it forks */
else|#
directive|else
name|int
name|numthread
init|=
operator|(
name|cfg
operator|->
name|num_threads
condition|?
name|cfg
operator|->
name|num_threads
else|:
literal|1
operator|)
decl_stmt|;
endif|#
directive|endif
name|size_t
name|total
init|=
name|numthread
operator|*
name|perthread
operator|+
name|misc
decl_stmt|;
name|size_t
name|avail
decl_stmt|;
name|struct
name|rlimit
name|rlim
decl_stmt|;
if|if
condition|(
name|total
operator|>
literal|1024
operator|&&
name|strncmp
argument_list|(
name|event_get_version
argument_list|()
argument_list|,
literal|"mini-event"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"too many file descriptors requested. The builtin"
literal|"mini-event cannot handle more than 1024. Config "
literal|"for less fds or compile with libevent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numthread
operator|*
name|perthread_noudp
operator|+
literal|15
operator|>
literal|1024
condition|)
name|fatal_exit
argument_list|(
literal|"too much tcp. not enough fds."
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|outgoing_num_ports
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1024
operator|-
name|numthread
operator|*
name|perthread_noudp
operator|-
literal|10
comment|/* safety margin */
operator|)
operator|/
name|numthread
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"continuing with less udp ports: %u"
argument_list|,
name|cfg
operator|->
name|outgoing_num_ports
argument_list|)
expr_stmt|;
name|total
operator|=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
name|perthread
operator|>
literal|64
operator|&&
name|strncmp
argument_list|(
name|event_get_version
argument_list|()
argument_list|,
literal|"winsock-event"
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"too many file descriptors requested. The winsock"
literal|" event handler cannot handle more than 64 per "
literal|" thread. Config for less fds"
argument_list|)
expr_stmt|;
if|if
condition|(
name|perthread_noudp
operator|+
literal|2
operator|>
literal|64
condition|)
name|fatal_exit
argument_list|(
literal|"too much tcp. not enough fds."
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|outgoing_num_ports
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|64
operator|-
name|perthread_noudp
operator|-
literal|2
comment|/* safety margin */
operator|)
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"continuing with less udp ports: %u"
argument_list|,
name|cfg
operator|->
name|outgoing_num_ports
argument_list|)
expr_stmt|;
name|total
operator|=
name|numthread
operator|*
operator|(
name|perthread_noudp
operator|+
operator|(
name|size_t
operator|)
name|cfg
operator|->
name|outgoing_num_ports
operator|)
operator|+
name|misc
expr_stmt|;
block|}
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"getrlimit: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
condition|)
return|return;
if|if
condition|(
operator|(
name|size_t
operator|)
name|rlim
operator|.
name|rlim_cur
operator|<
name|total
condition|)
block|{
name|avail
operator|=
operator|(
name|size_t
operator|)
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
call|(
name|rlim_t
call|)
argument_list|(
name|total
operator|+
literal|10
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
call|(
name|rlim_t
call|)
argument_list|(
name|total
operator|+
literal|10
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETRLIMIT
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setrlimit: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|log_warn
argument_list|(
literal|"cannot increase max open fds from %u to %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|avail
argument_list|,
operator|(
name|unsigned
operator|)
name|total
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* check that calculation below does not underflow, 			 * with 15 as margin */
if|if
condition|(
name|numthread
operator|*
name|perthread_noudp
operator|+
literal|15
operator|>
name|avail
condition|)
name|fatal_exit
argument_list|(
literal|"too much tcp. not enough fds."
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|outgoing_num_ports
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|avail
operator|-
name|numthread
operator|*
name|perthread_noudp
operator|-
literal|10
comment|/* safety margin */
operator|)
operator|/
name|numthread
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"continuing with less udp ports: %u"
argument_list|,
name|cfg
operator|->
name|outgoing_num_ports
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"increase ulimit or decrease threads, "
literal|"ports in config to remove this warning"
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_warn
argument_list|(
literal|"increased limit(open files) from %u to %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|avail
argument_list|,
operator|(
name|unsigned
operator|)
name|total
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|cfg
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_GETRLIMIT */
block|}
comment|/** set verbosity, check rlimits, cache settings */
specifier|static
name|void
name|apply_settings
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|int
name|cmdline_verbose
parameter_list|)
block|{
comment|/* apply if they have changed */
name|verbosity
operator|=
name|cmdline_verbose
operator|+
name|cfg
operator|->
name|verbosity
expr_stmt|;
name|daemon_apply_cfg
argument_list|(
name|daemon
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|checkrlimits
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_KILL
comment|/** Read existing pid from pidfile.   * @param file: file name of pid file.  * @return: the pid from the file or -1 if none.  */
specifier|static
name|pid_t
name|readpid
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|char
name|pidbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|ssize_t
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|log_err
argument_list|(
literal|"Could not read pidfile %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|l
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|pidbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pidbuf
argument_list|)
argument_list|)
operator|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|log_err
argument_list|(
literal|"Could not read pidfile %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Empty pidfile means no pidfile... */
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|pidbuf
index|[
sizeof|sizeof
argument_list|(
name|pidbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|pidbuf
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|'\n'
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|pid
return|;
block|}
comment|/** write pid to file.   * @param pidfile: file name of pid file.  * @param pid: pid to write to file.  */
specifier|static
name|void
name|writepid
parameter_list|(
specifier|const
name|char
modifier|*
name|pidfile
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|pidfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot open pidfile %s: %s"
argument_list|,
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot write to pidfile %s: %s"
argument_list|,
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/**  * check old pid file.  * @param pidfile: the file name of the pid file.  * @param inchroot: if pidfile is inchroot and we can thus expect to  *	be able to delete it.  */
specifier|static
name|void
name|checkoldpid
parameter_list|(
name|char
modifier|*
name|pidfile
parameter_list|,
name|int
name|inchroot
parameter_list|)
block|{
name|pid_t
name|old
decl_stmt|;
if|if
condition|(
operator|(
name|old
operator|=
name|readpid
argument_list|(
name|pidfile
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* see if it is still alive */
if|if
condition|(
name|kill
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EPERM
condition|)
name|log_warn
argument_list|(
literal|"unbound is already running as pid %u."
argument_list|,
operator|(
name|unsigned
operator|)
name|old
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inchroot
condition|)
name|log_warn
argument_list|(
literal|"did not exit gracefully last time (%u)"
argument_list|,
operator|(
name|unsigned
operator|)
name|old
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_KILL */
comment|/** detach from command line */
specifier|static
name|void
name|detach
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DAEMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEPRECATED_DAEMON
argument_list|)
comment|/* use POSIX daemon(3) function */
if|if
condition|(
name|daemon
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"daemon failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no HAVE_DAEMON */
ifdef|#
directive|ifdef
name|HAVE_FORK
name|int
name|fd
decl_stmt|;
comment|/* Take off... */
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
operator|-
literal|1
case|:
name|fatal_exit
argument_list|(
literal|"fork failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
default|default:
comment|/* exit interactive session */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* detach */
ifdef|#
directive|ifdef
name|HAVE_SETSID
if|if
condition|(
name|setsid
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|fatal_exit
argument_list|(
literal|"setsid() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_FORK */
endif|#
directive|endif
comment|/* HAVE_DAEMON */
block|}
comment|/** daemonize, drop user priviliges and chroot if needed */
specifier|static
name|void
name|perform_setup
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|int
name|debug_mode
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cfgfile
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETPWNAM
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
comment|/* initialize, but not to 0 (root) */
name|memset
argument_list|(
operator|&
name|uid
argument_list|,
literal|112
argument_list|,
sizeof|sizeof
argument_list|(
name|uid
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gid
argument_list|,
literal|112
argument_list|,
sizeof|sizeof
argument_list|(
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|username
operator|&&
name|cfg
operator|->
name|username
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|cfg
operator|->
name|username
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal_exit
argument_list|(
literal|"user '%s' does not exist."
argument_list|,
name|cfg
operator|->
name|username
argument_list|)
expr_stmt|;
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|gid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
comment|/* endpwent below, in case we need pwd for setusercontext */
block|}
endif|#
directive|endif
comment|/* init syslog (as root) if needed, before daemonize, otherwise 	 * a fork error could not be printed since daemonize closed stderr.*/
if|if
condition|(
name|cfg
operator|->
name|use_syslog
condition|)
block|{
name|log_init
argument_list|(
name|cfg
operator|->
name|logfile
argument_list|,
name|cfg
operator|->
name|use_syslog
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
block|}
comment|/* if using a logfile, we cannot open it because the logfile would 	 * be created with the wrong permissions, we cannot chown it because 	 * we cannot chown system logfiles, so we do not open at all. 	 * So, using a logfile, the user does not see errors unless -d is 	 * given to unbound on the commandline. */
comment|/* read ssl keys while superuser and outside chroot */
ifdef|#
directive|ifdef
name|HAVE_SSL
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|rc
operator|=
name|daemon_remote_create
argument_list|(
name|cfg
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not set up remote-control"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|ssl_service_key
operator|&&
name|cfg
operator|->
name|ssl_service_key
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|listen_sslctx
operator|=
name|listen_sslctx_create
argument_list|(
name|cfg
operator|->
name|ssl_service_key
argument_list|,
name|cfg
operator|->
name|ssl_service_pem
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not set up listen SSL_CTX"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|connect_sslctx
operator|=
name|connect_sslctx_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not set up connect SSL_CTX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_KILL
comment|/* check old pid file before forking */
if|if
condition|(
name|cfg
operator|->
name|pidfile
operator|&&
name|cfg
operator|->
name|pidfile
index|[
literal|0
index|]
condition|)
block|{
comment|/* calculate position of pidfile */
if|if
condition|(
name|cfg
operator|->
name|pidfile
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|daemon
operator|->
name|pidfile
operator|=
name|strdup
argument_list|(
name|cfg
operator|->
name|pidfile
argument_list|)
expr_stmt|;
else|else
name|daemon
operator|->
name|pidfile
operator|=
name|fname_after_chroot
argument_list|(
name|cfg
operator|->
name|pidfile
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|pidfile
condition|)
name|fatal_exit
argument_list|(
literal|"pidfile alloc: out of memory"
argument_list|)
expr_stmt|;
name|checkoldpid
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
comment|/* true if pidfile is inside chrootdir, or nochroot */
operator|!
operator|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* daemonize because pid is needed by the writepid func */
if|if
condition|(
operator|!
name|debug_mode
operator|&&
name|cfg
operator|->
name|do_daemonize
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
block|}
comment|/* write new pidfile (while still root, so can be outside chroot) */
ifdef|#
directive|ifdef
name|HAVE_KILL
if|if
condition|(
name|cfg
operator|->
name|pidfile
operator|&&
name|cfg
operator|->
name|pidfile
index|[
literal|0
index|]
condition|)
block|{
name|writepid
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* delete of pidfile could potentially work, 			 * chown to get permissions */
if|if
condition|(
name|cfg
operator|->
name|username
operator|&&
name|cfg
operator|->
name|username
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot chown %u.%u %s: %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|uid
argument_list|,
operator|(
name|unsigned
operator|)
name|gid
argument_list|,
name|daemon
operator|->
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|daemon
expr_stmt|;
endif|#
directive|endif
comment|/* Set user context */
ifdef|#
directive|ifdef
name|HAVE_GETPWNAM
if|if
condition|(
name|cfg
operator|->
name|username
operator|&&
name|cfg
operator|->
name|username
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SETUSERCONTEXT
comment|/* setusercontext does initgroups, setuid, setgid, and 		 * also resource limits from login config, but we 		 * still call setresuid, setresgid to be sure to set all uid*/
if|if
condition|(
name|setusercontext
argument_list|(
name|NULL
argument_list|,
name|pwd
argument_list|,
name|uid
argument_list|,
name|LOGIN_SETALL
operator|&
operator|~
name|LOGIN_SETUSER
operator|&
operator|~
name|LOGIN_SETGROUP
argument_list|)
operator|!=
literal|0
condition|)
name|log_warn
argument_list|(
literal|"unable to setusercontext %s: %s"
argument_list|,
name|cfg
operator|->
name|username
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SETUSERCONTEXT */
block|}
endif|#
directive|endif
comment|/* HAVE_GETPWNAM */
comment|/* box into the chroot */
ifdef|#
directive|ifdef
name|HAVE_CHROOT
if|if
condition|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"unable to chdir to chroot %s: %s"
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"chdir to %s"
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chroot
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"unable to chroot to %s: %s"
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"unable to chdir to / in chroot %s: %s"
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"chroot to %s"
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|cfgfile
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|(
operator|*
name|cfgfile
operator|)
operator|+=
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
comment|/* adjust stored pidfile for chroot */
if|if
condition|(
name|daemon
operator|->
name|pidfile
operator|&&
name|daemon
operator|->
name|pidfile
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|old
init|=
name|daemon
operator|->
name|pidfile
decl_stmt|;
name|daemon
operator|->
name|pidfile
operator|=
name|strdup
argument_list|(
name|old
operator|+
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|pidfile
condition|)
name|log_err
argument_list|(
literal|"out of memory in pidfile adjust"
argument_list|)
expr_stmt|;
block|}
name|daemon
operator|->
name|chroot
operator|=
name|strdup
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
operator|->
name|chroot
condition|)
name|log_err
argument_list|(
literal|"out of memory in daemon chroot dir storage"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|cfgfile
expr_stmt|;
endif|#
directive|endif
comment|/* change to working directory inside chroot */
if|if
condition|(
name|cfg
operator|->
name|directory
operator|&&
name|cfg
operator|->
name|directory
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|dir
init|=
name|cfg
operator|->
name|directory
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|chrootdir
operator|&&
name|cfg
operator|->
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|dir
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|dir
operator|+=
name|strlen
argument_list|(
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"Could not chdir to %s: %s"
argument_list|,
name|dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* drop permissions after chroot, getpwnam, pidfile, syslog done*/
ifdef|#
directive|ifdef
name|HAVE_GETPWNAM
if|if
condition|(
name|cfg
operator|->
name|username
operator|&&
name|cfg
operator|->
name|username
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_INITGROUPS
if|if
condition|(
name|initgroups
argument_list|(
name|cfg
operator|->
name|username
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
name|log_warn
argument_list|(
literal|"unable to initgroups %s: %s"
argument_list|,
name|cfg
operator|->
name|username
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_INITGROUPS */
name|endpwent
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETRESGID
if|if
condition|(
name|setresgid
argument_list|(
name|gid
argument_list|,
name|gid
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SETREGID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN_BROKEN_SETREUID
argument_list|)
if|if
condition|(
name|setregid
argument_list|(
name|gid
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
comment|/* use setgid */
if|if
condition|(
name|setgid
argument_list|(
name|gid
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
comment|/* HAVE_SETRESGID */
name|fatal_exit
argument_list|(
literal|"unable to set group id of %s: %s"
argument_list|,
name|cfg
operator|->
name|username
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETRESUID
if|if
condition|(
name|setresuid
argument_list|(
name|uid
argument_list|,
name|uid
argument_list|,
name|uid
argument_list|)
operator|!=
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SETREUID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DARWIN_BROKEN_SETREUID
argument_list|)
if|if
condition|(
name|setreuid
argument_list|(
name|uid
argument_list|,
name|uid
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
comment|/* use setuid */
if|if
condition|(
name|setuid
argument_list|(
name|uid
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
comment|/* HAVE_SETRESUID */
name|fatal_exit
argument_list|(
literal|"unable to set user id of %s: %s"
argument_list|,
name|cfg
operator|->
name|username
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"drop user privileges, run as %s"
argument_list|,
name|cfg
operator|->
name|username
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_GETPWNAM */
comment|/* file logging inited after chroot,chdir,setuid is done so that  	 * it would succeed on SIGHUP as well */
if|if
condition|(
operator|!
name|cfg
operator|->
name|use_syslog
condition|)
name|log_init
argument_list|(
name|cfg
operator|->
name|logfile
argument_list|,
name|cfg
operator|->
name|use_syslog
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
block|}
comment|/**  * Run the daemon.   * @param cfgfile: the config file name.  * @param cmdline_verbose: verbosity resulting from commandline -v.  *    These increase verbosity as specified in the config file.  * @param debug_mode: if set, do not daemonize.  */
specifier|static
name|void
name|run_daemon
parameter_list|(
specifier|const
name|char
modifier|*
name|cfgfile
parameter_list|,
name|int
name|cmdline_verbose
parameter_list|,
name|int
name|debug_mode
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|daemon
modifier|*
name|daemon
init|=
name|NULL
decl_stmt|;
name|int
name|done_setup
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|daemon
operator|=
name|daemon_init
argument_list|()
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"alloc failure"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|daemon
operator|->
name|need_to_exit
condition|)
block|{
if|if
condition|(
name|done_setup
condition|)
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"Restart of %s."
argument_list|,
name|PACKAGE_STRING
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"Start of %s."
argument_list|,
name|PACKAGE_STRING
argument_list|)
expr_stmt|;
comment|/* config stuff */
if|if
condition|(
operator|!
operator|(
name|cfg
operator|=
name|config_create
argument_list|()
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"Could not alloc config defaults"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_read
argument_list|(
name|cfg
argument_list|,
name|cfgfile
argument_list|,
name|daemon
operator|->
name|chroot
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|fatal_exit
argument_list|(
literal|"Could not read config file: %s"
argument_list|,
name|cfgfile
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"Continuing with default config settings"
argument_list|)
expr_stmt|;
block|}
name|apply_settings
argument_list|(
name|daemon
argument_list|,
name|cfg
argument_list|,
name|cmdline_verbose
argument_list|)
expr_stmt|;
comment|/* prepare */
if|if
condition|(
operator|!
name|daemon_open_shared_ports
argument_list|(
name|daemon
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not open ports"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done_setup
condition|)
block|{
name|perform_setup
argument_list|(
name|daemon
argument_list|,
name|cfg
argument_list|,
name|debug_mode
argument_list|,
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|done_setup
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* reopen log after HUP to facilitate log rotation */
if|if
condition|(
operator|!
name|cfg
operator|->
name|use_syslog
condition|)
name|log_init
argument_list|(
name|cfg
operator|->
name|logfile
argument_list|,
literal|0
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
block|}
comment|/* work */
name|daemon_fork
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
comment|/* clean up for restart */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cleanup."
argument_list|)
expr_stmt|;
name|daemon_cleanup
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|config_delete
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Exit cleanup."
argument_list|)
expr_stmt|;
comment|/* this unlink may not work if the pidfile is located outside 	 * of the chroot/workdir or we no longer have permissions */
if|if
condition|(
name|daemon
operator|->
name|pidfile
condition|)
block|{
name|int
name|fd
decl_stmt|;
comment|/* truncate pidfile */
name|fd
operator|=
name|open
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* delete pidfile */
name|unlink
argument_list|(
name|daemon
operator|->
name|pidfile
argument_list|)
expr_stmt|;
block|}
name|daemon_delete
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
block|}
comment|/** getopt global, in case header files fail to declare it. */
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/** getopt global, in case header files fail to declare it. */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/**  * main program. Set options given commandline arguments.  * @param argc: number of commandline arguments.  * @param argv: array of commandline arguments.  * @return: exit status of the program.  */
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfgfile
init|=
name|CONFIGFILE
decl_stmt|;
specifier|const
name|char
modifier|*
name|winopt
init|=
name|NULL
decl_stmt|;
name|int
name|cmdline_verbose
init|=
literal|0
decl_stmt|;
name|int
name|debug_mode
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|int
name|cmdline_cfg
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SBRK
comment|/* take debug snapshot of heap */
name|unbound_start_brk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* parse the options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:dhvw:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|cfgfile
operator|=
name|optarg
expr_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|cmdline_cfg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'v'
case|:
name|cmdline_verbose
operator|++
expr_stmt|;
name|verbosity
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|winopt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|winopt
condition|)
block|{
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|wsvc_command_option
argument_list|(
name|winopt
argument_list|,
name|cfgfile
argument_list|,
name|cmdline_verbose
argument_list|,
name|cmdline_cfg
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"option not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|run_daemon
argument_list|(
name|cfgfile
argument_list|,
name|cmdline_verbose
argument_list|,
name|debug_mode
argument_list|)
expr_stmt|;
name|log_init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* close logfile */
return|return
literal|0
return|;
block|}
end_function

end_unit

