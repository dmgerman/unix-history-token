begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * buffer.h -- generic memory buffer.  *  * Copyright (c) 2005-2008, NLnet Labs. All rights reserved.  *  * See LICENSE for the license.  *  *  * The buffer module implements a generic buffer.  The API is based on  * the java.nio.Buffer interface.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDNS_SBUFFER_H
end_ifndef

begin_define
define|#
directive|define
name|LDNS_SBUFFER_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_SPLINT_S
define|#
directive|define
name|INLINE
else|#
directive|else
ifdef|#
directive|ifdef
name|SWIG
define|#
directive|define
name|INLINE
value|static
else|#
directive|else
define|#
directive|define
name|INLINE
value|static inline
endif|#
directive|endif
endif|#
directive|endif
comment|/*  * Copy data allowing for unaligned accesses in network byte order  * (big endian).  */
name|INLINE
name|uint16_t
name|sldns_read_uint16
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
return|return
name|ntohs
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|src
argument_list|)
return|;
else|#
directive|else
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|src
decl_stmt|;
return|return
operator|(
operator|(
name|uint16_t
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint16_t
operator|)
name|p
index|[
literal|1
index|]
return|;
endif|#
directive|endif
block|}
name|INLINE
name|uint32_t
name|sldns_read_uint32
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
return|return
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|src
argument_list|)
return|;
else|#
directive|else
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|src
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|3
index|]
operator|)
return|;
endif|#
directive|endif
block|}
comment|/*  * Copy data allowing for unaligned accesses in network byte order  * (big endian).  */
name|INLINE
name|void
name|sldns_write_uint16
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|dst
operator|=
name|htons
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|INLINE
name|void
name|sldns_write_uint32
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UNALIGNED_ACCESSES
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|dst
operator|=
name|htonl
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/**  * \file sbuffer.h  *  * This file contains the definition of sldns_buffer, and functions to manipulate those.  */
comment|/**   * implementation of buffers to ease operations  *  * sldns_buffers can contain arbitrary information, per octet. You can write  * to the current end of a buffer, read from the current position, and  * access any data within it.  */
struct|struct
name|sldns_buffer
block|{
comment|/** The current position used for reading/writing */
name|size_t
name|_position
decl_stmt|;
comment|/** The read/write limit */
name|size_t
name|_limit
decl_stmt|;
comment|/** The amount of data the buffer can contain */
name|size_t
name|_capacity
decl_stmt|;
comment|/** The data contained in the buffer */
name|uint8_t
modifier|*
name|_data
decl_stmt|;
comment|/** If the buffer is fixed it cannot be resized */
name|unsigned
name|_fixed
range|:
literal|1
decl_stmt|;
comment|/** The current state of the buffer. If writing to the buffer fails 	 * for any reason, this value is changed. This way, you can perform 	 * multiple writes in sequence and check for success afterwards. */
name|unsigned
name|_status_err
range|:
literal|1
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|sldns_buffer
name|sldns_buffer
typedef|;
ifdef|#
directive|ifdef
name|NDEBUG
name|INLINE
name|void
name|sldns_buffer_invariant
parameter_list|(
name|sldns_buffer
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|buffer
parameter_list|)
parameter_list|)
block|{ }
else|#
directive|else
name|INLINE
name|void
name|sldns_buffer_invariant
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|assert
argument_list|(
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buffer
operator|->
name|_position
operator|<=
name|buffer
operator|->
name|_limit
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buffer
operator|->
name|_limit
operator|<=
name|buffer
operator|->
name|_capacity
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buffer
operator|->
name|_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/**  * creates a new buffer with the specified capacity.  *  * \param[in] capacity the size (in bytes) to allocate for the buffer  * \return the created buffer  */
name|sldns_buffer
modifier|*
name|sldns_buffer_new
parameter_list|(
name|size_t
name|capacity
parameter_list|)
function_decl|;
comment|/**  * creates a buffer with the specified data.  The data IS copied  * and MEMORY allocations are done.  The buffer is not fixed and can  * be resized using buffer_reserve().  *  * \param[in] buffer pointer to the buffer to put the data in  * \param[in] data the data to encapsulate in the buffer  * \param[in] size the size of the data  */
name|void
name|sldns_buffer_new_frm_data
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Setup a buffer with the data pointed to. No data copied, no memory allocs.  * The buffer is fixed.  * \param[in] buffer pointer to the buffer to put the data in  * \param[in] data the data to encapsulate in the buffer  * \param[in] size the size of the data  */
name|void
name|sldns_buffer_init_frm_data
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * clears the buffer and make it ready for writing.  The buffer's limit  * is set to the capacity and the position is set to 0.  * \param[in] buffer the buffer to clear  */
name|INLINE
name|void
name|sldns_buffer_clear
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|sldns_buffer_invariant
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* reset status here? */
name|buffer
operator|->
name|_position
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|_limit
operator|=
name|buffer
operator|->
name|_capacity
expr_stmt|;
block|}
comment|/**  * makes the buffer ready for reading the data that has been written to  * the buffer.  The buffer's limit is set to the current position and  * the position is set to 0.  *  * \param[in] buffer the buffer to flip  * \return void  */
name|INLINE
name|void
name|sldns_buffer_flip
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|sldns_buffer_invariant
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_limit
operator|=
name|buffer
operator|->
name|_position
expr_stmt|;
name|buffer
operator|->
name|_position
operator|=
literal|0
expr_stmt|;
block|}
comment|/**  * make the buffer ready for re-reading the data.  The buffer's  * position is reset to 0.  * \param[in] buffer the buffer to rewind  */
name|INLINE
name|void
name|sldns_buffer_rewind
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|sldns_buffer_invariant
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|=
literal|0
expr_stmt|;
block|}
comment|/**  * returns the current position in the buffer (as a number of bytes)  * \param[in] buffer the buffer  * \return the current position  */
name|INLINE
name|size_t
name|sldns_buffer_position
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|buffer
operator|->
name|_position
return|;
block|}
comment|/**  * sets the buffer's position to MARK.  The position must be less than  * or equal to the buffer's limit.  * \param[in] buffer the buffer  * \param[in] mark the mark to use  */
name|INLINE
name|void
name|sldns_buffer_set_position
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|mark
parameter_list|)
block|{
name|assert
argument_list|(
name|mark
operator|<=
name|buffer
operator|->
name|_limit
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|=
name|mark
expr_stmt|;
block|}
comment|/**  * changes the buffer's position by COUNT bytes.  The position must not  * be moved behind the buffer's limit or before the beginning of the  * buffer.  * \param[in] buffer the buffer  * \param[in] count the count to use  */
name|INLINE
name|void
name|sldns_buffer_skip
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|ssize_t
name|count
parameter_list|)
block|{
name|assert
argument_list|(
name|buffer
operator|->
name|_position
operator|+
name|count
operator|<=
name|buffer
operator|->
name|_limit
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|+=
name|count
expr_stmt|;
block|}
comment|/**  * returns the maximum size of the buffer  * \param[in] buffer  * \return the size  */
name|INLINE
name|size_t
name|sldns_buffer_limit
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|buffer
operator|->
name|_limit
return|;
block|}
comment|/**  * changes the buffer's limit.  If the buffer's position is greater  * than the new limit the position is set to the limit.  * \param[in] buffer the buffer  * \param[in] limit the new limit  */
name|INLINE
name|void
name|sldns_buffer_set_limit
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|assert
argument_list|(
name|limit
operator|<=
name|buffer
operator|->
name|_capacity
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_limit
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|_position
operator|>
name|buffer
operator|->
name|_limit
condition|)
name|buffer
operator|->
name|_position
operator|=
name|buffer
operator|->
name|_limit
expr_stmt|;
block|}
comment|/**  * returns the number of bytes the buffer can hold.  * \param[in] buffer the buffer  * \return the number of bytes  */
name|INLINE
name|size_t
name|sldns_buffer_capacity
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|buffer
operator|->
name|_capacity
return|;
block|}
comment|/**  * changes the buffer's capacity.  The data is reallocated so any  * pointers to the data may become invalid.  The buffer's limit is set  * to the buffer's new capacity.  * \param[in] buffer the buffer  * \param[in] capacity the capacity to use  * \return whether this failed or succeeded  */
name|int
name|sldns_buffer_set_capacity
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|capacity
parameter_list|)
function_decl|;
comment|/**  * ensures BUFFER can contain at least AMOUNT more bytes.  The buffer's  * capacity is increased if necessary using buffer_set_capacity().  *  * The buffer's limit is always set to the (possibly increased)  * capacity.  * \param[in] buffer the buffer  * \param[in] amount amount to use  * \return whether this failed or succeeded  */
name|int
name|sldns_buffer_reserve
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|amount
parameter_list|)
function_decl|;
comment|/**  * returns a pointer to the data at the indicated position.  * \param[in] buffer the buffer  * \param[in] at position  * \return the pointer to the data  */
name|INLINE
name|uint8_t
modifier|*
name|sldns_buffer_at
parameter_list|(
specifier|const
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|)
block|{
name|assert
argument_list|(
name|at
operator|<=
name|buffer
operator|->
name|_limit
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|->
name|_data
operator|+
name|at
return|;
block|}
comment|/**  * returns a pointer to the beginning of the buffer (the data at  * position 0).  * \param[in] buffer the buffer  * \return the pointer  */
name|INLINE
name|uint8_t
modifier|*
name|sldns_buffer_begin
parameter_list|(
specifier|const
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|sldns_buffer_at
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**  * returns a pointer to the end of the buffer (the data at the buffer's  * limit).  * \param[in] buffer the buffer  * \return the pointer  */
name|INLINE
name|uint8_t
modifier|*
name|sldns_buffer_end
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|sldns_buffer_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_limit
argument_list|)
return|;
block|}
comment|/**  * returns a pointer to the data at the buffer's current position.  * \param[in] buffer the buffer  * \return the pointer  */
name|INLINE
name|uint8_t
modifier|*
name|sldns_buffer_current
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|sldns_buffer_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|)
return|;
block|}
comment|/**  * returns the number of bytes remaining between the indicated position and  * the limit.  * \param[in] buffer the buffer  * \param[in] at indicated position  * \return number of bytes  */
name|INLINE
name|size_t
name|sldns_buffer_remaining_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|)
block|{
name|sldns_buffer_invariant
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|at
operator|<=
name|buffer
operator|->
name|_limit
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|->
name|_limit
operator|-
name|at
return|;
block|}
comment|/**  * returns the number of bytes remaining between the buffer's position and  * limit.  * \param[in] buffer the buffer  * \return the number of bytes  */
name|INLINE
name|size_t
name|sldns_buffer_remaining
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|sldns_buffer_remaining_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|)
return|;
block|}
comment|/**  * checks if the buffer has at least COUNT more bytes available.  * Before reading or writing the caller needs to ensure enough space  * is available!  * \param[in] buffer the buffer  * \param[in] at indicated position  * \param[in] count how much is available  * \return true or false (as int?)  */
name|INLINE
name|int
name|sldns_buffer_available_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
return|return
name|count
operator|<=
name|sldns_buffer_remaining_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|)
return|;
block|}
comment|/**  * checks if the buffer has count bytes available at the current position  * \param[in] buffer the buffer  * \param[in] count how much is available  * \return true or false (as int?)  */
name|INLINE
name|int
name|sldns_buffer_available
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
return|return
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
name|count
argument_list|)
return|;
block|}
comment|/**  * writes the given data to the buffer at the specified position  * \param[in] buffer the buffer  * \param[in] at the position (in number of bytes) to write the data at  * \param[in] data pointer to the data to write to the buffer  * \param[in] count the number of bytes of data to write  */
name|INLINE
name|void
name|sldns_buffer_write_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|->
name|_data
operator|+
name|at
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**  * writes count bytes of data to the current position of the buffer  * \param[in] buffer the buffer  * \param[in] data the data to write  * \param[in] count the lenght of the data to write  */
name|INLINE
name|void
name|sldns_buffer_write
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|sldns_buffer_write_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|+=
name|count
expr_stmt|;
block|}
comment|/**  * copies the given (null-delimited) string to the specified position at the buffer  * \param[in] buffer the buffer  * \param[in] at the position in the buffer  * \param[in] str the string to write  */
name|INLINE
name|void
name|sldns_buffer_write_string_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|sldns_buffer_write_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**  * copies the given (null-delimited) string to the current position at the buffer  * \param[in] buffer the buffer  * \param[in] str the string to write  */
name|INLINE
name|void
name|sldns_buffer_write_string
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|sldns_buffer_write
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**  * writes the given byte of data at the given position in the buffer  * \param[in] buffer the buffer  * \param[in] at the position in the buffer  * \param[in] data the 8 bits to write  */
name|INLINE
name|void
name|sldns_buffer_write_u8_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_data
index|[
name|at
index|]
operator|=
name|data
expr_stmt|;
block|}
comment|/**  * writes the given byte of data at the current position in the buffer  * \param[in] buffer the buffer  * \param[in] data the 8 bits to write  */
name|INLINE
name|void
name|sldns_buffer_write_u8
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
name|sldns_buffer_write_u8_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**  * writes the given 2 byte integer at the given position in the buffer  * \param[in] buffer the buffer  * \param[in] at the position in the buffer  * \param[in] data the 16 bits to write  */
name|INLINE
name|void
name|sldns_buffer_write_u16_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_write_uint16
argument_list|(
name|buffer
operator|->
name|_data
operator|+
name|at
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**  * writes the given 2 byte integer at the current position in the buffer  * \param[in] buffer the buffer  * \param[in] data the 16 bits to write  */
name|INLINE
name|void
name|sldns_buffer_write_u16
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|sldns_buffer_write_u16_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**  * writes the given 4 byte integer at the given position in the buffer  * \param[in] buffer the buffer  * \param[in] at the position in the buffer  * \param[in] data the 32 bits to write  */
name|INLINE
name|void
name|sldns_buffer_write_u32_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|buffer
operator|->
name|_data
operator|+
name|at
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**  * writes the given 4 byte integer at the current position in the buffer  * \param[in] buffer the buffer  * \param[in] data the 32 bits to write  */
name|INLINE
name|void
name|sldns_buffer_write_u32
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|sldns_buffer_write_u32_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**  * copies count bytes of data at the given position to the given data-array  * \param[in] buffer the buffer  * \param[in] at the position in the buffer to start  * \param[out] data buffer to copy to  * \param[in] count the length of the data to copy  */
name|INLINE
name|void
name|sldns_buffer_read_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|buffer
operator|->
name|_data
operator|+
name|at
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**  * copies count bytes of data at the current position to the given data-array  * \param[in] buffer the buffer  * \param[out] data buffer to copy to  * \param[in] count the length of the data to copy  */
name|INLINE
name|void
name|sldns_buffer_read
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|sldns_buffer_read_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|_position
operator|+=
name|count
expr_stmt|;
block|}
comment|/**  * returns the byte value at the given position in the buffer  * \param[in] buffer the buffer  * \param[in] at the position in the buffer  * \return 1 byte integer  */
name|INLINE
name|uint8_t
name|sldns_buffer_read_u8_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|->
name|_data
index|[
name|at
index|]
return|;
block|}
comment|/**  * returns the byte value at the current position in the buffer  * \param[in] buffer the buffer  * \return 1 byte integer  */
name|INLINE
name|uint8_t
name|sldns_buffer_read_u8
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|uint8_t
name|result
init|=
name|sldns_buffer_read_u8_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**  * returns the 2-byte integer value at the given position in the buffer  * \param[in] buffer the buffer  * \param[in] at position in the buffer  * \return 2 byte integer  */
name|INLINE
name|uint16_t
name|sldns_buffer_read_u16_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sldns_read_uint16
argument_list|(
name|buffer
operator|->
name|_data
operator|+
name|at
argument_list|)
return|;
block|}
comment|/**  * returns the 2-byte integer value at the current position in the buffer  * \param[in] buffer the buffer  * \return 2 byte integer  */
name|INLINE
name|uint16_t
name|sldns_buffer_read_u16
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|uint16_t
name|result
init|=
name|sldns_buffer_read_u16_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**  * returns the 4-byte integer value at the given position in the buffer  * \param[in] buffer the buffer  * \param[in] at position in the buffer  * \return 4 byte integer  */
name|INLINE
name|uint32_t
name|sldns_buffer_read_u32_at
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|size_t
name|at
parameter_list|)
block|{
name|assert
argument_list|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sldns_read_uint32
argument_list|(
name|buffer
operator|->
name|_data
operator|+
name|at
argument_list|)
return|;
block|}
comment|/**  * returns the 4-byte integer value at the current position in the buffer  * \param[in] buffer the buffer  * \return 4 byte integer  */
name|INLINE
name|uint32_t
name|sldns_buffer_read_u32
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
name|uint32_t
name|result
init|=
name|sldns_buffer_read_u32_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**  * returns the status of the buffer  * \param[in] buffer  * \return the status  */
name|INLINE
name|int
name|sldns_buffer_status
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|buffer
operator|->
name|_status_err
return|;
block|}
comment|/**  * returns true if the status of the buffer is LDNS_STATUS_OK, false otherwise  * \param[in] buffer the buffer  * \return true or false  */
name|INLINE
name|int
name|sldns_buffer_status_ok
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|buffer
condition|)
block|{
return|return
name|sldns_buffer_status
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**  * prints to the buffer, increasing the capacity if required using  * buffer_reserve(). The buffer's position is set to the terminating '\\0'  * Returns the number of characters written (not including the  * terminating '\\0') or -1 on failure.  */
name|int
name|sldns_buffer_printf
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
block|)
empty_stmt|;
end_extern

begin_comment
comment|/**  * frees the buffer.  * \param[in] *buffer the buffer to be freed  * \return void  */
end_comment

begin_function_decl
name|void
name|sldns_buffer_free
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Makes the buffer fixed and returns a pointer to the data.  The  * caller is responsible for free'ing the result.  * \param[in] *buffer the buffer to be exported  * \return void  */
end_comment

begin_function_decl
name|void
modifier|*
name|sldns_buffer_export
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Copy contents of the from buffer to the result buffer and then flips   * the result buffer. Data will be silently truncated if the result buffer is  * too small.  * \param[out] *result resulting buffer which is copied to.  * \param[in] *from what to copy to result.  */
end_comment

begin_function_decl
name|void
name|sldns_buffer_copy
parameter_list|(
name|sldns_buffer
modifier|*
name|result
parameter_list|,
name|sldns_buffer
modifier|*
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDNS_SBUFFER_H */
end_comment

end_unit

