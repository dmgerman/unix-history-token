begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * keyraw.c - raw key operations and conversions  *  * (c) NLnet Labs, 2004-2008  *  * See the file LICENSE for the license  */
end_comment

begin_comment
comment|/**  * \file  * Implementation of raw DNSKEY functions (work on wire rdata).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ldns/keyraw.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ENGINE_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_function
name|size_t
name|sldns_rr_dnskey_key_size_raw
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|keydata
parameter_list|,
specifier|const
name|size_t
name|len
parameter_list|,
name|int
name|alg
parameter_list|)
block|{
comment|/* for DSA keys */
name|uint8_t
name|t
decl_stmt|;
comment|/* for RSA keys */
name|uint16_t
name|exp
decl_stmt|;
name|uint16_t
name|int16
decl_stmt|;
switch|switch
condition|(
operator|(
name|sldns_algorithm
operator|)
name|alg
condition|)
block|{
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|keydata
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|64
operator|+
name|t
operator|*
literal|8
operator|)
operator|*
literal|8
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
name|LDNS_RSAMD5
case|:
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|keydata
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* big exponent */
if|if
condition|(
name|len
operator|>
literal|3
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|int16
argument_list|,
name|keydata
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ntohs
argument_list|(
name|int16
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|-
name|exp
operator|-
literal|3
operator|)
operator|*
literal|8
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|exp
operator|=
name|keydata
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|len
operator|-
name|exp
operator|-
literal|1
operator|)
operator|*
literal|8
return|;
block|}
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_ECC_GOST
case|:
return|return
literal|512
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
return|return
literal|256
return|;
case|case
name|LDNS_ECDSAP384SHA384
case|:
return|return
literal|384
return|;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|uint16_t
name|sldns_calc_keytag_raw
parameter_list|(
name|uint8_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keysize
parameter_list|)
block|{
if|if
condition|(
name|keysize
operator|<
literal|4
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* look at the algorithm field, copied from 2535bis */
if|if
condition|(
name|key
index|[
literal|3
index|]
operator|==
name|LDNS_RSAMD5
condition|)
block|{
name|uint16_t
name|ac16
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|keysize
operator|>
literal|4
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|ac16
argument_list|,
name|key
operator|+
name|keysize
operator|-
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|ac16
operator|=
name|ntohs
argument_list|(
name|ac16
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|ac16
return|;
block|}
else|else
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|ac32
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keysize
condition|;
operator|++
name|i
control|)
block|{
name|ac32
operator|+=
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
name|key
index|[
name|i
index|]
else|:
name|key
index|[
name|i
index|]
operator|<<
literal|8
expr_stmt|;
block|}
name|ac32
operator|+=
operator|(
name|ac32
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
return|return
call|(
name|uint16_t
call|)
argument_list|(
name|ac32
operator|&
literal|0xFFFF
argument_list|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_GOST
end_ifdef

begin_comment
comment|/** store GOST engine reference loaded into OpenSSL library */
end_comment

begin_decl_stmt
name|ENGINE
modifier|*
name|sldns_gost_engine
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sldns_key_EVP_load_gost_id
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|gost_id
init|=
literal|0
decl_stmt|;
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|meth
decl_stmt|;
name|ENGINE
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|gost_id
condition|)
return|return
name|gost_id
return|;
comment|/* see if configuration loaded gost implementation from other engine*/
name|meth
operator|=
name|EVP_PKEY_asn1_find_str
argument_list|(
name|NULL
argument_list|,
literal|"gost2001"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|meth
condition|)
block|{
name|EVP_PKEY_asn1_get0_info
argument_list|(
operator|&
name|gost_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|meth
argument_list|)
expr_stmt|;
return|return
name|gost_id
return|;
block|}
comment|/* see if engine can be loaded already */
name|e
operator|=
name|ENGINE_by_id
argument_list|(
literal|"gost"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* load it ourself, in case statically linked */
name|ENGINE_load_builtin_engines
argument_list|()
expr_stmt|;
name|ENGINE_load_dynamic
argument_list|()
expr_stmt|;
name|e
operator|=
name|ENGINE_by_id
argument_list|(
literal|"gost"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* no gost engine in openssl */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ENGINE_set_default
argument_list|(
name|e
argument_list|,
name|ENGINE_METHOD_ALL
argument_list|)
condition|)
block|{
name|ENGINE_finish
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|meth
operator|=
name|EVP_PKEY_asn1_find_str
argument_list|(
operator|&
name|e
argument_list|,
literal|"gost2001"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|meth
condition|)
block|{
comment|/* algo not found */
name|ENGINE_finish
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Note: do not ENGINE_finish and ENGINE_free the acquired engine          * on some platforms this frees up the meth and unloads gost stuff */
name|sldns_gost_engine
operator|=
name|e
expr_stmt|;
name|EVP_PKEY_asn1_get0_info
argument_list|(
operator|&
name|gost_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|meth
argument_list|)
expr_stmt|;
return|return
name|gost_id
return|;
block|}
end_function

begin_function
name|void
name|sldns_key_EVP_unload_gost
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sldns_gost_engine
condition|)
block|{
name|ENGINE_finish
argument_list|(
name|sldns_gost_engine
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|sldns_gost_engine
argument_list|)
expr_stmt|;
name|sldns_gost_engine
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_GOST */
end_comment

begin_function
name|DSA
modifier|*
name|sldns_key_buf2dsa_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint8_t
name|T
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|DSA
modifier|*
name|dsa
decl_stmt|;
name|BIGNUM
modifier|*
name|Q
decl_stmt|;
name|BIGNUM
modifier|*
name|P
decl_stmt|;
name|BIGNUM
modifier|*
name|G
decl_stmt|;
name|BIGNUM
modifier|*
name|Y
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|T
operator|=
operator|(
name|uint8_t
operator|)
name|key
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
operator|(
literal|64
operator|+
name|T
operator|*
literal|8
operator|)
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|T
operator|>
literal|8
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
literal|1
operator|+
name|SHA_DIGEST_LENGTH
operator|+
literal|3
operator|*
name|length
condition|)
return|return
name|NULL
return|;
name|Q
operator|=
name|BN_bin2bn
argument_list|(
name|key
operator|+
name|offset
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SHA_DIGEST_LENGTH
expr_stmt|;
name|P
operator|=
name|BN_bin2bn
argument_list|(
name|key
operator|+
name|offset
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|G
operator|=
name|BN_bin2bn
argument_list|(
name|key
operator|+
name|offset
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|Y
operator|=
name|BN_bin2bn
argument_list|(
name|key
operator|+
name|offset
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
comment|/* create the key and set its properties */
if|if
condition|(
operator|!
name|Q
operator|||
operator|!
name|P
operator|||
operator|!
name|G
operator|||
operator|!
name|Y
operator|||
operator|!
operator|(
name|dsa
operator|=
name|DSA_new
argument_list|()
operator|)
condition|)
block|{
name|BN_free
argument_list|(
name|Q
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|P
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|G
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|Y
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|dsa
operator|->
name|p
operator|=
name|P
expr_stmt|;
name|dsa
operator|->
name|q
operator|=
name|Q
expr_stmt|;
name|dsa
operator|->
name|g
operator|=
name|G
expr_stmt|;
name|dsa
operator|->
name|pub_key
operator|=
name|Y
expr_stmt|;
endif|#
directive|endif
comment|/* splint */
return|return
name|dsa
return|;
block|}
end_function

begin_function
name|RSA
modifier|*
name|sldns_key_buf2rsa_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|exp
decl_stmt|;
name|uint16_t
name|int16
decl_stmt|;
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|BIGNUM
modifier|*
name|modulus
decl_stmt|;
name|BIGNUM
modifier|*
name|exponent
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
name|NULL
return|;
name|memmove
argument_list|(
operator|&
name|int16
argument_list|,
name|key
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ntohs
argument_list|(
name|int16
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* key length at least one */
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|offset
operator|+
name|exp
operator|+
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* Exponent */
name|exponent
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exponent
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|BN_bin2bn
argument_list|(
name|key
operator|+
name|offset
argument_list|,
operator|(
name|int
operator|)
name|exp
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|exp
expr_stmt|;
comment|/* Modulus */
name|modulus
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|modulus
condition|)
block|{
name|BN_free
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* length of the buffer must match the key length! */
operator|(
name|void
operator|)
name|BN_bin2bn
argument_list|(
name|key
operator|+
name|offset
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|offset
argument_list|)
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|RSA_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rsa
condition|)
block|{
name|BN_free
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|modulus
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|rsa
operator|->
name|n
operator|=
name|modulus
expr_stmt|;
name|rsa
operator|->
name|e
operator|=
name|exponent
expr_stmt|;
endif|#
directive|endif
comment|/* splint */
return|return
name|rsa
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_GOST
end_ifdef

begin_function
name|EVP_PKEY
modifier|*
name|sldns_gost2pkey_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|)
block|{
comment|/* prefix header for X509 encoding */
name|uint8_t
name|asn
index|[
literal|37
index|]
init|=
block|{
literal|0x30
block|,
literal|0x63
block|,
literal|0x30
block|,
literal|0x1c
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x13
block|,
literal|0x30
block|,
literal|0x12
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x23
block|,
literal|0x01
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x1e
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x43
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x40
block|}
decl_stmt|;
name|unsigned
name|char
name|encoded
index|[
literal|37
operator|+
literal|64
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|keylen
operator|!=
literal|64
condition|)
block|{
comment|/* key wrong size */
return|return
name|NULL
return|;
block|}
comment|/* create evp_key */
name|memmove
argument_list|(
name|encoded
argument_list|,
name|asn
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|encoded
operator|+
literal|37
argument_list|,
name|key
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|encoded
index|[
literal|0
index|]
expr_stmt|;
return|return
name|d2i_PUBKEY
argument_list|(
name|NULL
argument_list|,
operator|&
name|pp
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|encoded
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_GOST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA
end_ifdef

begin_function
name|EVP_PKEY
modifier|*
name|sldns_ecdsa2pkey_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|,
name|uint8_t
name|algo
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|256
operator|+
literal|2
index|]
decl_stmt|;
comment|/* sufficient for 2*384/8+1 */
specifier|const
name|unsigned
name|char
modifier|*
name|pp
init|=
name|buf
decl_stmt|;
name|EVP_PKEY
modifier|*
name|evp_key
decl_stmt|;
name|EC_KEY
modifier|*
name|ec
decl_stmt|;
comment|/* check length, which uncompressed must be 2 bignums */
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
condition|)
block|{
if|if
condition|(
name|keylen
operator|!=
literal|2
operator|*
literal|256
operator|/
literal|8
condition|)
return|return
name|NULL
return|;
name|ec
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|NID_X9_62_prime256v1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP384SHA384
condition|)
block|{
if|if
condition|(
name|keylen
operator|!=
literal|2
operator|*
literal|384
operator|/
literal|8
condition|)
return|return
name|NULL
return|;
name|ec
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|NID_secp384r1
argument_list|)
expr_stmt|;
block|}
else|else
name|ec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ec
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|keylen
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* sanity check */
comment|/* prepend the 0x02 (from docs) (or actually 0x04 from implementation 	 * of openssl) for uncompressed data */
name|buf
index|[
literal|0
index|]
operator|=
name|POINT_CONVERSION_UNCOMPRESSED
expr_stmt|;
name|memmove
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o2i_ECPublicKey
argument_list|(
operator|&
name|ec
argument_list|,
operator|&
name|pp
argument_list|,
operator|(
name|int
operator|)
name|keylen
operator|+
literal|1
argument_list|)
condition|)
block|{
name|EC_KEY_free
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|evp_key
condition|)
block|{
name|EC_KEY_free
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|EVP_PKEY_assign_EC_KEY
argument_list|(
name|evp_key
argument_list|,
name|ec
argument_list|)
condition|)
block|{
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
name|EC_KEY_free
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|evp_key
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ECDSA */
end_comment

begin_function
name|int
name|sldns_digest_evp
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|)
block|{
name|EVP_MD_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|EVP_MD_CTX_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|EVP_DigestInit_ex
argument_list|(
name|ctx
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|EVP_DigestUpdate
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
operator|||
operator|!
name|EVP_DigestFinal_ex
argument_list|(
name|ctx
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|EVP_MD_CTX_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|EVP_MD_CTX_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

end_unit

