begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * checkconf/unbound-host.c - replacement for host that supports validation.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file performs functionality like 'host', and also supports validation.  * It uses the libunbound library.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* remove alloc checks, not in this part of the code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_STATS
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_LITE
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_undef
undef|#
directive|undef
name|strdup
end_undef

begin_define
define|#
directive|define
name|unbound_lite_wrapstr
parameter_list|(
name|s
parameter_list|)
value|s
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libunbound/unbound.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS
end_ifdef

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"nss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** verbosity for unbound-host app */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Give unbound-host usage, and exit (1). */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage:	unbound-host [-vdhr46] [-c class] [-t type] hostname\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                     [-y key] [-f keyfile] [-F namedkeyfile]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                     [-C configfile]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Queries the DNS for information.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  The hostname is looked up for IP4, IP6 and mail.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  If an ip-address is given a reverse lookup is done.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Use the -v option to see DNSSEC security information.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -t type		what type to look for.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -c class		what class to look for, if not class IN.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -y 'keystring'	specify trust anchor, DS or DNSKEY, like\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"			-y 'example.com DS 31560 5 1 1CFED8478...'\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -f keyfile		read trust anchors from file, with lines as -y.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -F keyfile		read named.conf-style trust anchors.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -C config		use the specified unbound.conf (none read by default)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -r			read forwarder information from /etc/resolv.conf\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      			breaks validation if the fwder does not do DNSSEC.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -v			be more verbose, shows nodata and security.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -d			debug, traces the action, -d -d shows more.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -4			use ipv4 network, avoid ipv6.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -6			use ipv6 network, avoid ipv4.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -h			show this usage help.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BSD licensed, see LICENSE in source package for details.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Report bugs to %s\n"
argument_list|,
name|PACKAGE_BUGREPORT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** determine if str is ip4 and put into reverse lookup format */
end_comment

begin_function
specifier|static
name|int
name|isip4
parameter_list|(
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|char
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* ddd.ddd.ddd.ddd.in-addr.arpa. is less than 32 */
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|nm
argument_list|,
operator|&
name|addr
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%u.%u.%u.%u.in-addr.arpa"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
index|[
literal|3
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
index|[
literal|2
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
index|[
literal|1
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** determine if str is ip6 and put into reverse lookup format */
end_comment

begin_function
specifier|static
name|int
name|isip6
parameter_list|(
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|char
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|in6_addr
name|addr
decl_stmt|;
comment|/* [nibble.]{32}.ip6.arpa. is less than 128 */
specifier|const
name|char
modifier|*
name|hex
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|nm
argument_list|,
operator|&
name|addr
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|uint8_t
name|b
init|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr
operator|)
index|[
name|i
index|]
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|hex
index|[
operator|(
name|b
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hex
index|[
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
operator|+
literal|16
operator|*
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|16
operator|*
literal|4
argument_list|,
literal|"ip6.arpa"
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|res
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** massage input name */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|massage_qname
parameter_list|(
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
modifier|*
name|reverse
parameter_list|)
block|{
comment|/* recognise IP4 and IP6, create reverse addresses if needed */
name|char
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|isip4
argument_list|(
name|nm
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
operator|*
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isip6
argument_list|(
name|nm
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
operator|*
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|strdup
argument_list|(
name|nm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/** massage input type */
end_comment

begin_function
specifier|static
name|int
name|massage_type
parameter_list|(
specifier|const
name|char
modifier|*
name|t
parameter_list|,
name|int
name|reverse
parameter_list|,
name|int
modifier|*
name|multi
parameter_list|)
block|{
if|if
condition|(
name|t
condition|)
block|{
name|int
name|r
init|=
name|sldns_get_rr_type_by_name
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|t
argument_list|,
literal|"TYPE0"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|t
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error unknown type %s\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
if|if
condition|(
operator|!
name|t
operator|&&
name|reverse
condition|)
return|return
name|LDNS_RR_TYPE_PTR
return|;
operator|*
name|multi
operator|=
literal|1
expr_stmt|;
return|return
name|LDNS_RR_TYPE_A
return|;
block|}
end_function

begin_comment
comment|/** massage input class */
end_comment

begin_function
specifier|static
name|int
name|massage_class
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
condition|)
block|{
name|int
name|r
init|=
name|sldns_get_rr_class_by_name
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|c
argument_list|,
literal|"CLASS0"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|c
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error unknown class %s\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
return|return
name|LDNS_RR_CLASS_IN
return|;
block|}
end_function

begin_comment
comment|/** nice security status string */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|secure_str
parameter_list|(
name|struct
name|ub_result
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|->
name|secure
condition|)
return|return
literal|"(secure)"
return|;
if|if
condition|(
name|result
operator|->
name|bogus
condition|)
return|return
literal|"(BOGUS (security failure))"
return|;
return|return
literal|"(insecure)"
return|;
block|}
end_function

begin_comment
comment|/** nice string for type */
end_comment

begin_function
specifier|static
name|void
name|pretty_type
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|char
name|d
index|[
literal|16
index|]
decl_stmt|;
name|sldns_wire2str_type_buf
argument_list|(
operator|(
name|uint16_t
operator|)
name|t
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** nice string for class */
end_comment

begin_function
specifier|static
name|void
name|pretty_class
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
name|d
index|[
literal|16
index|]
decl_stmt|;
name|sldns_wire2str_class_buf
argument_list|(
operator|(
name|uint16_t
operator|)
name|c
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** nice string for rcode */
end_comment

begin_function
specifier|static
name|void
name|pretty_rcode
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|char
name|d
index|[
literal|16
index|]
decl_stmt|;
name|sldns_wire2str_rcode_buf
argument_list|(
name|r
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** convert and print rdata */
end_comment

begin_function
specifier|static
name|void
name|print_rd
parameter_list|(
name|int
name|t
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|s
index|[
literal|65535
index|]
decl_stmt|;
name|sldns_wire2str_rdata_buf
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|uint16_t
operator|)
name|t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** pretty line of RR data for results */
end_comment

begin_function
specifier|static
name|void
name|pretty_rdata
parameter_list|(
name|char
modifier|*
name|q
parameter_list|,
name|char
modifier|*
name|cstr
parameter_list|,
name|char
modifier|*
name|tstr
parameter_list|,
name|int
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cstr
argument_list|,
literal|"IN"
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" in class %s"
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_A
condition|)
name|printf
argument_list|(
literal|" has address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
name|printf
argument_list|(
literal|" has IPv6 address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_MX
condition|)
name|printf
argument_list|(
literal|" mail is handled by"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_PTR
condition|)
name|printf
argument_list|(
literal|" domain name pointer"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" has %s record"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
name|print_rd
argument_list|(
name|t
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** pretty line of output for results */
end_comment

begin_function
specifier|static
name|void
name|pretty_output
parameter_list|(
name|char
modifier|*
name|q
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|c
parameter_list|,
name|struct
name|ub_result
modifier|*
name|result
parameter_list|,
name|int
name|docname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|secstatus
init|=
name|secure_str
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|char
name|tstr
index|[
literal|16
index|]
decl_stmt|;
name|char
name|cstr
index|[
literal|16
index|]
decl_stmt|;
name|char
name|rcodestr
index|[
literal|16
index|]
decl_stmt|;
name|pretty_type
argument_list|(
name|tstr
argument_list|,
literal|16
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pretty_class
argument_list|(
name|cstr
argument_list|,
literal|16
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pretty_rcode
argument_list|(
name|rcodestr
argument_list|,
literal|16
argument_list|,
name|result
operator|->
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|->
name|havedata
operator|&&
name|result
operator|->
name|rcode
condition|)
block|{
name|printf
argument_list|(
literal|"Host %s not found: %d(%s)."
argument_list|,
name|q
argument_list|,
name|result
operator|->
name|rcode
argument_list|,
name|rcodestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|secstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|bogus
operator|&&
name|result
operator|->
name|why_bogus
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
operator|->
name|why_bogus
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|docname
operator|&&
name|result
operator|->
name|canonname
operator|&&
name|result
operator|->
name|canonname
operator|!=
name|result
operator|->
name|qname
condition|)
block|{
name|printf
argument_list|(
literal|"%s is an alias for %s"
argument_list|,
name|result
operator|->
name|qname
argument_list|,
name|result
operator|->
name|canonname
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|secstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* remove trailing . from long canonnames for nicer output */
if|if
condition|(
name|result
operator|->
name|canonname
operator|&&
name|strlen
argument_list|(
name|result
operator|->
name|canonname
argument_list|)
operator|>
literal|1
operator|&&
name|result
operator|->
name|canonname
index|[
name|strlen
argument_list|(
name|result
operator|->
name|canonname
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|result
operator|->
name|canonname
index|[
name|strlen
argument_list|(
name|result
operator|->
name|canonname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|->
name|havedata
condition|)
block|{
if|if
condition|(
name|verb
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|result
operator|->
name|canonname
condition|?
name|result
operator|->
name|canonname
else|:
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cstr
argument_list|,
literal|"IN"
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" in class %s"
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_A
condition|)
name|printf
argument_list|(
literal|" has no address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
name|printf
argument_list|(
literal|" has no IPv6 address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_PTR
condition|)
name|printf
argument_list|(
literal|" has no domain name ptr"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_MX
condition|)
name|printf
argument_list|(
literal|" has no mail handler record"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|sldns_wire2str_pkt
argument_list|(
name|result
operator|->
name|answer_packet
argument_list|,
operator|(
name|size_t
operator|)
name|result
operator|->
name|answer_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alloc failure\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" has no %s record"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|secstatus
argument_list|)
expr_stmt|;
block|}
comment|/* else: emptiness to indicate no data */
if|if
condition|(
name|result
operator|->
name|bogus
operator|&&
name|result
operator|->
name|why_bogus
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
operator|->
name|why_bogus
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|result
operator|->
name|data
index|[
name|i
index|]
condition|)
block|{
name|pretty_rdata
argument_list|(
name|result
operator|->
name|canonname
condition|?
name|result
operator|->
name|canonname
else|:
name|q
argument_list|,
name|cstr
argument_list|,
name|tstr
argument_list|,
name|t
argument_list|,
name|secstatus
argument_list|,
name|result
operator|->
name|data
index|[
name|i
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|result
operator|->
name|len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|->
name|bogus
operator|&&
name|result
operator|->
name|why_bogus
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
operator|->
name|why_bogus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** perform a lookup and printout return if domain existed */
end_comment

begin_function
specifier|static
name|int
name|dnslook
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|q
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|docname
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|ub_result
modifier|*
name|result
decl_stmt|;
name|ret
operator|=
name|ub_resolve
argument_list|(
name|ctx
argument_list|,
name|q
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"resolve error: %s\n"
argument_list|,
name|ub_strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pretty_output
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
name|result
argument_list|,
name|docname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|result
operator|->
name|nxdomain
expr_stmt|;
name|ub_resolve_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/** perform host lookup */
end_comment

begin_function
specifier|static
name|void
name|lookup
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
specifier|const
name|char
modifier|*
name|qt
parameter_list|,
specifier|const
name|char
modifier|*
name|qc
parameter_list|)
block|{
comment|/* massage input into a query name, type and class */
name|int
name|multi
init|=
literal|0
decl_stmt|;
comment|/* no type, so do A, AAAA, MX */
name|int
name|reverse
init|=
literal|0
decl_stmt|;
comment|/* we are doing a reverse lookup */
name|char
modifier|*
name|realq
init|=
name|massage_qname
argument_list|(
name|nm
argument_list|,
operator|&
name|reverse
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|massage_type
argument_list|(
name|qt
argument_list|,
name|reverse
argument_list|,
operator|&
name|multi
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|massage_class
argument_list|(
name|qc
argument_list|)
decl_stmt|;
comment|/* perform the query */
if|if
condition|(
name|multi
condition|)
block|{
if|if
condition|(
operator|!
name|dnslook
argument_list|(
name|ctx
argument_list|,
name|realq
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* domain exists, lookup more */
operator|(
name|void
operator|)
name|dnslook
argument_list|(
name|ctx
argument_list|,
name|realq
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dnslook
argument_list|(
name|ctx
argument_list|,
name|realq
argument_list|,
name|LDNS_RR_TYPE_MX
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dnslook
argument_list|(
name|ctx
argument_list|,
name|realq
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|realq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** print error if any */
end_comment

begin_function
specifier|static
name|void
name|check_ub_res
parameter_list|(
name|int
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: %s\n"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Main routine for checkconf */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|qclass
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|qtype
init|=
name|NULL
decl_stmt|;
name|struct
name|ub_ctx
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|int
name|debuglevel
init|=
literal|0
decl_stmt|;
name|ctx
operator|=
name|ub_ctx_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* parse the options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46F:c:df:hrt:vy:C:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'4'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"do-ip6:"
argument_list|,
literal|"no"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"do-ip4:"
argument_list|,
literal|"no"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|qclass
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_config
argument_list|(
name|ctx
argument_list|,
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debuglevel
operator|++
expr_stmt|;
if|if
condition|(
name|debuglevel
operator|<
literal|2
condition|)
name|debuglevel
operator|=
literal|2
expr_stmt|;
comment|/* at least VERB_DETAIL */
break|break;
case|case
literal|'r'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_resolvconf
argument_list|(
name|ctx
argument_list|,
literal|"/etc/resolv.conf"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|qtype
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verb
operator|++
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_add_ta
argument_list|(
name|ctx
argument_list|,
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_add_ta_file
argument_list|(
name|ctx
argument_list|,
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|check_ub_res
argument_list|(
name|ub_ctx_trustedkeys
argument_list|(
name|ctx
argument_list|,
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debuglevel
operator|!=
literal|0
condition|)
comment|/* set after possible -C options */
name|check_ub_res
argument_list|(
name|ub_ctx_debuglevel
argument_list|(
name|ctx
argument_list|,
name|debuglevel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ub_ctx_get_option
argument_list|(
name|ctx
argument_list|,
literal|"use-syslog"
argument_list|,
operator|&
name|optarg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
comment|/* disable use-syslog */
name|check_ub_res
argument_list|(
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"use-syslog:"
argument_list|,
literal|"no"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NSS
if|if
condition|(
name|NSS_NoDB_Init
argument_list|(
literal|"."
argument_list|)
operator|!=
name|SECSuccess
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not init NSS\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
name|lookup
argument_list|(
name|ctx
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

