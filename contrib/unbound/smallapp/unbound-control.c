begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * checkconf/unbound-control.c - remote control utility for unbound.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * The remote control utility contacts the unbound server over ssl and  * sends the command, receives the answer, and displays the result  * from the commandline.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_SSL_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_RAND_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/locks.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** Give unbound-control usage, and exit (1). */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage:	unbound-control [options] command\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	Remote control utility for unbound server.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -c file	config file, default is %s\n"
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -s ip[@port]	server address, if omitted config is used.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -q		quiet (don't print anything if it works ok).\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -h		show this usage help.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Commands:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  start				start server; runs unbound(8)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stop				stops the server\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  reload			reloads the server\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  				(this flushes data, stats, requestlist)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stats				print statistics\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stats_noreset			peek at statistics\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  status			display status of server\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  verbosity<number>		change logging detail\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  log_reopen			close and open the logfile\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  local_zone<name><type>	add new local zone\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  local_zone_remove<name>	remove local zone and its contents\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  local_data<RR data...>	add local data, for example\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"				local_data www.example.com A 192.0.2.1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  local_data_remove<name>	remove local RR data from name\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  dump_cache			print cache to stdout\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  load_cache			load cache from stdin\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  lookup<name>			print nameservers for name\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush<name>			flushes common types for name from cache\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  				types:  A, AAAA, MX, PTR, NS,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"					SOA, CNAME, DNAME, SRV, NAPTR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_type<name><type>	flush name, type from cache\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_zone<name>		flush everything at or under name\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  				from rr and dnssec caches\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_bogus			flush all bogus data\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_negative		flush all negative data\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_stats 			flush statistics, make zero\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_requestlist 		drop queries that are worked on\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  dump_requestlist		show what is worked on by first thread\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flush_infra [all | ip] 	remove ping, edns for one IP or all\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  dump_infra			show ping and edns entries\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  set_option opt: val		set option to value, no reload\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  get_option opt		get option value\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  list_stubs			list stub-zones and root hints in use\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  list_forwards			list forward-zones in use\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  list_insecure			list domain-insecure zones\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  list_local_zones		list local-zones in use\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  list_local_data		list local-data RRs in use\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  insecure_add zone 		add domain-insecure zone\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  insecure_remove zone		remove domain-insecure zone\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  forward_add [+i] zone addr..	add forward-zone with servers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  forward_remove [+i] zone	remove forward zone\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stub_add [+ip] zone addr..	add stub-zone with servers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stub_remove [+i] zone		remove stub zone\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		+i		also do dnssec insecure point\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		+p		set stub to use priming\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  forward [off | addr ...]	without arg show forward setup\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"				or off to turn off root forwarding\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"				or give list of ip addresses\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ratelimit_list [+a]		list ratelimited domains\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		+a		list all, also not ratelimited\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BSD licensed, see LICENSE in source package for details.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Report bugs to %s\n"
argument_list|,
name|PACKAGE_BUGREPORT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** exit with ssl error */
end_comment

begin_function
specifier|static
name|void
name|ssl_err
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** setup SSL context */
end_comment

begin_function
specifier|static
name|SSL_CTX
modifier|*
name|setup_ctx
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|char
modifier|*
name|s_cert
init|=
name|NULL
decl_stmt|,
modifier|*
name|c_key
init|=
name|NULL
decl_stmt|,
modifier|*
name|c_cert
init|=
name|NULL
decl_stmt|;
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|remote_control_use_cert
condition|)
block|{
name|s_cert
operator|=
name|fname_after_chroot
argument_list|(
name|cfg
operator|->
name|server_cert_file
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c_key
operator|=
name|fname_after_chroot
argument_list|(
name|cfg
operator|->
name|control_key_file
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c_cert
operator|=
name|fname_after_chroot
argument_list|(
name|cfg
operator|->
name|control_cert_file
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_cert
operator|||
operator|!
name|c_key
operator|||
operator|!
name|c_cert
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_client_method
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
name|ssl_err
argument_list|(
literal|"could not allocate SSL_CTX pointer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SSL_CTX_set_options
argument_list|(
name|ctx
argument_list|,
name|SSL_OP_NO_SSLv2
argument_list|)
operator|&
name|SSL_OP_NO_SSLv2
operator|)
operator|!=
name|SSL_OP_NO_SSLv2
condition|)
name|ssl_err
argument_list|(
literal|"could not set SSL_OP_NO_SSLv2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|remote_control_use_cert
condition|)
block|{
if|if
condition|(
operator|(
name|SSL_CTX_set_options
argument_list|(
name|ctx
argument_list|,
name|SSL_OP_NO_SSLv3
argument_list|)
operator|&
name|SSL_OP_NO_SSLv3
operator|)
operator|!=
name|SSL_OP_NO_SSLv3
condition|)
name|ssl_err
argument_list|(
literal|"could not set SSL_OP_NO_SSLv3"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_CTX_use_certificate_chain_file
argument_list|(
name|ctx
argument_list|,
name|c_cert
argument_list|)
operator|||
operator|!
name|SSL_CTX_use_PrivateKey_file
argument_list|(
name|ctx
argument_list|,
name|c_key
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|||
operator|!
name|SSL_CTX_check_private_key
argument_list|(
name|ctx
argument_list|)
condition|)
name|ssl_err
argument_list|(
literal|"Error setting up SSL_CTX client key and cert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSL_CTX_load_verify_locations
argument_list|(
name|ctx
argument_list|,
name|s_cert
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
name|ssl_err
argument_list|(
literal|"Error setting up SSL_CTX verify, server cert"
argument_list|)
expr_stmt|;
name|SSL_CTX_set_verify
argument_list|(
name|ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c_key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c_cert
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use ciphers that don't require authentication  */
if|if
condition|(
operator|!
name|SSL_CTX_set_cipher_list
argument_list|(
name|ctx
argument_list|,
literal|"aNULL"
argument_list|)
condition|)
name|ssl_err
argument_list|(
literal|"Error setting NULL cipher!"
argument_list|)
expr_stmt|;
block|}
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/** contact the server with TCP connect */
end_comment

begin_function
specifier|static
name|int
name|contact_server
parameter_list|(
specifier|const
name|char
modifier|*
name|svr
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|int
name|statuscmd
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|int
name|addrfamily
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* use svr or the first config entry */
if|if
condition|(
operator|!
name|svr
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|control_ifs
condition|)
name|svr
operator|=
name|cfg
operator|->
name|control_ifs
operator|->
name|str
expr_stmt|;
else|else
name|svr
operator|=
literal|"127.0.0.1"
expr_stmt|;
comment|/* config 0 addr (everything), means ask localhost */
if|if
condition|(
name|strcmp
argument_list|(
name|svr
argument_list|,
literal|"0.0.0.0"
argument_list|)
operator|==
literal|0
condition|)
name|svr
operator|=
literal|"127.0.0.1"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|svr
argument_list|,
literal|"::0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|svr
argument_list|,
literal|"0::0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|svr
argument_list|,
literal|"0::"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|svr
argument_list|,
literal|"::"
argument_list|)
operator|==
literal|0
condition|)
name|svr
operator|=
literal|"::1"
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|svr
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|svr
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not parse IP@port: %s"
argument_list|,
name|svr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_UN_H
block|}
elseif|else
if|if
condition|(
name|svr
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|usock
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
operator|&
name|addr
decl_stmt|;
name|usock
operator|->
name|sun_family
operator|=
name|AF_LOCAL
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_UN_SUN_LEN
name|usock
operator|->
name|sun_len
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|usock
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|usock
operator|->
name|sun_path
argument_list|,
name|svr
argument_list|,
sizeof|sizeof
argument_list|(
name|usock
operator|->
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
name|addrlen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
name|addrfamily
operator|=
name|AF_LOCAL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ipstrtoaddr
argument_list|(
name|svr
argument_list|,
name|cfg
operator|->
name|control_port
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not parse IP: %s"
argument_list|,
name|svr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrfamily
operator|==
literal|0
condition|)
name|addrfamily
operator|=
name|addr_is_ip6
argument_list|(
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
name|fd
operator|=
name|socket
argument_list|(
name|addrfamily
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|fatal_exit
argument_list|(
literal|"socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_exit
argument_list|(
literal|"socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err_addr
argument_list|(
literal|"connect"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
operator|&&
name|statuscmd
condition|)
block|{
name|printf
argument_list|(
literal|"unbound is stopped\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|log_err_addr
argument_list|(
literal|"connect"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAECONNREFUSED
operator|&&
name|statuscmd
condition|)
block|{
name|printf
argument_list|(
literal|"unbound is stopped\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/** setup SSL on the connection */
end_comment

begin_function
specifier|static
name|SSL
modifier|*
name|setup_ssl
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|X509
modifier|*
name|x
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_new"
argument_list|)
expr_stmt|;
name|SSL_set_connect_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_set_mode
argument_list|(
name|ssl
argument_list|,
name|SSL_MODE_AUTO_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_set_fd
argument_list|(
name|ssl
argument_list|,
name|fd
argument_list|)
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_set_fd"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|ssl
argument_list|)
operator|)
operator|==
literal|1
condition|)
break|break;
name|r
operator|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SSL_ERROR_WANT_READ
operator|&&
name|r
operator|!=
name|SSL_ERROR_WANT_WRITE
condition|)
name|ssl_err
argument_list|(
literal|"SSL handshake failed"
argument_list|)
expr_stmt|;
comment|/* wants to be called again */
block|}
comment|/* check authenticity of server */
if|if
condition|(
name|SSL_get_verify_result
argument_list|(
name|ssl
argument_list|)
operator|!=
name|X509_V_OK
condition|)
name|ssl_err
argument_list|(
literal|"SSL verification failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|remote_control_use_cert
condition|)
block|{
name|x
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|ssl_err
argument_list|(
literal|"Server presented no peer certificate"
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|ssl
return|;
block|}
end_function

begin_comment
comment|/** send stdin to server */
end_comment

begin_function
specifier|static
name|void
name|send_file
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_write contents"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** send command and display result */
end_comment

begin_function
specifier|static
name|int
name|go_cmd
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|pre
index|[
literal|10
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|space
init|=
literal|" "
decl_stmt|;
specifier|const
name|char
modifier|*
name|newline
init|=
literal|"\n"
decl_stmt|;
name|int
name|was_error
init|=
literal|0
decl_stmt|,
name|first_line
init|=
literal|1
decl_stmt|;
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pre
argument_list|,
sizeof|sizeof
argument_list|(
name|pre
argument_list|)
argument_list|,
literal|"UBCT%d "
argument_list|,
name|UNBOUND_CONTROL_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|pre
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|pre
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|space
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|space
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|newline
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|newline
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|ssl_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"load_cache"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|send_file
argument_list|(
name|ssl
argument_list|,
name|stdin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
comment|/* EOF */
break|break;
block|}
name|ssl_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first_line
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"error"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|was_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|first_line
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|was_error
return|;
block|}
end_function

begin_comment
comment|/** go ahead and read config, contact server and perform command and display */
end_comment

begin_function
specifier|static
name|int
name|go
parameter_list|(
specifier|const
name|char
modifier|*
name|cfgfile
parameter_list|,
name|char
modifier|*
name|svr
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|SSL
modifier|*
name|ssl
decl_stmt|;
comment|/* read config */
if|if
condition|(
operator|!
operator|(
name|cfg
operator|=
name|config_create
argument_list|()
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_read
argument_list|(
name|cfg
argument_list|,
name|cfgfile
argument_list|,
name|NULL
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"could not read config file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|remote_control_enable
condition|)
name|log_warn
argument_list|(
literal|"control-enable is 'no' in the config file."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|w_config_adjust_directory
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|=
name|setup_ctx
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
comment|/* contact server */
name|fd
operator|=
name|contact_server
argument_list|(
name|svr
argument_list|,
name|cfg
argument_list|,
name|argc
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"status"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ssl
operator|=
name|setup_ssl
argument_list|(
name|ctx
argument_list|,
name|fd
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* send command */
name|ret
operator|=
name|go_cmd
argument_list|(
name|ssl
argument_list|,
name|quiet
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SSL_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|config_delete
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Main routine for unbound-control */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfgfile
init|=
name|CONFIGFILE
decl_stmt|;
name|char
modifier|*
name|svr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|int
name|r
decl_stmt|;
name|WSADATA
name|wsa_data
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_THREAD_DEBUG
comment|/* stop the file output from unbound-control, overwites the servers */
specifier|extern
name|int
name|check_locking_order
decl_stmt|;
name|check_locking_order
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREAD_DEBUG */
name|log_ident_set
argument_list|(
literal|"unbound-control"
argument_list|)
expr_stmt|;
name|log_init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|checklock_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
operator|(
name|r
operator|=
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal_exit
argument_list|(
literal|"WSAStartup failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* use registry config file in preference to compiletime location */
if|if
condition|(
operator|!
operator|(
name|cfgfile
operator|=
name|w_lookup_reg_str
argument_list|(
literal|"Software\\Unbound"
argument_list|,
literal|"ConfigFile"
argument_list|)
operator|)
condition|)
name|cfgfile
operator|=
name|CONFIGFILE
expr_stmt|;
endif|#
directive|endif
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|ERR_load_SSL_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_library_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
block|{
comment|/* try to seed it */
name|unsigned
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|int
name|seed
init|=
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|v
init|=
name|seed
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|/
sizeof|sizeof
argument_list|(
name|v
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|memmove
argument_list|(
name|buf
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|,
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|v
operator|*
name|seed
operator|+
operator|(
name|unsigned
name|int
operator|)
name|i
expr_stmt|;
block|}
name|RAND_seed
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
literal|"no entropy, seeding openssl PRNG with time\n"
argument_list|)
expr_stmt|;
block|}
comment|/* parse the options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:s:qh"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|cfgfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|svr
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|execlp
argument_list|(
literal|"unbound"
argument_list|,
literal|"unbound"
argument_list|,
literal|"-c"
argument_list|,
name|cfgfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"could not exec unbound: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|go
argument_list|(
name|cfgfile
argument_list|,
name|svr
argument_list|,
name|quiet
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|checklock_stop
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

