begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * unbound-anchor.c - update the root anchor if necessary.  *  * Copyright (c) 2010, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file checks to see that the current 5011 keys work to prime the  * current root anchor.  If not a certificate is used to update the anchor.  *  * This is a concept solution for distribution of the DNSSEC root  * trust anchor.  It is a small tool, called "unbound-anchor", that  * runs before the main validator starts.  I.e. in the init script:  * unbound-anchor; unbound.  Thus it is meant to run at system boot time.  *  * Management-Abstract:  *    * first run: fill root.key file with hardcoded DS record.  *    * mostly: use RFC5011 tracking, quick . DNSKEY UDP query.  *    * failover: use builtin certificate, do https and update.  * Special considerations:  *    * 30-days RFC5011 timer saves a lot of https traffic.  *    * DNSKEY probe must be NOERROR, saves a lot of https traffic.  *    * fail if clock before sign date of the root, if cert expired.  *    * if the root goes back to unsigned, deals with it.  *  * It has hardcoded the root DS anchors and the ICANN CA root certificate.  * It allows with options to override those.  It also takes root-hints (it  * has to do a DNS resolve), and also has hardcoded defaults for those.  *  * Once it starts, just before the validator starts, it quickly checks if  * the root anchor file needs to be updated.  First it tries to use  * RFC5011-tracking of the root key.  If that fails (and for 30-days since  * last successful probe), then it attempts to update using the  * certificate.  So most of the time, the RFC5011 tracking will work fine,  * and within a couple milliseconds, the main daemon can start.  It will  * have only probed the . DNSKEY, not done expensive https transfers on the  * root infrastructure.  *  * If there is no root key in the root.key file, it bootstraps the  * RFC5011-tracking with its builtin DS anchors; if that fails it  * bootstraps the RFC5011-tracking using the certificate.  (again to avoid  * https, and it is also faster).  *   * It uses the XML file by converting it to DS records and writing that to the  * key file.  Unbound can detect that the 'special comments' are gone, and  * the file contains a list of normal DNSKEY/DS records, and uses that to  * bootstrap 5011 (the KSK is made VALID).  *  * The certificate update is done by fetching root-anchors.xml and  * root-anchors.p7s via SSL.  The HTTPS certificate can be logged but is  * not validated (https for channel security; the security comes from the  * certificate).  The 'data.iana.org' domain name A and AAAA are resolved  * without DNSSEC.  It tries a random IP until the transfer succeeds.  It  * then checks the p7s signature.  *  * On any failure, it leaves the root key file untouched.  The main  * validator has to cope with it, it cannot fix things (So a failure does  * not go 'without DNSSEC', no downgrade).  If it used its builtin stuff or  * did the https, it exits with an exit code, so that this can trigger the  * init script to log the event and potentially alert the operator that can  * do a manual check.  *  * The date is also checked.  Before 2010-07-15 is a failure (root not  * signed yet; avoids attacks on system clock).  The  * last-successful-RFC5011-probe (if available) has to be more than 30 days  * in the past (otherwise, RFC5011 should have worked).  This keeps  * unnecessary https traffic down.  If the main certificate is expired, it  * fails.  *  * The dates on the keys in the xml are checked (uses the libexpat xml  * parser), only the valid ones are used to re-enstate RFC5011 tracking.  * If 0 keys are valid, the zone has gone to insecure (a special marker is  * written in the keyfile that tells the main validator daemon the zone is  * insecure).  *  * Only the root ICANN CA is shipped, not the intermediate ones.  The  * intermediate CAs are included in the p7s file that was downloaded.  (the  * root cert is valid to 2028 and the intermediate to 2014, today).  *  * Obviously, the tool also has options so the operator can provide a new  * keyfile, a new certificate and new URLs, and fresh root hints.  By  * default it logs nothing on failure and success; it 'just works'.  *  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/unbound.h"
end_include

begin_include
include|#
directive|include
file|"sldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"sldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_EXPAT_H
end_ifndef

begin_error
error|#
directive|error
literal|"need libexpat to parse root-anchors.xml file."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_SSL_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_RAND_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_comment
comment|/** name of server in URL to fetch HTTPS from */
end_comment

begin_define
define|#
directive|define
name|URLNAME
value|"data.iana.org"
end_define

begin_comment
comment|/** path on HTTPS server to xml file */
end_comment

begin_define
define|#
directive|define
name|XMLNAME
value|"root-anchors/root-anchors.xml"
end_define

begin_comment
comment|/** path on HTTPS server to p7s file */
end_comment

begin_define
define|#
directive|define
name|P7SNAME
value|"root-anchors/root-anchors.p7s"
end_define

begin_comment
comment|/** name of the signer of the certificate */
end_comment

begin_define
define|#
directive|define
name|P7SIGNER
value|"dnssec@iana.org"
end_define

begin_comment
comment|/** port number for https access */
end_comment

begin_define
define|#
directive|define
name|HTTPS_PORT
value|443
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_comment
comment|/* sneakily reuse the the wsa_strerror function, on windows */
end_comment

begin_function_decl
name|char
modifier|*
name|wsa_strerror
parameter_list|(
name|int
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** verbosity for this application */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** list of IP addresses */
end_comment

begin_struct
struct|struct
name|ip_list
block|{
comment|/** next in list */
name|struct
name|ip_list
modifier|*
name|next
decl_stmt|;
comment|/** length of addr */
name|socklen_t
name|len
decl_stmt|;
comment|/** address ready to connect to */
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
comment|/** has the address been used */
name|int
name|used
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** Give unbound-anchor usage, and exit (1). */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage:	unbound-anchor [opts]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	Setup or update root anchor. "
literal|"Most options have defaults.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	Run this program before you start the validator.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	The anchor and cert have default builtin content\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	if the file does not exist or is empty.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-a file		root key file, default %s\n"
argument_list|,
name|ROOT_ANCHOR_FILE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		The key is input and output for this tool.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-c file		cert file, default %s\n"
argument_list|,
name|ROOT_CERT_FILE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-l		list builtin key and cert on stdout\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-u name		server in https url, default %s\n"
argument_list|,
name|URLNAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-x path		pathname to xml in url, default %s\n"
argument_list|,
name|XMLNAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-s path		pathname to p7s in url, default %s\n"
argument_list|,
name|P7SNAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-n name		signer's subject emailAddress, default %s\n"
argument_list|,
name|P7SIGNER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-4		work using IPv4 only\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-6		work using IPv6 only\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-f resolv.conf	use given resolv.conf to resolve -u name\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-r root.hints	use given root.hints to resolve -u name\n"
literal|"		builtin root hints are used by default\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-v		more verbose\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-C conf		debug, read config\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-P port		use port for https connect, default 443\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-F 		debug, force update with cert\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-h		show this usage help\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BSD licensed, see LICENSE in source package for details.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Report bugs to %s\n"
argument_list|,
name|PACKAGE_BUGREPORT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** return the built in root update certificate */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_builtin_cert
parameter_list|(
name|void
parameter_list|)
block|{
return|return
comment|/* The ICANN CA fetched at 24 Sep 2010.  Valid to 2028 */
literal|"-----BEGIN CERTIFICATE-----\n"
literal|"MIIDdzCCAl+gAwIBAgIBATANBgkqhkiG9w0BAQsFADBdMQ4wDAYDVQQKEwVJQ0FO\n"
literal|"TjEmMCQGA1UECxMdSUNBTk4gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxFjAUBgNV\n"
literal|"BAMTDUlDQU5OIFJvb3QgQ0ExCzAJBgNVBAYTAlVTMB4XDTA5MTIyMzA0MTkxMloX\n"
literal|"DTI5MTIxODA0MTkxMlowXTEOMAwGA1UEChMFSUNBTk4xJjAkBgNVBAsTHUlDQU5O\n"
literal|"IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRYwFAYDVQQDEw1JQ0FOTiBSb290IENB\n"
literal|"MQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKDb\n"
literal|"cLhPNNqc1NB+u+oVvOnJESofYS9qub0/PXagmgr37pNublVThIzyLPGCJ8gPms9S\n"
literal|"G1TaKNIsMI7d+5IgMy3WyPEOECGIcfqEIktdR1YWfJufXcMReZwU4v/AdKzdOdfg\n"
literal|"ONiwc6r70duEr1IiqPbVm5T05l1e6D+HkAvHGnf1LtOPGs4CHQdpIUcy2kauAEy2\n"
literal|"paKcOcHASvbTHK7TbbvHGPB+7faAztABLoneErruEcumetcNfPMIjXKdv1V1E3C7\n"
literal|"MSJKy+jAqqQJqjZoQGB0necZgUMiUv7JK1IPQRM2CXJllcyJrm9WFxY0c1KjBO29\n"
literal|"iIKK69fcglKcBuFShUECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8B\n"
literal|"Af8EBAMCAf4wHQYDVR0OBBYEFLpS6UmDJIZSL8eZzfyNa2kITcBQMA0GCSqGSIb3\n"
literal|"DQEBCwUAA4IBAQAP8emCogqHny2UYFqywEuhLys7R9UKmYY4suzGO4nkbgfPFMfH\n"
literal|"6M+Zj6owwxlwueZt1j/IaCayoKU3QsrYYoDRolpILh+FPwx7wseUEV8ZKpWsoDoD\n"
literal|"2JFbLg2cfB8u/OlE4RYmcxxFSmXBg0yQ8/IoQt/bxOcEEhhiQ168H2yE5rxJMt9h\n"
literal|"15nu5JBSewrCkYqYYmaxyOC3WrVGfHZxVI7MpIFcGdvSb2a1uyuua8l0BKgk3ujF\n"
literal|"0/wsHNeP22qNyVO+XVBzrM8fk8BSUFuiT/6tZTYXRtEt5aKQZgXbKU5dUF3jT9qg\n"
literal|"j/Br5BZw3X/zd325TvnswzMC1+ljLzHnQGGk\n"
literal|"-----END CERTIFICATE-----\n"
return|;
block|}
end_function

begin_comment
comment|/** return the built in root DS trust anchor */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_builtin_ds
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|". IN DS 19036 8 2 49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5\n"
return|;
block|}
end_function

begin_comment
comment|/** print hex data */
end_comment

begin_function
specifier|static
name|void
name|print_data
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** print ub context creation error and exit */
end_comment

begin_function
specifier|static
name|void
name|ub_ctx_error_exit
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|&&
name|str2
operator|&&
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|str
argument_list|,
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"error: could not create unbound resolver context\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Create a new unbound context with the commandline settings applied  */
end_comment

begin_function
specifier|static
name|struct
name|ub_ctx
modifier|*
name|create_unbound_context
parameter_list|(
specifier|const
name|char
modifier|*
name|res_conf
parameter_list|,
specifier|const
name|char
modifier|*
name|root_hints
parameter_list|,
specifier|const
name|char
modifier|*
name|debugconf
parameter_list|,
name|int
name|ip4only
parameter_list|,
name|int
name|ip6only
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|ub_ctx
modifier|*
name|ctx
init|=
name|ub_ctx_create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* do not waste time and network traffic to fetch extra nameservers */
name|r
operator|=
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"target-fetch-policy:"
argument_list|,
literal|"0 0 0 0 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|verb
condition|)
name|printf
argument_list|(
literal|"ctx targetfetchpolicy: %s\n"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read config file first, so its settings can be overridden */
if|if
condition|(
name|debugconf
condition|)
block|{
name|r
operator|=
name|ub_ctx_config
argument_list|(
name|ctx
argument_list|,
name|debugconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ub_ctx_error_exit
argument_list|(
name|ctx
argument_list|,
name|debugconf
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res_conf
condition|)
block|{
name|r
operator|=
name|ub_ctx_resolvconf
argument_list|(
name|ctx
argument_list|,
name|res_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ub_ctx_error_exit
argument_list|(
name|ctx
argument_list|,
name|res_conf
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|root_hints
condition|)
block|{
name|r
operator|=
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"root-hints:"
argument_list|,
name|root_hints
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ub_ctx_error_exit
argument_list|(
name|ctx
argument_list|,
name|root_hints
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip4only
condition|)
block|{
name|r
operator|=
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"do-ip6:"
argument_list|,
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ub_ctx_error_exit
argument_list|(
name|ctx
argument_list|,
literal|"ip4only"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip6only
condition|)
block|{
name|r
operator|=
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"do-ip4:"
argument_list|,
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|ub_ctx_error_exit
argument_list|(
name|ctx
argument_list|,
literal|"ip6only"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/** printout certificate in detail */
end_comment

begin_function
specifier|static
name|void
name|verb_cert
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|)
block|{
if|if
condition|(
name|verb
operator|==
literal|0
operator|||
name|verb
operator|==
literal|1
condition|)
return|return;
if|if
condition|(
name|verb
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|X509_print_ex_fp
argument_list|(
name|stdout
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
operator|^
operator|(
name|X509_FLAG_NO_SUBJECT
operator||
name|X509_FLAG_NO_ISSUER
operator||
name|X509_FLAG_NO_VALIDITY
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** printout certificates in detail */
end_comment

begin_decl_stmt
specifier|static
name|void
name|verb_certs
argument_list|(
specifier|const
name|char
operator|*
name|msg
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
argument_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
init|=
name|sk_X509_num
argument_list|(
name|sk
argument_list|)
decl_stmt|;
if|if
condition|(
name|verb
operator|==
literal|0
operator|||
name|verb
operator|==
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s (%d/%d)\n"
argument_list|,
name|msg
argument_list|,
name|i
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|verb_cert
argument_list|(
name|NULL
argument_list|,
name|sk_X509_value
argument_list|(
name|sk
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/** read certificates from a PEM bio */
end_comment

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|read_cert_bio
argument_list|(
argument|BIO* bio
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
operator|=
name|sk_X509_new_null
argument_list|()
block|;
if|if
condition|(
operator|!
name|sk
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_while
while|while
condition|(
operator|!
name|BIO_eof
argument_list|(
name|bio
argument_list|)
condition|)
block|{
name|X509
modifier|*
name|x
init|=
name|PEM_read_bio_X509
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verb
condition|)
block|{
name|printf
argument_list|(
literal|"failed to read X509\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|sk_X509_push
argument_list|(
name|sk
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_while

begin_return
return|return
name|sk
return|;
end_return

begin_comment
unit|}
comment|/* read the certificate file */
end_comment

begin_expr_stmt
unit|static
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|read_cert_file
argument_list|(
argument|const char* file
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
block|;
name|FILE
operator|*
name|in
block|;
name|int
name|content
operator|=
literal|0
block|;
name|char
name|buf
index|[
literal|128
index|]
block|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|file
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|sk
operator|=
name|sk_X509_new_null
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|sk
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|in
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|in
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|sk_X509_pop_free
argument_list|(
name|sk
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_if

begin_while
while|while
condition|(
operator|!
name|feof
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|X509
modifier|*
name|x
init|=
name|PEM_read_X509
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verb
condition|)
block|{
name|printf
argument_list|(
literal|"failed to read X509 file\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|sk_X509_push
argument_list|(
name|sk
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|content
operator|=
literal|1
expr_stmt|;
comment|/* read away newline after --END CERT-- */
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
break|break;
block|}
end_while

begin_expr_stmt
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|content
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s is empty\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|sk_X509_pop_free
argument_list|(
name|sk
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_if

begin_return
return|return
name|sk
return|;
end_return

begin_comment
unit|}
comment|/** read certificates from the builtin certificate */
end_comment

begin_expr_stmt
unit|static
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|read_builtin_cert
argument_list|(
argument|void
argument_list|)
block|{
specifier|const
name|char
operator|*
name|builtin_cert
operator|=
name|get_builtin_cert
argument_list|()
block|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
block|;
name|BIO
operator|*
name|bio
operator|=
name|BIO_new_mem_buf
argument_list|(
operator|(
name|void
operator|*
operator|)
name|builtin_cert
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|builtin_cert
argument_list|)
argument_list|)
block|;
if|if
condition|(
operator|!
name|bio
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|sk
operator|=
name|read_cert_bio
argument_list|(
name|bio
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|sk
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"internal error, out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|sk
return|;
end_return

begin_comment
unit|}
comment|/** read update cert file or use builtin */
end_comment

begin_expr_stmt
unit|static
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|read_cert_or_builtin
argument_list|(
argument|const char* file
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
operator|=
name|read_cert_file
argument_list|(
name|file
argument_list|)
block|;
if|if
condition|(
operator|!
name|sk
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"using builtin certificate\n"
argument_list|)
expr_stmt|;
name|sk
operator|=
name|read_builtin_cert
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"have %d trusted certificates\n"
argument_list|,
name|sk_X509_num
argument_list|(
name|sk
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|verb_certs
argument_list|(
literal|"trusted certificates"
argument_list|,
name|sk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|sk
return|;
end_return

begin_function
unit|}  static
name|void
name|do_list_builtin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|builtin_cert
init|=
name|get_builtin_cert
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|builtin_ds
init|=
name|get_builtin_ds
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|builtin_ds
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|builtin_cert
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** printout IP address with message */
end_comment

begin_function
specifier|static
name|void
name|verb_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|ip_list
modifier|*
name|ip
parameter_list|)
block|{
if|if
condition|(
name|verb
condition|)
block|{
name|char
name|out
index|[
literal|100
index|]
decl_stmt|;
name|void
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ip
operator|->
name|addr
operator|)
operator|->
name|sin_addr
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|len
operator|!=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
name|a
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ip
operator|->
name|addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ip
operator|->
name|addr
argument_list|)
operator|->
name|sin_family
argument_list|,
name|a
argument_list|,
name|out
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s (inet_ntop error)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|msg
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** free ip_list */
end_comment

begin_function
specifier|static
name|void
name|ip_list_free
parameter_list|(
name|struct
name|ip_list
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ip_list
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** create ip_list entry for a RR record */
end_comment

begin_function
specifier|static
name|struct
name|ip_list
modifier|*
name|RR_to_ip
parameter_list|(
name|int
name|tp
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|ip_list
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip_list
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
decl_stmt|;
name|uint16_t
name|p
init|=
operator|(
name|uint16_t
operator|)
name|port
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|LDNS_RR_TYPE_A
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ip
operator|->
name|addr
decl_stmt|;
name|ip
operator|->
name|len
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|->
name|sin_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"skipped badly formatted A\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memmove
argument_list|(
operator|&
name|sa
operator|->
name|sin_addr
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ip
operator|->
name|addr
decl_stmt|;
name|ip
operator|->
name|len
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sa
operator|->
name|sin6_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"skipped badly formatted AAAA\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memmove
argument_list|(
operator|&
name|sa
operator|->
name|sin6_addr
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"internal error: bad type in RRtoip\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|verb_addr
argument_list|(
literal|"resolved server address"
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
name|ip
return|;
block|}
end_function

begin_comment
comment|/** Resolve name, type, class and add addresses to iplist */
end_comment

begin_function
specifier|static
name|void
name|resolve_host_ip
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|tp
parameter_list|,
name|int
name|cl
parameter_list|,
name|struct
name|ip_list
modifier|*
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ub_result
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|r
operator|=
name|ub_resolve
argument_list|(
name|ctx
argument_list|,
name|host
argument_list|,
name|tp
argument_list|,
name|cl
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"error: resolve %s %s: %s\n"
argument_list|,
name|host
argument_list|,
operator|(
name|tp
operator|==
name|LDNS_RR_TYPE_A
operator|)
condition|?
literal|"A"
else|:
literal|"AAAA"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|res
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
operator|->
name|havedata
operator|||
name|res
operator|->
name|rcode
operator|||
operator|!
name|res
operator|->
name|data
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"resolve %s %s: no result\n"
argument_list|,
name|host
argument_list|,
operator|(
name|tp
operator|==
name|LDNS_RR_TYPE_A
operator|)
condition|?
literal|"A"
else|:
literal|"AAAA"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|res
operator|->
name|data
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ip_list
modifier|*
name|ip
init|=
name|RR_to_ip
argument_list|(
name|tp
argument_list|,
name|res
operator|->
name|data
index|[
name|i
index|]
argument_list|,
name|res
operator|->
name|len
index|[
name|i
index|]
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
continue|continue;
name|ip
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|ip
expr_stmt|;
block|}
name|ub_resolve_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** parse a text IP address into a sockaddr */
end_comment

begin_function
specifier|static
name|struct
name|ip_list
modifier|*
name|parse_ip_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|socklen_t
name|len
init|=
literal|0
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr_in6
name|a6
decl_stmt|;
name|struct
name|sockaddr_in
name|a
decl_stmt|;
block|}
name|addr
union|;
name|struct
name|ip_list
modifier|*
name|ip
decl_stmt|;
name|uint16_t
name|p
init|=
operator|(
name|uint16_t
operator|)
name|port
decl_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|str
argument_list|,
operator|&
name|addr
operator|.
name|a6
operator|.
name|sin6_addr
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* it is an IPv6 */
name|addr
operator|.
name|a6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|addr
operator|.
name|a6
operator|.
name|sin6_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|a6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|str
argument_list|,
operator|&
name|addr
operator|.
name|a
operator|.
name|sin_addr
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* it is an IPv4 */
name|addr
operator|.
name|a
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|a
operator|.
name|sin_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|len
condition|)
return|return
name|NULL
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip_list
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|ip
operator|->
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"server address is %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|ip
return|;
block|}
end_function

begin_comment
comment|/**  * Resolve a domain name (even though the resolver is down and there is  * no trust anchor).  Without DNSSEC validation.  * @param host: the name to resolve.  * 	If this name is an IP4 or IP6 address this address is returned.  * @param port: the port number used for the returned IP structs.  * @param res_conf: resolv.conf (if any).  * @param root_hints: root hints (if any).  * @param debugconf: unbound.conf for debugging options.  * @param ip4only: use only ip4 for resolve and only lookup A  * @param ip6only: use only ip6 for resolve and only lookup AAAA  * 	default is to lookup A and AAAA using ip4 and ip6.  * @return list of IP addresses.  */
end_comment

begin_function
specifier|static
name|struct
name|ip_list
modifier|*
name|resolve_name
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|,
specifier|const
name|char
modifier|*
name|res_conf
parameter_list|,
specifier|const
name|char
modifier|*
name|root_hints
parameter_list|,
specifier|const
name|char
modifier|*
name|debugconf
parameter_list|,
name|int
name|ip4only
parameter_list|,
name|int
name|ip6only
parameter_list|)
block|{
name|struct
name|ub_ctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ip_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
comment|/* first see if name is an IP address itself */
if|if
condition|(
operator|(
name|list
operator|=
name|parse_ip_addr
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
operator|)
condition|)
block|{
return|return
name|list
return|;
block|}
comment|/* create resolver context */
name|ctx
operator|=
name|create_unbound_context
argument_list|(
name|res_conf
argument_list|,
name|root_hints
argument_list|,
name|debugconf
argument_list|,
name|ip4only
argument_list|,
name|ip6only
argument_list|)
expr_stmt|;
comment|/* try resolution of A */
if|if
condition|(
operator|!
name|ip6only
condition|)
block|{
name|resolve_host_ip
argument_list|(
name|ctx
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* try resolution of AAAA */
if|if
condition|(
operator|!
name|ip4only
condition|)
block|{
name|resolve_host_ip
argument_list|(
name|ctx
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s has no IP addresses I can use\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/** clear used flags */
end_comment

begin_function
specifier|static
name|void
name|wipe_ip_usage
parameter_list|(
name|struct
name|ip_list
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** cound unused IPs */
end_comment

begin_function
specifier|static
name|int
name|count_unused
parameter_list|(
name|struct
name|ip_list
modifier|*
name|p
parameter_list|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|used
condition|)
name|num
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/** pick random unused element from IP list */
end_comment

begin_function
specifier|static
name|struct
name|ip_list
modifier|*
name|pick_random_ip
parameter_list|(
name|struct
name|ip_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ip_list
modifier|*
name|p
init|=
name|list
decl_stmt|;
name|int
name|num
init|=
name|count_unused
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|int
name|sel
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* not perfect, but random enough */
name|sel
operator|=
operator|(
name|int
operator|)
name|arc4random_uniform
argument_list|(
operator|(
name|uint32_t
operator|)
name|num
argument_list|)
expr_stmt|;
comment|/* skip over unused elements that we did not select */
while|while
condition|(
name|sel
operator|>
literal|0
operator|&&
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|used
condition|)
name|sel
operator|--
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
comment|/* find the next unused element */
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|used
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
comment|/* robustness */
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/** close the fd */
end_comment

begin_function
specifier|static
name|void
name|fd_close
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** printout socket errno */
end_comment

begin_function
specifier|static
name|void
name|print_sock_err
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|msg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|msg
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** connect to IP address */
end_comment

begin_function
specifier|static
name|int
name|connect_to_ip
parameter_list|(
name|struct
name|ip_list
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|verb_addr
argument_list|(
literal|"connect to"
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|fd
operator|=
name|socket
argument_list|(
name|ip
operator|->
name|len
operator|==
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|?
name|AF_INET
else|:
name|AF_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|print_sock_err
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ip
operator|->
name|addr
argument_list|,
name|ip
operator|->
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sock_err
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|fd_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/** create SSL context */
end_comment

begin_function
specifier|static
name|SSL_CTX
modifier|*
name|setup_sslctx
parameter_list|(
name|void
parameter_list|)
block|{
name|SSL_CTX
modifier|*
name|sslctx
init|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_client_method
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sslctx
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"SSL_CTX_new error\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|sslctx
return|;
block|}
end_function

begin_comment
comment|/** initiate TLS on a connection */
end_comment

begin_function
specifier|static
name|SSL
modifier|*
name|TLS_initiate
parameter_list|(
name|SSL_CTX
modifier|*
name|sslctx
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|X509
modifier|*
name|x
decl_stmt|;
name|int
name|r
decl_stmt|;
name|SSL
modifier|*
name|ssl
init|=
name|SSL_new
argument_list|(
name|sslctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"SSL_new error\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|SSL_set_connect_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_set_mode
argument_list|(
name|ssl
argument_list|,
name|SSL_MODE_AUTO_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_set_fd
argument_list|(
name|ssl
argument_list|,
name|fd
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"SSL_set_fd error\n"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|ssl
argument_list|)
operator|)
operator|==
literal|1
condition|)
break|break;
name|r
operator|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SSL_ERROR_WANT_READ
operator|&&
name|r
operator|!=
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"SSL handshake failed\n"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* wants to be called again */
block|}
name|x
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"Server presented no peer certificate\n"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|verb_cert
argument_list|(
literal|"server SSL certificate"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|ssl
return|;
block|}
end_function

begin_comment
comment|/** perform neat TLS shutdown */
end_comment

begin_function
specifier|static
name|void
name|TLS_shutdown
parameter_list|(
name|int
name|fd
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|SSL_CTX
modifier|*
name|sslctx
parameter_list|)
block|{
comment|/* shutdown the SSL connection nicely */
if|if
condition|(
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|SSL_CTX_free
argument_list|(
name|sslctx
argument_list|)
expr_stmt|;
name|fd_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** write a line over SSL */
end_comment

begin_function
specifier|static
name|int
name|write_ssl_line
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|l
decl_stmt|;
if|if
condition|(
name|sec
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|str
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|+
literal|2
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"line too long\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"SSL_write: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|l
index|]
operator|=
literal|'\r'
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* add \r\n */
if|if
condition|(
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not SSL_write %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** process header line, check rcode and keeping track of size */
end_comment

begin_function
specifier|static
name|int
name|process_one_header
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|clen
parameter_list|,
name|int
modifier|*
name|chunked
parameter_list|)
block|{
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"header: '%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"HTTP/1.1 "
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* check returncode */
if|if
condition|(
name|buf
index|[
literal|9
index|]
operator|!=
literal|'2'
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"bad status %s\n"
argument_list|,
name|buf
operator|+
literal|9
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"Content-Length: "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|chunked
condition|)
operator|*
name|clen
operator|=
operator|(
name|size_t
operator|)
name|atoi
argument_list|(
name|buf
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"Transfer-Encoding: chunked"
argument_list|,
literal|19
operator|+
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|clen
operator|=
literal|0
expr_stmt|;
operator|*
name|chunked
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**   * Read one line from SSL  * zero terminates.  * skips "\r\n" (but not copied to buf).  * @param ssl: the SSL connection to read from (blocking).  * @param buf: buffer to return line in.  * @param len: size of the buffer.  * @return 0 on error, 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|read_ssl_line
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|endnl
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|len
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"line too long\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|buf
operator|+
name|n
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
comment|/* EOF */
break|break;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not SSL_read\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|endnl
operator|&&
name|buf
index|[
name|n
index|]
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|endnl
condition|)
block|{
comment|/* bad data */
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"error: stray linefeeds\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
name|n
index|]
operator|==
literal|'\r'
condition|)
block|{
comment|/* skip \r, and also \n on the wire */
name|endnl
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
name|n
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* skip the \n, we are done */
break|break;
block|}
else|else
name|n
operator|++
expr_stmt|;
block|}
name|buf
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** read http headers and process them */
end_comment

begin_function
specifier|static
name|size_t
name|read_http_headers
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|size_t
modifier|*
name|clen
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|chunked
init|=
literal|0
decl_stmt|;
operator|*
name|clen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|read_ssl_line
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|process_one_header
argument_list|(
name|buf
argument_list|,
name|clen
argument_list|,
operator|&
name|chunked
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** read a data chunk */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_data_chunk
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|got
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0xfffffff0
condition|)
return|return
name|NULL
return|;
comment|/* to protect against integer overflow in malloc*/
name|data
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|got
operator|<
name|len
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|data
operator|+
name|got
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|got
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
comment|/* EOF */
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not SSL_read: unexpected EOF\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not SSL_read\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"at %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|got
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|got
operator|+=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"read %d data\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|data
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/** parse chunk header */
end_comment

begin_function
specifier|static
name|int
name|parse_chunk_header
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|size_t
name|v
init|=
operator|(
name|size_t
operator|)
name|strtol
argument_list|(
name|buf
argument_list|,
operator|&
name|e
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|buf
condition|)
return|return
literal|0
return|;
operator|*
name|result
operator|=
name|v
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** read chunked data from connection */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|do_chunked_read
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|BIO
modifier|*
name|mem
init|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"do_chunked_read\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|read_ssl_line
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
comment|/* read the chunked start line */
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"chunk header: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_chunk_header
argument_list|(
name|buf
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"could not parse chunk header\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"chunk len: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* are we done? */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|char
name|z
init|=
literal|0
decl_stmt|;
comment|/* skip end-of-chunk-trailer lines, 			 * until the empty line after that */
do|do
block|{
if|if
condition|(
operator|!
name|read_ssl_line
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
do|while
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
do|;
comment|/* end of chunks, zero terminate it */
if|if
condition|(
name|BIO_write
argument_list|(
name|mem
argument_list|,
operator|&
name|z
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|mem
return|;
block|}
comment|/* read the chunked body */
name|body
operator|=
name|read_data_chunk
argument_list|(
name|ssl
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
block|{
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|BIO_write
argument_list|(
name|mem
argument_list|,
name|body
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* skip empty line after data chunk */
if|if
condition|(
operator|!
name|read_ssl_line
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|BIO_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** start HTTP1.1 transaction on SSL */
end_comment

begin_function
specifier|static
name|int
name|write_http_get
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|urlname
parameter_list|)
block|{
if|if
condition|(
name|write_ssl_line
argument_list|(
name|ssl
argument_list|,
literal|"GET /%s HTTP/1.1"
argument_list|,
name|pathname
argument_list|)
operator|&&
name|write_ssl_line
argument_list|(
name|ssl
argument_list|,
literal|"Host: %s"
argument_list|,
name|urlname
argument_list|)
operator|&&
name|write_ssl_line
argument_list|(
name|ssl
argument_list|,
literal|"User-Agent: unbound-anchor/%s"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
operator|&&
comment|/* We do not really do multiple queries per connection, 	    * but this header setting is also not needed. 	    * write_ssl_line(ssl, "Connection: close", NULL)&&*/
name|write_ssl_line
argument_list|(
name|ssl
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** read chunked data and zero terminate; len is without zero */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_chunked_zero_terminate
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* do the chunked version */
name|BIO
modifier|*
name|tmp
init|=
name|do_chunked_read
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
name|size_t
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not read from https\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|l
operator|=
operator|(
name|size_t
operator|)
name|BIO_get_mem_data
argument_list|(
name|tmp
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"chunked data is %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
operator|||
name|d
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|l
operator|-
literal|1
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/** read HTTP result from SSL */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|read_http_result
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|BIO
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|read_http_headers
argument_list|(
name|ssl
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|data
operator|=
name|read_chunked_zero_terminate
argument_list|(
name|ssl
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|read_data_chunk
argument_list|(
name|ssl
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|print_data
argument_list|(
literal|"read data"
argument_list|,
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|m
operator|=
name|BIO_new_mem_buf
argument_list|(
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/** https to an IP addr, return BIO with pathname or NULL */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|https_to_ip
parameter_list|(
name|struct
name|ip_list
modifier|*
name|ip
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|urlname
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|BIO
modifier|*
name|bio
decl_stmt|;
name|SSL_CTX
modifier|*
name|sslctx
init|=
name|setup_sslctx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sslctx
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|fd
operator|=
name|connect_to_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|SSL_CTX_free
argument_list|(
name|sslctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ssl
operator|=
name|TLS_initiate
argument_list|(
name|sslctx
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
block|{
name|SSL_CTX_free
argument_list|(
name|sslctx
argument_list|)
expr_stmt|;
name|fd_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|write_http_get
argument_list|(
name|ssl
argument_list|,
name|pathname
argument_list|,
name|urlname
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not write to server\n"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|SSL_CTX_free
argument_list|(
name|sslctx
argument_list|)
expr_stmt|;
name|fd_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bio
operator|=
name|read_http_result
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|TLS_shutdown
argument_list|(
name|fd
argument_list|,
name|ssl
argument_list|,
name|sslctx
argument_list|)
expr_stmt|;
return|return
name|bio
return|;
block|}
end_function

begin_comment
comment|/**  * Do a HTTPS, HTTP1.1 over TLS, to fetch a file  * @param ip_list: list of IP addresses to use to fetch from.  * @param pathname: pathname of file on server to GET.  * @param urlname: name to pass as the virtual host for this request.  * @return a memory BIO with the file in it.  */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|https
parameter_list|(
name|struct
name|ip_list
modifier|*
name|ip_list
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|urlname
parameter_list|)
block|{
name|struct
name|ip_list
modifier|*
name|ip
decl_stmt|;
name|BIO
modifier|*
name|bio
init|=
name|NULL
decl_stmt|;
comment|/* try random address first, and work through the list */
name|wipe_ip_usage
argument_list|(
name|ip_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ip
operator|=
name|pick_random_ip
argument_list|(
name|ip_list
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|bio
operator|=
name|https_to_ip
argument_list|(
name|ip
argument_list|,
name|pathname
argument_list|,
name|urlname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bio
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|bio
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not fetch %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"fetched %s (%d bytes)\n"
argument_list|,
name|pathname
argument_list|,
operator|(
name|int
operator|)
name|BIO_ctrl_pending
argument_list|(
name|bio
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|bio
return|;
block|}
end_function

begin_comment
comment|/** free up a downloaded file BIO */
end_comment

begin_function
specifier|static
name|void
name|free_file_bio
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|char
modifier|*
name|pp
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|bio
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_get_mem_data
argument_list|(
name|bio
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** XML parse private data during the parse */
end_comment

begin_struct
struct|struct
name|xml_data
block|{
comment|/** the parser, reference */
name|XML_Parser
name|parser
decl_stmt|;
comment|/** the current tag; malloced; or NULL outside of tags */
name|char
modifier|*
name|tag
decl_stmt|;
comment|/** current date to use during the parse */
name|time_t
name|date
decl_stmt|;
comment|/** number of keys usefully read in */
name|int
name|num_keys
decl_stmt|;
comment|/** the compiled anchors as DS records */
name|BIO
modifier|*
name|ds
decl_stmt|;
comment|/** do we want to use this anchor? */
name|int
name|use_key
decl_stmt|;
comment|/** the current anchor: Zone */
name|BIO
modifier|*
name|czone
decl_stmt|;
comment|/** the current anchor: KeyTag */
name|BIO
modifier|*
name|ctag
decl_stmt|;
comment|/** the current anchor: Algorithm */
name|BIO
modifier|*
name|calgo
decl_stmt|;
comment|/** the current anchor: DigestType */
name|BIO
modifier|*
name|cdigtype
decl_stmt|;
comment|/** the current anchor: Digest*/
name|BIO
modifier|*
name|cdigest
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** The BIO for the tag */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|xml_selectbio
parameter_list|(
name|struct
name|xml_data
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|BIO
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|tag
argument_list|,
literal|"KeyTag"
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|=
name|data
operator|->
name|ctag
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tag
argument_list|,
literal|"Algorithm"
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|=
name|data
operator|->
name|calgo
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tag
argument_list|,
literal|"DigestType"
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|=
name|data
operator|->
name|cdigtype
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tag
argument_list|,
literal|"Digest"
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|=
name|data
operator|->
name|cdigest
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/**  * XML handle character data, the data inside an element.  * @param userData: xml_data structure  * @param s: the character data.  May not all be in one callback.  * 	NOT zero terminated.  * @param len: length of this part of the data.  */
end_comment

begin_function
specifier|static
name|void
name|xml_charhandle
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|xml_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|xml_data
operator|*
operator|)
name|userData
decl_stmt|;
name|BIO
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
comment|/* skip characters outside of elements */
if|if
condition|(
operator|!
name|data
operator|->
name|tag
condition|)
return|return;
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%s%s charhandle: '"
argument_list|,
name|data
operator|->
name|use_key
condition|?
literal|"use "
else|:
literal|""
argument_list|,
name|data
operator|->
name|tag
condition|?
name|data
operator|->
name|tag
else|:
literal|"none"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|data
operator|->
name|tag
argument_list|,
literal|"Zone"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|BIO_write
argument_list|(
name|data
operator|->
name|czone
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory in BIO_write\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* only store if key is used */
if|if
condition|(
operator|!
name|data
operator|->
name|use_key
condition|)
return|return;
name|b
operator|=
name|xml_selectbio
argument_list|(
name|data
argument_list|,
name|data
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
if|if
condition|(
name|BIO_write
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory in BIO_write\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * XML fetch value of particular attribute(by name) or NULL if not present.  * @param atts: attribute array (from xml_startelem).  * @param name: name of attribute to look for.  * @return the value or NULL. (ptr into atts).  */
end_comment

begin_function
specifier|static
specifier|const
name|XML_Char
modifier|*
name|find_att
parameter_list|(
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|atts
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|atts
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|atts
index|[
name|i
operator|+
literal|1
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * XML convert DateTime element to time_t.  * [-]CCYY-MM-DDThh:mm:ss[Z|(+|-)hh:mm]  * (with optional .ssssss fractional seconds)  * @param str: the string  * @return a time_t representation or 0 on failure.  */
end_comment

begin_function
specifier|static
name|time_t
name|xml_convertdate
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|time_t
name|t
init|=
literal|0
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* for this application, ignore minus in front; 	 * only positive dates are expected */
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse initial content of the string (lots of whitespace allowed) */
name|s
operator|=
name|strptime
argument_list|(
name|s
argument_list|,
literal|"%t%Y%t-%t%m%t-%t%d%tT%t%H%t:%t%M%t:%t%S%t"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"xml_convertdate parse failure %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* parse remainder of date string */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
comment|/* optional '.' and fractional seconds */
name|int
name|frac
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"%d%n"
argument_list|,
operator|&
name|frac
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"xml_convertdate f failure %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* fraction is not used, time_t has second accuracy */
name|s
operator|++
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'Z'
operator|||
operator|*
name|s
operator|==
literal|'z'
condition|)
block|{
comment|/* nothing to do for this */
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
comment|/* optional timezone spec: Z or +hh:mm or -hh:mm */
name|int
name|hr
init|=
literal|0
decl_stmt|,
name|mn
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"%d:%d%n"
argument_list|,
operator|&
name|hr
argument_list|,
operator|&
name|mn
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"xml_convertdate tz failure %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|+=
name|hr
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|+=
name|mn
expr_stmt|;
block|}
else|else
block|{
name|tm
operator|.
name|tm_hour
operator|-=
name|hr
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|-=
name|mn
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
comment|/* not ended properly */
comment|/* but ignore, (lenient) */
block|}
name|t
operator|=
name|sldns_mktime_from_utc
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"xml_convertdate mktime failure\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/**  * XML handle the KeyDigest start tag, check validity periods.  */
end_comment

begin_function
specifier|static
name|void
name|handle_keydigest
parameter_list|(
name|struct
name|xml_data
modifier|*
name|data
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|data
operator|->
name|use_key
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|find_att
argument_list|(
name|atts
argument_list|,
literal|"validFrom"
argument_list|)
condition|)
block|{
name|time_t
name|from
init|=
name|xml_convertdate
argument_list|(
name|find_att
argument_list|(
name|atts
argument_list|,
literal|"validFrom"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"error: xml cannot be parsed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|date
operator|<
name|from
condition|)
return|return;
block|}
if|if
condition|(
name|find_att
argument_list|(
name|atts
argument_list|,
literal|"validUntil"
argument_list|)
condition|)
block|{
name|time_t
name|until
init|=
name|xml_convertdate
argument_list|(
name|find_att
argument_list|(
name|atts
argument_list|,
literal|"validUntil"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|until
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"error: xml cannot be parsed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|date
operator|>
name|until
condition|)
return|return;
block|}
comment|/* yes we want to use this key */
name|data
operator|->
name|use_key
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|data
operator|->
name|ctag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|data
operator|->
name|calgo
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|data
operator|->
name|cdigtype
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|data
operator|->
name|cdigest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** See if XML element equals the zone name */
end_comment

begin_function
specifier|static
name|int
name|xml_is_zone_name
parameter_list|(
name|BIO
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|z
init|=
name|NULL
decl_stmt|;
name|long
name|zlen
decl_stmt|;
operator|(
name|void
operator|)
name|BIO_seek
argument_list|(
name|zone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zlen
operator|=
name|BIO_get_mem_data
argument_list|(
name|zone
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zlen
operator|||
operator|!
name|z
condition|)
return|return
literal|0
return|;
comment|/* zero terminate */
if|if
condition|(
name|zlen
operator|>=
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
name|memmove
argument_list|(
name|buf
argument_list|,
name|z
argument_list|,
operator|(
name|size_t
operator|)
name|zlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|zlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* compare */
return|return
operator|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   * XML start of element. This callback is called whenever an XML tag starts.  * XML_Char is UTF8.  * @param userData: the xml_data structure.  * @param name: the tag that starts.  * @param atts: array of strings, pairs of attr = value, ends with NULL.  * 	i.e. att[0]="att[1]" att[2]="att[3]" att[4]isNull  */
end_comment

begin_function
specifier|static
name|void
name|xml_startelem
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|xml_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|xml_data
operator|*
operator|)
name|userData
decl_stmt|;
name|BIO
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"xml tag start '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|tag
argument_list|)
expr_stmt|;
name|data
operator|->
name|tag
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|atts
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|printf
argument_list|(
literal|"  %s='%s'\n"
argument_list|,
name|atts
index|[
name|i
index|]
argument_list|,
name|atts
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* handle attributes to particular types */
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"KeyDigest"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|handle_keydigest
argument_list|(
name|data
argument_list|,
name|atts
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"Zone"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|data
operator|->
name|czone
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* for other types we prepare to pick up the data */
if|if
condition|(
operator|!
name|data
operator|->
name|use_key
condition|)
return|return;
name|b
operator|=
name|xml_selectbio
argument_list|(
name|data
argument_list|,
name|data
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
comment|/* empty it */
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Append str to bio */
end_comment

begin_function
specifier|static
name|void
name|xml_append_str
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|BIO_write
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory in BIO_write\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Append bio to bio */
end_comment

begin_function
specifier|static
name|void
name|xml_append_bio
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|BIO
modifier|*
name|a
parameter_list|)
block|{
name|char
modifier|*
name|z
init|=
name|NULL
decl_stmt|;
name|long
name|i
decl_stmt|,
name|len
decl_stmt|;
operator|(
name|void
operator|)
name|BIO_seek
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|BIO_get_mem_data
argument_list|(
name|a
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|z
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory in BIO_write\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* remove newlines in the data here */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\r'
operator|||
name|z
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|z
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* write to BIO */
if|if
condition|(
name|BIO_write
argument_list|(
name|b
argument_list|,
name|z
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory in BIO_write\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** write the parsed xml-DS to the DS list */
end_comment

begin_function
specifier|static
name|void
name|xml_append_ds
parameter_list|(
name|struct
name|xml_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* write DS to accumulated DS */
name|xml_append_str
argument_list|(
name|data
operator|->
name|ds
argument_list|,
literal|". IN DS "
argument_list|)
expr_stmt|;
name|xml_append_bio
argument_list|(
name|data
operator|->
name|ds
argument_list|,
name|data
operator|->
name|ctag
argument_list|)
expr_stmt|;
name|xml_append_str
argument_list|(
name|data
operator|->
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|xml_append_bio
argument_list|(
name|data
operator|->
name|ds
argument_list|,
name|data
operator|->
name|calgo
argument_list|)
expr_stmt|;
name|xml_append_str
argument_list|(
name|data
operator|->
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|xml_append_bio
argument_list|(
name|data
operator|->
name|ds
argument_list|,
name|data
operator|->
name|cdigtype
argument_list|)
expr_stmt|;
name|xml_append_str
argument_list|(
name|data
operator|->
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|xml_append_bio
argument_list|(
name|data
operator|->
name|ds
argument_list|,
name|data
operator|->
name|cdigest
argument_list|)
expr_stmt|;
name|xml_append_str
argument_list|(
name|data
operator|->
name|ds
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|data
operator|->
name|num_keys
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * XML end of element. This callback is called whenever an XML tag ends.  * XML_Char is UTF8.  * @param userData: the xml_data structure  * @param name: the tag that ends.  */
end_comment

begin_function
specifier|static
name|void
name|xml_endelem
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|xml_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|xml_data
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"xml tag end   '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|tag
argument_list|)
expr_stmt|;
name|data
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"KeyDigest"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|use_key
condition|)
name|xml_append_ds
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|use_key
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"Zone"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xml_is_zone_name
argument_list|(
name|data
operator|->
name|czone
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"xml not for the right zone\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Stop the parser when an entity declaration is encountered. For safety. */
end_comment

begin_function
specifier|static
name|void
name|xml_entitydeclhandler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|entityName
parameter_list|)
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|is_parameter_entity
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|value
parameter_list|)
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|value_length
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|base
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|systemId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|publicId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|notationName
parameter_list|)
parameter_list|)
block|{
if|#
directive|if
name|HAVE_DECL_XML_STOPPARSER
operator|(
name|void
operator|)
name|XML_StopParser
argument_list|(
operator|(
name|XML_Parser
operator|)
name|userData
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|userData
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * XML parser setup of the callbacks for the tags  */
end_comment

begin_function
specifier|static
name|void
name|xml_parse_setup
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|struct
name|xml_data
modifier|*
name|data
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|parser
operator|=
name|parser
expr_stmt|;
name|data
operator|->
name|date
operator|=
name|now
expr_stmt|;
name|data
operator|->
name|ds
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|->
name|ctag
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|->
name|czone
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|->
name|calgo
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|->
name|cdigtype
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|->
name|cdigest
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|ds
operator|||
operator|!
name|data
operator|->
name|ctag
operator|||
operator|!
name|data
operator|->
name|calgo
operator|||
operator|!
name|data
operator|->
name|czone
operator|||
operator|!
name|data
operator|->
name|cdigtype
operator|||
operator|!
name|data
operator|->
name|cdigest
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"; created by unbound-anchor on %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BIO_write
argument_list|(
name|data
operator|->
name|ds
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|XML_SetEntityDeclHandler
argument_list|(
name|parser
argument_list|,
name|xml_entitydeclhandler
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_startelem
argument_list|,
name|xml_endelem
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|xml_charhandle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Perform XML parsing of the root-anchors file  * Its format description can be read here  * https://data.iana.org/root-anchors/draft-icann-dnssec-trust-anchor.txt  * It uses libexpat.  * @param xml: BIO with xml data.  * @param now: the current time for checking DS validity periods.  * @return memoryBIO with the DS data in zone format.  * 	or NULL if the zone is insecure.  * 	(It exit()s on error)  */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|xml_parse
parameter_list|(
name|BIO
modifier|*
name|xml
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|char
modifier|*
name|pp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|XML_Parser
name|parser
decl_stmt|;
name|struct
name|xml_data
name|data
decl_stmt|;
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parser
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not XML_ParserCreate\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* setup callbacks */
name|xml_parse_setup
argument_list|(
name|parser
argument_list|,
operator|&
name|data
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* parse it */
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|xml
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|BIO_get_mem_data
argument_list|(
name|xml
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|pp
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|pp
argument_list|,
name|len
argument_list|,
literal|1
comment|/*isfinal*/
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|e
init|=
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"XML_Parse failure %s\n"
argument_list|,
name|e
condition|?
name|e
else|:
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* parsed */
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"XML was parsed successfully, %d keys\n"
argument_list|,
name|data
operator|.
name|num_keys
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|.
name|tag
argument_list|)
expr_stmt|;
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|BIO_seek
argument_list|(
name|data
operator|.
name|ds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|BIO_get_mem_data
argument_list|(
name|data
operator|.
name|ds
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"got DS bio %d: '"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|pp
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
condition|)
comment|/* compilers do not allow us to ignore fwrite .. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing to stdout\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
name|BIO_free
argument_list|(
name|data
operator|.
name|czone
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|data
operator|.
name|ctag
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|data
operator|.
name|calgo
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|data
operator|.
name|cdigtype
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|data
operator|.
name|cdigest
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|num_keys
operator|==
literal|0
condition|)
block|{
comment|/* the root zone seems to have gone insecure */
name|BIO_free
argument_list|(
name|data
operator|.
name|ds
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|data
operator|.
name|ds
return|;
block|}
block|}
end_function

begin_comment
comment|/* get key usage out of its extension, returns 0 if no key_usage extension */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_usage_of_ex
parameter_list|(
name|X509
modifier|*
name|cert
parameter_list|)
block|{
name|unsigned
name|long
name|val
init|=
literal|0
decl_stmt|;
name|ASN1_BIT_STRING
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|X509_get_ext_d2i
argument_list|(
name|cert
argument_list|,
name|NID_key_usage
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|length
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|s
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|length
operator|>
literal|1
condition|)
name|val
operator||=
name|s
operator|->
name|data
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
block|}
name|ASN1_BIT_STRING_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/** get valid signers from the list of signers in the signature */
end_comment

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|get_valid_signers
argument_list|(
argument|PKCS7* p7
argument_list|,
argument|const char* p7signer
argument_list|)
block|{
name|int
name|i
block|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|validsigners
operator|=
name|sk_X509_new_null
argument_list|()
block|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|signers
operator|=
name|PKCS7_get0_signers
argument_list|(
name|p7
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
block|;
name|unsigned
name|long
name|usage
operator|=
literal|0
block|;
if|if
condition|(
operator|!
name|validsigners
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|sk_X509_free
argument_list|(
name|signers
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|signers
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"no signers in pkcs7 signature\n"
argument_list|)
expr_stmt|;
name|sk_X509_free
argument_list|(
name|validsigners
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_if

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|signers
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|X509_NAME
modifier|*
name|nm
init|=
name|X509_get_subject_name
argument_list|(
name|sk_X509_value
argument_list|(
name|signers
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"signer %d: cert has no subject name\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|verb
operator|&&
name|nm
condition|)
block|{
name|char
modifier|*
name|nmline
init|=
name|X509_NAME_oneline
argument_list|(
name|nm
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"signer %d: Subject: %s\n"
argument_list|,
name|i
argument_list|,
name|nmline
condition|?
name|nmline
else|:
literal|"no subject"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|3
operator|&&
name|X509_NAME_get_text_by_NID
argument_list|(
name|nm
argument_list|,
name|NID_commonName
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"commonName: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|3
operator|&&
name|X509_NAME_get_text_by_NID
argument_list|(
name|nm
argument_list|,
name|NID_pkcs9_emailAddress
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"emailAddress: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verb
condition|)
block|{
name|int
name|ku_loc
init|=
name|X509_get_ext_by_NID
argument_list|(
name|sk_X509_value
argument_list|(
name|signers
argument_list|,
name|i
argument_list|)
argument_list|,
name|NID_key_usage
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|3
operator|&&
name|ku_loc
operator|>=
literal|0
condition|)
block|{
name|X509_EXTENSION
modifier|*
name|ex
init|=
name|X509_get_ext
argument_list|(
name|sk_X509_value
argument_list|(
name|signers
argument_list|,
name|i
argument_list|)
argument_list|,
name|ku_loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
condition|)
block|{
name|printf
argument_list|(
literal|"keyUsage: "
argument_list|)
expr_stmt|;
name|X509V3_EXT_print_fp
argument_list|(
name|stdout
argument_list|,
name|ex
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|p7signer
operator|||
name|strcmp
argument_list|(
name|p7signer
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* there is no name to check, return all records */
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"did not check commonName of signer\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|X509_NAME_get_text_by_NID
argument_list|(
name|nm
argument_list|,
name|NID_pkcs9_emailAddress
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"removed cert with no name\n"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* no name, no use */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|p7signer
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"removed cert with wrong name\n"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* wrong name, skip it */
block|}
block|}
comment|/* check that the key usage allows digital signatures 		 * (the p7s) */
name|usage
operator|=
name|get_usage_of_ex
argument_list|(
name|sk_X509_value
argument_list|(
name|signers
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|usage
operator|&
name|KU_DIGITAL_SIGNATURE
operator|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"removed cert with no key usage Digital Signature allowed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we like this cert, add it to our list of valid 		 * signers certificates */
name|sk_X509_push
argument_list|(
name|validsigners
argument_list|,
name|sk_X509_value
argument_list|(
name|signers
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|sk_X509_free
argument_list|(
name|signers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|validsigners
return|;
end_return

begin_comment
unit|}
comment|/** verify a PKCS7 signature, false on failure */
end_comment

begin_decl_stmt
unit|static
name|int
name|verify_p7sig
argument_list|(
name|BIO
operator|*
name|data
argument_list|,
name|BIO
operator|*
name|p7s
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|trust
argument_list|,
specifier|const
name|char
operator|*
name|p7signer
argument_list|)
block|{
name|PKCS7
modifier|*
name|p7
decl_stmt|;
name|X509_STORE
modifier|*
name|store
init|=
name|X509_STORE_new
argument_list|()
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|validsigners
expr_stmt|;
name|int
name|secure
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|X509_V_FLAG_CHECK_SS_SIGNATURE
name|X509_VERIFY_PARAM
modifier|*
name|param
init|=
name|X509_VERIFY_PARAM_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|param
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* do the selfcheck on the root certificate; it checks that the 	 * input is valid */
name|X509_VERIFY_PARAM_set_flags
argument_list|(
name|param
argument_list|,
name|X509_V_FLAG_CHECK_SS_SIGNATURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
condition|)
name|X509_STORE_set1_param
argument_list|(
name|store
argument_list|,
name|param
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|store
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|X509_V_FLAG_CHECK_SS_SIGNATURE
name|X509_VERIFY_PARAM_free
argument_list|(
name|param
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|X509_V_FLAG_CHECK_SS_SIGNATURE
name|X509_VERIFY_PARAM_free
argument_list|(
name|param
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|p7s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* convert p7s to p7 (the signature) */
name|p7
operator|=
name|d2i_PKCS7_bio
argument_list|(
name|p7s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p7
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"could not parse p7s signature file\n"
argument_list|)
expr_stmt|;
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"parsed the PKCS7 signature\n"
argument_list|)
expr_stmt|;
comment|/* convert trust to trusted certificate store */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|trust
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|X509_STORE_add_cert
argument_list|(
name|store
argument_list|,
name|sk_X509_value
argument_list|(
name|trust
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"failed X509_STORE_add_cert\n"
argument_list|)
expr_stmt|;
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|PKCS7_free
argument_list|(
name|p7
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"setup the X509_STORE\n"
argument_list|)
expr_stmt|;
comment|/* check what is in the Subject name of the certificates, 	 * and build a stack that contains only the right certificates */
name|validsigners
operator|=
name|get_valid_signers
argument_list|(
name|p7
argument_list|,
name|p7signer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validsigners
condition|)
block|{
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|PKCS7_free
argument_list|(
name|p7
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|PKCS7_verify
argument_list|(
name|p7
argument_list|,
name|validsigners
argument_list|,
name|store
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
name|PKCS7_NOINTERN
argument_list|)
operator|==
literal|1
condition|)
block|{
name|secure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"the PKCS7 signature verified\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verb
condition|)
block|{
name|ERR_print_errors_fp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|sk_X509_free
argument_list|(
name|validsigners
argument_list|)
expr_stmt|;
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|PKCS7_free
argument_list|(
name|p7
argument_list|)
expr_stmt|;
return|return
name|secure
return|;
block|}
end_decl_stmt

begin_comment
comment|/** write unsigned root anchor file, a 5011 revoked tp */
end_comment

begin_function
specifier|static
name|void
name|write_unsigned_root
parameter_list|(
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|root_anchor_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|root_anchor_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"; autotrust trust anchor file\n"
literal|";;REVOKED\n"
literal|";;id: . 1\n"
literal|"; This file was written by unbound-anchor on %s"
literal|"; It indicates that the root does not use DNSSEC\n"
literal|"; to restart DNSSEC overwrite this file with a\n"
literal|"; valid trustanchor or (empty-it and run unbound-anchor)\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"failed to write 'unsigned' to %s\n"
argument_list|,
name|root_anchor_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|&&
name|errno
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FSYNC
name|fsync
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FlushFileBuffers
argument_list|(
operator|(
name|HANDLE
operator|)
name|_fileno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** write root anchor file */
end_comment

begin_function
specifier|static
name|void
name|write_root_anchor
parameter_list|(
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|,
name|BIO
modifier|*
name|ds
parameter_list|)
block|{
name|char
modifier|*
name|pp
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
operator|(
name|void
operator|)
name|BIO_seek
argument_list|(
name|ds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|BIO_get_mem_data
argument_list|(
name|ds
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|pp
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
operator|=
name|fopen
argument_list|(
name|root_anchor_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|root_anchor_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|pp
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
literal|1
argument_list|,
name|out
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"failed to write all data to %s\n"
argument_list|,
name|root_anchor_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|&&
name|errno
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FSYNC
name|fsync
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FlushFileBuffers
argument_list|(
operator|(
name|HANDLE
operator|)
name|_fileno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Perform the verification and update of the trustanchor file */
end_comment

begin_decl_stmt
specifier|static
name|void
name|verify_and_update_anchor
argument_list|(
specifier|const
name|char
operator|*
name|root_anchor_file
argument_list|,
name|BIO
operator|*
name|xml
argument_list|,
name|BIO
operator|*
name|p7s
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|cert
argument_list|,
specifier|const
name|char
operator|*
name|p7signer
argument_list|)
block|{
name|BIO
modifier|*
name|ds
decl_stmt|;
comment|/* verify xml file */
if|if
condition|(
operator|!
name|verify_p7sig
argument_list|(
name|xml
argument_list|,
name|p7s
argument_list|,
name|cert
argument_list|,
name|p7signer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"the PKCS7 signature failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* parse the xml file into DS records */
name|ds
operator|=
name|xml_parse
argument_list|(
name|xml
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ds
condition|)
block|{
comment|/* the root zone is unsigned now */
name|write_unsigned_root
argument_list|(
name|root_anchor_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reinstate 5011 tracking */
name|write_root_anchor
argument_list|(
name|root_anchor_file
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
name|BIO_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_function
specifier|static
name|void
name|do_wsa_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|WSACleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** perform actual certupdate work */
end_comment

begin_function
specifier|static
name|int
name|do_certupdate
parameter_list|(
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|,
specifier|const
name|char
modifier|*
name|root_cert_file
parameter_list|,
specifier|const
name|char
modifier|*
name|urlname
parameter_list|,
specifier|const
name|char
modifier|*
name|xmlname
parameter_list|,
specifier|const
name|char
modifier|*
name|p7sname
parameter_list|,
specifier|const
name|char
modifier|*
name|p7signer
parameter_list|,
specifier|const
name|char
modifier|*
name|res_conf
parameter_list|,
specifier|const
name|char
modifier|*
name|root_hints
parameter_list|,
specifier|const
name|char
modifier|*
name|debugconf
parameter_list|,
name|int
name|ip4only
parameter_list|,
name|int
name|ip6only
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|ub_result
modifier|*
name|dnskey
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|cert
expr_stmt|;
name|BIO
modifier|*
name|xml
decl_stmt|,
modifier|*
name|p7s
decl_stmt|;
name|struct
name|ip_list
modifier|*
name|ip_list
init|=
name|NULL
decl_stmt|;
comment|/* read pem file or provide builtin */
name|cert
operator|=
name|read_cert_or_builtin
argument_list|(
name|root_cert_file
argument_list|)
expr_stmt|;
comment|/* lookup A, AAAA for the urlname (or parse urlname if IP address) */
name|ip_list
operator|=
name|resolve_name
argument_list|(
name|urlname
argument_list|,
name|port
argument_list|,
name|res_conf
argument_list|,
name|root_hints
argument_list|,
name|debugconf
argument_list|,
name|ip4only
argument_list|,
name|ip6only
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
literal|1
condition|)
block|{
comment|/* libunbound finished, startup WSA for the https connection */
name|WSADATA
name|wsa_data
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"WSAStartup failed: %s\n"
argument_list|,
name|wsa_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|atexit
argument_list|(
operator|&
name|do_wsa_cleanup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* fetch the necessary files over HTTPS */
name|xml
operator|=
name|https
argument_list|(
name|ip_list
argument_list|,
name|xmlname
argument_list|,
name|urlname
argument_list|)
expr_stmt|;
name|p7s
operator|=
name|https
argument_list|(
name|ip_list
argument_list|,
name|p7sname
argument_list|,
name|urlname
argument_list|)
expr_stmt|;
comment|/* verify and update the root anchor */
name|verify_and_update_anchor
argument_list|(
name|root_anchor_file
argument_list|,
name|xml
argument_list|,
name|p7s
argument_list|,
name|cert
argument_list|,
name|p7signer
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"success: the anchor has been updated "
literal|"using the cert\n"
argument_list|)
expr_stmt|;
name|free_file_bio
argument_list|(
name|xml
argument_list|)
expr_stmt|;
name|free_file_bio
argument_list|(
name|p7s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|sk_X509_pop_free
argument_list|(
name|cert
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ub_resolve_free
argument_list|(
name|dnskey
argument_list|)
expr_stmt|;
name|ip_list_free
argument_list|(
name|ip_list
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Try to read the root RFC5011 autotrust anchor file,  * @param file: filename.  * @return:  * 	0 if does not exist or empty  * 	1 if trust-point-revoked-5011  * 	2 if it is OK.  */
end_comment

begin_function
specifier|static
name|int
name|try_read_anchor
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|empty
init|=
literal|1
decl_stmt|;
name|char
name|line
index|[
literal|10240
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
comment|/* only if the file does not exist, can we fix it */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"error: cannot access the file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s does not exist\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;REVOKED"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s : the trust point is revoked\n"
literal|"and the zone is considered unsigned.\n"
literal|"if you wish to re-enable, delete the file\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
continue|continue;
comment|/* this line is a line of content */
name|empty
operator|=
literal|0
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s is empty\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s has content\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/** Write the builtin root anchor to a file */
end_comment

begin_function
specifier|static
name|void
name|write_builtin_anchor
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|builtin_root_anchor
init|=
name|get_builtin_ds
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"  could not write builtin anchor\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|builtin_root_anchor
argument_list|,
name|strlen
argument_list|(
name|builtin_root_anchor
argument_list|)
argument_list|,
literal|1
argument_list|,
name|out
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"  could not complete write builtin anchor\n"
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Check the root anchor file.  * If does not exist, provide builtin and write file.  * If empty, provide builtin and write file.  * If trust-point-revoked-5011 file: make the program exit.  * @param root_anchor_file: filename of the root anchor.  * @param used_builtin: set to 1 if the builtin is written.  * @return 0 if trustpoint is insecure, 1 on success.  Exit on failure.  */
end_comment

begin_function
specifier|static
name|int
name|provide_builtin
parameter_list|(
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|,
name|int
modifier|*
name|used_builtin
parameter_list|)
block|{
comment|/* try to read it */
switch|switch
condition|(
name|try_read_anchor
argument_list|(
name|root_anchor_file
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* no exist or empty */
name|write_builtin_anchor
argument_list|(
name|root_anchor_file
argument_list|)
expr_stmt|;
operator|*
name|used_builtin
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* revoked tp */
return|return
literal|0
return|;
case|case
literal|2
case|:
comment|/* it is fine */
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * add an autotrust anchor for the root to the context  */
end_comment

begin_function
specifier|static
name|void
name|add_5011_probe_root
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|ub_ctx_set_option
argument_list|(
name|ctx
argument_list|,
literal|"auto-trust-anchor-file:"
argument_list|,
name|root_anchor_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"add 5011 probe to ctx: %s\n"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Prime the root key and return the result.  Exit on error.  * @param ctx: the unbound context to perform the priming with.  * @return: the result of the prime, on error it exit()s.  */
end_comment

begin_function
specifier|static
name|struct
name|ub_result
modifier|*
name|prime_root_key
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|ub_result
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|ub_resolve
argument_list|(
name|ctx
argument_list|,
literal|"."
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"resolve DNSKEY: %s\n"
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/** see if ADDPEND keys exist in autotrust file (if possible) */
end_comment

begin_function
specifier|static
name|int
name|read_if_pending_keys
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|line
index|[
literal|8192
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"[ ADDPEND ]"
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"RFC5011-state has ADDPEND keys\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** read last successful probe time from autotrust file (if possible) */
end_comment

begin_function
specifier|static
name|int32_t
name|read_last_success_time
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|";;last_success: "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|time_t
name|x
init|=
operator|(
name|unsigned
name|int
operator|)
name|strtol
argument_list|(
name|line
operator|+
literal|16
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|+
literal|16
operator|==
name|e
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"failed to parse "
literal|"last_success probe time\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"last successful probe: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|int32_t
operator|)
name|x
return|;
block|}
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"no last_success probe time in anchor file\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Read autotrust 5011 probe file and see if the date  * compared to the current date allows a certupdate.  * If the last successful probe was recent then 5011 cannot be behind,  * and the failure cannot be solved with a certupdate.  * The debugconf is to validation-override the date for testing.  * @param root_anchor_file: filename of root key  * @return true if certupdate is ok.  */
end_comment

begin_function
specifier|static
name|int
name|probe_date_allows_certupdate
parameter_list|(
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|)
block|{
name|int
name|has_pending_keys
init|=
name|read_if_pending_keys
argument_list|(
name|root_anchor_file
argument_list|)
decl_stmt|;
name|int32_t
name|last_success
init|=
name|read_last_success_time
argument_list|(
name|root_anchor_file
argument_list|)
decl_stmt|;
name|int32_t
name|now
init|=
operator|(
name|int32_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int32_t
name|leeway
init|=
literal|30
operator|*
literal|24
operator|*
literal|3600
decl_stmt|;
comment|/* 30 days leeway */
comment|/* if the date is before 2010-07-15:00.00.00 then the root has not 	 * been signed yet, and thus we refuse to take action. */
if|if
condition|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|<
name|xml_convertdate
argument_list|(
literal|"2010-07-15T00:00:00"
argument_list|)
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"the date is before the root was first signed,"
literal|" please correct the clock\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|last_success
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* no probe time */
if|if
condition|(
name|has_pending_keys
condition|)
return|return
literal|1
return|;
comment|/* key in ADDPEND state, a previous probe has 		inserted that, and it was present in all recent probes, 		but it has not become active.  The 30 day timer may not have 		expired, but we know(for sure) there is a rollover going on. 		If we only managed to pickup the new key on its last day 		of announcement (for example) this can happen. */
if|if
condition|(
name|now
operator|-
name|last_success
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"the last successful probe is in the future,"
literal|" clock was modified\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|now
operator|-
name|last_success
operator|>=
name|leeway
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"the last successful probe was more than 30 "
literal|"days ago\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"the last successful probe is recent\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** perform the unbound-anchor work */
end_comment

begin_function
specifier|static
name|int
name|do_root_update_work
parameter_list|(
specifier|const
name|char
modifier|*
name|root_anchor_file
parameter_list|,
specifier|const
name|char
modifier|*
name|root_cert_file
parameter_list|,
specifier|const
name|char
modifier|*
name|urlname
parameter_list|,
specifier|const
name|char
modifier|*
name|xmlname
parameter_list|,
specifier|const
name|char
modifier|*
name|p7sname
parameter_list|,
specifier|const
name|char
modifier|*
name|p7signer
parameter_list|,
specifier|const
name|char
modifier|*
name|res_conf
parameter_list|,
specifier|const
name|char
modifier|*
name|root_hints
parameter_list|,
specifier|const
name|char
modifier|*
name|debugconf
parameter_list|,
name|int
name|ip4only
parameter_list|,
name|int
name|ip6only
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|ub_ctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ub_result
modifier|*
name|dnskey
decl_stmt|;
name|int
name|used_builtin
init|=
literal|0
decl_stmt|;
comment|/* see if builtin rootanchor needs to be provided, or if 	 * rootanchor is 'revoked-trust-point' */
if|if
condition|(
operator|!
name|provide_builtin
argument_list|(
name|root_anchor_file
argument_list|,
operator|&
name|used_builtin
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* make unbound context with 5011-probe for root anchor, 	 * and probe . DNSKEY */
name|ctx
operator|=
name|create_unbound_context
argument_list|(
name|res_conf
argument_list|,
name|root_hints
argument_list|,
name|debugconf
argument_list|,
name|ip4only
argument_list|,
name|ip6only
argument_list|)
expr_stmt|;
name|add_5011_probe_root
argument_list|(
name|ctx
argument_list|,
name|root_anchor_file
argument_list|)
expr_stmt|;
name|dnskey
operator|=
name|prime_root_key
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ub_ctx_delete
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* if secure: exit */
if|if
condition|(
name|dnskey
operator|->
name|secure
operator|&&
operator|!
name|force
condition|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"success: the anchor is ok\n"
argument_list|)
expr_stmt|;
name|ub_resolve_free
argument_list|(
name|dnskey
argument_list|)
expr_stmt|;
return|return
name|used_builtin
return|;
block|}
if|if
condition|(
name|force
operator|&&
name|verb
condition|)
name|printf
argument_list|(
literal|"debug cert update forced\n"
argument_list|)
expr_stmt|;
comment|/* if not (and NOERROR): check date and do certupdate */
if|if
condition|(
operator|(
name|dnskey
operator|->
name|rcode
operator|==
literal|0
operator|&&
name|probe_date_allows_certupdate
argument_list|(
name|root_anchor_file
argument_list|)
operator|)
operator|||
name|force
condition|)
block|{
if|if
condition|(
name|do_certupdate
argument_list|(
name|root_anchor_file
argument_list|,
name|root_cert_file
argument_list|,
name|urlname
argument_list|,
name|xmlname
argument_list|,
name|p7sname
argument_list|,
name|p7signer
argument_list|,
name|res_conf
argument_list|,
name|root_hints
argument_list|,
name|debugconf
argument_list|,
name|ip4only
argument_list|,
name|ip6only
argument_list|,
name|port
argument_list|,
name|dnskey
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|used_builtin
return|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"fail: the anchor is NOT ok and could not be fixed\n"
argument_list|)
expr_stmt|;
name|ub_resolve_free
argument_list|(
name|dnskey
argument_list|)
expr_stmt|;
return|return
name|used_builtin
return|;
block|}
end_function

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** getopt global, in case header files fail to declare it. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Main routine for unbound-anchor */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_anchor_file
init|=
name|ROOT_ANCHOR_FILE
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_cert_file
init|=
name|ROOT_CERT_FILE
decl_stmt|;
specifier|const
name|char
modifier|*
name|urlname
init|=
name|URLNAME
decl_stmt|;
specifier|const
name|char
modifier|*
name|xmlname
init|=
name|XMLNAME
decl_stmt|;
specifier|const
name|char
modifier|*
name|p7sname
init|=
name|P7SNAME
decl_stmt|;
specifier|const
name|char
modifier|*
name|p7signer
init|=
name|P7SIGNER
decl_stmt|;
specifier|const
name|char
modifier|*
name|res_conf
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_hints
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|debugconf
init|=
name|NULL
decl_stmt|;
name|int
name|dolist
init|=
literal|0
decl_stmt|,
name|ip4only
init|=
literal|0
decl_stmt|,
name|ip6only
init|=
literal|0
decl_stmt|,
name|force
init|=
literal|0
decl_stmt|,
name|port
init|=
name|HTTPS_PORT
decl_stmt|;
comment|/* parse the options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46C:FP:a:c:f:hln:r:s:u:vx:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|dolist
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|ip4only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|ip6only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|root_anchor_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|root_cert_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|urlname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xmlname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|p7sname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|p7signer
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|res_conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|root_hints
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|debugconf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|port
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verb
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|ERR_load_SSL_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_library_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|dolist
condition|)
name|do_list_builtin
argument_list|()
expr_stmt|;
return|return
name|do_root_update_work
argument_list|(
name|root_anchor_file
argument_list|,
name|root_cert_file
argument_list|,
name|urlname
argument_list|,
name|xmlname
argument_list|,
name|p7sname
argument_list|,
name|p7signer
argument_list|,
name|res_conf
argument_list|,
name|root_hints
argument_list|,
name|debugconf
argument_list|,
name|ip4only
argument_list|,
name|ip6only
argument_list|,
name|force
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

end_unit

