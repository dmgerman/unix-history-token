begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * unbound-event.h - unbound validating resolver public API with events  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the unbound interface for use with user defined  * pluggable event bases.  *  * Use ub_ctx_create_event_ub_base() to create an unbound context that uses  * the user provided event base API.  Then, use the ub_resolve_event call  * to add DNS resolve queries to the context.  Those then run whith the  * provided event_base, and when they are done you get a function callback.  *  * This method does not fork another process or create a thread, the effort  * is done by the unbound state machines that are connected to the event base.  *  * It is also possible to provide a libevent based event base by using  * ub_ctx_create_event_base().  But you have to use the same libevent that  * unbound was compiled with, otherwise it wouldn't work, the event and  * event_base structures would be different.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_UB_UNBOUND_EVENT_H
end_ifndef

begin_define
define|#
directive|define
name|_UB_UNBOUND_EVENT_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
struct_decl|struct
name|ub_ctx
struct_decl|;
struct_decl|struct
name|ub_result
struct_decl|;
struct_decl|struct
name|event_base
struct_decl|;
comment|/** event timeout */
define|#
directive|define
name|UB_EV_TIMEOUT
value|0x01
comment|/** event fd readable */
define|#
directive|define
name|UB_EV_READ
value|0x02
comment|/** event fd writable */
define|#
directive|define
name|UB_EV_WRITE
value|0x04
comment|/** event signal */
define|#
directive|define
name|UB_EV_SIGNAL
value|0x08
comment|/** event must persist */
define|#
directive|define
name|UB_EV_PERSIST
value|0x10
comment|/** magic number to identify this version of the pluggable event api */
define|#
directive|define
name|UB_EVENT_MAGIC
value|0x44d74d78
struct_decl|struct
name|ub_event
struct_decl|;
struct_decl|struct
name|ub_event_base
struct_decl|;
struct_decl|struct
name|timeval
struct_decl|;
comment|/**  * The Virtual Method Table for and ub_event_base "object"  */
struct|struct
name|ub_event_base_vmt
block|{
comment|/** Destructor for the ub_event_base object, 	 * (not called by libunbound) */
name|void
function_decl|(
modifier|*
name|free
function_decl|)
parameter_list|(
name|struct
name|ub_event_base
modifier|*
parameter_list|)
function_decl|;
comment|/** Run the event loop 	 * (not called by libunbound when using ub_resolve_event) */
name|int
function_decl|(
modifier|*
name|dispatch
function_decl|)
parameter_list|(
name|struct
name|ub_event_base
modifier|*
parameter_list|)
function_decl|;
comment|/** Exit the given event loop */
name|int
function_decl|(
modifier|*
name|loopexit
function_decl|)
parameter_list|(
name|struct
name|ub_event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/** Instantiate a new ub_event associated with this event base */
name|struct
name|ub_event
modifier|*
function_decl|(
modifier|*
name|new_event
function_decl|)
parameter_list|(
name|struct
name|ub_event_base
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|bits
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|/** Instantiate a new signal associated with this event base, 	 * (not called by libunbound) */
name|struct
name|ub_event
modifier|*
function_decl|(
modifier|*
name|new_signal
function_decl|)
parameter_list|(
name|struct
name|ub_event_base
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|/** Create a new ub_event associated with the given wsaevent, 	 * (not called by libunbound) */
name|struct
name|ub_event
modifier|*
function_decl|(
modifier|*
name|winsock_register_wsaevent
function_decl|)
parameter_list|(
name|struct
name|ub_event_base
modifier|*
parameter_list|,
name|void
modifier|*
name|wsaevent
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
block|}
struct|;
comment|/**  * A user defined pluggable event base is registered by providing a  * ub_event_base "object" with the ub_ctx_create_ub_event() function.  * The magic number must be correct and the Virtual Method Table must be  * fully equipped providing the event base API to be used by libunbound.  */
struct|struct
name|ub_event_base
block|{
comment|/** magic must be UB_EVENT_MAGIC (0x44d74d78) */
name|unsigned
name|long
name|magic
decl_stmt|;
comment|/** Virtual Method Table for ub_event_base */
name|struct
name|ub_event_base_vmt
modifier|*
name|vmt
decl_stmt|;
block|}
struct|;
comment|/**  * The Virtual Method Table for and ub_event "object"  */
struct|struct
name|ub_event_vmt
block|{
comment|/** Add event bits for this event to fire on. 	 * The event will be deactivated before this function is called. */
name|void
function_decl|(
modifier|*
name|add_bits
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
comment|/** Configure the event so it will not longer fire on given bits  	 * The event will be deactivated before this function is called. */
name|void
function_decl|(
modifier|*
name|del_bits
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
comment|/** Change or set the file descriptor on the event  	 * The event will be deactivated before this function is called. */
name|void
function_decl|(
modifier|*
name|set_fd
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/** Destructor for the ub_event object */
name|void
function_decl|(
modifier|*
name|free
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|)
function_decl|;
comment|/** Activate the event.  The given timeval is an timeout value. */
name|int
function_decl|(
modifier|*
name|add
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/** Deactivate the event */
name|int
function_decl|(
modifier|*
name|del
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|)
function_decl|;
comment|/** Reconfigure and activate a timeout event */
name|int
function_decl|(
modifier|*
name|add_timer
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|struct
name|ub_event_base
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/** Deactivate the timeout event */
name|int
function_decl|(
modifier|*
name|del_timer
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|)
function_decl|;
comment|/** Activate a signal event (not called by libunbound). */
name|int
function_decl|(
modifier|*
name|add_signal
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/** Deactivate a signal event (not called by libunbound). */
name|int
function_decl|(
modifier|*
name|del_signal
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|)
function_decl|;
comment|/** Destructor for a ub_event associated with a wsaevent, 	 * (not called by libunbound) 	 */
name|void
function_decl|(
modifier|*
name|winsock_unregister_wsaevent
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/** Libunbound will signal the eventloop when a TCP windows socket 	 * will block on next read or write (given by the eventbits), to work 	 * around edge trigger event behaviour of select on windows with TCP. 	 */
name|void
function_decl|(
modifier|*
name|winsock_tcp_wouldblock
function_decl|)
parameter_list|(
name|struct
name|ub_event
modifier|*
parameter_list|,
name|int
name|eventbit
parameter_list|)
function_decl|;
block|}
struct|;
comment|/**  * An "object" comprising a user defined pluggable event.  * The magic number must be correct and the Virtual Method Table must be  * fully equipped providing the ub_event API to be used by libunbound.  */
struct|struct
name|ub_event
block|{
comment|/** magic must be UB_EVENT_MAGIC (0x44d74d78) */
name|unsigned
name|long
name|magic
decl_stmt|;
comment|/** Virtual Method Table for ub_event */
name|struct
name|ub_event_vmt
modifier|*
name|vmt
decl_stmt|;
block|}
struct|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|ub_event_callback_t
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/**  * Create a resolving and validation context.  * The information from /etc/resolv.conf and /etc/hosts is not utilised by  * default. Use ub_ctx_resolvconf and ub_ctx_hosts to read them.  * @param base: the pluggable event base that the caller has created.  *      The unbound context uses this event base.  * @return a new context. default initialisation.  * 	returns NULL on error.  * You must use ub_resolve_event with this context.  * Do not call ub_ctx_async, ub_poll, ub_wait, ub_process, this is all done  * with the event_base.  Setup the options you like with the other functions.  */
name|struct
name|ub_ctx
modifier|*
name|ub_ctx_create_ub_event
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/**  * Create a resolving and validation context.  * The information from /etc/resolv.conf and /etc/hosts is not utilised by  * default. Use ub_ctx_resolvconf and ub_ctx_hosts to read them.  * You have to use the same libevent that unbound was compiled with,  * otherwise it wouldn't work, the event and event_base structures would  * be different.  * @param base: the event base that the caller has created.  The unbound  *	context uses this event base.  * @return a new context. default initialisation.  * 	returns NULL on error.  * You must use ub_resolve_event with this context.  * Do not call ub_ctx_async, ub_poll, ub_wait, ub_process, this is all done  * with the event_base.  Setup the options you like with the other functions.  */
name|struct
name|ub_ctx
modifier|*
name|ub_ctx_create_event
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/**  * Set a new libevent event_base on a context created with ub_ctx_create_event.  * You have to use the same libevent that unbound was compiled with,  * otherwise it wouldn't work, the event and event_base structures would  * be different.  * Any outbound queries will be canceled.  * @param ctx the ub_ctx to update.  Must have been created with ub_ctx_create_event  * @param base the new event_base to attach to the ctx  * @return 0 if OK, else error  */
name|int
name|ub_ctx_set_event
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/**  * Perform resolution and validation of the target name.  * Asynchronous, after a while, the callback will be called with your  * data and the result.  Uses the event_base user installed by creating the  * context with ub_ctx_create_event().  * @param ctx: context with event_base in it.  *	The context is finalized, and can no longer accept all config changes.  * @param name: domain name in text format (a string).  * @param rrtype: type of RR in host order, 1 is A.  * @param rrclass: class of RR in host order, 1 is IN (for internet).  * @param mydata: this data is your own data (you can pass NULL),  * 	and is passed on to the callback function.  * @param callback: this is called on completion of the resolution.  * 	It is called as:  * 	void callback(void* mydata, int rcode, void* packet, int packet_len,  * 		int sec, char* why_bogus)  * 	with mydata: the same as passed here, you may pass NULL,  * 	with rcode: 0 on no error, nonzero for mostly SERVFAIL situations,  *		this is a DNS rcode.  *	with packet: a buffer with DNS wireformat packet with the answer.  *		do not inspect if rcode != 0.  *		do not write or free the packet buffer, it is used internally  *		in unbound (for other callbacks that want the same data).  *	with packet_len: length in bytes of the packet buffer.  *	with sec: 0 if insecure, 1 if bogus, 2 if DNSSEC secure.  *	with why_bogus: text string explaining why it is bogus (or NULL).  *	These point to buffers inside unbound; do not deallocate the packet or  *	error string.  *  * 	If an error happens during processing, your callback will be called  * 	with error set to a nonzero value (and result==NULL).  * 	For localdata (etc/hosts) the callback is called immediately, before  * 	resolve_event returns, async_id=0 is returned.  * @param async_id: if you pass a non-NULL value, an identifier number is  *	returned for the query as it is in progress. It can be used to   *	cancel the query.  * @return 0 if OK, else error.  */
name|int
name|ub_resolve_event
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|rrtype
parameter_list|,
name|int
name|rrclass
parameter_list|,
name|void
modifier|*
name|mydata
parameter_list|,
name|ub_event_callback_t
name|callback
parameter_list|,
name|int
modifier|*
name|async_id
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _UB_UNBOUND_H */
end_comment

end_unit

