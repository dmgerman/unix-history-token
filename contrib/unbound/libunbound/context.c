begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * libunbound/context.c - validating context for unbound internal use  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the validator context structure.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/context.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"services/modstack.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_function
name|int
name|context_finalize
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|ctx
operator|->
name|env
operator|->
name|cfg
decl_stmt|;
name|verbosity
operator|=
name|cfg
operator|->
name|verbosity
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|logfile_override
condition|)
name|log_file
argument_list|(
name|ctx
operator|->
name|log_out
argument_list|)
expr_stmt|;
else|else
name|log_init
argument_list|(
name|cfg
operator|->
name|logfile
argument_list|,
name|cfg
operator|->
name|use_syslog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|config_apply
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modstack_setup
argument_list|(
operator|&
name|ctx
operator|->
name|mods
argument_list|,
name|cfg
operator|->
name|module_conf
argument_list|,
name|ctx
operator|->
name|env
argument_list|)
condition|)
return|return
name|UB_INITFAIL
return|;
name|ctx
operator|->
name|local_zones
operator|=
name|local_zones_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|local_zones
condition|)
return|return
name|UB_NOMEM
return|;
if|if
condition|(
operator|!
name|local_zones_apply_cfg
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|cfg
argument_list|)
condition|)
return|return
name|UB_INITFAIL
return|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
operator|->
name|msg_cache
operator|||
name|cfg
operator|->
name|msg_cache_size
operator|!=
name|slabhash_get_size
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
operator|||
name|cfg
operator|->
name|msg_cache_slabs
operator|!=
name|ctx
operator|->
name|env
operator|->
name|msg_cache
operator|->
name|size
condition|)
block|{
name|slabhash_delete
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|env
operator|->
name|msg_cache
operator|=
name|slabhash_create
argument_list|(
name|cfg
operator|->
name|msg_cache_slabs
argument_list|,
name|HASH_DEFAULT_STARTARRAY
argument_list|,
name|cfg
operator|->
name|msg_cache_size
argument_list|,
name|msgreply_sizefunc
argument_list|,
name|query_info_compare
argument_list|,
name|query_entry_delete
argument_list|,
name|reply_info_delete
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
operator|->
name|msg_cache
condition|)
return|return
name|UB_NOMEM
return|;
block|}
name|ctx
operator|->
name|env
operator|->
name|rrset_cache
operator|=
name|rrset_cache_adjust
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|ctx
operator|->
name|env
operator|->
name|cfg
argument_list|,
name|ctx
operator|->
name|env
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
operator|->
name|rrset_cache
condition|)
return|return
name|UB_NOMEM
return|;
name|ctx
operator|->
name|env
operator|->
name|infra_cache
operator|=
name|infra_adjust
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|infra_cache
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
operator|->
name|infra_cache
condition|)
return|return
name|UB_NOMEM
return|;
name|ctx
operator|->
name|finalized
operator|=
literal|1
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|context_query_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|a
operator|<
operator|*
operator|(
name|int
operator|*
operator|)
name|b
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|a
operator|>
operator|*
operator|(
name|int
operator|*
operator|)
name|b
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|context_query_delete
parameter_list|(
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|)
block|{
if|if
condition|(
operator|!
name|q
condition|)
return|return;
name|ub_resolve_free
argument_list|(
name|q
operator|->
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** How many times to try to find an unused query-id-number for async */
end_comment

begin_define
define|#
directive|define
name|NUM_ID_TRIES
value|100000
end_define

begin_comment
comment|/** find next useful id number of 0 on error */
end_comment

begin_function
specifier|static
name|int
name|find_id
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|int
modifier|*
name|id
parameter_list|)
block|{
name|size_t
name|tries
init|=
literal|0
decl_stmt|;
name|ctx
operator|->
name|next_querynum
operator|++
expr_stmt|;
while|while
condition|(
name|rbtree_search
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|ctx
operator|->
name|next_querynum
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|next_querynum
operator|++
expr_stmt|;
comment|/* numerical wraparound is fine */
if|if
condition|(
name|tries
operator|++
operator|>
name|NUM_ID_TRIES
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|id
operator|=
name|ctx
operator|->
name|next_querynum
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|ctx_query
modifier|*
name|context_new
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|rrtype
parameter_list|,
name|int
name|rrclass
parameter_list|,
name|ub_callback_t
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|NULL
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_id
argument_list|(
name|ctx
argument_list|,
operator|&
name|q
operator|->
name|querynum
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|q
operator|->
name|node
operator|.
name|key
operator|=
operator|&
name|q
operator|->
name|querynum
expr_stmt|;
name|q
operator|->
name|async
operator|=
operator|(
name|cb
operator|!=
name|NULL
operator|)
expr_stmt|;
name|q
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|q
operator|->
name|cb_arg
operator|=
name|cbarg
expr_stmt|;
name|q
operator|->
name|res
operator|=
operator|(
expr|struct
name|ub_result
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|res
condition|)
block|{
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|->
name|res
operator|->
name|qname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|res
operator|->
name|qname
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|->
name|res
operator|->
name|qtype
operator|=
name|rrtype
expr_stmt|;
name|q
operator|->
name|res
operator|->
name|qclass
operator|=
name|rrclass
expr_stmt|;
comment|/* add to query list */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|async
condition|)
name|ctx
operator|->
name|num_async
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|q
operator|->
name|node
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|struct
name|alloc_cache
modifier|*
name|context_obtain_alloc
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|locking
parameter_list|)
block|{
name|struct
name|alloc_cache
modifier|*
name|a
decl_stmt|;
name|int
name|tnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|locking
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|ctx
operator|->
name|alloc_list
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|ctx
operator|->
name|alloc_list
operator|=
name|a
operator|->
name|super
expr_stmt|;
comment|/* snip off list */
else|else
name|tnum
operator|=
name|ctx
operator|->
name|thr_next_num
operator|++
expr_stmt|;
if|if
condition|(
name|locking
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
condition|)
block|{
name|a
operator|->
name|super
operator|=
operator|&
name|ctx
operator|->
name|superalloc
expr_stmt|;
return|return
name|a
return|;
block|}
name|a
operator|=
operator|(
expr|struct
name|alloc_cache
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
name|alloc_init
argument_list|(
name|a
argument_list|,
operator|&
name|ctx
operator|->
name|superalloc
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|void
name|context_release_alloc
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|int
name|locking
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|||
operator|!
name|alloc
condition|)
return|return;
if|if
condition|(
name|locking
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
name|alloc
operator|->
name|super
operator|=
name|ctx
operator|->
name|alloc_list
expr_stmt|;
name|ctx
operator|->
name|alloc_list
operator|=
name|alloc
expr_stmt|;
if|if
condition|(
name|locking
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|context_serialize_new_query
parameter_list|(
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* format for new query is 	 * 	o uint32 cmd 	 * 	o uint32 id 	 * 	o uint32 type 	 * 	o uint32 class 	 * 	o rest queryname (string) 	 */
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|size_t
name|slen
init|=
name|strlen
argument_list|(
name|q
operator|->
name|res
operator|->
name|qname
argument_list|)
operator|+
literal|1
comment|/*end of string*/
decl_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|4
operator|+
name|slen
expr_stmt|;
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|sldns_write_uint32
argument_list|(
name|p
argument_list|,
name|UB_LIBCMD_NEWQUERY
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|q
operator|->
name|querynum
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|q
operator|->
name|res
operator|->
name|qtype
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|q
operator|->
name|res
operator|->
name|qclass
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|q
operator|->
name|res
operator|->
name|qname
argument_list|,
name|slen
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|ctx_query
modifier|*
name|context_deserialize_new_query
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|len
operator|<
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|1
condition|)
block|{
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|log_assert
argument_list|(
name|sldns_read_uint32
argument_list|(
name|p
argument_list|)
operator|==
name|UB_LIBCMD_NEWQUERY
argument_list|)
expr_stmt|;
name|q
operator|->
name|querynum
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|node
operator|.
name|key
operator|=
operator|&
name|q
operator|->
name|querynum
expr_stmt|;
name|q
operator|->
name|async
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|res
operator|=
operator|(
expr|struct
name|ub_result
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|res
condition|)
block|{
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|->
name|res
operator|->
name|qtype
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|res
operator|->
name|qclass
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|res
operator|->
name|qname
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|res
operator|->
name|qname
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/** add to query list */
name|ctx
operator|->
name|num_async
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|q
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|struct
name|ctx_query
modifier|*
name|context_lookup_new_query
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
name|int
name|querynum
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|1
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|log_assert
argument_list|(
name|sldns_read_uint32
argument_list|(
name|p
argument_list|)
operator|==
name|UB_LIBCMD_NEWQUERY
argument_list|)
expr_stmt|;
name|querynum
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|querynum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|log_assert
argument_list|(
name|q
operator|->
name|async
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|context_serialize_answer
parameter_list|(
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|int
name|err
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* answer format 	 * 	o uint32 cmd 	 * 	o uint32 id 	 * 	o uint32 error_code 	 * 	o uint32 msg_security 	 * 	o uint32 length of why_bogus string (+1 for eos); 0 absent. 	 * 	o why_bogus_string 	 * 	o the remainder is the answer msg from resolver lookup. 	 * 	  remainder can be length 0. 	 */
name|size_t
name|pkt_len
init|=
name|pkt
condition|?
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
else|:
literal|0
decl_stmt|;
name|size_t
name|wlen
init|=
operator|(
name|pkt
operator|&&
name|q
operator|->
name|res
operator|->
name|why_bogus
operator|)
condition|?
name|strlen
argument_list|(
name|q
operator|->
name|res
operator|->
name|why_bogus
argument_list|)
operator|+
literal|1
else|:
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|5
operator|+
name|pkt_len
operator|+
name|wlen
expr_stmt|;
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|sldns_write_uint32
argument_list|(
name|p
argument_list|,
name|UB_LIBCMD_ANSWER
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|q
operator|->
name|querynum
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|err
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|q
operator|->
name|msg_security
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|wlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlen
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|p
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|q
operator|->
name|res
operator|->
name|why_bogus
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|p
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|wlen
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|ctx_query
modifier|*
name|context_deserialize_answer
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
name|int
name|id
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
name|NULL
return|;
name|log_assert
argument_list|(
name|sldns_read_uint32
argument_list|(
name|p
argument_list|)
operator|==
name|UB_LIBCMD_ANSWER
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|NULL
return|;
operator|*
name|err
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|msg_security
operator|=
name|sldns_read_uint32
argument_list|(
name|p
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|wlen
operator|=
operator|(
name|size_t
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|&&
name|wlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|wlen
condition|)
name|q
operator|->
name|res
operator|->
name|why_bogus
operator|=
operator|(
name|char
operator|*
operator|)
name|memdup
argument_list|(
name|p
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|res
operator|->
name|why_bogus
condition|)
block|{
comment|/* pass malloc failure to the user callback */
name|q
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
operator|*
name|err
operator|=
name|UB_NOMEM
expr_stmt|;
return|return
name|q
return|;
block|}
name|q
operator|->
name|res
operator|->
name|why_bogus
index|[
name|wlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero terminated for sure */
block|}
if|if
condition|(
name|len
operator|>
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|wlen
condition|)
block|{
name|q
operator|->
name|msg_len
operator|=
name|len
operator|-
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
name|wlen
expr_stmt|;
name|q
operator|->
name|msg
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|memdup
argument_list|(
name|p
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|wlen
argument_list|,
name|q
operator|->
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|msg
condition|)
block|{
comment|/* pass malloc failure to the user callback */
name|q
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
operator|*
name|err
operator|=
name|UB_NOMEM
expr_stmt|;
return|return
name|q
return|;
block|}
block|}
return|return
name|q
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|context_serialize_cancel
parameter_list|(
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* format of cancel: 	 * 	o uint32 cmd 	 * 	o uint32 async-id */
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
argument_list|,
name|UB_LIBCMD_CANCEL
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|q
operator|->
name|querynum
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|ctx_query
modifier|*
name|context_deserialize_cancel
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
name|NULL
return|;
name|log_assert
argument_list|(
name|sldns_read_uint32
argument_list|(
name|p
argument_list|)
operator|==
name|UB_LIBCMD_CANCEL
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|int
operator|)
name|sldns_read_uint32
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|context_serialize_quit
parameter_list|(
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|sldns_write_uint32
argument_list|(
name|p
argument_list|,
name|UB_LIBCMD_QUIT
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|enum
name|ub_ctx_cmd
name|context_serial_getcmd
parameter_list|(
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|<
sizeof|sizeof
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|UB_LIBCMD_QUIT
return|;
name|v
operator|=
name|sldns_read_uint32
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

end_unit

