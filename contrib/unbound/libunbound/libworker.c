begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * libunbound/worker.c - worker thread or process that resolves  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the worker process or thread that performs  * the DNS resolving and validation. The worker is called by a procedure  * and if in the background continues until exit, if in the foreground  * returns from the procedure when done.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libunbound/libworker.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/context.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/unbound.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/worker.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/unbound-event.h"
end_include

begin_include
include|#
directive|include
file|"services/outside_network.h"
end_include

begin_include
include|#
directive|include
file|"services/mesh.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/outbound_list.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/lookup3.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/tube.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_hints.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"ldns/str2wire.h"
end_include

begin_comment
comment|/** handle new query command for bg worker */
end_comment

begin_function_decl
specifier|static
name|void
name|handle_newq
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** delete libworker env */
end_comment

begin_function
specifier|static
name|void
name|libworker_delete_env
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
name|w
operator|->
name|env
condition|)
block|{
name|outside_network_quit_prepare
argument_list|(
name|w
operator|->
name|back
argument_list|)
expr_stmt|;
name|mesh_delete
argument_list|(
name|w
operator|->
name|env
operator|->
name|mesh
argument_list|)
expr_stmt|;
name|context_release_alloc
argument_list|(
name|w
operator|->
name|ctx
argument_list|,
name|w
operator|->
name|env
operator|->
name|alloc
argument_list|,
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|w
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|forwards_delete
argument_list|(
name|w
operator|->
name|env
operator|->
name|fwds
argument_list|)
expr_stmt|;
name|hints_delete
argument_list|(
name|w
operator|->
name|env
operator|->
name|hints
argument_list|)
expr_stmt|;
name|ub_randfree
argument_list|(
name|w
operator|->
name|env
operator|->
name|rnd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|env
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SSL
name|SSL_CTX_free
argument_list|(
name|w
operator|->
name|sslctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outside_network_delete
argument_list|(
name|w
operator|->
name|back
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** delete libworker struct */
end_comment

begin_function
specifier|static
name|void
name|libworker_delete
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|libworker_delete_env
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|comm_base_delete
argument_list|(
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libworker_delete_event
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|libworker_delete_env
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|comm_base_delete_no_base
argument_list|(
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** setup fresh libworker struct */
end_comment

begin_function
specifier|static
name|struct
name|libworker
modifier|*
name|libworker_setup
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|is_bg
parameter_list|,
name|struct
name|event_base
modifier|*
name|eb
parameter_list|)
block|{
name|unsigned
name|int
name|seed
decl_stmt|;
name|struct
name|libworker
modifier|*
name|w
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|ctx
operator|->
name|env
operator|->
name|cfg
decl_stmt|;
name|int
modifier|*
name|ports
decl_stmt|;
name|int
name|numports
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|NULL
return|;
name|w
operator|->
name|is_bg
operator|=
name|is_bg
expr_stmt|;
name|w
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|w
operator|->
name|env
operator|=
operator|(
expr|struct
name|module_env
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|w
operator|->
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|env
condition|)
block|{
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|w
operator|->
name|env
operator|=
operator|*
name|ctx
operator|->
name|env
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|alloc
operator|=
name|context_obtain_alloc
argument_list|(
name|ctx
argument_list|,
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|env
operator|->
name|alloc
condition|)
block|{
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|w
operator|->
name|thread_num
operator|=
name|w
operator|->
name|env
operator|->
name|alloc
operator|->
name|thread_num
expr_stmt|;
name|alloc_set_id_cleanup
argument_list|(
name|w
operator|->
name|env
operator|->
name|alloc
argument_list|,
operator|&
name|libworker_alloc_cleanup
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|env
operator|->
name|scratch
operator|=
name|regional_create_custom
argument_list|(
name|cfg
operator|->
name|msg_buffer_size
argument_list|)
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|scratch_buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|cfg
operator|->
name|msg_buffer_size
argument_list|)
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|fwds
operator|=
name|forwards_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|env
operator|->
name|fwds
operator|&&
operator|!
name|forwards_apply_cfg
argument_list|(
name|w
operator|->
name|env
operator|->
name|fwds
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|forwards_delete
argument_list|(
name|w
operator|->
name|env
operator|->
name|fwds
argument_list|)
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|fwds
operator|=
name|NULL
expr_stmt|;
block|}
name|w
operator|->
name|env
operator|->
name|hints
operator|=
name|hints_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|env
operator|->
name|hints
operator|&&
operator|!
name|hints_apply_cfg
argument_list|(
name|w
operator|->
name|env
operator|->
name|hints
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|hints_delete
argument_list|(
name|w
operator|->
name|env
operator|->
name|hints
argument_list|)
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|hints
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|ssl_upstream
condition|)
block|{
name|w
operator|->
name|sslctx
operator|=
name|connect_sslctx_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|sslctx
condition|)
block|{
comment|/* to make the setup fail after unlock */
name|hints_delete
argument_list|(
name|w
operator|->
name|env
operator|->
name|hints
argument_list|)
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|hints
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|w
operator|->
name|env
operator|->
name|scratch
operator|||
operator|!
name|w
operator|->
name|env
operator|->
name|scratch_buffer
operator|||
operator|!
name|w
operator|->
name|env
operator|->
name|fwds
operator|||
operator|!
name|w
operator|->
name|env
operator|->
name|hints
condition|)
block|{
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|w
operator|->
name|env
operator|->
name|worker
operator|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|w
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|probe_timer
operator|=
name|NULL
expr_stmt|;
name|seed
operator|=
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|unsigned
name|int
operator|)
name|getpid
argument_list|()
operator|^
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|w
operator|->
name|thread_num
operator|)
operator|<<
literal|17
operator|)
expr_stmt|;
name|seed
operator|^=
operator|(
name|unsigned
name|int
operator|)
name|w
operator|->
name|env
operator|->
name|alloc
operator|->
name|next_id
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|env
operator|->
name|rnd
operator|=
name|ub_initstate
argument_list|(
name|seed
argument_list|,
name|ctx
operator|->
name|seed_rnd
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
name|seed
operator|=
literal|0
expr_stmt|;
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
comment|/* primitive lockout for threading: if it overwrites another 		 * thread it is like wiping the cache (which is likely empty 		 * at the start) */
comment|/* note we are holding the ctx lock in normal threaded 		 * cases so that is solved properly, it is only for many ctx 		 * in different threads that this may clash */
specifier|static
name|int
name|done_raninit
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|done_raninit
condition|)
block|{
name|done_raninit
operator|=
literal|1
expr_stmt|;
name|hash_set_raninit
argument_list|(
operator|(
name|uint32_t
operator|)
name|ub_random
argument_list|(
name|w
operator|->
name|env
operator|->
name|rnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|seed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eb
condition|)
name|w
operator|->
name|base
operator|=
name|comm_base_create_event
argument_list|(
name|eb
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|base
operator|=
name|comm_base_create
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|base
condition|)
block|{
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
name|numports
operator|=
name|cfg_condense_ports
argument_list|(
name|cfg
argument_list|,
operator|&
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|numports
operator|==
literal|0
condition|)
block|{
name|int
name|locked
init|=
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
decl_stmt|;
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|w
operator|->
name|back
operator|=
name|outside_network_create
argument_list|(
name|w
operator|->
name|base
argument_list|,
name|cfg
operator|->
name|msg_buffer_size
argument_list|,
operator|(
name|size_t
operator|)
name|cfg
operator|->
name|outgoing_num_ports
argument_list|,
name|cfg
operator|->
name|out_ifs
argument_list|,
name|cfg
operator|->
name|num_out_ifs
argument_list|,
name|cfg
operator|->
name|do_ip4
argument_list|,
name|cfg
operator|->
name|do_ip6
argument_list|,
name|cfg
operator|->
name|do_tcp
condition|?
name|cfg
operator|->
name|outgoing_num_tcp
else|:
literal|0
argument_list|,
name|w
operator|->
name|env
operator|->
name|infra_cache
argument_list|,
name|w
operator|->
name|env
operator|->
name|rnd
argument_list|,
name|cfg
operator|->
name|use_caps_bits_for_id
argument_list|,
name|ports
argument_list|,
name|numports
argument_list|,
name|cfg
operator|->
name|unwanted_threshold
argument_list|,
operator|&
name|libworker_alloc_cleanup
argument_list|,
name|w
argument_list|,
name|cfg
operator|->
name|do_udp
argument_list|,
name|w
operator|->
name|sslctx
argument_list|,
name|cfg
operator|->
name|delay_close
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|is_bg
operator|||
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|back
condition|)
block|{
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|w
operator|->
name|env
operator|->
name|mesh
operator|=
name|mesh_create
argument_list|(
operator|&
name|ctx
operator|->
name|mods
argument_list|,
name|w
operator|->
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|env
operator|->
name|mesh
condition|)
block|{
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|w
operator|->
name|env
operator|->
name|send_query
operator|=
operator|&
name|libworker_send_query
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|detach_subs
operator|=
operator|&
name|mesh_detach_subs
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|attach_sub
operator|=
operator|&
name|mesh_attach_sub
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|kill_sub
operator|=
operator|&
name|mesh_state_delete
expr_stmt|;
name|w
operator|->
name|env
operator|->
name|detect_cycle
operator|=
operator|&
name|mesh_detect_cycle
expr_stmt|;
name|comm_base_timept
argument_list|(
name|w
operator|->
name|base
argument_list|,
operator|&
name|w
operator|->
name|env
operator|->
name|now
argument_list|,
operator|&
name|w
operator|->
name|env
operator|->
name|now_tv
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_function
name|struct
name|libworker
modifier|*
name|libworker_create_event
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|event_base
modifier|*
name|eb
parameter_list|)
block|{
return|return
name|libworker_setup
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
name|eb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** handle cancel command for bg worker */
end_comment

begin_function
specifier|static
name|void
name|handle_cancel
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|q
operator|=
name|context_deserialize_cancel
argument_list|(
name|w
operator|->
name|ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|context_deserialize_cancel
argument_list|(
name|w
operator|->
name|ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q
condition|)
block|{
comment|/* probably simply lookup failed, i.e. the message had been 		 * processed and answered before the cancel arrived */
return|return;
block|}
name|q
operator|->
name|cancelled
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do control command coming into bg server */
end_comment

begin_function
specifier|static
name|void
name|libworker_do_cmd
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|,
name|uint8_t
modifier|*
name|msg
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|context_serial_getcmd
argument_list|(
name|msg
argument_list|,
name|len
argument_list|)
condition|)
block|{
default|default:
case|case
name|UB_LIBCMD_ANSWER
case|:
name|log_err
argument_list|(
literal|"unknown command for bg worker %d"
argument_list|,
operator|(
name|int
operator|)
name|context_serial_getcmd
argument_list|(
name|msg
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and fall through to quit */
case|case
name|UB_LIBCMD_QUIT
case|:
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|comm_base_exit
argument_list|(
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|UB_LIBCMD_NEWQUERY
case|:
name|handle_newq
argument_list|(
name|w
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|UB_LIBCMD_CANCEL
case|:
name|handle_cancel
argument_list|(
name|w
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/** handle control command coming into server */
end_comment

begin_decl_stmt
name|void
name|libworker_handle_control_cmd
argument_list|(
expr|struct
name|tube
operator|*
name|ATTR_UNUSED
argument_list|(
name|tube
argument_list|)
argument_list|,
name|uint8_t
operator|*
name|msg
argument_list|,
name|size_t
name|len
argument_list|,
name|int
name|err
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|struct
name|libworker
modifier|*
name|w
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* it is of no use to go on, exit */
name|comm_base_exit
argument_list|(
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
name|libworker_do_cmd
argument_list|(
name|w
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* also frees the buf */
block|}
end_decl_stmt

begin_comment
comment|/** the background thread func */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|libworker_dobg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* setup */
name|uint32_t
name|m
decl_stmt|;
name|struct
name|libworker
modifier|*
name|w
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ub_ctx
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|log_err
argument_list|(
literal|"libunbound bg worker init failed, nomem"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|=
name|w
operator|->
name|ctx
expr_stmt|;
name|log_thread_set
argument_list|(
operator|&
name|w
operator|->
name|thread_num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREADS_DISABLED
comment|/* we are forked */
name|w
operator|->
name|is_bg_thread
operator|=
literal|0
expr_stmt|;
comment|/* close non-used parts of the pipes */
name|tube_close_write
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_close_read
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|tube_setup_bg_listen
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|,
name|w
operator|->
name|base
argument_list|,
name|libworker_handle_control_cmd
argument_list|,
name|w
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"libunbound bg worker init failed, no bglisten"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|tube_setup_bg_write
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|,
name|w
operator|->
name|base
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"libunbound bg worker init failed, no bgwrite"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* do the work */
name|comm_base_dispatch
argument_list|(
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|m
operator|=
name|UB_LIBCMD_QUIT
expr_stmt|;
name|tube_remove_bg_listen
argument_list|(
name|w
operator|->
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_remove_bg_write
argument_list|(
name|w
operator|->
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tube_write_msg
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|m
argument_list|,
operator|(
name|uint32_t
operator|)
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREADS_DISABLED
comment|/* close pipes from forked process before exit */
name|tube_close_read
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_close_write
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|libworker_bg
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|libworker
modifier|*
name|w
decl_stmt|;
comment|/* fork or threadcreate */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|dothread
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|w
operator|=
name|libworker_setup
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|UB_NOMEM
return|;
name|w
operator|->
name|is_bg_thread
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_LOCK_CHECKS
name|w
operator|->
name|thread_num
operator|=
literal|1
expr_stmt|;
comment|/* for nicer DEBUG checklocks */
endif|#
directive|endif
name|ub_thread_create
argument_list|(
operator|&
name|ctx
operator|->
name|bg_tid
argument_list|,
name|libworker_dobg
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_FORK
comment|/* no fork on windows */
return|return
name|UB_FORKFAIL
return|;
else|#
directive|else
comment|/* HAVE_FORK */
switch|switch
condition|(
operator|(
name|ctx
operator|->
name|bg_pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|w
operator|=
name|libworker_setup
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* close non-used parts of the pipes */
name|tube_close_write
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_close_read
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|libworker_dobg
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
return|return
name|UB_FORKFAIL
return|;
default|default:
comment|/* close non-used parts, so that the worker 				 * bgprocess gets 'pipe closed' when the 				 * main process exits */
name|tube_close_read
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_close_write
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* HAVE_FORK */
block|}
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/** get msg reply struct (in temp region) */
end_comment

begin_function
specifier|static
name|struct
name|reply_info
modifier|*
name|parse_reply
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|query_info
modifier|*
name|qi
parameter_list|)
block|{
name|struct
name|reply_info
modifier|*
name|rep
decl_stmt|;
name|struct
name|msg_parse
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_packet
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|region
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|parse_create_msg
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|,
name|qi
argument_list|,
operator|&
name|rep
argument_list|,
name|region
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|rep
return|;
block|}
end_function

begin_comment
comment|/** insert canonname */
end_comment

begin_function
specifier|static
name|int
name|fill_canon
parameter_list|(
name|struct
name|ub_result
modifier|*
name|res
parameter_list|,
name|uint8_t
modifier|*
name|s
parameter_list|)
block|{
name|char
name|buf
index|[
literal|255
operator|+
literal|2
index|]
decl_stmt|;
name|dname_str
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|res
operator|->
name|canonname
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|res
operator|->
name|canonname
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/** fill data into result */
end_comment

begin_function
specifier|static
name|int
name|fill_res
parameter_list|(
name|struct
name|ub_result
modifier|*
name|res
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|answer
parameter_list|,
name|uint8_t
modifier|*
name|finalcname
parameter_list|,
name|struct
name|query_info
modifier|*
name|rq
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|data
decl_stmt|;
name|res
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
if|if
condition|(
name|finalcname
condition|)
block|{
if|if
condition|(
operator|!
name|fill_canon
argument_list|(
name|res
argument_list|,
name|finalcname
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* out of memory */
block|}
if|if
condition|(
name|rep
operator|->
name|rrset_count
operator|!=
literal|0
condition|)
name|res
operator|->
name|ttl
operator|=
operator|(
name|int
operator|)
name|rep
operator|->
name|ttl
expr_stmt|;
name|res
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|len
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|->
name|data
operator|&&
name|res
operator|->
name|len
operator|)
return|;
block|}
name|data
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|answer
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|rq
operator|->
name|qname
argument_list|,
name|answer
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fill_canon
argument_list|(
name|res
argument_list|,
name|answer
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* out of memory */
block|}
else|else
name|res
operator|->
name|canonname
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|data
operator|->
name|count
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|len
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
name|data
operator|->
name|count
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|data
operator|||
operator|!
name|res
operator|->
name|len
condition|)
return|return
literal|0
return|;
comment|/* out of memory */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* remove rdlength from rdata */
name|res
operator|->
name|len
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|data
operator|->
name|rr_len
index|[
name|i
index|]
operator|-
literal|2
argument_list|)
expr_stmt|;
name|res
operator|->
name|data
index|[
name|i
index|]
operator|=
name|memdup
argument_list|(
name|data
operator|->
name|rr_data
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
operator|(
name|size_t
operator|)
name|res
operator|->
name|len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|data
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
comment|/* out of memory */
block|}
comment|/* ttl for positive answers, from CNAME and answer RRs */
if|if
condition|(
name|data
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|size_t
name|j
decl_stmt|;
name|res
operator|->
name|ttl
operator|=
operator|(
name|int
operator|)
name|data
operator|->
name|ttl
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|j
index|]
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|d
operator|->
name|ttl
operator|<
name|res
operator|->
name|ttl
condition|)
name|res
operator|->
name|ttl
operator|=
operator|(
name|int
operator|)
name|d
operator|->
name|ttl
expr_stmt|;
block|}
block|}
comment|/* ttl for negative answers */
if|if
condition|(
name|data
operator|->
name|count
operator|==
literal|0
operator|&&
name|rep
operator|->
name|rrset_count
operator|!=
literal|0
condition|)
name|res
operator|->
name|ttl
operator|=
operator|(
name|int
operator|)
name|rep
operator|->
name|ttl
expr_stmt|;
name|res
operator|->
name|data
index|[
name|data
operator|->
name|count
index|]
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|len
index|[
name|data
operator|->
name|count
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** fill result from parsed message, on error fills servfail */
end_comment

begin_function
name|void
name|libworker_enter_result
parameter_list|(
name|struct
name|ub_result
modifier|*
name|res
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|regional
modifier|*
name|temp
parameter_list|,
name|enum
name|sec_status
name|msg_security
parameter_list|)
block|{
name|struct
name|query_info
name|rq
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|rep
decl_stmt|;
name|res
operator|->
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
name|rep
operator|=
name|parse_reply
argument_list|(
name|buf
argument_list|,
name|temp
argument_list|,
operator|&
name|rq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse buf"
argument_list|)
expr_stmt|;
return|return;
comment|/* error parsing buf, or out of memory */
block|}
if|if
condition|(
operator|!
name|fill_res
argument_list|(
name|res
argument_list|,
name|reply_find_answer_rrset
argument_list|(
operator|&
name|rq
argument_list|,
name|rep
argument_list|)
argument_list|,
name|reply_find_final_cname_target
argument_list|(
operator|&
name|rq
argument_list|,
name|rep
argument_list|)
argument_list|,
operator|&
name|rq
argument_list|,
name|rep
argument_list|)
condition|)
return|return;
comment|/* out of memory */
comment|/* rcode, havedata, nxdomain, secure, bogus */
name|res
operator|->
name|rcode
operator|=
operator|(
name|int
operator|)
name|FLAGS_GET_RCODE
argument_list|(
name|rep
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|data
operator|&&
name|res
operator|->
name|data
index|[
literal|0
index|]
condition|)
name|res
operator|->
name|havedata
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|rcode
operator|==
name|LDNS_RCODE_NXDOMAIN
condition|)
name|res
operator|->
name|nxdomain
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msg_security
operator|==
name|sec_status_secure
condition|)
name|res
operator|->
name|secure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msg_security
operator|==
name|sec_status_bogus
condition|)
name|res
operator|->
name|bogus
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/** fillup fg results */
end_comment

begin_function
specifier|static
name|void
name|libworker_fillup_fg
parameter_list|(
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|int
name|rcode
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|enum
name|sec_status
name|s
parameter_list|,
name|char
modifier|*
name|why_bogus
parameter_list|)
block|{
if|if
condition|(
name|why_bogus
condition|)
name|q
operator|->
name|res
operator|->
name|why_bogus
operator|=
name|strdup
argument_list|(
name|why_bogus
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|res
operator|->
name|rcode
operator|=
name|rcode
expr_stmt|;
name|q
operator|->
name|msg_security
operator|=
name|s
expr_stmt|;
return|return;
block|}
name|q
operator|->
name|res
operator|->
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
name|q
operator|->
name|msg_security
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|msg
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|msg_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|msg
condition|)
block|{
return|return;
comment|/* the error is in the rcode */
block|}
comment|/* canonname and results */
name|q
operator|->
name|msg_security
operator|=
name|s
expr_stmt|;
name|libworker_enter_result
argument_list|(
name|q
operator|->
name|res
argument_list|,
name|buf
argument_list|,
name|q
operator|->
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libworker_fg_done_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|rcode
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|enum
name|sec_status
name|s
parameter_list|,
name|char
modifier|*
name|why_bogus
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* fg query is done; exit comm base */
name|comm_base_exit
argument_list|(
name|q
operator|->
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
name|libworker_fillup_fg
argument_list|(
name|q
argument_list|,
name|rcode
argument_list|,
name|buf
argument_list|,
name|s
argument_list|,
name|why_bogus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** setup qinfo and edns */
end_comment

begin_function
specifier|static
name|int
name|setup_qinfo_edns
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|,
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
name|qinfo
operator|->
name|qtype
operator|=
operator|(
name|uint16_t
operator|)
name|q
operator|->
name|res
operator|->
name|qtype
expr_stmt|;
name|qinfo
operator|->
name|qclass
operator|=
operator|(
name|uint16_t
operator|)
name|q
operator|->
name|res
operator|->
name|qclass
expr_stmt|;
name|qinfo
operator|->
name|qname
operator|=
name|sldns_str2wire_dname
argument_list|(
name|q
operator|->
name|res
operator|->
name|qname
argument_list|,
operator|&
name|qinfo
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinfo
operator|->
name|qname
condition|)
block|{
return|return
literal|0
return|;
block|}
name|edns
operator|->
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|edns_version
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|bits
operator|=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
name|sldns_buffer_capacity
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|)
operator|<
literal|65535
condition|)
name|edns
operator|->
name|udp_size
operator|=
operator|(
name|uint16_t
operator|)
name|sldns_buffer_capacity
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
else|else
name|edns
operator|->
name|udp_size
operator|=
literal|65535
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|libworker_fg
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|libworker
modifier|*
name|w
init|=
name|libworker_setup
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|uint16_t
name|qflags
decl_stmt|,
name|qid
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|UB_INITFAIL
return|;
if|if
condition|(
operator|!
name|setup_qinfo_edns
argument_list|(
name|w
argument_list|,
name|q
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|)
condition|)
block|{
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|UB_SYNTAX
return|;
block|}
name|qid
operator|=
literal|0
expr_stmt|;
name|qflags
operator|=
name|BIT_RD
expr_stmt|;
name|q
operator|->
name|w
operator|=
name|w
expr_stmt|;
comment|/* see if there is a fixed answer */
name|sldns_buffer_write_u16_at
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
literal|0
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16_at
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
literal|2
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_zones_answer
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|libworker_fillup_fg
argument_list|(
name|q
argument_list|,
name|LDNS_RCODE_NOERROR
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|sec_status_insecure
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
comment|/* process new query */
if|if
condition|(
operator|!
name|mesh_new_callback
argument_list|(
name|w
operator|->
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|qinfo
argument_list|,
name|qflags
argument_list|,
operator|&
name|edns
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|qid
argument_list|,
name|libworker_fg_done_cb
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
comment|/* wait for reply */
name|comm_base_dispatch
argument_list|(
name|w
operator|->
name|base
argument_list|)
expr_stmt|;
name|libworker_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|void
name|libworker_event_done_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|rcode
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|enum
name|sec_status
name|s
parameter_list|,
name|char
modifier|*
name|why_bogus
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|arg
decl_stmt|;
name|ub_event_callback_t
name|cb
init|=
operator|(
name|ub_event_callback_t
operator|)
name|q
operator|->
name|cb
decl_stmt|;
name|void
modifier|*
name|cb_arg
init|=
name|q
operator|->
name|cb_arg
decl_stmt|;
name|int
name|cancelled
init|=
name|q
operator|->
name|cancelled
decl_stmt|;
comment|/* delete it now */
name|struct
name|ub_ctx
modifier|*
name|ctx
init|=
name|q
operator|->
name|w
operator|->
name|ctx
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_async
operator|--
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cancelled
condition|)
block|{
comment|/* call callback */
name|int
name|sec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|sec_status_bogus
condition|)
name|sec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|==
name|sec_status_secure
condition|)
name|sec
operator|=
literal|2
expr_stmt|;
call|(
modifier|*
name|cb
call|)
argument_list|(
name|cb_arg
argument_list|,
name|rcode
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sec
argument_list|,
name|why_bogus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|libworker_attach_mesh
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|int
modifier|*
name|async_id
parameter_list|)
block|{
name|struct
name|libworker
modifier|*
name|w
init|=
name|ctx
operator|->
name|event_worker
decl_stmt|;
name|uint16_t
name|qflags
decl_stmt|,
name|qid
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|UB_INITFAIL
return|;
if|if
condition|(
operator|!
name|setup_qinfo_edns
argument_list|(
name|w
argument_list|,
name|q
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|)
condition|)
return|return
name|UB_SYNTAX
return|;
name|qid
operator|=
literal|0
expr_stmt|;
name|qflags
operator|=
name|BIT_RD
expr_stmt|;
name|q
operator|->
name|w
operator|=
name|w
expr_stmt|;
comment|/* see if there is a fixed answer */
name|sldns_buffer_write_u16_at
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
literal|0
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16_at
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
literal|2
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_zones_answer
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
name|libworker_event_done_cb
argument_list|(
name|q
argument_list|,
name|LDNS_RCODE_NOERROR
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|sec_status_insecure
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
comment|/* process new query */
if|if
condition|(
name|async_id
condition|)
operator|*
name|async_id
operator|=
name|q
operator|->
name|querynum
expr_stmt|;
if|if
condition|(
operator|!
name|mesh_new_callback
argument_list|(
name|w
operator|->
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|qinfo
argument_list|,
name|qflags
argument_list|,
operator|&
name|edns
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|qid
argument_list|,
name|libworker_event_done_cb
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/** add result to the bg worker result queue */
end_comment

begin_function
specifier|static
name|void
name|add_bg_result
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|,
name|struct
name|ctx_query
modifier|*
name|q
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|uint8_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
comment|/* serialize and delete unneeded q */
if|if
condition|(
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
condition|)
name|q
operator|->
name|res
operator|->
name|why_bogus
operator|=
name|strdup
argument_list|(
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
condition|)
block|{
name|q
operator|->
name|msg_len
operator|=
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|q
operator|->
name|msg
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|q
operator|->
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|msg
condition|)
name|msg
operator|=
name|context_serialize_answer
argument_list|(
name|q
argument_list|,
name|UB_NOMEM
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|context_serialize_answer
argument_list|(
name|q
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|msg
operator|=
name|context_serialize_answer
argument_list|(
name|q
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reason
condition|)
name|q
operator|->
name|res
operator|->
name|why_bogus
operator|=
name|strdup
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|msg
operator|=
name|context_serialize_answer
argument_list|(
name|q
argument_list|,
name|err
argument_list|,
name|pkt
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|w
operator|->
name|ctx
operator|->
name|num_async
operator|--
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory for async answer"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|tube_queue_item
argument_list|(
name|w
operator|->
name|ctx
operator|->
name|rr_pipe
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory for async answer"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|libworker_bg_done_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|rcode
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|enum
name|sec_status
name|s
parameter_list|,
name|char
modifier|*
name|why_bogus
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|cancelled
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|w
operator|->
name|is_bg_thread
condition|)
block|{
comment|/* delete it now */
name|struct
name|ub_ctx
modifier|*
name|ctx
init|=
name|q
operator|->
name|w
operator|->
name|ctx
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_async
operator|--
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
comment|/* cancelled, do not give answer */
return|return;
block|}
name|q
operator|->
name|msg_security
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|buf
operator|=
name|q
operator|->
name|w
operator|->
name|env
operator|->
name|scratch_buffer
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
literal|0
condition|)
block|{
name|error_encode
argument_list|(
name|buf
argument_list|,
name|rcode
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|BIT_RD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|add_bg_result
argument_list|(
name|q
operator|->
name|w
argument_list|,
name|q
argument_list|,
name|buf
argument_list|,
name|UB_NOERROR
argument_list|,
name|why_bogus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** handle new query command for bg worker */
end_comment

begin_function
specifier|static
name|void
name|handle_newq
parameter_list|(
name|struct
name|libworker
modifier|*
name|w
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint16_t
name|qflags
decl_stmt|,
name|qid
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|is_bg_thread
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|q
operator|=
name|context_lookup_new_query
argument_list|(
name|w
operator|->
name|ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|w
operator|->
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|context_deserialize_new_query
argument_list|(
name|w
operator|->
name|ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
name|log_err
argument_list|(
literal|"failed to deserialize newq"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|setup_qinfo_edns
argument_list|(
name|w
argument_list|,
name|q
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|)
condition|)
block|{
name|add_bg_result
argument_list|(
name|w
argument_list|,
name|q
argument_list|,
name|NULL
argument_list|,
name|UB_SYNTAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|qid
operator|=
literal|0
expr_stmt|;
name|qflags
operator|=
name|BIT_RD
expr_stmt|;
comment|/* see if there is a fixed answer */
name|sldns_buffer_write_u16_at
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
literal|0
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16_at
argument_list|(
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
literal|2
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_zones_answer
argument_list|(
name|w
operator|->
name|ctx
operator|->
name|local_zones
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|w
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|q
operator|->
name|msg_security
operator|=
name|sec_status_insecure
expr_stmt|;
name|add_bg_result
argument_list|(
name|w
argument_list|,
name|q
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|UB_NOERROR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|->
name|w
operator|=
name|w
expr_stmt|;
comment|/* process new query */
if|if
condition|(
operator|!
name|mesh_new_callback
argument_list|(
name|w
operator|->
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|qinfo
argument_list|,
name|qflags
argument_list|,
operator|&
name|edns
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|,
name|qid
argument_list|,
name|libworker_bg_done_cb
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|add_bg_result
argument_list|(
name|w
argument_list|,
name|q
argument_list|,
name|NULL
argument_list|,
name|UB_NOMEM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libworker_alloc_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|libworker
modifier|*
name|w
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|arg
decl_stmt|;
name|slabhash_clear
argument_list|(
operator|&
name|w
operator|->
name|env
operator|->
name|rrset_cache
operator|->
name|table
argument_list|)
expr_stmt|;
name|slabhash_clear
argument_list|(
name|w
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|outbound_entry
modifier|*
name|libworker_send_query
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|int
name|dnssec
parameter_list|,
name|int
name|want_dnssec
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|size_t
name|zonelen
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|libworker
modifier|*
name|w
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|q
operator|->
name|env
operator|->
name|worker
decl_stmt|;
name|struct
name|outbound_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|outbound_entry
operator|*
operator|)
name|regional_alloc
argument_list|(
name|q
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|NULL
return|;
name|e
operator|->
name|qstate
operator|=
name|q
expr_stmt|;
name|e
operator|->
name|qsent
operator|=
name|outnet_serviced_query
argument_list|(
name|w
operator|->
name|back
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|flags
argument_list|,
name|dnssec
argument_list|,
name|want_dnssec
argument_list|,
name|q
operator|->
name|env
operator|->
name|cfg
operator|->
name|tcp_upstream
argument_list|,
name|q
operator|->
name|env
operator|->
name|cfg
operator|->
name|ssl_upstream
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|zone
argument_list|,
name|zonelen
argument_list|,
name|libworker_handle_service_reply
argument_list|,
name|e
argument_list|,
name|w
operator|->
name|back
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|qsent
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_function
name|int
name|libworker_handle_reply
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply_info
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|q
init|=
operator|(
expr|struct
name|module_qstate
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|libworker
modifier|*
name|lw
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|q
operator|->
name|env
operator|->
name|worker
decl_stmt|;
name|struct
name|outbound_entry
name|e
decl_stmt|;
name|e
operator|.
name|qstate
operator|=
name|q
expr_stmt|;
name|e
operator|.
name|qsent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mesh_report_reply
argument_list|(
name|lw
operator|->
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|e
argument_list|,
name|reply_info
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* sanity check. */
if|if
condition|(
operator|!
name|LDNS_QR_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|||
name|LDNS_OPCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|!=
name|LDNS_PACKET_QUERY
operator|||
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* error becomes timeout for the module as if this reply 		 * never arrived. */
name|mesh_report_reply
argument_list|(
name|lw
operator|->
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mesh_report_reply
argument_list|(
name|lw
operator|->
name|env
operator|->
name|mesh
argument_list|,
operator|&
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_NOERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|libworker_handle_service_reply
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply_info
parameter_list|)
block|{
name|struct
name|outbound_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|outbound_entry
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|libworker
modifier|*
name|lw
init|=
operator|(
expr|struct
name|libworker
operator|*
operator|)
name|e
operator|->
name|qstate
operator|->
name|env
operator|->
name|worker
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mesh_report_reply
argument_list|(
name|lw
operator|->
name|env
operator|->
name|mesh
argument_list|,
name|e
argument_list|,
name|reply_info
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* sanity check. */
if|if
condition|(
operator|!
name|LDNS_QR_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|||
name|LDNS_OPCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|!=
name|LDNS_PACKET_QUERY
operator|||
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* error becomes timeout for the module as if this reply 		 * never arrived. */
name|mesh_report_reply
argument_list|(
name|lw
operator|->
name|env
operator|->
name|mesh
argument_list|,
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mesh_report_reply
argument_list|(
name|lw
operator|->
name|env
operator|->
name|mesh
argument_list|,
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_NOERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --- fake callbacks for fptr_wlist to work --- */
end_comment

begin_decl_stmt
name|void
name|worker_handle_control_cmd
argument_list|(
expr|struct
name|tube
operator|*
name|ATTR_UNUSED
argument_list|(
name|tube
argument_list|)
argument_list|,
name|uint8_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|len
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|worker_handle_request
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|repinfo
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|worker_handle_reply
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|worker_handle_service_reply
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|remote_accept_callback
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|repinfo
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|remote_control_callback
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|repinfo
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
name|void
name|worker_sighandler
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|sig
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|outbound_entry
modifier|*
name|worker_send_query
argument_list|(
name|uint8_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|qname
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|qnamelen
argument_list|)
argument_list|,
name|uint16_t
name|ATTR_UNUSED
argument_list|(
name|qtype
argument_list|)
argument_list|,
name|uint16_t
name|ATTR_UNUSED
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|uint16_t
name|ATTR_UNUSED
argument_list|(
name|flags
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|dnssec
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|want_dnssec
argument_list|)
argument_list|,
expr|struct
name|sockaddr_storage
operator|*
name|ATTR_UNUSED
argument_list|(
name|addr
argument_list|)
argument_list|,
name|socklen_t
name|ATTR_UNUSED
argument_list|(
name|addrlen
argument_list|)
argument_list|,
name|uint8_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|zone
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|zonelen
argument_list|)
argument_list|,
expr|struct
name|module_qstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|q
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
name|void
name|worker_alloc_cleanup
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_stat_timer_cb
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_probe_timer_cb
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_start_accept
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_stop_accept
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|order_lock_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|e1
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|e2
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|codeline_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|replay_var_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|remote_get_opt_ssl
parameter_list|(
name|char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|str
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
end_ifdef

begin_function
name|void
name|worker_win_stop_cb
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|ev
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wsvc_cron_cb
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UB_ON_WINDOWS */
end_comment

end_unit

