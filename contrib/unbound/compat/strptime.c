begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** strptime workaround (for oa macos leopard)   * This strptime follows the man strptime (2001-11-12)   *		conforming to SUSv2, POSIX.1-2001   *   * This very simple version of strptime has no:   * - E alternatives   * - O alternatives   * - Glibc additions   * - Does not process week numbers   * - Does not properly processes year day   *   * LICENSE   * Copyright (c) 2008, NLnet Labs, Matthijs Mekking   * All rights reserved.   *   * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are met:   * * Redistributions of source code must retain the above copyright notice,   *     this list of conditions and the following disclaimer.   * * Redistributions in binary form must reproduce the above copyright   *   notice, this list of conditions and the following disclaimer in the   *   documentation and/or other materials provided with the distribution.   * * Neither the name of NLnetLabs nor the names of its   *   contributors may be used to endorse or promote products derived from this   *   software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   * POSSIBILITY OF SUCH DAMAGE.  **/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CONFIG_H
end_ifndef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STRPTIME_WORKS
end_ifndef

begin_define
define|#
directive|define
name|TM_YEAR_BASE
value|1900
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|abb_weekdays
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|full_weekdays
index|[]
init|=
block|{
literal|"Sunday"
block|,
literal|"Monday"
block|,
literal|"Tuesday"
block|,
literal|"Wednesday"
block|,
literal|"Thursday"
block|,
literal|"Friday"
block|,
literal|"Saturday"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|abb_months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|full_months
index|[]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ampm
index|[]
init|=
block|{
literal|"am"
block|,
literal|"pm"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|match_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|strs
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|strs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|buf
argument_list|,
name|strs
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|buf
operator|+=
name|len
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2int
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|isdigit
argument_list|(
operator|*
name|buf
index|[
literal|0
index|]
argument_list|)
operator|&&
name|count
operator|<
name|max
condition|)
block|{
name|ret
operator|=
name|ret
operator|*
literal|10
operator|+
operator|(
operator|*
name|buf
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/** Converts the character string s to values which are stored in tm   * using the format specified by format  **/
end_comment

begin_function
name|char
modifier|*
name|unbound_strptime
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|split_year
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|format
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* whitespace, literal or format */
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* whitespace */
comment|/** whitespace matches zero or more whitespace characters in the 			  * input string. 			 **/
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|/* format */
name|format
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|format
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
comment|/* %% is converted to % */
if|if
condition|(
operator|*
name|s
operator|!=
name|c
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* weekday name, abbreviated or full */
case|case
literal|'A'
case|:
name|ret
operator|=
name|match_string
argument_list|(
operator|&
name|s
argument_list|,
name|full_weekdays
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ret
operator|=
name|match_string
argument_list|(
operator|&
name|s
argument_list|,
name|abb_weekdays
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_wday
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* month name, abbreviated or full */
case|case
literal|'B'
case|:
case|case
literal|'h'
case|:
name|ret
operator|=
name|match_string
argument_list|(
operator|&
name|s
argument_list|,
name|full_months
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ret
operator|=
name|match_string
argument_list|(
operator|&
name|s
argument_list|,
name|abb_months
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_mon
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* date and time representation */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%x %X"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* century number */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|99
condition|)
block|{
comment|/* must be in [00,99] */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|split_year
condition|)
block|{
name|tm
operator|->
name|tm_year
operator|=
name|ret
operator|*
literal|100
operator|+
operator|(
name|tm
operator|->
name|tm_year
operator|%
literal|100
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tm
operator|->
name|tm_year
operator|=
name|ret
operator|*
literal|100
operator|-
name|TM_YEAR_BASE
expr_stmt|;
name|split_year
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* day of month */
case|case
literal|'e'
case|:
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
operator|||
name|ret
operator|>
literal|31
condition|)
block|{
comment|/* must be in [01,31] */
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_mday
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* equivalent to %m/%d/%y */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%m/%d/%y"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* hour */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|23
condition|)
block|{
comment|/* must be in [00,23] */
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_hour
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* 12hr clock hour */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
operator|||
name|ret
operator|>
literal|12
condition|)
block|{
comment|/* must be in [01,12] */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|12
condition|)
comment|/* actually [0,11] */
name|ret
operator|=
literal|0
expr_stmt|;
name|tm
operator|->
name|tm_hour
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* day of year */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
operator|||
name|ret
operator|>
literal|366
condition|)
block|{
comment|/* must be in [001,366] */
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_yday
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* month */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
operator|||
name|ret
operator|>
literal|12
condition|)
block|{
comment|/* must be in [01,12] */
return|return
name|NULL
return|;
block|}
comment|/* months go from 0-11 */
name|tm
operator|->
name|tm_mon
operator|=
operator|(
name|ret
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* minute */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|59
condition|)
block|{
comment|/* must be in [00,59] */
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_min
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* arbitrary whitespace */
case|case
literal|'t'
case|:
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* am pm */
name|ret
operator|=
name|match_string
argument_list|(
operator|&
name|s
argument_list|,
name|ampm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|<
literal|0
operator|||
name|tm
operator|->
name|tm_hour
operator|>
literal|11
condition|)
block|{
comment|/* %I */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
comment|/* pm */
name|tm
operator|->
name|tm_hour
operator|+=
literal|12
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* equivalent of %I:%M:%S %p */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%I:%M:%S %p"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* equivalent of %H:%M */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%H:%M"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* seconds */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 60 may occur for leap seconds */
comment|/* earlier 61 was also allowed */
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|60
condition|)
block|{
comment|/* must be in [00,60] */
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_sec
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* equivalent of %H:%M:%S */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%H:%M:%S"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* week number, with the first Sun of Jan being w1 */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|53
condition|)
block|{
comment|/* must be in [00,53] */
return|return
name|NULL
return|;
block|}
comment|/** it is hard (and not necessary for nsd) to determine time 					  * data from week number. 					 **/
break|break;
case|case
literal|'w'
case|:
comment|/* day of week */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|6
condition|)
block|{
comment|/* must be in [0,6] */
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_wday
operator|=
name|ret
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* week number, with the first Mon of Jan being w1 */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|53
condition|)
block|{
comment|/* must be in [00,53] */
return|return
name|NULL
return|;
block|}
comment|/** it is hard (and not necessary for nsd) to determine time 					  * data from week number. 					 **/
break|break;
case|case
literal|'x'
case|:
comment|/* date format */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%m/%d/%y"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'X'
case|:
comment|/* time format */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|unbound_strptime
argument_list|(
name|s
argument_list|,
literal|"%H:%M:%S"
argument_list|,
name|tm
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'y'
case|:
comment|/* last two digits of a year */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|99
condition|)
block|{
comment|/* must be in [00,99] */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|split_year
condition|)
block|{
name|tm
operator|->
name|tm_year
operator|=
operator|(
operator|(
name|tm
operator|->
name|tm_year
operator|/
literal|100
operator|)
operator|*
literal|100
operator|)
operator|+
name|ret
expr_stmt|;
block|}
else|else
block|{
name|split_year
operator|=
literal|1
expr_stmt|;
comment|/** currently: 						  * if in [0,68] we are in 21th century, 						  * if in [69,99] we are in 20th century. 						 **/
if|if
condition|(
name|ret
operator|<
literal|69
condition|)
comment|/* 2000 */
name|ret
operator|+=
literal|100
expr_stmt|;
name|tm
operator|->
name|tm_year
operator|=
name|ret
expr_stmt|;
block|}
break|break;
case|case
literal|'Y'
case|:
comment|/* year */
name|ret
operator|=
name|str2int
argument_list|(
operator|&
name|s
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|9999
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|tm_year
operator|=
name|ret
operator|-
name|TM_YEAR_BASE
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
default|default:
comment|/* unsupported, cannot match format */
return|return
name|NULL
return|;
break|break;
block|}
block|}
else|else
block|{
comment|/* literal */
comment|/* if input cannot match format, return NULL */
if|if
condition|(
operator|*
name|s
operator|!=
name|c
condition|)
return|return
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
name|format
operator|++
expr_stmt|;
block|}
comment|/* return pointer to remainder of s */
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STRPTIME_WORKS */
end_comment

end_unit

