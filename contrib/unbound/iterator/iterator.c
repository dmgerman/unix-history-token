begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * iterator/iterator.c - iterative resolver DNS query response module  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains a module that performs recusive iterative DNS query  * processing.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iterator.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_utils.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_hints.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_donotq.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_resptype.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_scrub.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_priv.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_neg.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|"ldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_function
name|int
name|iter_init
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_env
modifier|*
name|iter_env
init|=
operator|(
expr|struct
name|iter_env
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_env
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iter_env
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|iter_env
expr_stmt|;
if|if
condition|(
operator|!
name|iter_apply_cfg
argument_list|(
name|iter_env
argument_list|,
name|env
operator|->
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"iterator: could not apply configuration settings."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|iter_deinit
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_env
modifier|*
name|iter_env
decl_stmt|;
if|if
condition|(
operator|!
name|env
operator|||
operator|!
name|env
operator|->
name|modinfo
index|[
name|id
index|]
condition|)
return|return;
name|iter_env
operator|=
operator|(
expr|struct
name|iter_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
expr_stmt|;
name|free
argument_list|(
name|iter_env
operator|->
name|target_fetch_policy
argument_list|)
expr_stmt|;
name|priv_delete
argument_list|(
name|iter_env
operator|->
name|priv
argument_list|)
expr_stmt|;
name|donotq_delete
argument_list|(
name|iter_env
operator|->
name|donotq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iter_env
argument_list|)
expr_stmt|;
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/** new query for iterator */
end_comment

begin_function
specifier|static
name|int
name|iter_new
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_qstate
argument_list|)
argument_list|)
decl_stmt|;
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|iq
expr_stmt|;
if|if
condition|(
operator|!
name|iq
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|iq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iq
argument_list|)
argument_list|)
expr_stmt|;
name|iq
operator|->
name|state
operator|=
name|INIT_REQUEST_STATE
expr_stmt|;
name|iq
operator|->
name|final_state
operator|=
name|FINISHED_STATE
expr_stmt|;
name|iq
operator|->
name|an_prepend_list
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|an_prepend_last
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|ns_prepend_list
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|ns_prepend_last
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|query_restart_count
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|referral_count
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|sent_count
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|wait_priming_stub
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|refetch_glue
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|dnssec_expected
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|dnssec_lame_query
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|chase_flags
operator|=
name|qstate
operator|->
name|query_flags
expr_stmt|;
comment|/* Start with the (current) qname. */
name|iq
operator|->
name|qchase
operator|=
name|qstate
operator|->
name|qinfo
expr_stmt|;
name|outbound_list_init
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Transition to the next state. This can be used to advance a currently  * processing event. It cannot be used to reactivate a forEvent.  *  * @param iq: iterator query state  * @param nextstate The state to transition to.  * @return true. This is so this can be called as the return value for the  *         actual process*State() methods. (Transitioning to the next state  *         implies further processing).  */
end_comment

begin_function
specifier|static
name|int
name|next_state
parameter_list|(
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|enum
name|iter_state
name|nextstate
parameter_list|)
block|{
comment|/* If transitioning to a "response" state, make sure that there is a 	 * response */
if|if
condition|(
name|iter_state_is_responsestate
argument_list|(
name|nextstate
argument_list|)
condition|)
block|{
if|if
condition|(
name|iq
operator|->
name|response
operator|==
name|NULL
condition|)
block|{
name|log_err
argument_list|(
literal|"transitioning to response state sans "
literal|"response."
argument_list|)
expr_stmt|;
block|}
block|}
name|iq
operator|->
name|state
operator|=
name|nextstate
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Transition an event to its final state. Final states always either return  * a result up the module chain, or reactivate a dependent event. Which  * final state to transtion to is set in the module state for the event when  * it was created, and depends on the original purpose of the event.  *  * The response is stored in the qstate->buf buffer.  *  * @param iq: iterator query state  * @return false. This is so this method can be used as the return value for  *         the processState methods. (Transitioning to the final state  */
end_comment

begin_function
specifier|static
name|int
name|final_state
parameter_list|(
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|)
block|{
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|iq
operator|->
name|final_state
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Callback routine to handle errors in parent query states  * @param qstate: query state that failed.  * @param id: module id.  * @param super: super state.  */
end_comment

begin_function
specifier|static
name|void
name|error_supers
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|super
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|super_iq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|super
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
comment|/* mark address as failed. */
name|struct
name|delegpt_ns
modifier|*
name|dpns
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|super_iq
operator|->
name|dp
condition|)
name|dpns
operator|=
name|delegpt_find_ns
argument_list|(
name|super_iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpns
condition|)
block|{
comment|/* not interested */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"subq error, but not interested"
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"superq"
argument_list|,
operator|&
name|super
operator|->
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|super_iq
operator|->
name|dp
condition|)
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|super_iq
operator|->
name|dp
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* see if the failure did get (parent-lame) info */
if|if
condition|(
operator|!
name|cache_fill_missing
argument_list|(
name|super
operator|->
name|env
argument_list|,
name|super_iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|super
operator|->
name|region
argument_list|,
name|super_iq
operator|->
name|dp
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory adding missing"
argument_list|)
expr_stmt|;
block|}
name|dpns
operator|->
name|resolved
operator|=
literal|1
expr_stmt|;
comment|/* mark as failed */
name|super_iq
operator|->
name|num_target_queries
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
comment|/* prime failed to get delegation */
name|super_iq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* evaluate targets again */
name|super_iq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
comment|/* super becomes runnable, and will process this change */
block|}
end_function

begin_comment
comment|/**  * Return an error to the client  * @param qstate: our query state  * @param id: module id  * @param rcode: error code (DNS errcode).  * @return: 0 for use by caller, to make notation easy, like:  * 	return error_response(..).   */
end_comment

begin_function
specifier|static
name|int
name|error_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"return error response %s"
argument_list|,
name|sldns_lookup_by_id
argument_list|(
name|sldns_rcodes
argument_list|,
name|rcode
argument_list|)
condition|?
name|sldns_lookup_by_id
argument_list|(
name|sldns_rcodes
argument_list|,
name|rcode
argument_list|)
operator|->
name|name
else|:
literal|"??"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|return_rcode
operator|=
name|rcode
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|NULL
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return an error to the client and cache the error code in the  * message cache (so per qname, qtype, qclass).  * @param qstate: our query state  * @param id: module id  * @param rcode: error code (DNS errcode).  * @return: 0 for use by caller, to make notation easy, like:  * 	return error_response(..).   */
end_comment

begin_function
specifier|static
name|int
name|error_response_cache
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|rcode
parameter_list|)
block|{
comment|/* store in cache */
name|struct
name|reply_info
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|err
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|.
name|flags
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|BIT_QR
operator||
name|BIT_RA
argument_list|)
expr_stmt|;
name|FLAGS_SET_RCODE
argument_list|(
name|err
operator|.
name|flags
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
name|err
operator|.
name|qdcount
operator|=
literal|1
expr_stmt|;
name|err
operator|.
name|ttl
operator|=
name|NORR_TTL
expr_stmt|;
name|err
operator|.
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|err
operator|.
name|ttl
argument_list|)
expr_stmt|;
comment|/* do not waste time trying to validate this servfail */
name|err
operator|.
name|security
operator|=
name|sec_status_indeterminate
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"store error response in message cache"
argument_list|)
expr_stmt|;
name|iter_dns_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
operator|&
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|rcode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** check if prepend item is duplicate item */
end_comment

begin_function
specifier|static
name|int
name|prepend_is_duplicate
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|sets
parameter_list|,
name|size_t
name|to
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dup
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|dup
operator|->
name|rk
operator|.
name|type
operator|&&
name|sets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|rrset_class
operator|==
name|dup
operator|->
name|rk
operator|.
name|rrset_class
operator|&&
name|sets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname_len
operator|==
name|dup
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|sets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dup
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** prepend the prepend list in the answer and authority section of dns_msg */
end_comment

begin_function
specifier|static
name|int
name|iter_prepend
parameter_list|(
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|iter_prep_list
modifier|*
name|p
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|sets
decl_stmt|;
name|size_t
name|num_an
init|=
literal|0
decl_stmt|,
name|num_ns
init|=
literal|0
decl_stmt|;
empty_stmt|;
for|for
control|(
name|p
operator|=
name|iq
operator|->
name|an_prepend_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|num_an
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|iq
operator|->
name|ns_prepend_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|num_ns
operator|++
expr_stmt|;
if|if
condition|(
name|num_an
operator|+
name|num_ns
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"prepending %d rrsets"
argument_list|,
operator|(
name|int
operator|)
name|num_an
operator|+
operator|(
name|int
operator|)
name|num_ns
argument_list|)
expr_stmt|;
name|sets
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
operator|(
name|num_an
operator|+
name|num_ns
operator|+
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sets
condition|)
return|return
literal|0
return|;
comment|/* ANSWER section */
name|num_an
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|iq
operator|->
name|an_prepend_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|sets
index|[
name|num_an
operator|++
index|]
operator|=
name|p
operator|->
name|rrset
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|sets
operator|+
name|num_an
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|rrsets
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AUTH section */
name|num_ns
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|iq
operator|->
name|ns_prepend_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|prepend_is_duplicate
argument_list|(
name|sets
operator|+
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|num_an
argument_list|,
name|num_ns
argument_list|,
name|p
operator|->
name|rrset
argument_list|)
operator|||
name|prepend_is_duplicate
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
argument_list|,
name|p
operator|->
name|rrset
argument_list|)
condition|)
continue|continue;
name|sets
index|[
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|num_an
operator|+
name|num_ns
operator|++
index|]
operator|=
name|p
operator|->
name|rrset
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|sets
operator|+
name|num_an
operator|+
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|num_ns
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|,
operator|(
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NXDOMAIN rcode can stay if we prepended DNAME/CNAMEs, because 	 * this is what recursors should give. */
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|+=
name|num_an
operator|+
name|num_ns
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+=
name|num_an
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|+=
name|num_ns
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|=
name|sets
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Add rrset to ANSWER prepend list  * @param qstate: query state.  * @param iq: iterator query state.  * @param rrset: rrset to add.  * @return false on failure (malloc).  */
end_comment

begin_function
specifier|static
name|int
name|iter_add_prepend_answer
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|iter_prep_list
modifier|*
name|p
init|=
operator|(
expr|struct
name|iter_prep_list
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_prep_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|rrset
operator|=
name|rrset
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* add at end */
if|if
condition|(
name|iq
operator|->
name|an_prepend_last
condition|)
name|iq
operator|->
name|an_prepend_last
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|iq
operator|->
name|an_prepend_list
operator|=
name|p
expr_stmt|;
name|iq
operator|->
name|an_prepend_last
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Add rrset to AUTHORITY prepend list  * @param qstate: query state.  * @param iq: iterator query state.  * @param rrset: rrset to add.  * @return false on failure (malloc).  */
end_comment

begin_function
specifier|static
name|int
name|iter_add_prepend_auth
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|iter_prep_list
modifier|*
name|p
init|=
operator|(
expr|struct
name|iter_prep_list
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_prep_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|rrset
operator|=
name|rrset
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* add at end */
if|if
condition|(
name|iq
operator|->
name|ns_prepend_last
condition|)
name|iq
operator|->
name|ns_prepend_last
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|iq
operator|->
name|ns_prepend_list
operator|=
name|p
expr_stmt|;
name|iq
operator|->
name|ns_prepend_last
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Given a CNAME response (defined as a response containing a CNAME or DNAME  * that does not answer the request), process the response, modifying the  * state as necessary. This follows the CNAME/DNAME chain and returns the  * final query name.  *  * sets the new query name, after following the CNAME/DNAME chain.  * @param qstate: query state.  * @param iq: iterator query state.  * @param msg: the response.  * @param mname: returned target new query name.  * @param mname_len: length of mname.  * @return false on (malloc) error.  */
end_comment

begin_function
specifier|static
name|int
name|handle_cname_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|mname
parameter_list|,
name|size_t
modifier|*
name|mname_len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Start with the (current) qname. */
operator|*
name|mname
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
operator|*
name|mname_len
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
comment|/* Iterate over the ANSWER rrsets in order, looking for CNAMEs and  	 * DNAMES. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|r
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
comment|/* If there is a (relevant) DNAME, add it to the list. 		 * We always expect there to be CNAME that was generated  		 * by this DNAME following, so we don't process the DNAME  		 * directly.  */
if|if
condition|(
name|ntohs
argument_list|(
name|r
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
operator|&&
name|dname_strict_subdomain_c
argument_list|(
operator|*
name|mname
argument_list|,
name|r
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iter_add_prepend_answer
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|r
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|query_dname_compare
argument_list|(
operator|*
name|mname
argument_list|,
name|r
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Add this relevant CNAME rrset to the prepend list.*/
if|if
condition|(
operator|!
name|iter_add_prepend_answer
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
name|get_cname_target
argument_list|(
name|r
argument_list|,
name|mname
argument_list|,
name|mname_len
argument_list|)
expr_stmt|;
block|}
comment|/* Other rrsets in the section are ignored. */
block|}
comment|/* add authority rrsets to authority prepend, for wildcarded CNAMEs */
for|for
control|(
name|i
operator|=
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|r
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
comment|/* only add NSEC/NSEC3, as they may be needed for validation */
if|if
condition|(
name|ntohs
argument_list|(
name|r
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ntohs
argument_list|(
name|r
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
if|if
condition|(
operator|!
name|iter_add_prepend_auth
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Generate a subrequest.  * Generate a local request event. Local events are tied to this module, and  * have a correponding (first tier) event that is waiting for this event to  * resolve to continue.  *  * @param qname The query name for this request.  * @param qnamelen length of qname  * @param qtype The query type for this request.  * @param qclass The query class for this request.  * @param qstate The event that is generating this event.  * @param id: module id.  * @param iq: The iterator state that is generating this event.  * @param initial_state The initial response state (normally this  *          is QUERY_RESP_STATE, unless it is known that the request won't  *          need iterative processing  * @param finalstate The final state for the response to this request.  * @param subq_ret: if newly allocated, the subquerystate, or NULL if it does  * 	not need initialisation.  * @param v: if true, validation is done on the subquery.  * @return false on error (malloc).  */
end_comment

begin_function
specifier|static
name|int
name|generate_sub_request
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|enum
name|iter_state
name|initial_state
parameter_list|,
name|enum
name|iter_state
name|finalstate
parameter_list|,
name|struct
name|module_qstate
modifier|*
modifier|*
name|subq_ret
parameter_list|,
name|int
name|v
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
init|=
name|NULL
decl_stmt|;
name|struct
name|iter_qstate
modifier|*
name|subiq
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|qflags
init|=
literal|0
decl_stmt|;
comment|/* OPCODE QUERY, no flags */
name|struct
name|query_info
name|qinf
decl_stmt|;
name|int
name|prime
init|=
operator|(
name|finalstate
operator|==
name|PRIME_RESP_STATE
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|qinf
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|qinf
operator|.
name|qname_len
operator|=
name|qnamelen
expr_stmt|;
name|qinf
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|qinf
operator|.
name|qclass
operator|=
name|qclass
expr_stmt|;
comment|/* RD should be set only when sending the query back through the INIT 	 * state. */
if|if
condition|(
name|initial_state
operator|==
name|INIT_REQUEST_STATE
condition|)
name|qflags
operator||=
name|BIT_RD
expr_stmt|;
comment|/* We set the CD flag so we can send this through the "head" of  	 * the resolution chain, which might have a validator. We are  	 * uninterested in validating things not on the direct resolution  	 * path.  */
if|if
condition|(
operator|!
name|v
condition|)
name|qflags
operator||=
name|BIT_CD
expr_stmt|;
comment|/* attach subquery, lookup existing or make a new one */
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_attach_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|attach_sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|attach_sub
call|)
argument_list|(
name|qstate
argument_list|,
operator|&
name|qinf
argument_list|,
name|qflags
argument_list|,
name|prime
argument_list|,
operator|&
name|subq
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
operator|*
name|subq_ret
operator|=
name|subq
expr_stmt|;
if|if
condition|(
name|subq
condition|)
block|{
comment|/* initialise the new subquery */
name|subq
operator|->
name|curmod
operator|=
name|id
expr_stmt|;
name|subq
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_state_initial
expr_stmt|;
name|subq
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|regional_alloc
argument_list|(
name|subq
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_qstate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subq
operator|->
name|minfo
index|[
name|id
index|]
condition|)
block|{
name|log_err
argument_list|(
literal|"init subq: out of memory"
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_kill_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|kill_sub
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|kill_sub
call|)
argument_list|(
name|subq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|subiq
operator|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|subq
operator|->
name|minfo
index|[
name|id
index|]
expr_stmt|;
name|memset
argument_list|(
name|subiq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|subiq
argument_list|)
argument_list|)
expr_stmt|;
name|subiq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
name|subiq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|subiq
operator|->
name|depth
operator|=
name|iq
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|outbound_list_init
argument_list|(
operator|&
name|subiq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|subiq
operator|->
name|state
operator|=
name|initial_state
expr_stmt|;
name|subiq
operator|->
name|final_state
operator|=
name|finalstate
expr_stmt|;
name|subiq
operator|->
name|qchase
operator|=
name|subq
operator|->
name|qinfo
expr_stmt|;
name|subiq
operator|->
name|chase_flags
operator|=
name|subq
operator|->
name|query_flags
expr_stmt|;
name|subiq
operator|->
name|refetch_glue
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Generate and send a root priming request.  * @param qstate: the qtstate that triggered the need to prime.  * @param iq: iterator query state.  * @param id: module id.  * @param qclass: the class to prime.  * @return 0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|prime_root
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"priming . %s NS"
argument_list|,
name|sldns_lookup_by_id
argument_list|(
name|sldns_rr_classes
argument_list|,
operator|(
name|int
operator|)
name|qclass
argument_list|)
condition|?
name|sldns_lookup_by_id
argument_list|(
name|sldns_rr_classes
argument_list|,
operator|(
name|int
operator|)
name|qclass
argument_list|)
operator|->
name|name
else|:
literal|"??"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|hints_lookup_root
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|hints
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Cannot prime due to lack of hints"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Priming requests start at the QUERYTARGETS state, skipping  	 * the normal INIT state logic (which would cause an infloop). */
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
literal|"\000"
argument_list|,
literal|1
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|,
name|PRIME_RESP_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"could not prime root"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|subq
condition|)
block|{
name|struct
name|iter_qstate
modifier|*
name|subiq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|subq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
comment|/* Set the initial delegation point to the hint. 		 * copy dp, it is now part of the root prime query.  		 * dp was part of in the fixed hints structure. */
name|subiq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|dp
argument_list|,
name|subq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subiq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory priming root, copydp"
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_kill_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|kill_sub
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|kill_sub
call|)
argument_list|(
name|subq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* there should not be any target queries. */
name|subiq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
name|subiq
operator|->
name|dnssec_expected
operator|=
name|iter_indicates_dnssec
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|subiq
operator|->
name|dp
argument_list|,
name|NULL
argument_list|,
name|subq
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
block|}
comment|/* this module stops, our submodule starts, and does the query. */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Generate and process a stub priming request. This method tests for the  * need to prime a stub zone, so it is safe to call for every request.  *  * @param qstate: the qtstate that triggered the need to prime.  * @param iq: iterator query state.  * @param id: module id.  * @param qname: request name.  * @param qclass: request class.  * @return true if a priming subrequest was made, false if not. The will only  *         issue a priming request if it detects an unprimed stub.  *         Uses value of 2 to signal during stub-prime in root-prime situation  *         that a noprime-stub is available and resolution can continue.  */
end_comment

begin_function
specifier|static
name|int
name|prime_stub
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
comment|/* Lookup the stub hint. This will return null if the stub doesn't  	 * need to be re-primed. */
name|struct
name|iter_hints_stub
modifier|*
name|stub
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|stub_dp
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
if|if
condition|(
operator|!
name|qname
condition|)
return|return
literal|0
return|;
name|stub
operator|=
name|hints_lookup_stub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|hints
argument_list|,
name|qname
argument_list|,
name|qclass
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* The stub (if there is one) does not need priming. */
if|if
condition|(
operator|!
name|stub
condition|)
return|return
literal|0
return|;
name|stub_dp
operator|=
name|stub
operator|->
name|dp
expr_stmt|;
comment|/* is it a noprime stub (always use) */
if|if
condition|(
name|stub
operator|->
name|noprime
condition|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iq
operator|->
name|dp
operator|==
name|NULL
condition|)
name|r
operator|=
literal|2
expr_stmt|;
comment|/* copy the dp out of the fixed hints structure, so that 		 * it can be changed when servicing this query */
name|iq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|stub_dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory priming stub"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* return 1 to make module stop, with error */
block|}
name|log_nametypeclass
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"use stub"
argument_list|,
name|stub_dp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/* Otherwise, we need to (re)prime the stub. */
name|log_nametypeclass
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"priming stub"
argument_list|,
name|stub_dp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
comment|/* Stub priming events start at the QUERYTARGETS state to avoid the 	 * redundant INIT state processing. */
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|stub_dp
operator|->
name|name
argument_list|,
name|stub_dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|,
name|PRIME_RESP_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"could not prime stub"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* return 1 to make module stop, with error */
block|}
if|if
condition|(
name|subq
condition|)
block|{
name|struct
name|iter_qstate
modifier|*
name|subiq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|subq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
comment|/* Set the initial delegation point to the hint. */
comment|/* make copy to avoid use of stub dp by different qs/threads */
name|subiq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|stub_dp
argument_list|,
name|subq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subiq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory priming stub, copydp"
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_kill_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|kill_sub
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|kill_sub
call|)
argument_list|(
name|subq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* return 1 to make module stop, with error */
block|}
comment|/* there should not be any target queries -- although there  		 * wouldn't be anyway, since stub hints never have  		 * missing targets. */
name|subiq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
name|subiq
operator|->
name|wait_priming_stub
operator|=
literal|1
expr_stmt|;
name|subiq
operator|->
name|dnssec_expected
operator|=
name|iter_indicates_dnssec
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|subiq
operator|->
name|dp
argument_list|,
name|NULL
argument_list|,
name|subq
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
block|}
comment|/* this module stops, our submodule starts, and does the query. */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Generate A and AAAA checks for glue that is in-zone for the referral  * we just got to obtain authoritative information on the adresses.  *  * @param qstate: the qtstate that triggered the need to prime.  * @param iq: iterator query state.  * @param id: module id.  */
end_comment

begin_function
specifier|static
name|void
name|generate_a_aaaa_check
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_env
modifier|*
name|ie
init|=
operator|(
expr|struct
name|iter_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|rep
init|=
name|iq
operator|->
name|response
operator|->
name|rep
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|log_assert
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|depth
operator|==
name|ie
operator|->
name|max_dependency_depth
condition|)
return|return;
comment|/* walk through additional, and check if in-zone, 	 * only relevant A, AAAA are left after scrub anyway */
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* check *ALL* addresses that are transmitted in additional*/
comment|/* is it an address ? */
if|if
condition|(
operator|!
operator|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_AAAA
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* is this query the same as the A/AAAA check for it */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
operator|==
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|&&
name|query_dname_compare
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
continue|continue;
comment|/* generate subrequest for it */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"schedule addr fetch"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"could not generate addr check"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ignore subq - not need for more init */
block|}
block|}
end_function

begin_comment
comment|/**  * Generate a NS check request to obtain authoritative information  * on an NS rrset.  *  * @param qstate: the qtstate that triggered the need to prime.  * @param iq: iterator query state.  * @param id: module id.  */
end_comment

begin_function
specifier|static
name|void
name|generate_ns_check
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_env
modifier|*
name|ie
init|=
operator|(
expr|struct
name|iter_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
name|log_assert
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|depth
operator|==
name|ie
operator|->
name|max_dependency_depth
condition|)
return|return;
comment|/* is this query the same as the nscheck? */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|query_dname_compare
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
block|{
comment|/* spawn off A, AAAA queries for in-zone glue to check */
name|generate_a_aaaa_check
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"schedule ns fetch"
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"could not generate ns check"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|subq
condition|)
block|{
name|struct
name|iter_qstate
modifier|*
name|subiq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|subq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
comment|/* make copy to avoid use of stub dp by different qs/threads */
comment|/* refetch glue to start higher up the tree */
name|subiq
operator|->
name|refetch_glue
operator|=
literal|1
expr_stmt|;
name|subiq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|subq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subiq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory generating ns check, copydp"
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_kill_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|kill_sub
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|kill_sub
call|)
argument_list|(
name|subq
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Generate a DNSKEY prefetch query to get the DNSKEY for the DS record we  * just got in a referral (where we have dnssec_expected, thus have trust  * anchors above it).  Note that right after calling this routine the  * iterator detached subqueries (because of following the referral), and thus  * the DNSKEY query becomes detached, its return stored in the cache for  * later lookup by the validator.  This cache lookup by the validator avoids  * the roundtrip incurred by the DNSKEY query.  The DNSKEY query is now  * performed at about the same time the original query is sent to the domain,  * thus the two answers are likely to be returned at about the same time,  * saving a roundtrip from the validated lookup.  *  * @param qstate: the qtstate that triggered the need to prime.  * @param iq: iterator query state.  * @param id: module id.  */
end_comment

begin_function
specifier|static
name|void
name|generate_dnskey_prefetch
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
name|log_assert
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* is this query the same as the prefetch? */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DNSKEY
operator|&&
name|query_dname_compare
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
block|{
return|return;
block|}
comment|/* if the DNSKEY is in the cache this lookup will stop quickly */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"schedule dnskey prefetch"
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* we'll be slower, but it'll work */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"could not generate dnskey prefetch"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|subq
condition|)
block|{
name|struct
name|iter_qstate
modifier|*
name|subiq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|subq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
comment|/* this qstate has the right delegation for the dnskey lookup*/
comment|/* make copy to avoid use of stub dp by different qs/threads */
name|subiq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|subq
operator|->
name|region
argument_list|)
expr_stmt|;
comment|/* if !subiq->dp, it'll start from the cache, no problem */
block|}
block|}
end_function

begin_comment
comment|/**  * See if the query needs forwarding.  *   * @param qstate: query state.  * @param iq: iterator query state.  * @return true if the request is forwarded, false if not.  * 	If returns true but, iq->dp is NULL then a malloc failure occurred.  */
end_comment

begin_function
specifier|static
name|int
name|forward_request
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|)
block|{
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|uint8_t
modifier|*
name|delname
init|=
name|iq
operator|->
name|qchase
operator|.
name|qname
decl_stmt|;
name|size_t
name|delnamelen
init|=
name|iq
operator|->
name|qchase
operator|.
name|qname_len
decl_stmt|;
if|if
condition|(
name|iq
operator|->
name|refetch_glue
condition|)
block|{
name|delname
operator|=
name|iq
operator|->
name|dp
operator|->
name|name
expr_stmt|;
name|delnamelen
operator|=
name|iq
operator|->
name|dp
operator|->
name|namelen
expr_stmt|;
block|}
comment|/* strip one label off of DS query to lookup higher for it */
if|if
condition|(
operator|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|iq
operator|->
name|refetch_glue
operator|)
operator|&&
operator|!
name|dname_is_root
argument_list|(
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|)
condition|)
name|dname_remove_label
argument_list|(
operator|&
name|delname
argument_list|,
operator|&
name|delnamelen
argument_list|)
expr_stmt|;
name|dp
operator|=
name|forwards_lookup
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|fwds
argument_list|,
name|delname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
literal|0
return|;
comment|/* send recursion desired to forward addr */
name|iq
operator|->
name|chase_flags
operator||=
name|BIT_RD
expr_stmt|;
name|iq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
comment|/* iq->dp checked by caller */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"forwarding request"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**   * Process the initial part of the request handling. This state roughly  * corresponds to resolver algorithms steps 1 (find answer in cache) and 2  * (find the best servers to ask).  *  * Note that all requests start here, and query restarts revisit this state.  *  * This state either generates: 1) a response, from cache or error, 2) a  * priming event, or 3) forwards the request to the next state (init2,  * generally).  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param ie: iterator shared global environment.  * @param id: module id.  * @return true if the event needs more request processing immediately,  *         false if not.  */
end_comment

begin_function
specifier|static
name|int
name|processInitRequest
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|delname
decl_stmt|;
name|size_t
name|delnamelen
decl_stmt|;
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|log_query_info
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"resolving"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
comment|/* check effort */
comment|/* We enforce a maximum number of query restarts. This is primarily a 	 * cheap way to prevent CNAME loops. */
if|if
condition|(
name|iq
operator|->
name|query_restart_count
operator|>
name|MAX_RESTART_COUNT
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request has exceeded the maximum number"
literal|" of query restarts with %d"
argument_list|,
name|iq
operator|->
name|query_restart_count
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* We enforce a maximum recursion/dependency depth -- in general,  	 * this is unnecessary for dependency loops (although it will  	 * catch those), but it provides a sensible limit to the amount  	 * of work required to answer a given query. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"request has dependency depth of %d"
argument_list|,
name|iq
operator|->
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|depth
operator|>
name|ie
operator|->
name|max_dependency_depth
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request has exceeded the maximum "
literal|"dependency depth with depth of %d"
argument_list|,
name|iq
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* If the request is qclass=ANY, setup to generate each class */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
operator|==
name|LDNS_RR_CLASS_ANY
condition|)
block|{
name|iq
operator|->
name|qchase
operator|.
name|qclass
operator|=
literal|0
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|COLLECT_CLASS_STATE
argument_list|)
return|;
block|}
comment|/* Resolver Algorithm Step 1 -- Look for the answer in local data. */
comment|/* This either results in a query restart (CNAME cache response), a 	 * terminating response (ANSWER), or a cache miss (null). */
if|if
condition|(
name|qstate
operator|->
name|blacklist
condition|)
block|{
comment|/* if cache, or anything else, was blacklisted then 		 * getting older results from cache is a bad idea, no cache */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cache blacklisted, going to the network"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|dns_cache_lookup
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname_len
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|&&
name|qstate
operator|->
name|env
operator|->
name|neg_cache
condition|)
block|{
comment|/* lookup in negative cache; may result in  			 * NOERROR/NODATA or NXDOMAIN answers that need validation */
name|msg
operator|=
name|val_neg_getmsg
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|neg_cache
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch_buffer
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|,
literal|1
comment|/*add SOA*/
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* item taken from cache does not match our query name, thus 		 * security needs to be re-examined later */
if|if
condition|(
name|msg
operator|&&
name|query_dname_compare
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|)
operator|!=
literal|0
condition|)
name|msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
block|}
if|if
condition|(
name|msg
condition|)
block|{
comment|/* handle positive cache response */
name|enum
name|response_type
name|type
init|=
name|response_type_from_cache
argument_list|(
name|msg
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
block|{
name|log_dns_msg
argument_list|(
literal|"msg from cache lookup"
argument_list|,
operator|&
name|msg
operator|->
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"msg ttl is %d, prefetch ttl %d"
argument_list|,
operator|(
name|int
operator|)
name|msg
operator|->
name|rep
operator|->
name|ttl
argument_list|,
operator|(
name|int
operator|)
name|msg
operator|->
name|rep
operator|->
name|prefetch_ttl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_CNAME
condition|)
block|{
name|uint8_t
modifier|*
name|sname
init|=
literal|0
decl_stmt|;
name|size_t
name|slen
init|=
literal|0
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"returning CNAME response from "
literal|"cache"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle_cname_response
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|msg
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|slen
argument_list|)
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
name|iq
operator|->
name|qchase
operator|.
name|qname
operator|=
name|sname
expr_stmt|;
name|iq
operator|->
name|qchase
operator|.
name|qname_len
operator|=
name|slen
expr_stmt|;
comment|/* This *is* a query restart, even if it is a cheap  			 * one. */
name|iq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|refetch_glue
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|query_restart_count
operator|++
expr_stmt|;
name|iq
operator|->
name|sent_count
operator|=
literal|0
expr_stmt|;
name|sock_list_insert
argument_list|(
operator|&
name|qstate
operator|->
name|reply_origin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|)
return|;
block|}
comment|/* if from cache, NULL, else insert 'cache IP' len=0 */
if|if
condition|(
name|qstate
operator|->
name|reply_origin
condition|)
name|sock_list_insert
argument_list|(
operator|&
name|qstate
operator|->
name|reply_origin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
comment|/* it is an answer, response, to final state */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"returning answer from cache."
argument_list|)
expr_stmt|;
name|iq
operator|->
name|response
operator|=
name|msg
expr_stmt|;
return|return
name|final_state
argument_list|(
name|iq
argument_list|)
return|;
block|}
comment|/* attempt to forward the request */
if|if
condition|(
name|forward_request
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"alloc failure for forward dp"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
name|iq
operator|->
name|refetch_glue
operator|=
literal|0
expr_stmt|;
comment|/* the request has been forwarded. 		 * forwarded requests need to be immediately sent to the  		 * next state, QUERYTARGETS. */
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
comment|/* Resolver Algorithm Step 2 -- find the "best" servers. */
comment|/* first, adjust for DS queries. To avoid the grandparent problem,  	 * we just look for the closest set of server to the parent of qname. 	 * When re-fetching glue we also need to ask the parent. 	 */
if|if
condition|(
name|iq
operator|->
name|refetch_glue
condition|)
block|{
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"internal or malloc fail: no dp for refetch"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
name|delname
operator|=
name|iq
operator|->
name|dp
operator|->
name|name
expr_stmt|;
name|delnamelen
operator|=
name|iq
operator|->
name|dp
operator|->
name|namelen
expr_stmt|;
block|}
else|else
block|{
name|delname
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
name|delnamelen
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|iq
operator|->
name|refetch_glue
operator|||
operator|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|qstate
operator|->
name|prefetch_leeway
operator|)
condition|)
block|{
comment|/* remove first label from delname, root goes to hints, 		 * but only to fetch glue, not for qtype=DS. */
comment|/* also when prefetching an NS record, fetch it again from 		 * its parent, just as if it expired, so that you do not 		 * get stuck on an older nameserver that gives old NSrecords */
if|if
condition|(
name|dname_is_root
argument_list|(
name|delname
argument_list|)
operator|&&
operator|(
name|iq
operator|->
name|refetch_glue
operator|||
operator|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|qstate
operator|->
name|prefetch_leeway
operator|)
operator|)
condition|)
name|delname
operator|=
name|NULL
expr_stmt|;
comment|/* go to root priming */
else|else
name|dname_remove_label
argument_list|(
operator|&
name|delname
argument_list|,
operator|&
name|delnamelen
argument_list|)
expr_stmt|;
block|}
comment|/* delname is the name to lookup a delegation for. If NULL rootprime */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Lookup the delegation in the cache. If null, then the  		 * cache needs to be primed for the qclass. */
if|if
condition|(
name|delname
condition|)
name|iq
operator|->
name|dp
operator|=
name|dns_cache_find_delegation
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|delname
argument_list|,
name|delnamelen
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
operator|&
name|iq
operator|->
name|deleg_msg
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
operator|+
name|qstate
operator|->
name|prefetch_leeway
argument_list|)
expr_stmt|;
else|else
name|iq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
comment|/* If the cache has returned nothing, then we have a  		 * root priming situation. */
if|if
condition|(
name|iq
operator|->
name|dp
operator|==
name|NULL
condition|)
block|{
comment|/* if there is a stub, then no root prime needed */
name|int
name|r
init|=
name|prime_stub
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|delname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|2
condition|)
break|break;
comment|/* got noprime-stub-zone, continue */
elseif|else
if|if
condition|(
name|r
condition|)
return|return
literal|0
return|;
comment|/* stub prime request made */
if|if
condition|(
name|forwards_lookup_root
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|fwds
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
block|{
comment|/* forward zone root, no root prime needed */
comment|/* fill in some dp - safety belt */
name|iq
operator|->
name|dp
operator|=
name|hints_lookup_root
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|hints
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"internal error: no hints dp"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
name|iq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in safety belt"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|INIT_REQUEST_2_STATE
argument_list|)
return|;
block|}
comment|/* Note that the result of this will set a new 			 * DelegationPoint based on the result of priming. */
if|if
condition|(
operator|!
name|prime_root
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_REFUSED
argument_list|)
return|;
comment|/* priming creates and sends a subordinate query, with  			 * this query as the parent. So further processing for  			 * this event will stop until reactivated by the  			 * results of priming. */
return|return
literal|0
return|;
block|}
comment|/* see if this dp not useless. 		 * It is useless if: 		 *	o all NS items are required glue.  		 *	  or the query is for NS item that is required glue. 		 *	o no addresses are provided. 		 *	o RD qflag is on. 		 * Instead, go up one level, and try to get even further 		 * If the root was useless, use safety belt information.  		 * Only check cache returns, because replies for servers 		 * could be useless but lead to loops (bumping into the 		 * same server reply) if useless-checked. 		 */
if|if
condition|(
name|iter_dp_is_useless
argument_list|(
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|query_flags
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dname_is_root
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* use safety belt */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Cache has root NS but "
literal|"no addresses. Fallback to the safety belt."
argument_list|)
expr_stmt|;
name|iq
operator|->
name|dp
operator|=
name|hints_lookup_root
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|hints
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
comment|/* note deleg_msg is from previous lookup, 				 * but RD is on, so it is not used */
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"internal error: no hints dp"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_REFUSED
argument_list|)
return|;
block|}
name|iq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in safety belt"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
break|break;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cache delegation was useless:"
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* go up */
name|delname
operator|=
name|iq
operator|->
name|dp
operator|->
name|name
expr_stmt|;
name|delnamelen
operator|=
name|iq
operator|->
name|dp
operator|->
name|namelen
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|delname
argument_list|,
operator|&
name|delnamelen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cache delegation returns delegpt"
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* Otherwise, set the current delegation point and move on to the  	 * next state. */
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|INIT_REQUEST_2_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * Process the second part of the initial request handling. This state  * basically exists so that queries that generate root priming events have  * the same init processing as ones that do not. Request events that reach  * this state must have a valid currentDelegationPoint set.  *  * This part is primarly handling stub zone priming. Events that reach this  * state must have a current delegation point.  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @return true if the event needs more request processing immediately,  *         false if not.  */
end_comment

begin_function
specifier|static
name|int
name|processInitRequest2
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|delname
decl_stmt|;
name|size_t
name|delnamelen
decl_stmt|;
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"resolving (init part 2): "
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|refetch_glue
condition|)
block|{
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"internal or malloc fail: no dp for refetch"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
name|delname
operator|=
name|iq
operator|->
name|dp
operator|->
name|name
expr_stmt|;
name|delnamelen
operator|=
name|iq
operator|->
name|dp
operator|->
name|namelen
expr_stmt|;
block|}
else|else
block|{
name|delname
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
name|delnamelen
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|iq
operator|->
name|refetch_glue
condition|)
block|{
if|if
condition|(
operator|!
name|dname_is_root
argument_list|(
name|delname
argument_list|)
condition|)
name|dname_remove_label
argument_list|(
operator|&
name|delname
argument_list|,
operator|&
name|delnamelen
argument_list|)
expr_stmt|;
name|iq
operator|->
name|refetch_glue
operator|=
literal|0
expr_stmt|;
comment|/* if CNAME causes restart, no refetch */
block|}
comment|/* Check to see if we need to prime a stub zone. */
if|if
condition|(
name|prime_stub
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|delname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
block|{
comment|/* A priming sub request was made */
return|return
literal|0
return|;
block|}
comment|/* most events just get forwarded to the next state. */
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|INIT_REQUEST_3_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * Process the third part of the initial request handling. This state exists  * as a separate state so that queries that generate stub priming events  * will get the tail end of the init process but not repeat the stub priming  * check.  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @return true, advancing the event to the QUERYTARGETS_STATE.  */
end_comment

begin_function
specifier|static
name|int
name|processInitRequest3
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"resolving (init part 3): "
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
comment|/* if the cache reply dp equals a validation anchor or msg has DS, 	 * then DNSSEC RRSIGs are expected in the reply */
name|iq
operator|->
name|dnssec_expected
operator|=
name|iter_indicates_dnssec
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|iq
operator|->
name|deleg_msg
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
comment|/* If the RD flag wasn't set, then we just finish with the  	 * cached referral as the response. */
if|if
condition|(
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
operator|)
condition|)
block|{
name|iq
operator|->
name|response
operator|=
name|iq
operator|->
name|deleg_msg
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
operator|&&
name|iq
operator|->
name|response
condition|)
name|log_dns_msg
argument_list|(
literal|"no RD requested, using delegation msg"
argument_list|,
operator|&
name|iq
operator|->
name|response
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|reply_origin
condition|)
name|sock_list_insert
argument_list|(
operator|&
name|qstate
operator|->
name|reply_origin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
return|return
name|final_state
argument_list|(
name|iq
argument_list|)
return|;
block|}
comment|/* After this point, unset the RD flag -- this query is going to  	 * be sent to an auth. server. */
name|iq
operator|->
name|chase_flags
operator|&=
operator|~
name|BIT_RD
expr_stmt|;
comment|/* if dnssec expected, fetch key for the trust-anchor or cached-DS */
if|if
condition|(
name|iq
operator|->
name|dnssec_expected
operator|&&
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|prefetch_key
operator|&&
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
block|{
name|generate_dnskey_prefetch
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detach_subs
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detach_subs
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detach_subs
call|)
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to the next state. */
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Given a basic query, generate a parent-side "target" query.   * These are subordinate queries for missing delegation point target addresses,  * for which only the parent of the delegation provides correct IP addresses.  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @param name: target qname.  * @param namelen: target qname length.  * @param qtype: target qtype (either A or AAAA).  * @param qclass: target qclass.  * @return true on success, false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|generate_parentside_target_query
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|subq
condition|)
block|{
name|struct
name|iter_qstate
modifier|*
name|subiq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|subq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
comment|/* blacklist the cache - we want to fetch parent stuff */
name|sock_list_insert
argument_list|(
operator|&
name|subq
operator|->
name|blacklist
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|subq
operator|->
name|region
argument_list|)
expr_stmt|;
name|subiq
operator|->
name|query_for_pside_glue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
condition|)
block|{
name|subiq
operator|->
name|dp
operator|=
name|delegpt_copy
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|subq
operator|->
name|region
argument_list|)
expr_stmt|;
name|subiq
operator|->
name|dnssec_expected
operator|=
name|iter_indicates_dnssec
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|subiq
operator|->
name|dp
argument_list|,
name|NULL
argument_list|,
name|subq
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
name|subiq
operator|->
name|refetch_glue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|subiq
operator|->
name|dp
operator|=
name|dns_cache_find_delegation
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|subq
operator|->
name|region
argument_list|,
operator|&
name|subiq
operator|->
name|deleg_msg
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
operator|+
name|subq
operator|->
name|prefetch_leeway
argument_list|)
expr_stmt|;
comment|/* if no dp, then it's from root, refetch unneeded */
if|if
condition|(
name|subiq
operator|->
name|dp
condition|)
block|{
name|subiq
operator|->
name|dnssec_expected
operator|=
name|iter_indicates_dnssec
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|subiq
operator|->
name|dp
argument_list|,
name|NULL
argument_list|,
name|subq
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
name|subiq
operator|->
name|refetch_glue
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"new pside target"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Given a basic query, generate a "target" query. These are subordinate  * queries for missing delegation point target addresses.  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @param name: target qname.  * @param namelen: target qname length.  * @param qtype: target qtype (either A or AAAA).  * @param qclass: target qclass.  * @return true on success, false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|generate_target_query
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"new target"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Given an event at a certain state, generate zero or more target queries  * for it's current delegation point.  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param ie: iterator shared global environment.  * @param id: module id.  * @param maxtargets: The maximum number of targets to query for.  *	if it is negative, there is no maximum number of targets.  * @param num: returns the number of queries generated and processed,   *	which may be zero if there were no missing targets.  * @return false on error.  */
end_comment

begin_function
specifier|static
name|int
name|query_for_targets
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|maxtargets
parameter_list|,
name|int
modifier|*
name|num
parameter_list|)
block|{
name|int
name|query_count
init|=
literal|0
decl_stmt|;
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|int
name|missing
decl_stmt|;
name|int
name|toget
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iq
operator|->
name|depth
operator|==
name|ie
operator|->
name|max_dependency_depth
condition|)
return|return
literal|0
return|;
name|iter_mark_cycle_targets
argument_list|(
name|qstate
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
name|missing
operator|=
operator|(
name|int
operator|)
name|delegpt_count_missing_targets
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|maxtargets
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* that would not be useful */
comment|/* Generate target requests. Basically, any missing targets  	 * are queried for here, regardless if it is necessary to do  	 * so to continue processing. */
if|if
condition|(
name|maxtargets
operator|<
literal|0
operator|||
name|maxtargets
operator|>
name|missing
condition|)
name|toget
operator|=
name|missing
expr_stmt|;
else|else
name|toget
operator|=
name|maxtargets
expr_stmt|;
if|if
condition|(
name|toget
operator|==
literal|0
condition|)
block|{
operator|*
name|num
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* select 'toget' items from the total of 'missing' items */
name|log_assert
argument_list|(
name|toget
operator|<=
name|missing
argument_list|)
expr_stmt|;
comment|/* loop over missing targets */
for|for
control|(
name|ns
operator|=
name|iq
operator|->
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ns
operator|->
name|resolved
condition|)
continue|continue;
comment|/* randomly select this item with probability toget/missing */
if|if
condition|(
operator|!
name|iter_ns_probability
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|rnd
argument_list|,
name|toget
argument_list|,
name|missing
argument_list|)
condition|)
block|{
comment|/* do not select this one, next; select toget number 			 * of items from a list one less in size */
name|missing
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ie
operator|->
name|supports_ipv6
operator|&&
operator|!
name|ns
operator|->
name|got6
condition|)
block|{
comment|/* Send the AAAA request. */
if|if
condition|(
operator|!
name|generate_target_query
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
block|{
operator|*
name|num
operator|=
name|query_count
expr_stmt|;
if|if
condition|(
name|query_count
operator|>
literal|0
condition|)
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|0
return|;
block|}
name|query_count
operator|++
expr_stmt|;
block|}
comment|/* Send the A request. */
if|if
condition|(
name|ie
operator|->
name|supports_ipv4
operator|&&
operator|!
name|ns
operator|->
name|got4
condition|)
block|{
if|if
condition|(
operator|!
name|generate_target_query
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
block|{
operator|*
name|num
operator|=
name|query_count
expr_stmt|;
if|if
condition|(
name|query_count
operator|>
literal|0
condition|)
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|0
return|;
block|}
name|query_count
operator|++
expr_stmt|;
block|}
comment|/* mark this target as in progress. */
name|ns
operator|->
name|resolved
operator|=
literal|1
expr_stmt|;
name|missing
operator|--
expr_stmt|;
name|toget
operator|--
expr_stmt|;
if|if
condition|(
name|toget
operator|==
literal|0
condition|)
break|break;
block|}
operator|*
name|num
operator|=
name|query_count
expr_stmt|;
if|if
condition|(
name|query_count
operator|>
literal|0
condition|)
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** see if last resort is possible - does config allow queries to parent */
end_comment

begin_function
specifier|static
name|int
name|can_have_last_resort
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|)
block|{
name|struct
name|delegpt
modifier|*
name|fwddp
decl_stmt|;
name|struct
name|iter_hints_stub
modifier|*
name|stub
decl_stmt|;
comment|/* do not process a last resort (the parent side) if a stub 	 * or forward is configured, because we do not want to go 'above' 	 * the configured servers */
if|if
condition|(
operator|!
name|dname_is_root
argument_list|(
name|dp
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|stub
operator|=
operator|(
expr|struct
name|iter_hints_stub
operator|*
operator|)
name|name_tree_find
argument_list|(
operator|&
name|env
operator|->
name|hints
operator|->
name|tree
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|dp
operator|->
name|namelabs
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
operator|)
operator|&&
comment|/* has_parent side is turned off for stub_first, where we 		 * are allowed to go to the parent */
name|stub
operator|->
name|dp
operator|->
name|has_parent_side_NS
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"configured stub servers failed -- returning SERVFAIL"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|fwddp
operator|=
name|forwards_find
argument_list|(
name|env
operator|->
name|fwds
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
operator|)
operator|&&
comment|/* has_parent_side is turned off for forward_first, where 		 * we are allowed to go to the parent */
name|fwddp
operator|->
name|has_parent_side_NS
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"configured forward servers failed -- returning SERVFAIL"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Called by processQueryTargets when it would like extra targets to query  * but it seems to be out of options.  At last resort some less appealing  * options are explored.  If there are no more options, the result is SERVFAIL  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param ie: iterator shared global environment.  * @param id: module id.  * @return true if the event requires more request processing immediately,  *         false if not.   */
end_comment

begin_function
specifier|static
name|int
name|processLastResort
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|int
name|query_count
init|=
literal|0
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"No more query targets, attempting last resort"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_have_last_resort
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|iq
argument_list|)
condition|)
block|{
comment|/* fail -- no more targets, no more hope of targets, no hope  		 * of a response. */
return|return
name|error_response_cache
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
operator|&&
name|dname_is_root
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
condition|)
block|{
name|struct
name|delegpt
modifier|*
name|p
init|=
name|hints_lookup_root
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|hints
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|;
name|iq
operator|->
name|chase_flags
operator|&=
operator|~
name|BIT_RD
expr_stmt|;
comment|/* go to authorities */
for|for
control|(
name|ns
operator|=
name|p
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
operator|(
name|void
operator|)
name|delegpt_add_ns
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|lame
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
name|p
operator|->
name|target_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next_target
control|)
block|{
operator|(
name|void
operator|)
name|delegpt_add_addr
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|a
operator|->
name|bogus
argument_list|,
name|a
operator|->
name|lame
argument_list|)
expr_stmt|;
block|}
block|}
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
condition|)
block|{
if|if
condition|(
operator|!
name|iter_lookup_parent_NS_from_cache
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
operator|||
operator|!
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
condition|)
block|{
comment|/* if: malloc failure in lookup go up to try */
comment|/* if: no parent NS in cache - go up one level */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"try to grab parent NS"
argument_list|)
expr_stmt|;
name|iq
operator|->
name|store_parent_NS
operator|=
name|iq
operator|->
name|dp
expr_stmt|;
name|iq
operator|->
name|chase_flags
operator|&=
operator|~
name|BIT_RD
expr_stmt|;
comment|/* go to authorities */
name|iq
operator|->
name|deleg_msg
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|refetch_glue
operator|=
literal|1
expr_stmt|;
name|iq
operator|->
name|query_restart_count
operator|++
expr_stmt|;
name|iq
operator|->
name|sent_count
operator|=
literal|0
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|)
return|;
block|}
block|}
comment|/* see if that makes new names available */
if|if
condition|(
operator|!
name|cache_fill_missing
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory in cache_fill_missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|dp
operator|->
name|usable_list
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"try parent-side-name, w. glue from cache"
argument_list|)
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
comment|/* try to fill out parent glue from cache */
if|if
condition|(
name|iter_lookup_parent_glue_from_cache
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
condition|)
block|{
comment|/* got parent stuff from cache, see if we can continue */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"try parent-side glue from cache"
argument_list|)
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
comment|/* query for an extra name added by the parent-NS record */
if|if
condition|(
name|delegpt_count_missing_targets
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|qs
init|=
literal|0
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"try parent-side target name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query_for_targets
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|,
literal|1
argument_list|,
operator|&
name|qs
argument_list|)
condition|)
block|{
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
name|iq
operator|->
name|num_target_queries
operator|+=
name|qs
expr_stmt|;
if|if
condition|(
name|qs
operator|!=
literal|0
condition|)
block|{
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|0
return|;
comment|/* and wait for them */
block|}
block|}
if|if
condition|(
name|iq
operator|->
name|depth
operator|==
name|ie
operator|->
name|max_dependency_depth
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"maxdepth and need more nameservers, fail"
argument_list|)
expr_stmt|;
return|return
name|error_response_cache
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* mark cycle targets for parent-side lookups */
name|iter_mark_pside_cycle_targets
argument_list|(
name|qstate
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* see if we can issue queries to get nameserver addresses */
comment|/* this lookup is not randomized, but sequential. */
for|for
control|(
name|ns
operator|=
name|iq
operator|->
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
comment|/* query for parent-side A and AAAA for nameservers */
if|if
condition|(
name|ie
operator|->
name|supports_ipv6
operator|&&
operator|!
name|ns
operator|->
name|done_pside6
condition|)
block|{
comment|/* Send the AAAA request. */
if|if
condition|(
operator|!
name|generate_parentside_target_query
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
name|ns
operator|->
name|done_pside6
operator|=
literal|1
expr_stmt|;
name|query_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ie
operator|->
name|supports_ipv4
operator|&&
operator|!
name|ns
operator|->
name|done_pside4
condition|)
block|{
comment|/* Send the A request. */
if|if
condition|(
operator|!
name|generate_parentside_target_query
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
name|ns
operator|->
name|done_pside4
operator|=
literal|1
expr_stmt|;
name|query_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|query_count
operator|!=
literal|0
condition|)
block|{
comment|/* suspend to await results */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"try parent-side glue lookup"
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|+=
name|query_count
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* if this was a parent-side glue query itself, then store that 	 * failure in cache. */
if|if
condition|(
name|iq
operator|->
name|query_for_pside_glue
operator|&&
operator|!
name|iq
operator|->
name|pside_glue
condition|)
name|iter_store_parentside_neg
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|deleg_msg
condition|?
name|iq
operator|->
name|deleg_msg
operator|->
name|rep
else|:
operator|(
name|iq
operator|->
name|response
condition|?
name|iq
operator|->
name|response
operator|->
name|rep
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"out of query targets -- returning SERVFAIL"
argument_list|)
expr_stmt|;
comment|/* fail -- no more targets, no more hope of targets, no hope  	 * of a response. */
return|return
name|error_response_cache
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * Try to find the NS record set that will resolve a qtype DS query. Due  * to grandparent/grandchild reasons we did not get a proper lookup right  * away.  We need to create type NS queries until we get the right parent  * for this lookup.  We remove labels from the query to find the right point.  * If we end up at the old dp name, then there is no solution.  *   * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @return true if the event requires more immediate processing, false if  *         not. This is generally only true when forwarding the request to  *         the final state (i.e., on answer).  */
end_comment

begin_function
specifier|static
name|int
name|processDSNSFind
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
init|=
name|NULL
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processDSNSFind"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|dsns_point
condition|)
block|{
comment|/* initialize */
name|iq
operator|->
name|dsns_point
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname
expr_stmt|;
name|iq
operator|->
name|dsns_point_len
operator|=
name|iq
operator|->
name|qchase
operator|.
name|qname_len
expr_stmt|;
block|}
comment|/* robustcheck for internal error: we are not underneath the dp */
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|iq
operator|->
name|dsns_point
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
condition|)
block|{
return|return
name|error_response_cache
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* go up one (more) step, until we hit the dp, if so, end */
name|dname_remove_label
argument_list|(
operator|&
name|iq
operator|->
name|dsns_point
argument_list|,
operator|&
name|iq
operator|->
name|dsns_point_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|iq
operator|->
name|dsns_point
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* there was no inbetween nameserver, use the old delegation 		 * point again.  And this time, because dsns_point is nonNULL 		 * we are going to accept the (bad) result */
name|iq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
name|iq
operator|->
name|state
operator|=
name|DSNS_FIND_STATE
expr_stmt|;
comment|/* spawn NS lookup (validation not needed, this is for DS lookup) */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"fetch nameservers"
argument_list|,
name|iq
operator|->
name|dsns_point
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|iq
operator|->
name|dsns_point
argument_list|,
name|iq
operator|->
name|dsns_point_len
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|error_response_cache
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * This is the request event state where the request will be sent to one of  * its current query targets. This state also handles issuing target lookup  * queries for missing target IP addresses. Queries typically iterate on  * this state, both when they are just trying different targets for a given  * delegation point, and when they change delegation points. This state  * roughly corresponds to RFC 1034 algorithm steps 3 and 4.  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param ie: iterator shared global environment.  * @param id: module id.  * @return true if the event requires more request processing immediately,  *         false if not. This state only returns true when it is generating  *         a SERVFAIL response because the query has hit a dead end.  */
end_comment

begin_function
specifier|static
name|int
name|processQueryTargets
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|tf_policy
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|target
decl_stmt|;
name|struct
name|outbound_entry
modifier|*
name|outq
decl_stmt|;
comment|/* NOTE: a request will encounter this state for each target it  	 * needs to send a query to. That is, at least one per referral,  	 * more if some targets timeout or return throwaway answers. */
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"processQueryTargets:"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processQueryTargets: targetqueries %d, "
literal|"currentqueries %d sentcount %d"
argument_list|,
name|iq
operator|->
name|num_target_queries
argument_list|,
name|iq
operator|->
name|num_current_queries
argument_list|,
name|iq
operator|->
name|sent_count
argument_list|)
expr_stmt|;
comment|/* Make sure that we haven't run away */
comment|/* FIXME: is this check even necessary? */
if|if
condition|(
name|iq
operator|->
name|referral_count
operator|>
name|MAX_REFERRAL_COUNT
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request has exceeded the maximum "
literal|"number of referrrals with %d"
argument_list|,
name|iq
operator|->
name|referral_count
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
if|if
condition|(
name|iq
operator|->
name|sent_count
operator|>
name|MAX_SENT_COUNT
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request has exceeded the maximum "
literal|"number of sends with %d"
argument_list|,
name|iq
operator|->
name|sent_count
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* Make sure we have a delegation point, otherwise priming failed 	 * or another failure occurred */
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Failed to get a delegation, giving up"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ie
operator|->
name|supports_ipv6
condition|)
name|delegpt_no_ipv6
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ie
operator|->
name|supports_ipv4
condition|)
name|delegpt_no_ipv4
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|num_current_queries
operator|>
literal|0
condition|)
block|{
comment|/* already busy answering a query, this restart is because 		 * more delegpt addrs became available, wait for existing 		 * query. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"woke up, but wait for outstanding query"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_reply
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tf_policy
operator|=
literal|0
expr_stmt|;
comment|/*< not<=, because although the array is large enough for<=, the 	 * generated query will immediately be discarded due to depth and 	 * that servfail is cached, which is not good as opportunism goes. */
if|if
condition|(
name|iq
operator|->
name|depth
operator|<
name|ie
operator|->
name|max_dependency_depth
operator|&&
name|iq
operator|->
name|sent_count
operator|<
name|TARGET_FETCH_STOP
condition|)
block|{
name|tf_policy
operator|=
name|ie
operator|->
name|target_fetch_policy
index|[
name|iq
operator|->
name|depth
index|]
expr_stmt|;
block|}
comment|/* if in 0x20 fallback get as many targets as possible */
if|if
condition|(
name|iq
operator|->
name|caps_fallback
condition|)
block|{
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|size_t
name|naddr
decl_stmt|,
name|nres
decl_stmt|,
name|navail
decl_stmt|;
if|if
condition|(
operator|!
name|query_for_targets
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|extra
argument_list|)
condition|)
block|{
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
name|iq
operator|->
name|num_target_queries
operator|+=
name|extra
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|num_target_queries
operator|>
literal|0
condition|)
block|{
comment|/* wait to get all targets, we want to try em */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"wait for all targets for fallback"
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_reply
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* did we do enough fallback queries already? */
name|delegpt_count_addr
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
operator|&
name|naddr
argument_list|,
operator|&
name|nres
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
comment|/* the current caps_server is the number of fallbacks sent. 		 * the original query is one that matched too, so we have 		 * caps_server+1 number of matching queries now */
if|if
condition|(
name|iq
operator|->
name|caps_server
operator|+
literal|1
operator|>=
name|naddr
operator|*
literal|3
operator|||
name|iq
operator|->
name|caps_server
operator|+
literal|1
operator|>=
name|MAX_SENT_COUNT
condition|)
block|{
comment|/* we're done, process the response */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"0x20 fallback had %d responses "
literal|"match for %d wanted, done."
argument_list|,
operator|(
name|int
operator|)
name|iq
operator|->
name|caps_server
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|)
name|naddr
operator|*
literal|3
argument_list|)
expr_stmt|;
name|iq
operator|->
name|caps_fallback
operator|=
literal|0
expr_stmt|;
name|iter_dec_attempts
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* space for fallback */
name|iq
operator|->
name|num_current_queries
operator|++
expr_stmt|;
comment|/* RespState decrements it*/
name|iq
operator|->
name|referral_count
operator|++
expr_stmt|;
comment|/* make sure we don't loop */
name|iq
operator|->
name|sent_count
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|state
operator|=
name|QUERY_RESP_STATE
expr_stmt|;
return|return
literal|1
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"0x20 fallback number %d"
argument_list|,
operator|(
name|int
operator|)
name|iq
operator|->
name|caps_server
argument_list|)
expr_stmt|;
comment|/* if there is a policy to fetch missing targets  	 * opportunistically, do it. we rely on the fact that once a  	 * query (or queries) for a missing name have been issued,  	 * they will not show up again. */
block|}
elseif|else
if|if
condition|(
name|tf_policy
operator|!=
literal|0
condition|)
block|{
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"attempt to get extra %d targets"
argument_list|,
name|tf_policy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|query_for_targets
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|,
name|tf_policy
argument_list|,
operator|&
name|extra
argument_list|)
expr_stmt|;
comment|/* errors ignored, these targets are not strictly necessary for 		 * this result, we do not have to reply with SERVFAIL */
name|iq
operator|->
name|num_target_queries
operator|+=
name|extra
expr_stmt|;
block|}
comment|/* Add the current set of unused targets to our queue. */
name|delegpt_add_unused_targets
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* Select the next usable target, filtering out unsuitable targets. */
name|target
operator|=
name|iter_server_selection
argument_list|(
name|ie
argument_list|,
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|namelen
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|,
operator|&
name|iq
operator|->
name|dnssec_lame_query
argument_list|,
operator|&
name|iq
operator|->
name|chase_to_rd
argument_list|,
name|iq
operator|->
name|num_target_queries
argument_list|,
name|qstate
operator|->
name|blacklist
argument_list|)
expr_stmt|;
comment|/* If no usable target was selected... */
if|if
condition|(
operator|!
name|target
condition|)
block|{
comment|/* Here we distinguish between three states: generate a new  		 * target query, just wait, or quit (with a SERVFAIL). 		 * We have the following information: number of active  		 * target queries, number of active current queries,  		 * the presence of missing targets at this delegation  		 * point, and the given query target policy. */
comment|/* Check for the wait condition. If this is true, then  		 * an action must be taken. */
if|if
condition|(
name|iq
operator|->
name|num_target_queries
operator|==
literal|0
operator|&&
name|iq
operator|->
name|num_current_queries
operator|==
literal|0
condition|)
block|{
comment|/* If there is nothing to wait for, then we need  			 * to distinguish between generating (a) new target  			 * query, or failing. */
if|if
condition|(
name|delegpt_count_missing_targets
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|qs
init|=
literal|0
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"querying for next "
literal|"missing target"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query_for_targets
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|,
literal|1
argument_list|,
operator|&
name|qs
argument_list|)
condition|)
block|{
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
if|if
condition|(
name|qs
operator|==
literal|0
operator|&&
name|delegpt_count_missing_targets
argument_list|(
name|iq
operator|->
name|dp
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it looked like there were missing 					 * targets, but they did not turn up. 					 * Try the bad choices again (if any), 					 * when we get back here missing==0, 					 * so this is not a loop. */
return|return
literal|1
return|;
block|}
name|iq
operator|->
name|num_target_queries
operator|+=
name|qs
expr_stmt|;
block|}
comment|/* Since a target query might have been made, we  			 * need to check again. */
if|if
condition|(
name|iq
operator|->
name|num_target_queries
operator|==
literal|0
condition|)
block|{
return|return
name|processLastResort
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
return|;
block|}
block|}
comment|/* otherwise, we have no current targets, so submerge  		 * until one of the target or direct queries return. */
if|if
condition|(
name|iq
operator|->
name|num_target_queries
operator|>
literal|0
operator|&&
name|iq
operator|->
name|num_current_queries
operator|>
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no current targets -- waiting "
literal|"for %d targets to resolve or %d outstanding"
literal|" queries to respond"
argument_list|,
name|iq
operator|->
name|num_target_queries
argument_list|,
name|iq
operator|->
name|num_current_queries
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_reply
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iq
operator|->
name|num_target_queries
operator|>
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no current targets -- waiting "
literal|"for %d targets to resolve."
argument_list|,
name|iq
operator|->
name|num_target_queries
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_subquery
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no current targets -- waiting "
literal|"for %d outstanding queries to respond."
argument_list|,
name|iq
operator|->
name|num_current_queries
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_reply
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* We have a valid target. */
if|if
condition|(
name|verbosity
operator|>=
name|VERB_QUERY
condition|)
block|{
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"sending query:"
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|)
expr_stmt|;
name|log_name_addr
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"sending to target:"
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
operator|&
name|target
operator|->
name|addr
argument_list|,
name|target
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dnssec status: %s%s"
argument_list|,
name|iq
operator|->
name|dnssec_expected
condition|?
literal|"expected"
else|:
literal|"not expected"
argument_list|,
name|iq
operator|->
name|dnssec_lame_query
condition|?
literal|" but lame_query anyway"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_send_query
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|send_query
argument_list|)
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|send_query
call|)
argument_list|(
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname_len
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|iq
operator|->
name|chase_flags
operator||
operator|(
name|iq
operator|->
name|chase_to_rd
condition|?
name|BIT_RD
else|:
literal|0
operator|)
argument_list|,
name|EDNS_DO
operator||
name|BIT_CD
argument_list|,
name|iq
operator|->
name|dnssec_expected
argument_list|,
operator|&
name|target
operator|->
name|addr
argument_list|,
name|target
operator|->
name|addrlen
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|namelen
argument_list|,
name|qstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outq
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"error sending query to auth server"
argument_list|,
operator|&
name|target
operator|->
name|addr
argument_list|,
name|target
operator|->
name|addrlen
argument_list|)
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
name|outbound_list_insert
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|,
name|outq
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|++
expr_stmt|;
name|iq
operator|->
name|sent_count
operator|++
expr_stmt|;
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_wait_reply
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** find NS rrset in given list */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|find_NS
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|size_t
name|from
parameter_list|,
name|size_t
name|to
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
return|return
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   * Process the query response. All queries end up at this state first. This  * process generally consists of analyzing the response and routing the  * event to the next state (either bouncing it back to a request state, or  * terminating the processing for this event).  *   * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @return true if the event requires more immediate processing, false if  *         not. This is generally only true when forwarding the request to  *         the final state (i.e., on answer).  */
end_comment

begin_function
specifier|static
name|int
name|processQueryResponse
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|dnsseclame
init|=
literal|0
decl_stmt|;
name|enum
name|response_type
name|type
decl_stmt|;
name|iq
operator|->
name|num_current_queries
operator|--
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|response
operator|==
name|NULL
condition|)
block|{
name|iq
operator|->
name|chase_to_rd
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|dnssec_lame_query
operator|=
literal|0
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"query response was timeout"
argument_list|)
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
name|type
operator|=
name|response_type_from_server
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|iq
operator|->
name|chase_flags
operator|&
name|BIT_RD
operator|)
operator|||
name|iq
operator|->
name|chase_to_rd
argument_list|)
argument_list|,
name|iq
operator|->
name|response
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
name|iq
operator|->
name|chase_to_rd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_REFERRAL
operator|&&
operator|(
name|iq
operator|->
name|chase_flags
operator|&
name|BIT_RD
operator|)
condition|)
block|{
comment|/* When forwarding (RD bit is set), we handle referrals  		 * differently. No queries should be sent elsewhere */
name|type
operator|=
name|RESPONSE_TYPE_ANSWER
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|dnssec_expected
operator|&&
operator|!
name|iq
operator|->
name|dnssec_lame_query
operator|&&
operator|!
operator|(
name|iq
operator|->
name|chase_flags
operator|&
name|BIT_RD
operator|)
operator|&&
name|type
operator|!=
name|RESPONSE_TYPE_LAME
operator|&&
name|type
operator|!=
name|RESPONSE_TYPE_REC_LAME
operator|&&
name|type
operator|!=
name|RESPONSE_TYPE_THROWAWAY
operator|&&
name|type
operator|!=
name|RESPONSE_TYPE_UNTYPED
condition|)
block|{
comment|/* a possible answer, see if it is missing DNSSEC */
comment|/* but not when forwarding, so we dont mark fwder lame */
if|if
condition|(
operator|!
name|iter_msg_has_dnssec
argument_list|(
name|iq
operator|->
name|response
argument_list|)
condition|)
block|{
comment|/* Mark this address as dnsseclame in this dp, 			 * because that will make serverselection disprefer 			 * it, but also, once it is the only final option, 			 * use dnssec-lame-bypass if it needs to query there.*/
if|if
condition|(
name|qstate
operator|->
name|reply
condition|)
block|{
name|struct
name|delegpt_addr
modifier|*
name|a
init|=
name|delegpt_find_addr
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
operator|&
name|qstate
operator|->
name|reply
operator|->
name|addr
argument_list|,
name|qstate
operator|->
name|reply
operator|->
name|addrlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
condition|)
name|a
operator|->
name|dnsseclame
operator|=
literal|1
expr_stmt|;
block|}
comment|/* test the answer is from the zone we expected, 		 	 * otherwise, (due to parent,child on same server), we 		 	 * might mark the server,zone lame inappropriately */
if|if
condition|(
operator|!
name|iter_msg_from_zone
argument_list|(
name|iq
operator|->
name|response
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|type
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
condition|)
name|qstate
operator|->
name|reply
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|RESPONSE_TYPE_LAME
expr_stmt|;
name|dnsseclame
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|iq
operator|->
name|dnssec_lame_query
operator|=
literal|0
expr_stmt|;
comment|/* see if referral brings us close to the target */
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_REFERRAL
condition|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|ns
init|=
name|find_NS
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|ns_numrrsets
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
name|ns
operator|=
name|find_NS
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
operator|||
operator|!
name|dname_strict_subdomain_c
argument_list|(
name|ns
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
operator|||
operator|!
name|dname_subdomain_c
argument_list|(
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|ns
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"bad referral, throwaway"
argument_list|)
expr_stmt|;
name|type
operator|=
name|RESPONSE_TYPE_THROWAWAY
expr_stmt|;
block|}
else|else
name|iter_scrub_ds
argument_list|(
name|iq
operator|->
name|response
argument_list|,
name|ns
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|iter_scrub_ds
argument_list|(
name|iq
operator|->
name|response
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* handle each of the type cases */
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_ANSWER
condition|)
block|{
comment|/* ANSWER type responses terminate the query algorithm,  		 * so they sent on their */
if|if
condition|(
name|verbosity
operator|>=
name|VERB_DETAIL
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"query response was %s"
argument_list|,
name|FLAGS_GET_RCODE
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
condition|?
literal|"NXDOMAIN ANSWER"
else|:
operator|(
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|an_numrrsets
condition|?
literal|"ANSWER"
else|:
literal|"nodata ANSWER"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* if qtype is DS, check we have the right level of answer, 		 * like grandchild answer but we need the middle, reject it */
if|if
condition|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
operator|!
name|iq
operator|->
name|dsns_point
operator|&&
operator|!
operator|(
name|iq
operator|->
name|chase_flags
operator|&
name|BIT_RD
operator|)
operator|&&
name|iter_ds_toolow
argument_list|(
name|iq
operator|->
name|response
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
operator|&&
name|iter_dp_cangodown
argument_list|(
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
condition|)
block|{
comment|/* close down outstanding requests to be discarded */
name|outbound_list_clear
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detach_subs
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detach_subs
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detach_subs
call|)
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
return|return
name|processDSNSFind
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
return|;
block|}
name|iter_dns_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|iq
operator|->
name|response
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|prefetch_leeway
argument_list|,
name|iq
operator|->
name|dp
operator|&&
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
comment|/* close down outstanding requests to be discarded */
name|outbound_list_clear
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detach_subs
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detach_subs
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detach_subs
call|)
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|reply
condition|)
name|sock_list_insert
argument_list|(
operator|&
name|qstate
operator|->
name|reply_origin
argument_list|,
operator|&
name|qstate
operator|->
name|reply
operator|->
name|addr
argument_list|,
name|qstate
operator|->
name|reply
operator|->
name|addrlen
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
return|return
name|final_state
argument_list|(
name|iq
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_REFERRAL
condition|)
block|{
comment|/* REFERRAL type responses get a reset of the  		 * delegation point, and back to the QUERYTARGETS_STATE. */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"query response was REFERRAL"
argument_list|)
expr_stmt|;
comment|/* if hardened, only store referral if we asked for it */
if|if
condition|(
operator|!
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|harden_referral_path
operator|||
operator|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
comment|/* we know that all other NS rrsets are scrubbed 			    * away, thus on referral only one is left. 			    * see if that equals the query name... */
operator|&&
operator|(
comment|/* auth section, but sometimes in answer section*/
name|reply_find_rrset_section_ns
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
operator|||
name|reply_find_rrset_section_an
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Store the referral under the current query */
comment|/* no prefetch-leeway, since its not the answer */
name|iter_dns_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|iq
operator|->
name|response
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|store_parent_NS
condition|)
name|iter_store_parentside_NS
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|neg_cache
condition|)
name|val_neg_addreferral
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|neg_cache
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* store parent-side-in-zone-glue, if directly queried for */
if|if
condition|(
name|iq
operator|->
name|query_for_pside_glue
operator|&&
operator|!
name|iq
operator|->
name|pside_glue
condition|)
block|{
name|iq
operator|->
name|pside_glue
operator|=
name|reply_find_rrset
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qname_len
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|pside_glue
condition|)
block|{
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"found parent-side "
literal|"glue"
argument_list|,
name|iq
operator|->
name|pside_glue
argument_list|)
expr_stmt|;
name|iter_store_parentside_rrset
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|pside_glue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset the event state, setting the current delegation  		 * point to the referral. */
name|iq
operator|->
name|deleg_msg
operator|=
name|iq
operator|->
name|response
expr_stmt|;
name|iq
operator|->
name|dp
operator|=
name|delegpt_from_message
argument_list|(
name|iq
operator|->
name|response
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|dp
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
if|if
condition|(
operator|!
name|cache_fill_missing
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|,
name|qstate
operator|->
name|region
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
if|if
condition|(
name|iq
operator|->
name|store_parent_NS
operator|&&
name|query_dname_compare
argument_list|(
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|store_parent_NS
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|iter_merge_retry_counts
argument_list|(
name|iq
operator|->
name|dp
argument_list|,
name|iq
operator|->
name|store_parent_NS
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* Count this as a referral. */
name|iq
operator|->
name|referral_count
operator|++
expr_stmt|;
name|iq
operator|->
name|sent_count
operator|=
literal|0
expr_stmt|;
comment|/* see if the next dp is a trust anchor, or a DS was sent 		 * along, indicating dnssec is expected for next zone */
name|iq
operator|->
name|dnssec_expected
operator|=
name|iter_indicates_dnssec
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|iq
operator|->
name|dp
argument_list|,
name|iq
operator|->
name|response
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qclass
argument_list|)
expr_stmt|;
comment|/* if dnssec, validating then also fetch the key for the DS */
if|if
condition|(
name|iq
operator|->
name|dnssec_expected
operator|&&
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|prefetch_key
operator|&&
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
name|generate_dnskey_prefetch
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* spawn off NS and addr to auth servers for the NS we just 		 * got in the referral. This gets authoritative answer 		 * (answer section trust level) rrset.  		 * right after, we detach the subs, answer goes to cache. */
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|harden_referral_path
condition|)
name|generate_ns_check
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* stop current outstanding queries.  		 * FIXME: should the outstanding queries be waited for and 		 * handled? Say by a subquery that inherits the outbound_entry. 		 */
name|outbound_list_clear
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detach_subs
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detach_subs
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detach_subs
call|)
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cleared outbound list for next round"
argument_list|)
expr_stmt|;
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_CNAME
condition|)
block|{
name|uint8_t
modifier|*
name|sname
init|=
name|NULL
decl_stmt|;
name|size_t
name|snamelen
init|=
literal|0
decl_stmt|;
comment|/* CNAME type responses get a query restart (i.e., get a  		 * reset of the query state and go back to INIT_REQUEST_STATE). 		 */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"query response was CNAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"cname msg"
argument_list|,
operator|&
name|iq
operator|->
name|response
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|)
expr_stmt|;
comment|/* if qtype is DS, check we have the right level of answer, 		 * like grandchild answer but we need the middle, reject it */
if|if
condition|(
name|iq
operator|->
name|qchase
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
operator|!
name|iq
operator|->
name|dsns_point
operator|&&
operator|!
operator|(
name|iq
operator|->
name|chase_flags
operator|&
name|BIT_RD
operator|)
operator|&&
name|iter_ds_toolow
argument_list|(
name|iq
operator|->
name|response
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
operator|&&
name|iter_dp_cangodown
argument_list|(
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
condition|)
block|{
name|outbound_list_clear
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detach_subs
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detach_subs
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detach_subs
call|)
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
return|return
name|processDSNSFind
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|/* Process the CNAME response. */
if|if
condition|(
operator|!
name|handle_cname_response
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|iq
operator|->
name|response
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|snamelen
argument_list|)
condition|)
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
comment|/* cache the CNAME response under the current query */
comment|/* NOTE : set referral=1, so that rrsets get stored but not  		 * the partial query answer (CNAME only). */
comment|/* prefetchleeway applied because this updates answer parts */
name|iter_dns_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|iq
operator|->
name|response
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
literal|1
argument_list|,
name|qstate
operator|->
name|prefetch_leeway
argument_list|,
name|iq
operator|->
name|dp
operator|&&
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* set the current request's qname to the new value. */
name|iq
operator|->
name|qchase
operator|.
name|qname
operator|=
name|sname
expr_stmt|;
name|iq
operator|->
name|qchase
operator|.
name|qname_len
operator|=
name|snamelen
expr_stmt|;
comment|/* Clear the query state, since this is a query restart. */
name|iq
operator|->
name|deleg_msg
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|dsns_point
operator|=
name|NULL
expr_stmt|;
comment|/* Note the query restart. */
name|iq
operator|->
name|query_restart_count
operator|++
expr_stmt|;
name|iq
operator|->
name|sent_count
operator|=
literal|0
expr_stmt|;
comment|/* stop current outstanding queries.  		 * FIXME: should the outstanding queries be waited for and 		 * handled? Say by a subquery that inherits the outbound_entry. 		 */
name|outbound_list_clear
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detach_subs
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detach_subs
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detach_subs
call|)
argument_list|(
name|qstate
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_target_queries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|reply
condition|)
name|sock_list_insert
argument_list|(
operator|&
name|qstate
operator|->
name|reply_origin
argument_list|,
operator|&
name|qstate
operator|->
name|reply
operator|->
name|addr
argument_list|,
name|qstate
operator|->
name|reply
operator|->
name|addrlen
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cleared outbound list for query restart"
argument_list|)
expr_stmt|;
comment|/* go to INIT_REQUEST_STATE for new qname. */
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_LAME
condition|)
block|{
comment|/* Cache the LAMEness. */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"query response was %sLAME"
argument_list|,
name|dnsseclame
condition|?
literal|"DNSSEC "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mark lame: mismatch in qname and dpname"
argument_list|)
expr_stmt|;
comment|/* throwaway this reply below */
block|}
elseif|else
if|if
condition|(
name|qstate
operator|->
name|reply
condition|)
block|{
comment|/* need addr for lameness cache, but we may have 			 * gotten this from cache, so test to be sure */
if|if
condition|(
operator|!
name|infra_set_lame
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|infra_cache
argument_list|,
operator|&
name|qstate
operator|->
name|reply
operator|->
name|addr
argument_list|,
name|qstate
operator|->
name|reply
operator|->
name|addrlen
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|namelen
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|,
name|dnsseclame
argument_list|,
literal|0
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"mark host lame: out of memory"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_REC_LAME
condition|)
block|{
comment|/* Cache the LAMEness. */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"query response REC_LAME: "
literal|"recursive but not authoritative server"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|iq
operator|->
name|qchase
operator|.
name|qname
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mark rec_lame: mismatch in qname and dpname"
argument_list|)
expr_stmt|;
comment|/* throwaway this reply below */
block|}
elseif|else
if|if
condition|(
name|qstate
operator|->
name|reply
condition|)
block|{
comment|/* need addr for lameness cache, but we may have 			 * gotten this from cache, so test to be sure */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"mark as REC_LAME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|infra_set_lame
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|infra_cache
argument_list|,
operator|&
name|qstate
operator|->
name|reply
operator|->
name|addr
argument_list|,
name|qstate
operator|->
name|reply
operator|->
name|addrlen
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|namelen
argument_list|,
operator|*
name|qstate
operator|->
name|env
operator|->
name|now
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|iq
operator|->
name|qchase
operator|.
name|qtype
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"mark host lame: out of memory"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_THROWAWAY
condition|)
block|{
comment|/* LAME and THROWAWAY responses are handled the same way.  		 * In this case, the event is just sent directly back to  		 * the QUERYTARGETS_STATE without resetting anything,  		 * because, clearly, the next target must be tried. */
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"query response was THROWAWAY"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_warn
argument_list|(
literal|"A query response came back with an unknown type: %d"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* LAME, THROWAWAY and "unknown" all end up here. 	 * Recycle to the QUERYTARGETS state to hopefully try a  	 * different target. */
return|return
name|next_state
argument_list|(
name|iq
argument_list|,
name|QUERYTARGETS_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return priming query results to interestes super querystates.  *   * Sets the delegation point and delegation message (not nonRD queries).  * This is a callback from walk_supers.  *  * @param qstate: priming query state that finished.  * @param id: module id.  * @param forq: the qstate for which priming has been done.  */
end_comment

begin_function
specifier|static
name|void
name|prime_supers
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|forq
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|foriq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|forq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|log_assert
argument_list|(
name|qstate
operator|->
name|is_priming
operator|||
name|foriq
operator|->
name|wait_priming_stub
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|qstate
operator|->
name|return_rcode
operator|==
name|LDNS_RCODE_NOERROR
argument_list|)
expr_stmt|;
comment|/* Convert our response to a delegation point */
name|dp
operator|=
name|delegpt_from_message
argument_list|(
name|qstate
operator|->
name|return_msg
argument_list|,
name|forq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
comment|/* if there is no convertable delegation point, then  		 * the ANSWER type was (presumably) a negative answer. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"prime response was not a positive "
literal|"ANSWER; failing"
argument_list|)
expr_stmt|;
name|foriq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
name|foriq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
return|return;
block|}
name|log_query_info
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"priming successful for"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|foriq
operator|->
name|dp
operator|=
name|dp
expr_stmt|;
name|foriq
operator|->
name|deleg_msg
operator|=
name|dns_copy_msg
argument_list|(
name|qstate
operator|->
name|return_msg
argument_list|,
name|forq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foriq
operator|->
name|deleg_msg
condition|)
block|{
name|log_err
argument_list|(
literal|"copy prime response: out of memory"
argument_list|)
expr_stmt|;
name|foriq
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
name|foriq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
return|return;
block|}
comment|/* root priming responses go to init stage 2, priming stub  	 * responses to to stage 3. */
if|if
condition|(
name|foriq
operator|->
name|wait_priming_stub
condition|)
block|{
name|foriq
operator|->
name|state
operator|=
name|INIT_REQUEST_3_STATE
expr_stmt|;
name|foriq
operator|->
name|wait_priming_stub
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|foriq
operator|->
name|state
operator|=
name|INIT_REQUEST_2_STATE
expr_stmt|;
comment|/* because we are finished, the parent will be reactivated */
block|}
end_function

begin_comment
comment|/**   * This handles the response to a priming query. This is used to handle both  * root and stub priming responses. This is basically the equivalent of the  * QUERY_RESP_STATE, but will not handle CNAME responses and will treat  * REFERRALs as ANSWERS. It will also update and reactivate the originating  * event.  *  * @param qstate: query state.  * @param id: module id.  * @return true if the event needs more immediate processing, false if not.  *         This state always returns false.  */
end_comment

begin_function
specifier|static
name|int
name|processPrimeResponse
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|enum
name|response_type
name|type
decl_stmt|;
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BIT_RD
operator||
name|BIT_RA
operator|)
expr_stmt|;
comment|/* ignore rec-lame */
name|type
operator|=
name|response_type_from_server
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|iq
operator|->
name|chase_flags
operator|&
name|BIT_RD
operator|)
operator|||
name|iq
operator|->
name|chase_to_rd
argument_list|)
argument_list|,
name|iq
operator|->
name|response
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|iq
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_ANSWER
condition|)
block|{
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|iq
operator|->
name|response
expr_stmt|;
block|}
else|else
block|{
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* validate the root or stub after priming (if enabled). 	 * This is the same query as the prime query, but with validation. 	 * Now that we are primed, the additional queries that validation 	 * may need can be resolved, such as DLV. */
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|harden_referral_path
condition|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
init|=
name|NULL
decl_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"schedule prime validation"
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"could not generate prime check"
argument_list|)
expr_stmt|;
block|}
name|generate_a_aaaa_check
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* This event is finished. */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * Do final processing on responses to target queries. Events reach this  * state after the iterative resolution algorithm terminates. This state is  * responsible for reactiving the original event, and housekeeping related  * to received target responses (caching, updating the current delegation  * point, etc).  * Callback from walk_supers for every super state that is interested in   * the results from this query.  *  * @param qstate: query state.  * @param id: module id.  * @param forq: super query state.  */
end_comment

begin_function
specifier|static
name|void
name|processTargetResponse
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|forq
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|iter_qstate
modifier|*
name|foriq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|forq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
name|struct
name|delegpt_ns
modifier|*
name|dpns
decl_stmt|;
name|log_assert
argument_list|(
name|qstate
operator|->
name|return_rcode
operator|==
name|LDNS_RCODE_NOERROR
argument_list|)
expr_stmt|;
name|foriq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processTargetResponse"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processTargetResponse super"
argument_list|,
operator|&
name|forq
operator|->
name|qinfo
argument_list|)
expr_stmt|;
comment|/* check to see if parent event is still interested (in orig name).  */
if|if
condition|(
operator|!
name|foriq
operator|->
name|dp
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"subq: parent not interested, was reset"
argument_list|)
expr_stmt|;
return|return;
comment|/* not interested anymore */
block|}
name|dpns
operator|=
name|delegpt_find_ns
argument_list|(
name|foriq
operator|->
name|dp
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpns
condition|)
block|{
comment|/* If not interested, just stop processing this event */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"subq: parent not interested anymore"
argument_list|)
expr_stmt|;
comment|/* could be because parent was jostled out of the cache, 		   and a new identical query arrived, that does not want it*/
return|return;
block|}
comment|/* Tell the originating event that this target query has finished 	 * (regardless if it succeeded or not). */
name|foriq
operator|->
name|num_target_queries
operator|--
expr_stmt|;
comment|/* if iq->query_for_pside_glue then add the pside_glue (marked lame) */
if|if
condition|(
name|iq
operator|->
name|pside_glue
condition|)
block|{
comment|/* if the pside_glue is NULL, then it could not be found, 		 * the done_pside is already set when created and a cache 		 * entry created in processFinished so nothing to do here */
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"add parentside glue to dp"
argument_list|,
name|iq
operator|->
name|pside_glue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delegpt_add_rrset
argument_list|(
name|foriq
operator|->
name|dp
argument_list|,
name|forq
operator|->
name|region
argument_list|,
name|iq
operator|->
name|pside_glue
argument_list|,
literal|1
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory adding pside glue"
argument_list|)
expr_stmt|;
block|}
comment|/* This response is relevant to the current query, so we  	 * add (attempt to add, anyway) this target(s) and reactivate  	 * the original event.  	 * NOTE: we could only look for the AnswerRRset if the  	 * response type was ANSWER. */
name|rrset
operator|=
name|reply_find_answer_rrset
argument_list|(
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
condition|)
block|{
comment|/* if CNAMEs have been followed - add new NS to delegpt. */
comment|/* BTW. RFC 1918 says NS should not have got CNAMEs. Robust. */
if|if
condition|(
operator|!
name|delegpt_find_ns
argument_list|(
name|foriq
operator|->
name|dp
argument_list|,
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
condition|)
block|{
comment|/* if dpns->lame then set newcname ns lame too */
if|if
condition|(
operator|!
name|delegpt_add_ns
argument_list|(
name|foriq
operator|->
name|dp
argument_list|,
name|forq
operator|->
name|region
argument_list|,
name|rrset
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dpns
operator|->
name|lame
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory adding cnamed-ns"
argument_list|)
expr_stmt|;
block|}
comment|/* if dpns->lame then set the address(es) lame too */
if|if
condition|(
operator|!
name|delegpt_add_rrset
argument_list|(
name|foriq
operator|->
name|dp
argument_list|,
name|forq
operator|->
name|region
argument_list|,
name|rrset
argument_list|,
name|dpns
operator|->
name|lame
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory adding targets"
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"added target response"
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_ALGO
argument_list|,
name|foriq
operator|->
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"iterator TargetResponse failed"
argument_list|)
expr_stmt|;
name|dpns
operator|->
name|resolved
operator|=
literal|1
expr_stmt|;
comment|/* fail the target */
block|}
block|}
end_function

begin_comment
comment|/**  * Process response for DS NS Find queries, that attempt to find the delegation  * point where we ask the DS query from.  *  * @param qstate: query state.  * @param id: module id.  * @param forq: super query state.  */
end_comment

begin_function
specifier|static
name|void
name|processDSNSResponse
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|forq
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|foriq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|forq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
comment|/* if the finished (iq->response) query has no NS set: continue 	 * up to look for the right dp; nothing to change, do DPNSstate */
if|if
condition|(
name|qstate
operator|->
name|return_rcode
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
return|return;
comment|/* seek further */
comment|/* find the NS RRset (without allowing CNAMEs) */
if|if
condition|(
operator|!
name|reply_find_rrset
argument_list|(
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
condition|)
block|{
return|return;
comment|/* seek further */
block|}
comment|/* else, store as DP and continue at querytargets */
name|foriq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
name|foriq
operator|->
name|dp
operator|=
name|delegpt_from_message
argument_list|(
name|qstate
operator|->
name|return_msg
argument_list|,
name|forq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foriq
operator|->
name|dp
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in dsns dp alloc"
argument_list|)
expr_stmt|;
return|return;
comment|/* dp==NULL in QUERYTARGETS makes SERVFAIL */
block|}
comment|/* success, go query the querytargets in the new dp (and go down) */
block|}
end_function

begin_comment
comment|/**  * Process response for qclass=ANY queries for a particular class.  * Append to result or error-exit.  *  * @param qstate: query state.  * @param id: module id.  * @param forq: super query state.  */
end_comment

begin_function
specifier|static
name|void
name|processClassResponse
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|forq
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|foriq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|forq
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|dns_msg
modifier|*
name|from
init|=
name|qstate
operator|->
name|return_msg
decl_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processClassResponse"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"processClassResponse super"
argument_list|,
operator|&
name|forq
operator|->
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|->
name|return_rcode
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
comment|/* cause servfail for qclass ANY query */
name|foriq
operator|->
name|response
operator|=
name|NULL
expr_stmt|;
name|foriq
operator|->
name|state
operator|=
name|FINISHED_STATE
expr_stmt|;
return|return;
block|}
comment|/* append result */
if|if
condition|(
operator|!
name|foriq
operator|->
name|response
condition|)
block|{
comment|/* allocate the response: copy RCODE, sec_state */
name|foriq
operator|->
name|response
operator|=
name|dns_copy_msg
argument_list|(
name|from
argument_list|,
name|forq
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foriq
operator|->
name|response
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed for qclass ANY response"
argument_list|)
expr_stmt|;
name|foriq
operator|->
name|state
operator|=
name|FINISHED_STATE
expr_stmt|;
return|return;
block|}
name|foriq
operator|->
name|response
operator|->
name|qinfo
operator|.
name|qclass
operator|=
name|forq
operator|->
name|qinfo
operator|.
name|qclass
expr_stmt|;
comment|/* qclass ANY does not receive the AA flag on replies */
name|foriq
operator|->
name|response
operator|->
name|rep
operator|->
name|authoritative
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dns_msg
modifier|*
name|to
init|=
name|foriq
operator|->
name|response
decl_stmt|;
comment|/* add _from_ this response _to_ existing collection */
comment|/* if there are records, copy RCODE */
comment|/* lower sec_state if this message is lower */
if|if
condition|(
name|from
operator|->
name|rep
operator|->
name|rrset_count
operator|!=
literal|0
condition|)
block|{
name|size_t
name|n
init|=
name|from
operator|->
name|rep
operator|->
name|rrset_count
operator|+
name|to
operator|->
name|rep
operator|->
name|rrset_count
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|dest
decl_stmt|,
modifier|*
modifier|*
name|d
decl_stmt|;
comment|/* copy appropriate rcode */
name|to
operator|->
name|rep
operator|->
name|flags
operator|=
name|from
operator|->
name|rep
operator|->
name|flags
expr_stmt|;
comment|/* copy rrsets */
name|dest
operator|=
name|regional_alloc
argument_list|(
name|forq
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed in collect ANY"
argument_list|)
expr_stmt|;
name|foriq
operator|->
name|state
operator|=
name|FINISHED_STATE
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|dest
expr_stmt|;
comment|/* copy AN */
name|memcpy
argument_list|(
name|dest
argument_list|,
name|to
operator|->
name|rep
operator|->
name|rrsets
argument_list|,
name|to
operator|->
name|rep
operator|->
name|an_numrrsets
operator|*
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|to
operator|->
name|rep
operator|->
name|an_numrrsets
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|from
operator|->
name|rep
operator|->
name|rrsets
argument_list|,
name|from
operator|->
name|rep
operator|->
name|an_numrrsets
operator|*
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|from
operator|->
name|rep
operator|->
name|an_numrrsets
expr_stmt|;
comment|/* copy NS */
name|memcpy
argument_list|(
name|dest
argument_list|,
name|to
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|to
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|to
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|*
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|to
operator|->
name|rep
operator|->
name|ns_numrrsets
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|from
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|from
operator|->
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|from
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|*
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|from
operator|->
name|rep
operator|->
name|ns_numrrsets
expr_stmt|;
comment|/* copy AR */
name|memcpy
argument_list|(
name|dest
argument_list|,
name|to
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|to
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|to
operator|->
name|rep
operator|->
name|ns_numrrsets
argument_list|,
name|to
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|*
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|to
operator|->
name|rep
operator|->
name|ar_numrrsets
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|from
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|from
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|from
operator|->
name|rep
operator|->
name|ns_numrrsets
argument_list|,
name|from
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|*
sizeof|sizeof
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update counts */
name|to
operator|->
name|rep
operator|->
name|rrsets
operator|=
name|d
expr_stmt|;
name|to
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+=
name|from
operator|->
name|rep
operator|->
name|an_numrrsets
expr_stmt|;
name|to
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|+=
name|from
operator|->
name|rep
operator|->
name|ns_numrrsets
expr_stmt|;
name|to
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|+=
name|from
operator|->
name|rep
operator|->
name|ar_numrrsets
expr_stmt|;
name|to
operator|->
name|rep
operator|->
name|rrset_count
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|->
name|rep
operator|->
name|security
operator|<
name|to
operator|->
name|rep
operator|->
name|security
condition|)
comment|/* lowest sec */
name|to
operator|->
name|rep
operator|->
name|security
operator|=
name|from
operator|->
name|rep
operator|->
name|security
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|rep
operator|->
name|qdcount
operator|!=
literal|0
condition|)
comment|/* insert qd if appropriate */
name|to
operator|->
name|rep
operator|->
name|qdcount
operator|=
name|from
operator|->
name|rep
operator|->
name|qdcount
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|rep
operator|->
name|ttl
operator|<
name|to
operator|->
name|rep
operator|->
name|ttl
condition|)
comment|/* use smallest TTL */
name|to
operator|->
name|rep
operator|->
name|ttl
operator|=
name|from
operator|->
name|rep
operator|->
name|ttl
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|<
name|to
operator|->
name|rep
operator|->
name|prefetch_ttl
condition|)
name|to
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|from
operator|->
name|rep
operator|->
name|prefetch_ttl
expr_stmt|;
block|}
comment|/* are we done? */
name|foriq
operator|->
name|num_current_queries
operator|--
expr_stmt|;
if|if
condition|(
name|foriq
operator|->
name|num_current_queries
operator|==
literal|0
condition|)
name|foriq
operator|->
name|state
operator|=
name|FINISHED_STATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Collect class ANY responses and make them into one response.  This  * state is started and it creates queries for all classes (that have  * root hints).  The answers are then collected.  *  * @param qstate: query state.  * @param id: module id.  * @return true if the event needs more immediate processing, false if not.  */
end_comment

begin_function
specifier|static
name|int
name|processCollectClass
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|subq
decl_stmt|;
comment|/* If qchase.qclass == 0 then send out queries for all classes. 	 * Otherwise, do nothing (wait for all answers to arrive and the 	 * processClassResponse to put them together, and that moves us 	 * towards the Finished state when done. */
if|if
condition|(
name|iq
operator|->
name|qchase
operator|.
name|qclass
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|c
init|=
literal|0
decl_stmt|;
name|iq
operator|->
name|qchase
operator|.
name|qclass
operator|=
name|LDNS_RR_CLASS_ANY
expr_stmt|;
while|while
condition|(
name|iter_get_next_root
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|hints
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|fwds
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
comment|/* generate query for this class */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"spawn collect query"
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generate_sub_request
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
argument_list|,
name|c
argument_list|,
name|qstate
argument_list|,
name|id
argument_list|,
name|iq
argument_list|,
name|INIT_REQUEST_STATE
argument_list|,
name|FINISHED_STATE
argument_list|,
operator|&
name|subq
argument_list|,
operator|(
name|int
operator|)
operator|!
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
argument_list|)
condition|)
block|{
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* ignore subq, no special init required */
name|iq
operator|->
name|num_current_queries
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xffff
condition|)
break|break;
else|else
name|c
operator|++
expr_stmt|;
block|}
comment|/* if no roots are configured at all, return */
if|if
condition|(
name|iq
operator|->
name|num_current_queries
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"No root hints or fwds, giving up "
literal|"on qclass ANY"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_REFUSED
argument_list|)
return|;
block|}
comment|/* return false, wait for queries to return */
block|}
comment|/* if woke up here because of an answer, wait for more answers */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   * This handles the final state for first-tier responses (i.e., responses to  * externally generated queries).  *  * @param qstate: query state.  * @param iq: iterator query state.  * @param id: module id.  * @return true if the event needs more processing, false if not. Since this  *         is the final state for an event, it always returns false.  */
end_comment

begin_function
specifier|static
name|int
name|processFinished
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"finishing processing for"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
comment|/* store negative cache element for parent side glue. */
if|if
condition|(
name|iq
operator|->
name|query_for_pside_glue
operator|&&
operator|!
name|iq
operator|->
name|pside_glue
condition|)
name|iter_store_parentside_neg
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|deleg_msg
condition|?
name|iq
operator|->
name|deleg_msg
operator|->
name|rep
else|:
operator|(
name|iq
operator|->
name|response
condition|?
name|iq
operator|->
name|response
operator|->
name|rep
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|response
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"No response is set, servfail"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* Make sure that the RA flag is set (since the presence of  	 * this module means that recursion is available) */
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|flags
operator||=
name|BIT_RA
expr_stmt|;
comment|/* Clear the AA flag */
comment|/* FIXME: does this action go here or in some other module? */
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|flags
operator|&=
operator|~
name|BIT_AA
expr_stmt|;
comment|/* make sure QR flag is on */
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|flags
operator||=
name|BIT_QR
expr_stmt|;
comment|/* we have finished processing this query */
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
comment|/* TODO:  we are using a private TTL, trim the response. */
comment|/* if (mPrivateTTL> 0){IterUtils.setPrivateTTL(resp, mPrivateTTL); } */
comment|/* prepend any items we have accumulated */
if|if
condition|(
name|iq
operator|->
name|an_prepend_list
operator|||
name|iq
operator|->
name|ns_prepend_list
condition|)
block|{
if|if
condition|(
operator|!
name|iter_prepend
argument_list|(
name|iq
argument_list|,
name|iq
operator|->
name|response
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"prepend rrsets: out of memory"
argument_list|)
expr_stmt|;
return|return
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
return|;
block|}
comment|/* reset the query name back */
name|iq
operator|->
name|response
operator|->
name|qinfo
operator|=
name|qstate
operator|->
name|qinfo
expr_stmt|;
comment|/* the security state depends on the combination */
name|iq
operator|->
name|response
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
comment|/* store message with the finished prepended items, 		 * but only if we did recursion. The nonrecursion referral 		 * from cache does not need to be stored in the msg cache. */
if|if
condition|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_RD
condition|)
block|{
name|iter_dns_store
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
name|qstate
operator|->
name|prefetch_leeway
argument_list|,
name|iq
operator|->
name|dp
operator|&&
name|iq
operator|->
name|dp
operator|->
name|has_parent_side_NS
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
block|}
block|}
name|qstate
operator|->
name|return_rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
name|qstate
operator|->
name|return_msg
operator|=
name|iq
operator|->
name|response
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return priming query results to interestes super querystates.  *   * Sets the delegation point and delegation message (not nonRD queries).  * This is a callback from walk_supers.  *  * @param qstate: query state that finished.  * @param id: module id.  * @param super: the qstate to inform.  */
end_comment

begin_function
name|void
name|iter_inform_super
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|super
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qstate
operator|->
name|is_priming
operator|&&
name|super
operator|->
name|qinfo
operator|.
name|qclass
operator|==
name|LDNS_RR_CLASS_ANY
condition|)
name|processClassResponse
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|super
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|super
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
operator|(
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|super
operator|->
name|minfo
index|[
name|id
index|]
operator|)
operator|->
name|state
operator|==
name|DSNS_FIND_STATE
condition|)
name|processDSNSResponse
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|super
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qstate
operator|->
name|return_rcode
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
name|error_supers
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|super
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qstate
operator|->
name|is_priming
condition|)
name|prime_supers
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|super
argument_list|)
expr_stmt|;
else|else
name|processTargetResponse
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|super
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Handle iterator state.  * Handle events. This is the real processing loop for events, responsible  * for moving events through the various states. If a processing method  * returns true, then it will be advanced to the next state. If false, then  * processing will stop.  *  * @param qstate: query state.  * @param ie: iterator shared global environment.  * @param iq: iterator query state.  * @param id: module id.  */
end_comment

begin_function
specifier|static
name|void
name|iter_handle
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|cont
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cont
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"iter_handle processing q with state %s"
argument_list|,
name|iter_state_to_string
argument_list|(
name|iq
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iq
operator|->
name|state
condition|)
block|{
case|case
name|INIT_REQUEST_STATE
case|:
name|cont
operator|=
name|processInitRequest
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT_REQUEST_2_STATE
case|:
name|cont
operator|=
name|processInitRequest2
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT_REQUEST_3_STATE
case|:
name|cont
operator|=
name|processInitRequest3
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUERYTARGETS_STATE
case|:
name|cont
operator|=
name|processQueryTargets
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUERY_RESP_STATE
case|:
name|cont
operator|=
name|processQueryResponse
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRIME_RESP_STATE
case|:
name|cont
operator|=
name|processPrimeResponse
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLLECT_CLASS_STATE
case|:
name|cont
operator|=
name|processCollectClass
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DSNS_FIND_STATE
case|:
name|cont
operator|=
name|processDSNSFind
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINISHED_STATE
case|:
name|cont
operator|=
name|processFinished
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_warn
argument_list|(
literal|"iterator: invalid state: %d"
argument_list|,
name|iq
operator|->
name|state
argument_list|)
expr_stmt|;
name|cont
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**   * This is the primary entry point for processing request events. Note that  * this method should only be used by external modules.  * @param qstate: query state.  * @param ie: iterator shared global environment.  * @param iq: iterator query state.  * @param id: module id.  */
end_comment

begin_function
specifier|static
name|void
name|process_request
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|)
block|{
comment|/* external requests start in the INIT state, and finish using the 	 * FINISHED state. */
name|iq
operator|->
name|state
operator|=
name|INIT_REQUEST_STATE
expr_stmt|;
name|iq
operator|->
name|final_state
operator|=
name|FINISHED_STATE
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"process_request: new external request event"
argument_list|)
expr_stmt|;
name|iter_handle
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** process authoritative server reply */
end_comment

begin_function
specifier|static
name|void
name|process_response
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|iter_qstate
modifier|*
name|iq
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|outbound
parameter_list|,
name|enum
name|module_ev
name|event
parameter_list|)
block|{
name|struct
name|msg_parse
modifier|*
name|prs
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|sldns_buffer
modifier|*
name|pkt
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"process_response: new external response event"
argument_list|)
expr_stmt|;
name|iq
operator|->
name|response
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|state
operator|=
name|QUERY_RESP_STATE
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|module_event_noreply
operator|||
name|event
operator|==
name|module_event_error
condition|)
block|{
goto|goto
name|handle_it
goto|;
block|}
if|if
condition|(
operator|(
name|event
operator|!=
name|module_event_reply
operator|&&
name|event
operator|!=
name|module_event_capsfail
operator|)
operator|||
operator|!
name|qstate
operator|->
name|reply
condition|)
block|{
name|log_err
argument_list|(
literal|"Bad event combined with response"
argument_list|)
expr_stmt|;
name|outbound_list_remove
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|,
name|outbound
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* parse message */
name|prs
operator|=
operator|(
expr|struct
name|msg_parse
operator|*
operator|)
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msg_parse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prs
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory on incoming message"
argument_list|)
expr_stmt|;
comment|/* like packet got dropped */
goto|goto
name|handle_it
goto|;
block|}
name|memset
argument_list|(
name|prs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prs
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|edns
argument_list|)
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|qstate
operator|->
name|reply
operator|->
name|c
operator|->
name|buffer
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_packet
argument_list|(
name|pkt
argument_list|,
name|prs
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"parse error on reply packet"
argument_list|)
expr_stmt|;
goto|goto
name|handle_it
goto|;
block|}
comment|/* edns is not examined, but removed from message to help cache */
if|if
condition|(
name|parse_extract_edns
argument_list|(
name|prs
argument_list|,
operator|&
name|edns
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
goto|goto
name|handle_it
goto|;
comment|/* remove CD-bit, we asked for in case we handle validation ourself */
name|prs
operator|->
name|flags
operator|&=
operator|~
name|BIT_CD
expr_stmt|;
comment|/* normalize and sanitize: easy to delete items from linked lists */
if|if
condition|(
operator|!
name|scrub_message
argument_list|(
name|pkt
argument_list|,
name|prs
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|,
name|qstate
operator|->
name|env
argument_list|,
name|ie
argument_list|)
condition|)
goto|goto
name|handle_it
goto|;
comment|/* allocate response dns_msg in region */
name|iq
operator|->
name|response
operator|=
name|dns_alloc_msg
argument_list|(
name|pkt
argument_list|,
name|prs
argument_list|,
name|qstate
operator|->
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|response
condition|)
goto|goto
name|handle_it
goto|;
name|log_query_info
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"response for"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|log_name_addr
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"reply from"
argument_list|,
name|iq
operator|->
name|dp
operator|->
name|name
argument_list|,
operator|&
name|qstate
operator|->
name|reply
operator|->
name|addr
argument_list|,
name|qstate
operator|->
name|reply
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|log_dns_msg
argument_list|(
literal|"incoming scrubbed packet:"
argument_list|,
operator|&
name|iq
operator|->
name|response
operator|->
name|qinfo
argument_list|,
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|module_event_capsfail
condition|)
block|{
if|if
condition|(
operator|!
name|iq
operator|->
name|caps_fallback
condition|)
block|{
comment|/* start fallback */
name|iq
operator|->
name|caps_fallback
operator|=
literal|1
expr_stmt|;
name|iq
operator|->
name|caps_server
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|caps_reply
operator|=
name|iq
operator|->
name|response
operator|->
name|rep
expr_stmt|;
name|iq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|--
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Capsforid: starting fallback"
argument_list|)
expr_stmt|;
goto|goto
name|handle_it
goto|;
block|}
else|else
block|{
comment|/* check if reply is the same, otherwise, fail */
if|if
condition|(
operator|!
name|reply_equal
argument_list|(
name|iq
operator|->
name|response
operator|->
name|rep
argument_list|,
name|iq
operator|->
name|caps_reply
argument_list|,
name|qstate
operator|->
name|env
operator|->
name|scratch
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Capsforid fallback: "
literal|"getting different replies, failed"
argument_list|)
expr_stmt|;
name|outbound_list_remove
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|,
name|outbound
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* continue the fallback procedure at next server */
name|iq
operator|->
name|caps_server
operator|++
expr_stmt|;
name|iq
operator|->
name|state
operator|=
name|QUERYTARGETS_STATE
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|--
expr_stmt|;
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"Capsforid: reply is equal. "
literal|"go to next fallback"
argument_list|)
expr_stmt|;
goto|goto
name|handle_it
goto|;
block|}
block|}
name|iq
operator|->
name|caps_fallback
operator|=
literal|0
expr_stmt|;
comment|/* if we were in fallback, 0x20 is OK now */
name|handle_it
label|:
name|outbound_list_remove
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|,
name|outbound
argument_list|)
expr_stmt|;
name|iter_handle
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iter_operate
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|enum
name|module_ev
name|event
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|outbound
parameter_list|)
block|{
name|struct
name|iter_env
modifier|*
name|ie
init|=
operator|(
expr|struct
name|iter_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|iter_qstate
modifier|*
name|iq
init|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
decl_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"iterator[module %d] operate: extstate:%s event:%s"
argument_list|,
name|id
argument_list|,
name|strextstate
argument_list|(
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
argument_list|)
argument_list|,
name|strmodulevent
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
condition|)
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"iterator operate: query"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qname
operator|!=
name|iq
operator|->
name|qchase
operator|.
name|qname
condition|)
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"iterator operate: chased to"
argument_list|,
operator|&
name|iq
operator|->
name|qchase
argument_list|)
expr_stmt|;
comment|/* perform iterator state machine */
if|if
condition|(
operator|(
name|event
operator|==
name|module_event_new
operator|||
name|event
operator|==
name|module_event_pass
operator|)
operator|&&
name|iq
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|iter_new
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|iq
operator|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
expr_stmt|;
name|process_request
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iq
operator|&&
name|event
operator|==
name|module_event_pass
condition|)
block|{
name|iter_handle
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iq
operator|&&
name|outbound
condition|)
block|{
name|process_response
argument_list|(
name|qstate
argument_list|,
name|iq
argument_list|,
name|ie
argument_list|,
name|id
argument_list|,
name|outbound
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|event
operator|==
name|module_event_error
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"got called with event error, giving up"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_err
argument_list|(
literal|"bad event for iterator"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|error_response
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iter_clear
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_qstate
modifier|*
name|iq
decl_stmt|;
if|if
condition|(
operator|!
name|qstate
condition|)
return|return;
name|iq
operator|=
operator|(
expr|struct
name|iter_qstate
operator|*
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|iq
condition|)
block|{
name|outbound_list_clear
argument_list|(
operator|&
name|iq
operator|->
name|outlist
argument_list|)
expr_stmt|;
name|iq
operator|->
name|num_current_queries
operator|=
literal|0
expr_stmt|;
block|}
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|iter_get_mem
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|iter_env
modifier|*
name|ie
init|=
operator|(
expr|struct
name|iter_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ie
condition|)
return|return
literal|0
return|;
return|return
sizeof|sizeof
argument_list|(
operator|*
name|ie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
operator|(
name|size_t
operator|)
name|ie
operator|->
name|max_dependency_depth
operator|+
literal|1
operator|)
operator|+
name|donotq_get_mem
argument_list|(
name|ie
operator|->
name|donotq
argument_list|)
operator|+
name|priv_get_mem
argument_list|(
name|ie
operator|->
name|priv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * The iterator function block   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|module_func_block
name|iter_block
init|=
block|{
literal|"iterator"
block|,
operator|&
name|iter_init
block|,
operator|&
name|iter_deinit
block|,
operator|&
name|iter_operate
block|,
operator|&
name|iter_inform_super
block|,
operator|&
name|iter_clear
block|,
operator|&
name|iter_get_mem
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|module_func_block
modifier|*
name|iter_get_funcblock
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|iter_block
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|iter_state_to_string
parameter_list|(
name|enum
name|iter_state
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|INIT_REQUEST_STATE
case|:
return|return
literal|"INIT REQUEST STATE"
return|;
case|case
name|INIT_REQUEST_2_STATE
case|:
return|return
literal|"INIT REQUEST STATE (stage 2)"
return|;
case|case
name|INIT_REQUEST_3_STATE
case|:
return|return
literal|"INIT REQUEST STATE (stage 3)"
return|;
case|case
name|QUERYTARGETS_STATE
case|:
return|return
literal|"QUERY TARGETS STATE"
return|;
case|case
name|PRIME_RESP_STATE
case|:
return|return
literal|"PRIME RESPONSE STATE"
return|;
case|case
name|COLLECT_CLASS_STATE
case|:
return|return
literal|"COLLECT CLASS STATE"
return|;
case|case
name|DSNS_FIND_STATE
case|:
return|return
literal|"DSNS FIND STATE"
return|;
case|case
name|QUERY_RESP_STATE
case|:
return|return
literal|"QUERY RESPONSE STATE"
return|;
case|case
name|FINISHED_STATE
case|:
return|return
literal|"FINISHED RESPONSE STATE"
return|;
default|default :
return|return
literal|"UNKNOWN ITER STATE"
return|;
block|}
block|}
end_function

begin_function
name|int
name|iter_state_is_responsestate
parameter_list|(
name|enum
name|iter_state
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|INIT_REQUEST_STATE
case|:
case|case
name|INIT_REQUEST_2_STATE
case|:
case|case
name|INIT_REQUEST_3_STATE
case|:
case|case
name|QUERYTARGETS_STATE
case|:
case|case
name|COLLECT_CLASS_STATE
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

