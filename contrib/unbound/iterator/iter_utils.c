begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * iterator/iter_utils.c - iterative resolver module utility functions.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to assist the iterator module.  * Configuration options. Forward zones.   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_utils.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iterator.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_hints.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_donotq.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_priv.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kcache.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_kentry.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_utils.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_sigcrypt.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_comment
comment|/** time when nameserver glue is said to be 'recent' */
end_comment

begin_define
define|#
directive|define
name|SUSPICION_RECENT_EXPIRY
value|86400
end_define

begin_comment
comment|/** penalty to validation failed blacklisted IPs */
end_comment

begin_define
define|#
directive|define
name|BLACKLIST_PENALTY
value|(USEFUL_SERVER_TOP_TIMEOUT*4)
end_define

begin_comment
comment|/** fillup fetch policy array */
end_comment

begin_function
specifier|static
name|void
name|fetch_fill
parameter_list|(
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|str
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|max_dependency_depth
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|target_fetch_policy
index|[
name|i
index|]
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
condition|)
name|fatal_exit
argument_list|(
literal|"cannot parse fetch policy number %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Read config string that represents the target fetch policy */
end_comment

begin_function
specifier|static
name|int
name|read_fetch_policy
parameter_list|(
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|count
init|=
name|cfg_count_numbers
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"Cannot parse target fetch policy: \"%s\""
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ie
operator|->
name|max_dependency_depth
operator|=
name|count
operator|-
literal|1
expr_stmt|;
name|ie
operator|->
name|target_fetch_policy
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|ie
operator|->
name|max_dependency_depth
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ie
operator|->
name|target_fetch_policy
condition|)
block|{
name|log_err
argument_list|(
literal|"alloc fetch policy: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fetch_fill
argument_list|(
name|ie
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|iter_apply_cfg
parameter_list|(
name|struct
name|iter_env
modifier|*
name|iter_env
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* target fetch policy */
if|if
condition|(
operator|!
name|read_fetch_policy
argument_list|(
name|iter_env
argument_list|,
name|cfg
operator|->
name|target_fetch_policy
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iter_env
operator|->
name|max_dependency_depth
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"target fetch policy for level %d is %d"
argument_list|,
name|i
argument_list|,
name|iter_env
operator|->
name|target_fetch_policy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter_env
operator|->
name|donotq
condition|)
name|iter_env
operator|->
name|donotq
operator|=
name|donotq_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iter_env
operator|->
name|donotq
operator|||
operator|!
name|donotq_apply_cfg
argument_list|(
name|iter_env
operator|->
name|donotq
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not set donotqueryaddresses"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|iter_env
operator|->
name|priv
condition|)
name|iter_env
operator|->
name|priv
operator|=
name|priv_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iter_env
operator|->
name|priv
operator|||
operator|!
name|priv_apply_cfg
argument_list|(
name|iter_env
operator|->
name|priv
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not set private addresses"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iter_env
operator|->
name|supports_ipv6
operator|=
name|cfg
operator|->
name|do_ip6
expr_stmt|;
name|iter_env
operator|->
name|supports_ipv4
operator|=
name|cfg
operator|->
name|do_ip4
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** filter out unsuitable targets  * @param iter_env: iterator environment with ipv6-support flag.  * @param env: module environment with infra cache.  * @param name: zone name  * @param namelen: length of name  * @param qtype: query type (host order).  * @param now: current time  * @param a: address in delegation point we are examining.  * @return an integer that signals the target suitability.  *	as follows:  *	-1: The address should be omitted from the list.  *	    Because:  *		o The address is bogus (DNSSEC validation failure).  *		o Listed as donotquery  *		o is ipv6 but no ipv6 support (in operating system).  *		o is ipv4 but no ipv4 support (in operating system).  *		o is lame  *	Otherwise, an rtt in milliseconds.  *	0 .. USEFUL_SERVER_TOP_TIMEOUT-1  *		The roundtrip time timeout estimate. less than 2 minutes.  *		Note that util/rtt.c has a MIN_TIMEOUT of 50 msec, thus  *		values 0 .. 49 are not used, unless that is changed.  *	USEFUL_SERVER_TOP_TIMEOUT  *		This value exactly is given for unresponsive blacklisted.  *	USEFUL_SERVER_TOP_TIMEOUT+1  *		For non-blacklisted servers: huge timeout, but has traffic.  *	USEFUL_SERVER_TOP_TIMEOUT*1 ..  *		parent-side lame servers get this penalty. A dispreferential  *		server. (lame in delegpt).  *	USEFUL_SERVER_TOP_TIMEOUT*2 ..  *		dnsseclame servers get penalty  *	USEFUL_SERVER_TOP_TIMEOUT*3 ..  *		recursion lame servers get penalty  *	UNKNOWN_SERVER_NICENESS   *		If no information is known about the server, this is  *		returned. 376 msec or so.  *	+BLACKLIST_PENALTY (of USEFUL_TOP_TIMEOUT*4) for dnssec failed IPs.  *  * When a final value is chosen that is dnsseclame ; dnsseclameness checking  * is turned off (so we do not discard the reply).  * When a final value is chosen that is recursionlame; RD bit is set on query.  * Because of the numbers this means recursionlame also have dnssec lameness  * checking turned off.   */
end_comment

begin_function
specifier|static
name|int
name|iter_filter_unsuitable
parameter_list|(
name|struct
name|iter_env
modifier|*
name|iter_env
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|delegpt_addr
modifier|*
name|a
parameter_list|)
block|{
name|int
name|rtt
decl_stmt|,
name|lame
decl_stmt|,
name|reclame
decl_stmt|,
name|dnsseclame
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|bogus
condition|)
return|return
operator|-
literal|1
return|;
comment|/* address of server is bogus */
if|if
condition|(
name|donotq_lookup
argument_list|(
name|iter_env
operator|->
name|donotq
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"skip addr on the donotquery list"
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* server is on the donotquery list */
block|}
if|if
condition|(
operator|!
name|iter_env
operator|->
name|supports_ipv6
operator|&&
name|addr_is_ip6
argument_list|(
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* there is no ip6 available */
block|}
if|if
condition|(
operator|!
name|iter_env
operator|->
name|supports_ipv4
operator|&&
operator|!
name|addr_is_ip6
argument_list|(
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* there is no ip4 available */
block|}
comment|/* check lameness - need zone , class info */
if|if
condition|(
name|infra_get_lame_rtt
argument_list|(
name|env
operator|->
name|infra_cache
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
operator|&
name|lame
argument_list|,
operator|&
name|dnsseclame
argument_list|,
operator|&
name|reclame
argument_list|,
operator|&
name|rtt
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"servselect"
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"   rtt=%d%s%s%s%s"
argument_list|,
name|rtt
argument_list|,
name|lame
condition|?
literal|" LAME"
else|:
literal|""
argument_list|,
name|dnsseclame
condition|?
literal|" DNSSEC_LAME"
else|:
literal|""
argument_list|,
name|reclame
condition|?
literal|" REC_LAME"
else|:
literal|""
argument_list|,
name|a
operator|->
name|lame
condition|?
literal|" ADDR_LAME"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|lame
condition|)
return|return
operator|-
literal|1
return|;
comment|/* server is lame */
elseif|else
if|if
condition|(
name|rtt
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
comment|/* server is unresponsive, 			 * we used to return TOP_TIMOUT, but fairly useless, 			 * because if == TOP_TIMEOUT is dropped because 			 * blacklisted later, instead, remove it here, so 			 * other choices (that are not blacklisted) can be 			 * tried */
return|return
operator|-
literal|1
return|;
comment|/* select remainder from worst to best */
elseif|else
if|if
condition|(
name|reclame
condition|)
return|return
name|rtt
operator|+
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|3
return|;
comment|/* nonpref */
elseif|else
if|if
condition|(
name|dnsseclame
operator|||
name|a
operator|->
name|dnsseclame
condition|)
return|return
name|rtt
operator|+
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|2
return|;
comment|/* nonpref */
elseif|else
if|if
condition|(
name|a
operator|->
name|lame
condition|)
return|return
name|rtt
operator|+
name|USEFUL_SERVER_TOP_TIMEOUT
operator|+
literal|1
return|;
comment|/* nonpref */
else|else
return|return
name|rtt
return|;
block|}
comment|/* no server information present */
if|if
condition|(
name|a
operator|->
name|dnsseclame
condition|)
return|return
name|UNKNOWN_SERVER_NICENESS
operator|+
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|2
return|;
comment|/* nonpref */
elseif|else
if|if
condition|(
name|a
operator|->
name|lame
condition|)
return|return
name|USEFUL_SERVER_TOP_TIMEOUT
operator|+
literal|1
operator|+
name|UNKNOWN_SERVER_NICENESS
return|;
comment|/* nonpref */
return|return
name|UNKNOWN_SERVER_NICENESS
return|;
block|}
end_function

begin_comment
comment|/** lookup RTT information, and also store fastest rtt (if any) */
end_comment

begin_function
specifier|static
name|int
name|iter_fill_rtt
parameter_list|(
name|struct
name|iter_env
modifier|*
name|iter_env
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|int
modifier|*
name|best_rtt
parameter_list|,
name|struct
name|sock_list
modifier|*
name|blacklist
parameter_list|)
block|{
name|int
name|got_it
init|=
literal|0
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|bogus
condition|)
return|return
literal|0
return|;
comment|/* NS bogus, all bogus, nothing found */
for|for
control|(
name|a
operator|=
name|dp
operator|->
name|result_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next_result
control|)
block|{
name|a
operator|->
name|sel_rtt
operator|=
name|iter_filter_unsuitable
argument_list|(
name|iter_env
argument_list|,
name|env
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
name|now
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|sel_rtt
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|sock_list_find
argument_list|(
name|blacklist
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
condition|)
name|a
operator|->
name|sel_rtt
operator|+=
name|BLACKLIST_PENALTY
expr_stmt|;
if|if
condition|(
operator|!
name|got_it
condition|)
block|{
operator|*
name|best_rtt
operator|=
name|a
operator|->
name|sel_rtt
expr_stmt|;
name|got_it
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|sel_rtt
operator|<
operator|*
name|best_rtt
condition|)
block|{
operator|*
name|best_rtt
operator|=
name|a
operator|->
name|sel_rtt
expr_stmt|;
block|}
block|}
block|}
return|return
name|got_it
return|;
block|}
end_function

begin_comment
comment|/** filter the addres list, putting best targets at front,  * returns number of best targets (or 0, no suitable targets) */
end_comment

begin_function
specifier|static
name|int
name|iter_filter_order
parameter_list|(
name|struct
name|iter_env
modifier|*
name|iter_env
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|int
modifier|*
name|selected_rtt
parameter_list|,
name|int
name|open_target
parameter_list|,
name|struct
name|sock_list
modifier|*
name|blacklist
parameter_list|)
block|{
name|int
name|got_num
init|=
literal|0
decl_stmt|,
name|low_rtt
init|=
literal|0
decl_stmt|,
name|swap_to_front
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
comment|/* fillup sel_rtt and find best rtt in the bunch */
name|got_num
operator|=
name|iter_fill_rtt
argument_list|(
name|iter_env
argument_list|,
name|env
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
name|now
argument_list|,
name|dp
argument_list|,
operator|&
name|low_rtt
argument_list|,
name|blacklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_num
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|low_rtt
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
operator|&&
operator|(
name|delegpt_count_missing_targets
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
operator|||
name|open_target
operator|>
literal|0
operator|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Bad choices, trying to get more choice"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* we want more choice. The best choice is a bad one. 			     return 0 to force the caller to fetch more */
block|}
name|got_num
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|dp
operator|->
name|result_list
expr_stmt|;
while|while
condition|(
name|a
condition|)
block|{
comment|/* skip unsuitable targets */
if|if
condition|(
name|a
operator|->
name|sel_rtt
operator|==
operator|-
literal|1
condition|)
block|{
name|prev
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
continue|continue;
block|}
comment|/* classify the server address and determine what to do */
name|swap_to_front
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|sel_rtt
operator|>=
name|low_rtt
operator|&&
name|a
operator|->
name|sel_rtt
operator|-
name|low_rtt
operator|<=
name|RTT_BAND
condition|)
block|{
name|got_num
operator|++
expr_stmt|;
name|swap_to_front
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|sel_rtt
operator|<
name|low_rtt
operator|&&
name|low_rtt
operator|-
name|a
operator|->
name|sel_rtt
operator|<=
name|RTT_BAND
condition|)
block|{
name|got_num
operator|++
expr_stmt|;
name|swap_to_front
operator|=
literal|1
expr_stmt|;
block|}
comment|/* swap to front if necessary, or move to next result */
if|if
condition|(
name|swap_to_front
operator|&&
name|prev
condition|)
block|{
name|n
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
name|prev
operator|->
name|next_result
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|next_result
operator|=
name|dp
operator|->
name|result_list
expr_stmt|;
name|dp
operator|->
name|result_list
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
block|}
block|}
operator|*
name|selected_rtt
operator|=
name|low_rtt
expr_stmt|;
return|return
name|got_num
return|;
block|}
end_function

begin_function
name|struct
name|delegpt_addr
modifier|*
name|iter_server_selection
parameter_list|(
name|struct
name|iter_env
modifier|*
name|iter_env
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|int
modifier|*
name|dnssec_lame
parameter_list|,
name|int
modifier|*
name|chase_to_rd
parameter_list|,
name|int
name|open_target
parameter_list|,
name|struct
name|sock_list
modifier|*
name|blacklist
parameter_list|)
block|{
name|int
name|sel
decl_stmt|;
name|int
name|selrtt
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|num
init|=
name|iter_filter_order
argument_list|(
name|iter_env
argument_list|,
name|env
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|qtype
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
name|dp
argument_list|,
operator|&
name|selrtt
argument_list|,
name|open_target
argument_list|,
name|blacklist
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"selrtt %d"
argument_list|,
name|selrtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|selrtt
operator|>
name|BLACKLIST_PENALTY
condition|)
block|{
if|if
condition|(
name|selrtt
operator|-
name|BLACKLIST_PENALTY
operator|>
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|3
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"chase to "
literal|"blacklisted recursion lame server"
argument_list|)
expr_stmt|;
operator|*
name|chase_to_rd
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|selrtt
operator|-
name|BLACKLIST_PENALTY
operator|>
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|2
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"chase to "
literal|"blacklisted dnssec lame server"
argument_list|)
expr_stmt|;
operator|*
name|dnssec_lame
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|selrtt
operator|>
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|3
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"chase to recursion lame server"
argument_list|)
expr_stmt|;
operator|*
name|chase_to_rd
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|selrtt
operator|>
name|USEFUL_SERVER_TOP_TIMEOUT
operator|*
literal|2
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"chase to dnssec lame server"
argument_list|)
expr_stmt|;
operator|*
name|dnssec_lame
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|selrtt
operator|==
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"chase to blacklisted lame server"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|a
operator|=
name|dp
operator|->
name|result_list
expr_stmt|;
if|if
condition|(
operator|++
name|a
operator|->
name|attempts
operator|<
name|OUTBOUND_MSG_RETRY
condition|)
return|return
name|a
return|;
name|dp
operator|->
name|result_list
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/* randomly select a target from the list */
name|log_assert
argument_list|(
name|num
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* grab secure random number, to pick unexpected server. 	 * also we need it to be threadsafe. */
name|sel
operator|=
name|ub_random_max
argument_list|(
name|env
operator|->
name|rnd
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|a
operator|=
name|dp
operator|->
name|result_list
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|sel
operator|>
literal|0
operator|&&
name|a
condition|)
block|{
name|prev
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
name|sel
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|a
condition|)
comment|/* robustness */
return|return
name|NULL
return|;
if|if
condition|(
operator|++
name|a
operator|->
name|attempts
operator|<
name|OUTBOUND_MSG_RETRY
condition|)
return|return
name|a
return|;
comment|/* remove it from the delegation point result list */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_result
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
else|else
name|dp
operator|->
name|result_list
operator|=
name|a
operator|->
name|next_result
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|struct
name|dns_msg
modifier|*
name|dns_alloc_msg
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|m
init|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_create_msg
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|,
operator|&
name|m
operator|->
name|qinfo
argument_list|,
operator|&
name|m
operator|->
name|rep
argument_list|,
name|region
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure: allocating incoming dns_msg"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
name|struct
name|dns_msg
modifier|*
name|dns_copy_msg
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|from
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|m
init|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|qinfo
operator|=
name|from
operator|->
name|qinfo
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|qinfo
operator|.
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|from
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|from
operator|->
name|qinfo
operator|.
name|qname_len
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|rep
operator|=
name|reply_info_copy
argument_list|(
name|from
operator|->
name|rep
argument_list|,
name|NULL
argument_list|,
name|region
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|m
return|;
block|}
end_function

begin_function
name|void
name|iter_dns_store
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|msgqinf
parameter_list|,
name|struct
name|reply_info
modifier|*
name|msgrep
parameter_list|,
name|int
name|is_referral
parameter_list|,
name|time_t
name|leeway
parameter_list|,
name|int
name|pside
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dns_cache_store
argument_list|(
name|env
argument_list|,
name|msgqinf
argument_list|,
name|msgrep
argument_list|,
name|is_referral
argument_list|,
name|leeway
argument_list|,
name|pside
argument_list|,
name|region
argument_list|,
name|flags
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory: cannot store data in cache"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iter_ns_probability
parameter_list|(
name|struct
name|ub_randstate
modifier|*
name|rnd
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|int
name|sel
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|m
condition|)
comment|/* 100% chance */
return|return
literal|1
return|;
comment|/* we do not need secure random numbers here, but 	 * we do need it to be threadsafe, so we use this */
name|sel
operator|=
name|ub_random_max
argument_list|(
name|rnd
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|sel
operator|<
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/** detect dependency cycle for query and target */
end_comment

begin_function
specifier|static
name|int
name|causes_cycle
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|t
parameter_list|,
name|uint16_t
name|c
parameter_list|)
block|{
name|struct
name|query_info
name|qinf
decl_stmt|;
name|qinf
operator|.
name|qname
operator|=
name|name
expr_stmt|;
name|qinf
operator|.
name|qname_len
operator|=
name|namelen
expr_stmt|;
name|qinf
operator|.
name|qtype
operator|=
name|t
expr_stmt|;
name|qinf
operator|.
name|qclass
operator|=
name|c
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_detect_cycle
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|detect_cycle
argument_list|)
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|detect_cycle
call|)
argument_list|(
name|qstate
argument_list|,
operator|&
name|qinf
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|BIT_RD
operator||
name|BIT_CD
argument_list|)
argument_list|,
name|qstate
operator|->
name|is_priming
argument_list|,
name|qstate
operator|->
name|is_valrec
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iter_mark_cycle_targets
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ns
operator|->
name|resolved
condition|)
continue|continue;
comment|/* see if this ns as target causes dependency cycle */
if|if
condition|(
name|causes_cycle
argument_list|(
name|qstate
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
operator|||
name|causes_cycle
argument_list|(
name|qstate
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"skipping target due "
literal|"to dependency cycle (harden-glue: no may "
literal|"fix some of the cycles)"
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
name|ns
operator|->
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|iter_mark_pside_cycle_targets
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ns
operator|->
name|done_pside4
operator|&&
name|ns
operator|->
name|done_pside6
condition|)
continue|continue;
comment|/* see if this ns as target causes dependency cycle */
if|if
condition|(
name|causes_cycle
argument_list|(
name|qstate
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"skipping target due "
literal|"to dependency cycle"
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
name|ns
operator|->
name|done_pside4
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|causes_cycle
argument_list|(
name|qstate
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"skipping target due "
literal|"to dependency cycle"
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qstate
operator|->
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
name|ns
operator|->
name|done_pside6
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|iter_dp_is_useless
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
comment|/* check: 	 *      o RD qflag is on. 	 *      o no addresses are provided. 	 *      o all NS items are required glue. 	 * OR 	 *      o RD qflag is on. 	 *      o no addresses are provided. 	 *      o the query is for one of the nameservers in dp, 	 *        and that nameserver is a glue-name for this dp. 	 */
if|if
condition|(
operator|!
operator|(
name|qflags
operator|&
name|BIT_RD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* either available or unused targets */
if|if
condition|(
name|dp
operator|->
name|usable_list
operator|||
name|dp
operator|->
name|result_list
condition|)
return|return
literal|0
return|;
comment|/* see if query is for one of the nameservers, which is glue */
if|if
condition|(
operator|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_AAAA
operator|)
operator|&&
name|dname_subdomain_c
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|dp
operator|->
name|name
argument_list|)
operator|&&
name|delegpt_find_ns
argument_list|(
name|dp
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ns
operator|->
name|resolved
condition|)
comment|/* skip failed targets */
continue|continue;
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|ns
operator|->
name|name
argument_list|,
name|dp
operator|->
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* one address is not required glue */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|iter_indicates_dnssec
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|trust_anchor
modifier|*
name|a
decl_stmt|;
comment|/* information not available, !env->anchors can be common */
if|if
condition|(
operator|!
name|env
operator|||
operator|!
name|env
operator|->
name|anchors
operator|||
operator|!
name|dp
operator|||
operator|!
name|dp
operator|->
name|name
condition|)
return|return
literal|0
return|;
comment|/* a trust anchor exists with this name, RRSIGs expected */
if|if
condition|(
operator|(
name|a
operator|=
name|anchor_find
argument_list|(
name|env
operator|->
name|anchors
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelabs
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|dclass
argument_list|)
operator|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|a
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* see if DS rrset was given, in AUTH section */
if|if
condition|(
name|msg
operator|&&
name|msg
operator|->
name|rep
operator|&&
name|reply_find_rrset_section_ns
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|dclass
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* look in key cache */
if|if
condition|(
name|env
operator|->
name|key_cache
condition|)
block|{
name|struct
name|key_entry_key
modifier|*
name|kk
init|=
name|key_cache_obtain
argument_list|(
name|env
operator|->
name|key_cache
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|dclass
argument_list|,
name|env
operator|->
name|scratch
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|kk
condition|)
block|{
if|if
condition|(
name|query_dname_compare
argument_list|(
name|kk
operator|->
name|name
argument_list|,
name|dp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|key_entry_isgood
argument_list|(
name|kk
argument_list|)
operator|||
name|key_entry_isbad
argument_list|(
name|kk
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|key_entry_isnull
argument_list|(
name|kk
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|regional_free_all
argument_list|(
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iter_msg_has_dnssec
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|msg
operator|||
operator|!
name|msg
operator|->
name|rep
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|rrsig_count
operator|>
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* empty message has no DNSSEC info, with DNSSEC the reply is 	 * not empty (NSEC) */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iter_msg_from_zone
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|enum
name|response_type
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
if|if
condition|(
operator|!
name|msg
operator|||
operator|!
name|dp
operator|||
operator|!
name|msg
operator|->
name|rep
operator|||
operator|!
name|dp
operator|->
name|name
condition|)
return|return
literal|0
return|;
comment|/* SOA RRset - always from reply zone */
if|if
condition|(
name|reply_find_rrset_section_an
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|dclass
argument_list|)
operator|||
name|reply_find_rrset_section_ns
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|dclass
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|type
operator|==
name|RESPONSE_TYPE_REFERRAL
condition|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* if it adds a single label, i.e. we expect .com, 		 * and referral to example.com. NS ... , then origin zone 		 * is .com. For a referral to sub.example.com. NS ... then 		 * we do not know, since example.com. may be in between. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|dclass
condition|)
block|{
name|int
name|l
init|=
name|dname_count_labels
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|dp
operator|->
name|namelabs
operator|+
literal|1
operator|&&
name|dname_strict_subdomain
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|l
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelabs
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|type
operator|==
name|RESPONSE_TYPE_ANSWER
operator|||
name|type
operator|==
name|RESPONSE_TYPE_CNAME
argument_list|)
expr_stmt|;
comment|/* not a referral, and not lame delegation (upwards), so,  	 * any NS rrset must be from the zone itself */
if|if
condition|(
name|reply_find_rrset_section_an
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|dclass
argument_list|)
operator|||
name|reply_find_rrset_section_ns
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|dclass
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* a DNSKEY set is expected at the zone apex as well */
comment|/* this is for 'minimal responses' for DNSKEYs */
if|if
condition|(
name|reply_find_rrset_section_an
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|dclass
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * check equality of two rrsets   * @param k1: rrset  * @param k2: rrset  * @return true if equal  */
end_comment

begin_function
specifier|static
name|int
name|rrset_equal
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k1
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k2
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d1
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k1
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d2
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k2
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|k1
operator|->
name|rk
operator|.
name|dname_len
operator|!=
name|k2
operator|->
name|rk
operator|.
name|dname_len
operator|||
name|k1
operator|->
name|rk
operator|.
name|flags
operator|!=
name|k2
operator|->
name|rk
operator|.
name|flags
operator|||
name|k1
operator|->
name|rk
operator|.
name|type
operator|!=
name|k2
operator|->
name|rk
operator|.
name|type
operator|||
name|k1
operator|->
name|rk
operator|.
name|rrset_class
operator|!=
name|k2
operator|->
name|rk
operator|.
name|rrset_class
operator|||
name|query_dname_compare
argument_list|(
name|k1
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|k2
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
comment|/* do not check ttl: d1->ttl != d2->ttl || */
name|d1
operator|->
name|count
operator|!=
name|d2
operator|->
name|count
operator|||
name|d1
operator|->
name|rrsig_count
operator|!=
name|d2
operator|->
name|rrsig_count
operator|||
name|d1
operator|->
name|trust
operator|!=
name|d2
operator|->
name|trust
operator|||
name|d1
operator|->
name|security
operator|!=
name|d2
operator|->
name|security
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|d1
operator|->
name|count
operator|+
name|d1
operator|->
name|rrsig_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d1
operator|->
name|rr_len
index|[
name|i
index|]
operator|!=
name|d2
operator|->
name|rr_len
index|[
name|i
index|]
operator|||
comment|/* no ttl check: d1->rr_ttl[i] != d2->rr_ttl[i] ||*/
name|memcmp
argument_list|(
name|d1
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|d2
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|d1
operator|->
name|rr_len
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|reply_equal
parameter_list|(
name|struct
name|reply_info
modifier|*
name|p
parameter_list|,
name|struct
name|reply_info
modifier|*
name|q
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|!=
name|q
operator|->
name|flags
operator|||
name|p
operator|->
name|qdcount
operator|!=
name|q
operator|->
name|qdcount
operator|||
comment|/* do not check TTL, this may differ */
comment|/* 		p->ttl != q->ttl || 		p->prefetch_ttl != q->prefetch_ttl || 		*/
name|p
operator|->
name|security
operator|!=
name|q
operator|->
name|security
operator|||
name|p
operator|->
name|an_numrrsets
operator|!=
name|q
operator|->
name|an_numrrsets
operator|||
name|p
operator|->
name|ns_numrrsets
operator|!=
name|q
operator|->
name|ns_numrrsets
operator|||
name|p
operator|->
name|ar_numrrsets
operator|!=
name|q
operator|->
name|ar_numrrsets
operator|||
name|p
operator|->
name|rrset_count
operator|!=
name|q
operator|->
name|rrset_count
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rrset_equal
argument_list|(
name|p
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|q
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rrset_canonical_equal
argument_list|(
name|region
argument_list|,
name|p
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|q
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|regional_free_all
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|caps_strip_reply
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rep
condition|)
return|return;
comment|/* see if message is a referral, in which case the additional and 	 * NS record cannot be removed */
comment|/* referrals have the AA flag unset (strict check, not elsewhere in 	 * unbound, but for 0x20 this is very convenient). */
if|if
condition|(
operator|!
operator|(
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
condition|)
return|return;
comment|/* remove the additional section from the reply */
if|if
condition|(
name|rep
operator|->
name|ar_numrrsets
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"caps fallback: removing additional section"
argument_list|)
expr_stmt|;
name|rep
operator|->
name|rrset_count
operator|-=
name|rep
operator|->
name|ar_numrrsets
expr_stmt|;
name|rep
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
block|}
comment|/* is there an NS set in the authority section to remove? */
comment|/* the failure case (Cisco firewalls) only has one rrset in authsec */
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
comment|/* remove NS rrset and break from loop (loop limits 			 * have changed) */
comment|/* move last rrset into this position (there is no 			 * additional section any more) */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"caps fallback: removing NS rrset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|rep
operator|->
name|rrset_count
operator|-
literal|1
condition|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
name|rep
operator|->
name|rrsets
index|[
name|rep
operator|->
name|rrset_count
operator|-
literal|1
index|]
expr_stmt|;
name|rep
operator|->
name|rrset_count
operator|--
expr_stmt|;
name|rep
operator|->
name|ns_numrrsets
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|iter_store_parentside_rrset
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|rrset_ref
name|ref
decl_stmt|;
name|rrset
operator|=
name|packed_rrset_copy_alloc
argument_list|(
name|rrset
argument_list|,
name|env
operator|->
name|alloc
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrset
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in store_parentside_rrset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rrset
operator|->
name|rk
operator|.
name|flags
operator||=
name|PACKED_RRSET_PARENT_SIDE
expr_stmt|;
name|rrset
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|rrset
operator|->
name|rk
argument_list|)
expr_stmt|;
name|ref
operator|.
name|key
operator|=
name|rrset
expr_stmt|;
name|ref
operator|.
name|id
operator|=
name|rrset
operator|->
name|id
expr_stmt|;
comment|/* ignore ret: if it was in the cache, ref updated */
operator|(
name|void
operator|)
name|rrset_cache_update
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
operator|&
name|ref
argument_list|,
name|env
operator|->
name|alloc
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** fetch NS record from reply, if any */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|reply_get_NS_rrset
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_NS
argument_list|)
condition|)
block|{
return|return
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|iter_store_parentside_NS
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
init|=
name|reply_get_NS_rrset
argument_list|(
name|rep
argument_list|)
decl_stmt|;
if|if
condition|(
name|rrset
condition|)
block|{
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"store parent-side NS"
argument_list|,
name|rrset
argument_list|)
expr_stmt|;
name|iter_store_parentside_rrset
argument_list|(
name|env
argument_list|,
name|rrset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iter_store_parentside_neg
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
comment|/* TTL: NS from referral in iq->deleg_msg, 	 *      or first RR from iq->response, 	 *      or servfail5secs if !iq->response */
name|time_t
name|ttl
init|=
name|NORR_TTL
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|neg
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|newd
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
init|=
name|reply_get_NS_rrset
argument_list|(
name|rep
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rrset
operator|&&
name|rep
operator|->
name|rrset_count
operator|!=
literal|0
condition|)
name|rrset
operator|=
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|rrset
condition|)
name|ttl
operator|=
name|ub_packed_rrset_ttl
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
block|}
comment|/* create empty rrset to store */
name|neg
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|neg
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in store_parentside_neg"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|neg
operator|->
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|->
name|entry
operator|.
name|key
operator|=
name|neg
expr_stmt|;
name|neg
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|qinfo
operator|->
name|qtype
argument_list|)
expr_stmt|;
name|neg
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|qinfo
operator|->
name|qclass
argument_list|)
expr_stmt|;
name|neg
operator|->
name|rk
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|rk
operator|.
name|dname
operator|=
name|regional_alloc_init
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|neg
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in store_parentside_neg"
argument_list|)
expr_stmt|;
return|return;
block|}
name|neg
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|qinfo
operator|->
name|qname_len
expr_stmt|;
name|neg
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|neg
operator|->
name|rk
argument_list|)
expr_stmt|;
name|newd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|env
operator|->
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newd
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory in store_parentside_neg"
argument_list|)
expr_stmt|;
return|return;
block|}
name|neg
operator|->
name|entry
operator|.
name|data
operator|=
name|newd
expr_stmt|;
name|newd
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
comment|/* entry must have one RR, otherwise not valid in cache. 	 * put in one RR with empty rdata: those are ignored as nameserver */
name|newd
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|newd
operator|->
name|rrsig_count
operator|=
literal|0
expr_stmt|;
name|newd
operator|->
name|trust
operator|=
name|rrset_trust_ans_noAA
expr_stmt|;
name|newd
operator|->
name|rr_len
operator|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|newd
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|)
expr_stmt|;
name|newd
operator|->
name|rr_len
index|[
literal|0
index|]
operator|=
literal|0
comment|/* zero len rdata */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|packed_rrset_ptr_fixup
argument_list|(
name|newd
argument_list|)
expr_stmt|;
name|newd
operator|->
name|rr_ttl
index|[
literal|0
index|]
operator|=
name|newd
operator|->
name|ttl
expr_stmt|;
name|sldns_write_uint16
argument_list|(
name|newd
operator|->
name|rr_data
index|[
literal|0
index|]
argument_list|,
literal|0
comment|/* zero len rdata */
argument_list|)
expr_stmt|;
comment|/* store it */
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"store parent-side negative"
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|iter_store_parentside_rrset
argument_list|(
name|env
argument_list|,
name|neg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iter_lookup_parent_NS_from_cache
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|akey
decl_stmt|;
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|PACKED_RRSET_PARENT_SIDE
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"found parent-side NS in cache"
argument_list|,
name|akey
argument_list|)
expr_stmt|;
name|dp
operator|->
name|has_parent_side_NS
operator|=
literal|1
expr_stmt|;
comment|/* and mark the new names as lame */
if|if
condition|(
operator|!
name|delegpt_rrset_add_ns
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|iter_lookup_parent_glue_from_cache
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|akey
decl_stmt|;
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|size_t
name|num
init|=
name|delegpt_count_targets
argument_list|(
name|dp
argument_list|)
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
comment|/* get cached parentside A */
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|PACKED_RRSET_PARENT_SIDE
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"found parent-side"
argument_list|,
name|akey
argument_list|)
expr_stmt|;
name|ns
operator|->
name|done_pside4
operator|=
literal|1
expr_stmt|;
comment|/* a negative-cache-element has no addresses it adds */
if|if
condition|(
operator|!
name|delegpt_add_rrset_A
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
literal|1
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"malloc failure in lookup_parent_glue"
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* get cached parentside AAAA */
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|PACKED_RRSET_PARENT_SIDE
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
name|log_rrset_key
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"found parent-side"
argument_list|,
name|akey
argument_list|)
expr_stmt|;
name|ns
operator|->
name|done_pside6
operator|=
literal|1
expr_stmt|;
comment|/* a negative-cache-element has no addresses it adds */
if|if
condition|(
operator|!
name|delegpt_add_rrset_AAAA
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
literal|1
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"malloc failure in lookup_parent_glue"
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see if new (but lame) addresses have become available */
return|return
name|delegpt_count_targets
argument_list|(
name|dp
argument_list|)
operator|!=
name|num
return|;
block|}
end_function

begin_function
name|int
name|iter_get_next_root
parameter_list|(
name|struct
name|iter_hints
modifier|*
name|hints
parameter_list|,
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
modifier|*
name|c
parameter_list|)
block|{
name|uint16_t
name|c1
init|=
operator|*
name|c
decl_stmt|,
name|c2
init|=
operator|*
name|c
decl_stmt|;
name|int
name|r1
init|=
name|hints_next_root
argument_list|(
name|hints
argument_list|,
operator|&
name|c1
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|forwards_next_root
argument_list|(
name|fwd
argument_list|,
operator|&
name|c2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r1
operator|&&
operator|!
name|r2
condition|)
comment|/* got none, end of list */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|r1
condition|)
comment|/* got one, return that */
operator|*
name|c
operator|=
name|c2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|r2
condition|)
operator|*
name|c
operator|=
name|c1
expr_stmt|;
elseif|else
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
comment|/* got both take smallest */
operator|*
name|c
operator|=
name|c1
expr_stmt|;
else|else
operator|*
name|c
operator|=
name|c2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|iter_scrub_ds
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|ns
parameter_list|,
name|uint8_t
modifier|*
name|z
parameter_list|)
block|{
comment|/* Only the DS record for the delegation itself is expected. 	 * We allow DS for everything between the bailiwick and the  	 * zonecut, thus DS records must be at or above the zonecut. 	 * And the DS records must be below the server authority zone. 	 * The answer section is already scrubbed. */
name|size_t
name|i
init|=
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|)
condition|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
operator|&&
operator|(
operator|!
name|ns
operator|||
operator|!
name|dname_subdomain_c
argument_list|(
name|ns
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|||
name|query_dname_compare
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"removing irrelevant DS"
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|i
argument_list|,
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|+
name|i
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
operator|(
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|-
name|i
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|--
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|--
expr_stmt|;
comment|/* stay at same i, but new record */
continue|continue;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iter_dec_attempts
parameter_list|(
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|dp
operator|->
name|target_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next_target
control|)
block|{
if|if
condition|(
name|a
operator|->
name|attempts
operator|>=
name|OUTBOUND_MSG_RETRY
condition|)
block|{
comment|/* add back to result list */
name|a
operator|->
name|next_result
operator|=
name|dp
operator|->
name|result_list
expr_stmt|;
name|dp
operator|->
name|result_list
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|attempts
operator|>
name|d
condition|)
name|a
operator|->
name|attempts
operator|-=
name|d
expr_stmt|;
else|else
name|a
operator|->
name|attempts
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iter_merge_retry_counts
parameter_list|(
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|struct
name|delegpt
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|,
modifier|*
name|o
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|a
operator|=
name|dp
operator|->
name|target_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next_target
control|)
block|{
name|o
operator|=
name|delegpt_find_addr
argument_list|(
name|old
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"copy attempt count previous dp"
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|a
operator|->
name|attempts
operator|=
name|o
operator|->
name|attempts
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|a
operator|=
name|dp
operator|->
name|usable_list
expr_stmt|;
while|while
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|attempts
operator|>=
name|OUTBOUND_MSG_RETRY
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"remove from usable list dp"
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|)
expr_stmt|;
comment|/* remove from result list */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_usable
operator|=
name|a
operator|->
name|next_usable
expr_stmt|;
else|else
name|dp
operator|->
name|usable_list
operator|=
name|a
operator|->
name|next_usable
expr_stmt|;
comment|/* prev stays the same */
name|a
operator|=
name|a
operator|->
name|next_usable
expr_stmt|;
continue|continue;
block|}
name|prev
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next_usable
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iter_ds_toolow
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
comment|/* if for query example.com, there is example.com SOA or a subdomain 	 * of example.com, then we are too low and need to fetch NS. */
name|size_t
name|i
decl_stmt|;
comment|/* if we have a DNAME or CNAME we are probably wrong */
comment|/* if we have a qtype DS in the answer section, its fine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNAME
operator|||
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
comment|/* not the right answer, maybe too low, check the 			 * RRSIG signer name (if there is any) for a hint 			 * that it is from the dp zone anyway */
name|uint8_t
modifier|*
name|sname
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|val_find_rrset_signer
argument_list|(
name|s
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|&&
name|query_dname_compare
argument_list|(
name|dp
operator|->
name|name
argument_list|,
name|sname
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* it is fine, from the right dp */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
condition|)
return|return
literal|0
return|;
comment|/* fine, we have a DS record */
block|}
for|for
control|(
name|i
operator|=
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
block|{
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|msg
operator|->
name|qinfo
operator|.
name|qname
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* point is too low */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* right dp */
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|uint8_t
modifier|*
name|sname
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|val_find_rrset_signer
argument_list|(
name|s
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|&&
name|query_dname_compare
argument_list|(
name|dp
operator|->
name|name
argument_list|,
name|sname
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* it is fine, from the right dp */
return|return
literal|1
return|;
block|}
block|}
comment|/* we do not know */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|iter_dp_cangodown
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
comment|/* no delegation point, do not see how we can go down, 	 * robust check, it should really exist */
if|if
condition|(
operator|!
name|dp
condition|)
return|return
literal|0
return|;
comment|/* see if dp equals the qname, then we cannot go down further */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|dp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* if dp is one label above the name we also cannot go down further */
if|if
condition|(
name|dname_count_labels
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|)
operator|==
name|dp
operator|->
name|namelabs
operator|+
literal|1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

