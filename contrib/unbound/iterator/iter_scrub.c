begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * iterator/iter_scrub.c - scrubbing, normalization, sanitization of DNS msgs.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file has routine(s) for cleaning up incoming DNS messages from   * possible useless or malicious junk in it.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_scrub.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iterator.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_priv.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_comment
comment|/** RRset flag used during scrubbing. The RRset is OK. */
end_comment

begin_define
define|#
directive|define
name|RRSET_SCRUB_OK
value|0x80
end_define

begin_comment
comment|/** remove rrset, update loop variables */
end_comment

begin_function
specifier|static
name|void
name|remove_rrset
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|prev
parameter_list|,
name|struct
name|rrset_parse
modifier|*
modifier|*
name|rrset
parameter_list|)
block|{
if|if
condition|(
name|verbosity
operator|>=
name|VERB_QUERY
operator|&&
name|str
operator|&&
operator|(
operator|*
name|rrset
operator|)
operator|->
name|dname_len
operator|<=
name|LDNS_MAX_DOMAINLEN
condition|)
block|{
name|uint8_t
name|buf
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|rrset
operator|)
operator|->
name|dname
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
name|VERB_QUERY
argument_list|,
name|str
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|rrset
operator|)
operator|->
name|type
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|*
name|rrset
operator|)
operator|->
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|rrset_all_next
operator|=
operator|(
operator|*
name|rrset
operator|)
operator|->
name|rrset_all_next
expr_stmt|;
else|else
name|msg
operator|->
name|rrset_first
operator|=
operator|(
operator|*
name|rrset
operator|)
operator|->
name|rrset_all_next
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|rrset_last
operator|==
operator|*
name|rrset
condition|)
name|msg
operator|->
name|rrset_last
operator|=
name|prev
expr_stmt|;
name|msg
operator|->
name|rrset_count
operator|--
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|rrset
operator|)
operator|->
name|section
condition|)
block|{
case|case
name|LDNS_SECTION_ANSWER
case|:
name|msg
operator|->
name|an_rrsets
operator|--
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_AUTHORITY
case|:
name|msg
operator|->
name|ns_rrsets
operator|--
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_ADDITIONAL
case|:
name|msg
operator|->
name|ar_rrsets
operator|--
expr_stmt|;
break|break;
default|default:
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|msgparse_bucket_remove
argument_list|(
name|msg
argument_list|,
operator|*
name|rrset
argument_list|)
expr_stmt|;
operator|*
name|rrset
operator|=
operator|(
operator|*
name|rrset
operator|)
operator|->
name|rrset_all_next
expr_stmt|;
block|}
end_function

begin_comment
comment|/** return true if rr type has additional names in it */
end_comment

begin_function
specifier|static
name|int
name|has_additional
parameter_list|(
name|uint16_t
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|LDNS_RR_TYPE_MB
case|:
case|case
name|LDNS_RR_TYPE_MD
case|:
case|case
name|LDNS_RR_TYPE_MF
case|:
case|case
name|LDNS_RR_TYPE_NS
case|:
case|case
name|LDNS_RR_TYPE_MX
case|:
case|case
name|LDNS_RR_TYPE_KX
case|:
case|case
name|LDNS_RR_TYPE_SRV
case|:
return|return
literal|1
return|;
case|case
name|LDNS_RR_TYPE_NAPTR
case|:
comment|/* TODO: NAPTR not supported, glue stripped off */
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** get additional name from rrset RR, return false if no name present */
end_comment

begin_function
specifier|static
name|int
name|get_additional_name
parameter_list|(
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|struct
name|rr_parse
modifier|*
name|rr
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|size_t
modifier|*
name|nmlen
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|oldpos
decl_stmt|;
switch|switch
condition|(
name|rrset
operator|->
name|type
condition|)
block|{
case|case
name|LDNS_RR_TYPE_MB
case|:
case|case
name|LDNS_RR_TYPE_MD
case|:
case|case
name|LDNS_RR_TYPE_MF
case|:
case|case
name|LDNS_RR_TYPE_NS
case|:
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LDNS_RR_TYPE_MX
case|:
case|case
name|LDNS_RR_TYPE_KX
case|:
name|offset
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LDNS_RR_TYPE_SRV
case|:
name|offset
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|LDNS_RR_TYPE_NAPTR
case|:
comment|/* TODO: NAPTR not supported, glue stripped off */
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
name|len
operator|=
name|sldns_read_uint16
argument_list|(
name|rr
operator|->
name|ttl_data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|offset
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* rdata field too small */
operator|*
name|nm
operator|=
name|rr
operator|->
name|ttl_data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|offset
expr_stmt|;
name|oldpos
operator|=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|*
name|nm
operator|-
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nmlen
operator|=
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|oldpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nmlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Place mark on rrsets in additional section they are OK */
end_comment

begin_function
specifier|static
name|void
name|mark_additional_rrset
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|)
block|{
comment|/* Mark A and AAAA for NS as appropriate additional section info. */
name|uint8_t
modifier|*
name|nm
init|=
name|NULL
decl_stmt|;
name|size_t
name|nmlen
init|=
literal|0
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|rr
decl_stmt|;
if|if
condition|(
operator|!
name|has_additional
argument_list|(
name|rrset
operator|->
name|type
argument_list|)
condition|)
return|return;
for|for
control|(
name|rr
operator|=
name|rrset
operator|->
name|rr_first
init|;
name|rr
condition|;
name|rr
operator|=
name|rr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|get_additional_name
argument_list|(
name|rrset
argument_list|,
name|rr
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
name|pkt
argument_list|)
condition|)
block|{
comment|/* mark A */
name|hashvalue_t
name|h
init|=
name|pkt_hash_rrset
argument_list|(
name|pkt
argument_list|,
name|nm
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|rrset
operator|->
name|rrset_class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|r
init|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|rrset
operator|->
name|rrset_class
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|section
operator|==
name|LDNS_SECTION_ADDITIONAL
condition|)
block|{
name|r
operator|->
name|flags
operator||=
name|RRSET_SCRUB_OK
expr_stmt|;
block|}
comment|/* mark AAAA */
name|h
operator|=
name|pkt_hash_rrset
argument_list|(
name|pkt
argument_list|,
name|nm
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|rrset
operator|->
name|rrset_class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|rrset
operator|->
name|rrset_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|section
operator|==
name|LDNS_SECTION_ADDITIONAL
condition|)
block|{
name|r
operator|->
name|flags
operator||=
name|RRSET_SCRUB_OK
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/** Get target name of a CNAME */
end_comment

begin_function
specifier|static
name|int
name|parse_get_cname_target
parameter_list|(
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|sname
parameter_list|,
name|size_t
modifier|*
name|snamelen
parameter_list|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_count
operator|!=
literal|1
condition|)
block|{
name|struct
name|rr_parse
modifier|*
name|sig
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Found CNAME rrset with "
literal|"size> 1: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|rrset
operator|->
name|rr_count
argument_list|)
expr_stmt|;
comment|/* use the first CNAME! */
name|rrset
operator|->
name|rr_count
operator|=
literal|1
expr_stmt|;
name|rrset
operator|->
name|size
operator|=
name|rrset
operator|->
name|rr_first
operator|->
name|size
expr_stmt|;
for|for
control|(
name|sig
operator|=
name|rrset
operator|->
name|rrsig_first
init|;
name|sig
condition|;
name|sig
operator|=
name|sig
operator|->
name|next
control|)
name|rrset
operator|->
name|size
operator|+=
name|sig
operator|->
name|size
expr_stmt|;
name|rrset
operator|->
name|rr_last
operator|=
name|rrset
operator|->
name|rr_first
expr_stmt|;
name|rrset
operator|->
name|rr_first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rrset
operator|->
name|rr_first
operator|->
name|size
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* CNAME rdata too small */
operator|*
name|sname
operator|=
name|rrset
operator|->
name|rr_first
operator|->
name|ttl_data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
comment|/* skip ttl, rdatalen */
operator|*
name|snamelen
operator|=
name|rrset
operator|->
name|rr_first
operator|->
name|size
operator|-
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Synthesize CNAME from DNAME, false if too long */
end_comment

begin_function
specifier|static
name|int
name|synth_cname
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|dname_rrset
parameter_list|,
name|uint8_t
modifier|*
name|alias
parameter_list|,
name|size_t
modifier|*
name|aliaslen
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
comment|/* we already know that sname is a strict subdomain of DNAME owner */
name|uint8_t
modifier|*
name|dtarg
init|=
name|NULL
decl_stmt|;
name|size_t
name|dtarglen
decl_stmt|;
if|if
condition|(
operator|!
name|parse_get_cname_target
argument_list|(
name|dname_rrset
argument_list|,
operator|&
name|dtarg
argument_list|,
operator|&
name|dtarglen
argument_list|)
condition|)
return|return
literal|0
return|;
name|log_assert
argument_list|(
name|qnamelen
operator|>
name|dname_rrset
operator|->
name|dname_len
argument_list|)
expr_stmt|;
comment|/* DNAME from com. to net. with qname example.com. -> example.net. */
comment|/* so: \3com\0 to \3net\0 and qname \7example\3com\0 */
operator|*
name|aliaslen
operator|=
name|qnamelen
operator|+
name|dtarglen
operator|-
name|dname_rrset
operator|->
name|dname_len
expr_stmt|;
if|if
condition|(
operator|*
name|aliaslen
operator|>
name|LDNS_MAX_DOMAINLEN
condition|)
return|return
literal|0
return|;
comment|/* should have been RCODE YXDOMAIN */
comment|/* decompress dnames into buffer, we know it fits */
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|alias
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|alias
operator|+
operator|(
name|qnamelen
operator|-
name|dname_rrset
operator|->
name|dname_len
operator|)
argument_list|,
name|dtarg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** synthesize a CNAME rrset */
end_comment

begin_function
specifier|static
name|struct
name|rrset_parse
modifier|*
name|synth_cname_rrset
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|sname
parameter_list|,
name|size_t
modifier|*
name|snamelen
parameter_list|,
name|uint8_t
modifier|*
name|alias
parameter_list|,
name|size_t
name|aliaslen
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|prev
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|nx
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|cn
init|=
operator|(
expr|struct
name|rrset_parse
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_parse
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cn
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|cn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|rr_first
operator|=
operator|(
expr|struct
name|rr_parse
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rr_parse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|rr_first
condition|)
return|return
name|NULL
return|;
name|cn
operator|->
name|rr_last
operator|=
name|cn
operator|->
name|rr_first
expr_stmt|;
comment|/* CNAME from sname to alias */
name|cn
operator|->
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
operator|*
name|snamelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|dname
condition|)
return|return
name|NULL
return|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|cn
operator|->
name|dname
argument_list|,
operator|*
name|sname
argument_list|)
expr_stmt|;
name|cn
operator|->
name|dname_len
operator|=
operator|*
name|snamelen
expr_stmt|;
name|cn
operator|->
name|type
operator|=
name|LDNS_RR_TYPE_CNAME
expr_stmt|;
name|cn
operator|->
name|section
operator|=
name|rrset
operator|->
name|section
expr_stmt|;
name|cn
operator|->
name|rrset_class
operator|=
name|rrset
operator|->
name|rrset_class
expr_stmt|;
name|cn
operator|->
name|rr_count
operator|=
literal|1
expr_stmt|;
name|cn
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|aliaslen
expr_stmt|;
name|cn
operator|->
name|hash
operator|=
name|pkt_hash_rrset
argument_list|(
name|pkt
argument_list|,
name|cn
operator|->
name|dname
argument_list|,
name|cn
operator|->
name|type
argument_list|,
name|cn
operator|->
name|rrset_class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* allocate TTL + rdatalen + uncompressed dname */
name|memset
argument_list|(
name|cn
operator|->
name|rr_first
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rr_parse
argument_list|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|rr_first
operator|->
name|outside_packet
operator|=
literal|1
expr_stmt|;
name|cn
operator|->
name|rr_first
operator|->
name|ttl_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|aliaslen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|rr_first
operator|->
name|ttl_data
condition|)
return|return
name|NULL
return|;
name|sldns_write_uint32
argument_list|(
name|cn
operator|->
name|rr_first
operator|->
name|ttl_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TTL = 0 */
name|sldns_write_uint16
argument_list|(
name|cn
operator|->
name|rr_first
operator|->
name|ttl_data
operator|+
literal|4
argument_list|,
name|aliaslen
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|cn
operator|->
name|rr_first
operator|->
name|ttl_data
operator|+
literal|6
argument_list|,
name|alias
argument_list|,
name|aliaslen
argument_list|)
expr_stmt|;
name|cn
operator|->
name|rr_first
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|aliaslen
expr_stmt|;
comment|/* link it in */
name|cn
operator|->
name|rrset_all_next
operator|=
name|nx
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|rrset_all_next
operator|=
name|cn
expr_stmt|;
else|else
name|msg
operator|->
name|rrset_first
operator|=
name|cn
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
name|msg
operator|->
name|rrset_last
operator|=
name|cn
expr_stmt|;
name|msg
operator|->
name|rrset_count
operator|++
expr_stmt|;
name|msg
operator|->
name|an_rrsets
operator|++
expr_stmt|;
comment|/* it is not inserted in the msg hashtable. */
operator|*
name|sname
operator|=
name|cn
operator|->
name|rr_first
operator|->
name|ttl_data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
operator|*
name|snamelen
operator|=
name|aliaslen
expr_stmt|;
return|return
name|cn
return|;
block|}
end_function

begin_comment
comment|/** check if DNAME applies to a name */
end_comment

begin_function
specifier|static
name|int
name|pkt_strict_sub
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|sname
parameter_list|,
name|uint8_t
modifier|*
name|dr
parameter_list|)
block|{
name|uint8_t
name|buf1
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|uint8_t
name|buf2
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* decompress names */
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|buf1
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|buf2
argument_list|,
name|dr
argument_list|)
expr_stmt|;
return|return
name|dname_strict_subdomain_c
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** check subdomain with decompression */
end_comment

begin_function
specifier|static
name|int
name|pkt_sub
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|comprname
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|)
block|{
name|uint8_t
name|buf
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|buf
argument_list|,
name|comprname
argument_list|)
expr_stmt|;
return|return
name|dname_subdomain_c
argument_list|(
name|buf
argument_list|,
name|zone
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** check subdomain with decompression, compressed is parent */
end_comment

begin_function
specifier|static
name|int
name|sub_of_pkt
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|comprname
parameter_list|)
block|{
name|uint8_t
name|buf
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|buf
argument_list|,
name|comprname
argument_list|)
expr_stmt|;
return|return
name|dname_subdomain_c
argument_list|(
name|zone
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This routine normalizes a response. This includes removing "irrelevant"  * records from the answer and additional sections and (re)synthesizing  * CNAMEs from DNAMEs, if present.  *  * @param pkt: packet.  * @param msg: msg to normalize.  * @param qinfo: original query.  * @param region: where to allocate synthesized CNAMEs.  * @return 0 on error.  */
end_comment

begin_function
specifier|static
name|int
name|scrub_normalize
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|uint8_t
modifier|*
name|sname
init|=
name|qinfo
operator|->
name|qname
decl_stmt|;
name|size_t
name|snamelen
init|=
name|qinfo
operator|->
name|qname_len
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|rrset
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|nsset
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|flags
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
operator|&&
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|flags
argument_list|)
operator|!=
name|LDNS_RCODE_NXDOMAIN
condition|)
return|return
literal|1
return|;
comment|/* For the ANSWER section, remove all "irrelevant" records and add 	 * synthesized CNAMEs from DNAMEs 	 * This will strip out-of-order CNAMEs as well. */
comment|/* walk through the parse packet rrset list, keep track of previous 	 * for insert and delete ease, and examine every RRset */
name|prev
operator|=
name|NULL
expr_stmt|;
name|rrset
operator|=
name|msg
operator|->
name|rrset_first
expr_stmt|;
while|while
condition|(
name|rrset
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DNAME
operator|&&
name|pkt_strict_sub
argument_list|(
name|pkt
argument_list|,
name|sname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
condition|)
block|{
comment|/* check if next rrset is correct CNAME. else, 			 * synthesize a CNAME */
name|struct
name|rrset_parse
modifier|*
name|nx
init|=
name|rrset
operator|->
name|rrset_all_next
decl_stmt|;
name|uint8_t
name|alias
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
name|aliaslen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rrset
operator|->
name|rr_count
operator|!=
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Found DNAME rrset with "
literal|"size> 1: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|rrset
operator|->
name|rr_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|synth_cname
argument_list|(
name|sname
argument_list|,
name|snamelen
argument_list|,
name|rrset
argument_list|,
name|alias
argument_list|,
operator|&
name|aliaslen
argument_list|,
name|pkt
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"synthesized CNAME "
literal|"too long"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nx
operator|&&
name|nx
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|sname
argument_list|,
name|nx
operator|->
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* check next cname */
name|uint8_t
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|size_t
name|tlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|parse_get_cname_target
argument_list|(
name|rrset
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|tlen
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|alias
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's OK and better capitalized */
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|nx
expr_stmt|;
continue|continue;
block|}
comment|/* synth ourselves */
block|}
comment|/* synth a CNAME rrset */
name|prev
operator|=
name|synth_cname_rrset
argument_list|(
operator|&
name|sname
argument_list|,
operator|&
name|snamelen
argument_list|,
name|alias
argument_list|,
name|aliaslen
argument_list|,
name|region
argument_list|,
name|msg
argument_list|,
name|rrset
argument_list|,
name|rrset
argument_list|,
name|nx
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory synthesizing CNAME"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* FIXME: resolve the conflict between synthesized  			 * CNAME ttls and the cache. */
name|rrset
operator|=
name|nx
expr_stmt|;
continue|continue;
block|}
comment|/* The only records in the ANSWER section not allowed to */
if|if
condition|(
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|sname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Follow the CNAME chain. */
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
name|uint8_t
modifier|*
name|oldsname
init|=
name|sname
decl_stmt|;
if|if
condition|(
operator|!
name|parse_get_cname_target
argument_list|(
name|rrset
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|snamelen
argument_list|)
condition|)
return|return
literal|0
return|;
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
comment|/* in CNAME ANY response, can have data after CNAME */
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
block|{
while|while
condition|(
name|rrset
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
operator|&&
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|oldsname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* Otherwise, make sure that the RRset matches the qtype. */
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_ANY
operator|&&
name|qinfo
operator|->
name|qtype
operator|!=
name|rrset
operator|->
name|type
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Mark the additional names from relevant rrset as OK. */
comment|/* only for RRsets that match the query name, other ones 		 * will be removed by sanitize, so no additional for them */
if|if
condition|(
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
operator|==
literal|0
condition|)
name|mark_additional_rrset
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|rrset
argument_list|)
expr_stmt|;
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
comment|/* Mark additional names from AUTHORITY */
while|while
condition|(
name|rrset
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_AUTHORITY
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DNAME
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_CNAME
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* only one NS set allowed in authority section */
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
comment|/* NS set must be pertinent to the query */
if|if
condition|(
operator|!
name|sub_of_pkt
argument_list|(
name|pkt
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nsset
operator|==
name|NULL
condition|)
block|{
name|nsset
operator|=
name|rrset
expr_stmt|;
block|}
else|else
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|mark_additional_rrset
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|rrset
argument_list|)
expr_stmt|;
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
comment|/* For each record in the additional section, remove it if it is an 	 * address record and not in the collection of additional names  	 * found in ANSWER and AUTHORITY. */
comment|/* These records have not been marked OK previously */
while|while
condition|(
name|rrset
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ADDITIONAL
condition|)
block|{
comment|/* FIXME: what about other types? */
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
if|if
condition|(
operator|(
name|rrset
operator|->
name|flags
operator|&
name|RRSET_SCRUB_OK
operator|)
condition|)
block|{
comment|/* remove flag to clean up flags variable */
name|rrset
operator|->
name|flags
operator|&=
operator|~
name|RRSET_SCRUB_OK
expr_stmt|;
block|}
else|else
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DNAME
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_CNAME
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"normalize: removing irrelevant "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Store potential poison in the cache (only if hardening disabled).  * The rrset is stored in the cache but removed from the message.  * So that it will be used for infrastructure purposes, but not be   * returned to the client.  * @param pkt: packet  * @param msg: message parsed  * @param env: environment with cache  * @param rrset: to store.  */
end_comment

begin_function
specifier|static
name|void
name|store_rrset
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
name|struct
name|rrset_ref
name|ref
decl_stmt|;
name|time_t
name|now
init|=
operator|*
name|env
operator|->
name|now
decl_stmt|;
name|k
operator|=
name|alloc_special_obtain
argument_list|(
name|env
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
return|return;
name|k
operator|->
name|entry
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parse_copy_decompress_rrset
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|rrset
argument_list|,
name|NULL
argument_list|,
name|k
argument_list|)
condition|)
block|{
name|alloc_special_release
argument_list|(
name|env
operator|->
name|alloc
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
expr_stmt|;
name|packed_rrset_ttl_add
argument_list|(
name|d
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|ref
operator|.
name|key
operator|=
name|k
expr_stmt|;
name|ref
operator|.
name|id
operator|=
name|k
operator|->
name|id
expr_stmt|;
comment|/*ignore ret: it was in the cache, ref updated */
operator|(
name|void
operator|)
name|rrset_cache_update
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
operator|&
name|ref
argument_list|,
name|env
operator|->
name|alloc
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Check if there are SOA records in the authority section (negative) */
end_comment

begin_function
specifier|static
name|int
name|soa_in_auth
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|rrset
decl_stmt|;
for|for
control|(
name|rrset
operator|=
name|msg
operator|->
name|rrset_first
init|;
name|rrset
condition|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
control|)
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_SOA
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_AUTHORITY
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Check if right hand name in NSEC is within zone  * @param rrset: the NSEC rrset  * @param zonename: the zone name.  * @return true if BAD.  */
end_comment

begin_function
specifier|static
name|int
name|sanitize_nsec_is_overreach
parameter_list|(
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
name|zonename
parameter_list|)
block|{
name|struct
name|rr_parse
modifier|*
name|rr
decl_stmt|;
name|uint8_t
modifier|*
name|rhs
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|log_assert
argument_list|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_NSEC
argument_list|)
expr_stmt|;
for|for
control|(
name|rr
operator|=
name|rrset
operator|->
name|rr_first
init|;
name|rr
condition|;
name|rr
operator|=
name|rr
operator|->
name|next
control|)
block|{
name|rhs
operator|=
name|rr
operator|->
name|ttl_data
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
name|len
operator|=
name|sldns_read_uint16
argument_list|(
name|rr
operator|->
name|ttl_data
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname_valid
argument_list|(
name|rhs
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* malformed domain name in rdata */
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|rhs
argument_list|,
name|zonename
argument_list|)
condition|)
block|{
comment|/* overreaching */
return|return
literal|1
return|;
block|}
block|}
comment|/* all NSEC RRs OK */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Given a response event, remove suspect RRsets from the response.  * "Suspect" rrsets are potentially poison. Note that this routine expects  * the response to be in a "normalized" state -- that is, all "irrelevant"  * RRsets have already been removed, CNAMEs are in order, etc.  *  * @param pkt: packet.  * @param msg: msg to normalize.  * @param qinfo: the question originally asked.  * @param zonename: name of server zone.  * @param env: module environment with config and cache.  * @param ie: iterator environment with private address data.  * @return 0 on error.  */
end_comment

begin_function
specifier|static
name|int
name|scrub_sanitize
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint8_t
modifier|*
name|zonename
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|del_addi
init|=
literal|0
decl_stmt|;
comment|/* if additional-holding rrsets are deleted, we 		do not trust the normalized additional-A-AAAA any more */
name|struct
name|rrset_parse
modifier|*
name|rrset
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|rrset
operator|=
name|msg
operator|->
name|rrset_first
expr_stmt|;
comment|/* the first DNAME is allowed to stay. It needs checking before 	 * it can be used from the cache. After normalization, an initial  	 * DNAME will have a correctly synthesized CNAME after it. */
if|if
condition|(
name|rrset
operator|&&
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DNAME
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
operator|&&
name|pkt_strict_sub
argument_list|(
name|pkt
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
operator|&&
name|pkt_sub
argument_list|(
name|pkt
argument_list|,
name|rrset
operator|->
name|dname
argument_list|,
name|zonename
argument_list|)
condition|)
block|{
name|prev
operator|=
name|rrset
expr_stmt|;
comment|/* DNAME allowed to stay in answer section */
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
comment|/* remove all records from the answer section that are  	 * not the same domain name as the query domain name. 	 * The answer section should contain rrsets with the same name 	 * as the question. For DNAMEs a CNAME has been synthesized. 	 * Wildcards have the query name in answer section. 	 * ANY queries get query name in answer section. 	 * Remainders of CNAME chains are cut off and resolved by iterator. */
while|while
condition|(
name|rrset
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
condition|)
block|{
if|if
condition|(
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|has_additional
argument_list|(
name|rrset
operator|->
name|type
argument_list|)
condition|)
name|del_addi
operator|=
literal|1
expr_stmt|;
name|remove_rrset
argument_list|(
literal|"sanitize: removing extraneous answer "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
comment|/* At this point, we brutally remove ALL rrsets that aren't  	 * children of the originating zone. The idea here is that,  	 * as far as we know, the server that we contacted is ONLY  	 * authoritative for the originating zone. It, of course, MAY  	 * be authoriative for any other zones, and of course, MAY  	 * NOT be authoritative for some subdomains of the originating  	 * zone. */
name|prev
operator|=
name|NULL
expr_stmt|;
name|rrset
operator|=
name|msg
operator|->
name|rrset_first
expr_stmt|;
while|while
condition|(
name|rrset
condition|)
block|{
comment|/* remove private addresses */
if|if
condition|(
operator|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_AAAA
operator|)
condition|)
block|{
comment|/* do not set servfail since this leads to too 			 * many drops of other people using rfc1918 space */
comment|/* also do not remove entire rrset, unless all records 			 * in it are bad */
if|if
condition|(
name|priv_rrset_bad
argument_list|(
name|ie
operator|->
name|priv
argument_list|,
name|pkt
argument_list|,
name|rrset
argument_list|)
condition|)
block|{
name|remove_rrset
argument_list|(
name|NULL
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* skip DNAME records -- they will always be followed by a  		 * synthesized CNAME, which will be relevant. 		 * FIXME: should this do something differently with DNAME  		 * rrsets NOT in Section.ANSWER? */
comment|/* But since DNAME records are also subdomains of the zone, 		 * same check can be used */
if|if
condition|(
operator|!
name|pkt_sub
argument_list|(
name|pkt
argument_list|,
name|rrset
operator|->
name|dname
argument_list|,
name|zonename
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|an_rrsets
operator|==
literal|0
operator|&&
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_AUTHORITY
operator|&&
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
operator|&&
operator|!
name|soa_in_auth
argument_list|(
name|msg
argument_list|)
operator|&&
name|sub_of_pkt
argument_list|(
name|pkt
argument_list|,
name|zonename
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
condition|)
block|{
comment|/* noerror, nodata and this NS rrset is above 				 * the zone. This is LAME!  				 * Leave in the NS for lame classification. */
comment|/* remove everything from the additional 				 * (we dont want its glue that was approved 				 * during the normalize action) */
name|del_addi
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|env
operator|->
name|cfg
operator|->
name|harden_glue
condition|)
block|{
comment|/* store in cache! Since it is relevant 				 * (from normalize) it will be picked up  				 * from the cache to be used later */
name|store_rrset
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|env
argument_list|,
name|rrset
argument_list|)
expr_stmt|;
name|remove_rrset
argument_list|(
literal|"sanitize: storing potential "
literal|"poison RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|has_additional
argument_list|(
name|rrset
operator|->
name|type
argument_list|)
condition|)
name|del_addi
operator|=
literal|1
expr_stmt|;
name|remove_rrset
argument_list|(
literal|"sanitize: removing potential "
literal|"poison RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|del_addi
operator|&&
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ADDITIONAL
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"sanitize: removing potential "
literal|"poison reference RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check if right hand side of NSEC is within zone */
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_NSEC
operator|&&
name|sanitize_nsec_is_overreach
argument_list|(
name|rrset
argument_list|,
name|zonename
argument_list|)
condition|)
block|{
name|remove_rrset
argument_list|(
literal|"sanitize: removing overreaching NSEC "
literal|"RRset:"
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|prev
argument_list|,
operator|&
name|rrset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|scrub_message
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint8_t
modifier|*
name|zonename
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|iter_env
modifier|*
name|ie
parameter_list|)
block|{
comment|/* basic sanity checks */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"scrub for"
argument_list|,
name|zonename
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|qdcount
operator|>
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|msg
operator|->
name|flags
operator|&
name|BIT_QR
operator|)
condition|)
return|return
literal|0
return|;
name|msg
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BIT_AD
operator||
name|BIT_Z
operator|)
expr_stmt|;
comment|/* force off bit AD and Z */
comment|/* make sure that a query is echoed back when NOERROR or NXDOMAIN */
comment|/* this is not required for basic operation but is a forgery  	 * resistance (security) feature */
if|if
condition|(
operator|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
operator|||
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
operator|)
operator|&&
name|msg
operator|->
name|qdcount
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* if a query is echoed back, make sure it is correct. Otherwise, 	 * this may be not a reply to our query. */
if|if
condition|(
name|msg
operator|->
name|qdcount
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|msg
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|msg
operator|->
name|qtype
operator|!=
name|qinfo
operator|->
name|qtype
operator|||
name|msg
operator|->
name|qclass
operator|!=
name|qinfo
operator|->
name|qclass
condition|)
return|return
literal|0
return|;
block|}
comment|/* normalize the response, this cleans up the additional.  */
if|if
condition|(
operator|!
name|scrub_normalize
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|qinfo
argument_list|,
name|region
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* delete all out-of-zone information */
if|if
condition|(
operator|!
name|scrub_sanitize
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|qinfo
argument_list|,
name|zonename
argument_list|,
name|env
argument_list|,
name|ie
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

