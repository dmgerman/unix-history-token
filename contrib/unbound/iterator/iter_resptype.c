begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * iterator/iter_resptype.c - response type information and classification.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file defines the response type. DNS Responses can be classified as  * one of the response types.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_resptype.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/pkthdr.h"
end_include

begin_function
name|enum
name|response_type
name|response_type_from_cache
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|request
parameter_list|)
block|{
comment|/* If the message is NXDOMAIN, then it is an ANSWER. */
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
condition|)
return|return
name|RESPONSE_TYPE_ANSWER
return|;
if|if
condition|(
name|request
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
return|return
name|RESPONSE_TYPE_ANSWER
return|;
comment|/* First we look at the answer section. This can tell us if this is 	 * CNAME or positive ANSWER. */
if|if
condition|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|>
literal|0
condition|)
block|{
comment|/* Now look at the answer section first. 3 states:  		 *	o our answer is there directly, 		 *	o our answer is there after a cname, 		 *	o or there is just a cname. */
name|uint8_t
modifier|*
name|mname
init|=
name|request
operator|->
name|qname
decl_stmt|;
name|size_t
name|mname_len
init|=
name|request
operator|->
name|qname_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
comment|/* If we have encountered an answer (before or  			 * after a CNAME), then we are done! Note that  			 * if qtype == CNAME then this will be noted as  			 * an ANSWER before it gets treated as a CNAME,  			 * as it should */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|request
operator|->
name|qtype
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|request
operator|->
name|qclass
operator|&&
name|query_dname_compare
argument_list|(
name|mname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|RESPONSE_TYPE_ANSWER
return|;
block|}
comment|/* If we have encountered a CNAME, make sure that  			 * it is relevant. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|query_dname_compare
argument_list|(
name|mname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|get_cname_target
argument_list|(
name|s
argument_list|,
operator|&
name|mname
argument_list|,
operator|&
name|mname_len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we encountered a CNAME (or a bunch of CNAMEs), and  		 * still got to here, then it is a CNAME response. (i.e.,  		 * the CNAME chain didn't terminate in an answer rrset.) */
if|if
condition|(
name|mname
operator|!=
name|request
operator|->
name|qname
condition|)
block|{
return|return
name|RESPONSE_TYPE_CNAME
return|;
block|}
block|}
comment|/* At this point, since we don't need to detect REFERRAL or LAME  	 * messages, it can only be an ANSWER. */
return|return
name|RESPONSE_TYPE_ANSWER
return|;
block|}
end_function

begin_function
name|enum
name|response_type
name|response_type_from_server
parameter_list|(
name|int
name|rdset
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|request
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|uint8_t
modifier|*
name|origzone
init|=
operator|(
name|uint8_t
operator|*
operator|)
literal|"\000"
decl_stmt|;
comment|/* the default */
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|msg
operator|||
operator|!
name|request
condition|)
return|return
name|RESPONSE_TYPE_THROWAWAY
return|;
comment|/* If the message is NXDOMAIN, then it answers the question. */
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
condition|)
block|{
comment|/* make sure its not recursive when we don't want it to */
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_RA
operator|)
operator|&&
operator|!
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
operator|&&
operator|!
name|rdset
condition|)
return|return
name|RESPONSE_TYPE_REC_LAME
return|;
comment|/* it could be a CNAME with NXDOMAIN rcode */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|query_dname_compare
argument_list|(
name|request
operator|->
name|qname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|RESPONSE_TYPE_CNAME
return|;
block|}
block|}
return|return
name|RESPONSE_TYPE_ANSWER
return|;
block|}
comment|/* Other response codes mean (so far) to throw the response away as 	 * meaningless and move on to the next nameserver. */
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|flags
argument_list|)
operator|!=
name|LDNS_RCODE_NOERROR
condition|)
return|return
name|RESPONSE_TYPE_THROWAWAY
return|;
comment|/* Note: TC bit has already been handled */
if|if
condition|(
name|dp
condition|)
block|{
name|origzone
operator|=
name|dp
operator|->
name|name
expr_stmt|;
block|}
comment|/* First we look at the answer section. This can tell us if this is a 	 * CNAME or ANSWER or (provisional) ANSWER. */
if|if
condition|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|>
literal|0
condition|)
block|{
name|uint8_t
modifier|*
name|mname
init|=
name|request
operator|->
name|qname
decl_stmt|;
name|size_t
name|mname_len
init|=
name|request
operator|->
name|qname_len
decl_stmt|;
comment|/* Now look at the answer section first. 3 states: our  		 * answer is there directly, our answer is there after  		 * a cname, or there is just a cname. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* if the answer section has NS rrset, and qtype ANY  		 	 * and the delegation is lower, and no CNAMEs followed, 		 	 * this is a referral where the NS went to AN section */
if|if
condition|(
operator|(
name|request
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
operator|||
name|request
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_NS
operator|)
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|request
operator|->
name|qclass
operator|&&
name|dname_strict_subdomain_c
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|origzone
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
condition|)
return|return
name|RESPONSE_TYPE_ANSWER
return|;
return|return
name|RESPONSE_TYPE_REFERRAL
return|;
block|}
comment|/* If we have encountered an answer (before or  			 * after a CNAME), then we are done! Note that  			 * if qtype == CNAME then this will be noted as an 			 * ANSWER before it gets treated as a CNAME, as  			 * it should. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|request
operator|->
name|qtype
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|request
operator|->
name|qclass
operator|&&
name|query_dname_compare
argument_list|(
name|mname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
condition|)
return|return
name|RESPONSE_TYPE_ANSWER
return|;
comment|/* If the AA bit isn't on, and we've seen  				 * the answer, we only provisionally say  				 * 'ANSWER' -- it very well could be a  				 * REFERRAL. */
break|break;
block|}
comment|/* If we have encountered a CNAME, make sure that  			 * it is relevant. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|query_dname_compare
argument_list|(
name|mname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|get_cname_target
argument_list|(
name|s
argument_list|,
operator|&
name|mname
argument_list|,
operator|&
name|mname_len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* not a referral, and qtype any, thus an answer */
if|if
condition|(
name|request
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
return|return
name|RESPONSE_TYPE_ANSWER
return|;
comment|/* if we encountered a CNAME (or a bunch of CNAMEs), and  		 * still got to here, then it is a CNAME response.  		 * (This is regardless of the AA bit at this point) */
if|if
condition|(
name|mname
operator|!=
name|request
operator|->
name|qname
condition|)
block|{
return|return
name|RESPONSE_TYPE_CNAME
return|;
block|}
block|}
comment|/* Looking at the authority section, we just look and see if  	 * there is a SOA record, that means a NOERROR/NODATA */
for|for
control|(
name|i
operator|=
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
operator|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* The normal way of detecting NOERROR/NODATA. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
operator|&&
name|dname_subdomain_c
argument_list|(
name|request
operator|->
name|qname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
comment|/* we do our own recursion, thank you */
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_RA
operator|)
operator|&&
operator|!
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
operator|&&
operator|!
name|rdset
condition|)
return|return
name|RESPONSE_TYPE_REC_LAME
return|;
return|return
name|RESPONSE_TYPE_ANSWER
return|;
block|}
block|}
comment|/* Looking at the authority section, we just look and see if  	 * there is a delegation NS set, turning it into a delegation.  	 * Otherwise, we will have to conclude ANSWER (either it is  	 * NOERROR/NODATA, or an non-authoritative answer). */
for|for
control|(
name|i
operator|=
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
operator|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|+
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
comment|/* Detect REFERRAL/LAME/ANSWER based on the relationship  		 * of the NS set to the originating zone name. */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
comment|/* If we are getting an NS set for the zone we  			 * thought we were contacting, then it is an answer.*/
if|if
condition|(
name|query_dname_compare
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|origzone
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* see if mistakenly a recursive server was 				 * deployed and is responding nonAA */
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_RA
operator|)
operator|&&
operator|!
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
operator|&&
operator|!
name|rdset
condition|)
return|return
name|RESPONSE_TYPE_REC_LAME
return|;
comment|/* Or if a lame server is deployed, 				 * which gives ns==zone delegation from cache  				 * without AA bit as well, with nodata nosoa*/
comment|/* real answer must be +AA and SOA RFC(2308), 				 * so this is wrong, and we SERVFAIL it if 				 * this is the only possible reply, if it 				 * is misdeployed the THROWAWAY makes us pick 				 * the next server from the selection */
if|if
condition|(
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|==
literal|0
operator|&&
operator|!
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
operator|&&
operator|!
name|rdset
condition|)
return|return
name|RESPONSE_TYPE_THROWAWAY
return|;
return|return
name|RESPONSE_TYPE_ANSWER
return|;
block|}
comment|/* If we are getting a referral upwards (or to  			 * the same zone), then the server is 'lame'. */
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|origzone
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdset
condition|)
comment|/* forward or reclame not LAME */
return|return
name|RESPONSE_TYPE_THROWAWAY
return|;
return|return
name|RESPONSE_TYPE_LAME
return|;
block|}
comment|/* If the NS set is below the delegation point we  			 * are on, and it is non-authoritative, then it is  			 * a referral, otherwise it is an answer. */
if|if
condition|(
name|dname_subdomain_c
argument_list|(
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|origzone
argument_list|)
condition|)
block|{
comment|/* NOTE: I no longer remember in what case  				 * we would like this to be an answer.  				 * NODATA should have a SOA or nothing,  				 * not an NS rrset.  				 * True, referrals should not have the AA  				 * bit set, but... */
comment|/* if((msg->rep->flags&BIT_AA)) 					return RESPONSE_TYPE_ANSWER; */
return|return
name|RESPONSE_TYPE_REFERRAL
return|;
block|}
comment|/* Otherwise, the NS set is irrelevant. */
block|}
block|}
comment|/* If we've gotten this far, this is NOERROR/NODATA (which could  	 * be an entirely empty message) */
comment|/* check if recursive answer; saying it has empty cache */
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_RA
operator|)
operator|&&
operator|!
operator|(
name|msg
operator|->
name|rep
operator|->
name|flags
operator|&
name|BIT_AA
operator|)
operator|&&
operator|!
name|rdset
condition|)
return|return
name|RESPONSE_TYPE_REC_LAME
return|;
return|return
name|RESPONSE_TYPE_ANSWER
return|;
block|}
end_function

end_unit

