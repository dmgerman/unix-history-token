begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/data/msgreply.c - store message and reply data.   *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains a data structure to store a message and its reply.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/lookup3.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_comment
comment|/** MAX TTL default for messages and rrsets */
end_comment

begin_decl_stmt
name|time_t
name|MAX_TTL
init|=
literal|3600
operator|*
literal|24
operator|*
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ten days */
end_comment

begin_comment
comment|/** MIN TTL default for messages and rrsets */
end_comment

begin_decl_stmt
name|time_t
name|MIN_TTL
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** allocate qinfo, return 0 on error */
end_comment

begin_function
specifier|static
name|int
name|parse_create_qinfo
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|->
name|qname
condition|)
block|{
if|if
condition|(
name|region
condition|)
name|qinf
operator|->
name|qname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|msg
operator|->
name|qname_len
argument_list|)
expr_stmt|;
else|else
name|qinf
operator|->
name|qname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|msg
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinf
operator|->
name|qname
condition|)
return|return
literal|0
return|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|qinf
operator|->
name|qname
argument_list|,
name|msg
operator|->
name|qname
argument_list|)
expr_stmt|;
block|}
else|else
name|qinf
operator|->
name|qname
operator|=
literal|0
expr_stmt|;
name|qinf
operator|->
name|qname_len
operator|=
name|msg
operator|->
name|qname_len
expr_stmt|;
name|qinf
operator|->
name|qtype
operator|=
name|msg
operator|->
name|qtype
expr_stmt|;
name|qinf
operator|->
name|qclass
operator|=
name|msg
operator|->
name|qclass
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** constructor for replyinfo */
end_comment

begin_function
specifier|static
name|struct
name|reply_info
modifier|*
name|construct_reply_info_base
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|size_t
name|qd
parameter_list|,
name|time_t
name|ttl
parameter_list|,
name|time_t
name|prettl
parameter_list|,
name|size_t
name|an
parameter_list|,
name|size_t
name|ns
parameter_list|,
name|size_t
name|ar
parameter_list|,
name|size_t
name|total
parameter_list|,
name|enum
name|sec_status
name|sec
parameter_list|)
block|{
name|struct
name|reply_info
modifier|*
name|rep
decl_stmt|;
comment|/* rrset_count-1 because the first ref is part of the struct. */
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
name|total
decl_stmt|;
if|if
condition|(
name|region
condition|)
name|rep
operator|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|rep
operator|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
operator|*
operator|(
name|total
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep
condition|)
return|return
name|NULL
return|;
name|rep
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|rep
operator|->
name|qdcount
operator|=
name|qd
expr_stmt|;
name|rep
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|rep
operator|->
name|prefetch_ttl
operator|=
name|prettl
expr_stmt|;
name|rep
operator|->
name|an_numrrsets
operator|=
name|an
expr_stmt|;
name|rep
operator|->
name|ns_numrrsets
operator|=
name|ns
expr_stmt|;
name|rep
operator|->
name|ar_numrrsets
operator|=
name|ar
expr_stmt|;
name|rep
operator|->
name|rrset_count
operator|=
name|total
expr_stmt|;
name|rep
operator|->
name|security
operator|=
name|sec
expr_stmt|;
name|rep
operator|->
name|authoritative
operator|=
literal|0
expr_stmt|;
comment|/* array starts after the refs */
if|if
condition|(
name|region
condition|)
name|rep
operator|->
name|rrsets
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|*
operator|)
operator|&
operator|(
name|rep
operator|->
name|ref
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
name|rep
operator|->
name|rrsets
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|*
operator|)
operator|&
operator|(
name|rep
operator|->
name|ref
index|[
name|total
index|]
operator|)
expr_stmt|;
comment|/* zero the arrays to assist cleanup in case of malloc failure */
name|memset
argument_list|(
name|rep
operator|->
name|rrsets
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
condition|)
name|memset
argument_list|(
operator|&
name|rep
operator|->
name|ref
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
operator|*
name|total
argument_list|)
expr_stmt|;
return|return
name|rep
return|;
block|}
end_function

begin_comment
comment|/** allocate replyinfo, return 0 on error */
end_comment

begin_function
specifier|static
name|int
name|parse_create_repinfo
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|reply_info
modifier|*
modifier|*
name|rep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
operator|*
name|rep
operator|=
name|construct_reply_info_base
argument_list|(
name|region
argument_list|,
name|msg
operator|->
name|flags
argument_list|,
name|msg
operator|->
name|qdcount
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|msg
operator|->
name|an_rrsets
argument_list|,
name|msg
operator|->
name|ns_rrsets
argument_list|,
name|msg
operator|->
name|ar_rrsets
argument_list|,
name|msg
operator|->
name|rrset_count
argument_list|,
name|sec_status_unchecked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rep
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** allocate (special) rrset keys, return 0 on error */
end_comment

begin_function
specifier|static
name|int
name|repinfo_alloc_rrset_keys
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|region
condition|)
block|{
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
condition|)
block|{
name|memset
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|key
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
name|alloc_special_obtain
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** do the rdata copy */
end_comment

begin_function
specifier|static
name|int
name|rdata_copy
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|data
parameter_list|,
name|uint8_t
modifier|*
name|to
parameter_list|,
name|struct
name|rr_parse
modifier|*
name|rr
parameter_list|,
name|time_t
modifier|*
name|rr_ttl
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|uint16_t
name|pkt_len
decl_stmt|;
specifier|const
name|sldns_rr_descriptor
modifier|*
name|desc
decl_stmt|;
operator|*
name|rr_ttl
operator|=
name|sldns_read_uint32
argument_list|(
name|rr
operator|->
name|ttl_data
argument_list|)
expr_stmt|;
comment|/* RFC 2181 Section 8. if msb of ttl is set treat as if zero. */
if|if
condition|(
operator|*
name|rr_ttl
operator|&
literal|0x80000000U
condition|)
operator|*
name|rr_ttl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|rr_ttl
operator|<
name|MIN_TTL
condition|)
operator|*
name|rr_ttl
operator|=
name|MIN_TTL
expr_stmt|;
if|if
condition|(
operator|*
name|rr_ttl
operator|<
name|data
operator|->
name|ttl
condition|)
name|data
operator|->
name|ttl
operator|=
operator|*
name|rr_ttl
expr_stmt|;
if|if
condition|(
name|rr
operator|->
name|outside_packet
condition|)
block|{
comment|/* uncompressed already, only needs copy */
name|memmove
argument_list|(
name|to
argument_list|,
name|rr
operator|->
name|ttl_data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|rr
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rr
operator|->
name|ttl_data
operator|-
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* insert decompressed size into rdata len stored in memory */
comment|/* -2 because rdatalen bytes are not included. */
name|pkt_len
operator|=
name|htons
argument_list|(
name|rr
operator|->
name|size
operator|-
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|to
argument_list|,
operator|&
name|pkt_len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
literal|2
expr_stmt|;
comment|/* read packet rdata len */
name|pkt_len
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|pkt_len
condition|)
return|return
literal|0
return|;
name|desc
operator|=
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
operator|&&
name|desc
operator|&&
name|desc
operator|->
name|_dname_count
operator|>
literal|0
condition|)
block|{
name|int
name|count
init|=
operator|(
name|int
operator|)
name|desc
operator|->
name|_dname_count
decl_stmt|;
name|int
name|rdf
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|oldpos
decl_stmt|;
comment|/* decompress dnames. */
while|while
condition|(
name|pkt_len
operator|>
literal|0
operator|&&
name|count
condition|)
block|{
switch|switch
condition|(
name|desc
operator|->
name|_wireformat
index|[
name|rdf
index|]
condition|)
block|{
case|case
name|LDNS_RDF_TYPE_DNAME
case|:
name|oldpos
operator|=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|to
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|pkt_len
operator|-=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
operator|-
name|oldpos
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LDNS_RDF_TYPE_STR
case|:
name|len
operator|=
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|len
operator|=
name|get_rdf_size
argument_list|(
name|desc
operator|->
name|_wireformat
index|[
name|rdf
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|memmove
argument_list|(
name|to
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|to
operator|+=
name|len
expr_stmt|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|len
operator|<=
name|pkt_len
argument_list|)
expr_stmt|;
name|pkt_len
operator|-=
name|len
expr_stmt|;
block|}
name|rdf
operator|++
expr_stmt|;
block|}
block|}
comment|/* copy remaining rdata */
if|if
condition|(
name|pkt_len
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|to
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** copy over the data into packed rrset */
end_comment

begin_function
specifier|static
name|int
name|parse_rr_copy
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|pset
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|rr
init|=
name|pset
operator|->
name|rr_first
decl_stmt|;
name|uint8_t
modifier|*
name|nextrdata
decl_stmt|;
name|size_t
name|total
init|=
name|pset
operator|->
name|rr_count
operator|+
name|pset
operator|->
name|rrsig_count
decl_stmt|;
name|data
operator|->
name|ttl
operator|=
name|MAX_TTL
expr_stmt|;
name|data
operator|->
name|count
operator|=
name|pset
operator|->
name|rr_count
expr_stmt|;
name|data
operator|->
name|rrsig_count
operator|=
name|pset
operator|->
name|rrsig_count
expr_stmt|;
name|data
operator|->
name|trust
operator|=
name|rrset_trust_none
expr_stmt|;
name|data
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
comment|/* layout: struct - rr_len - rr_data - rr_ttl - rdata - rrsig */
name|data
operator|->
name|rr_len
operator|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|)
expr_stmt|;
name|data
operator|->
name|rr_data
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|rr_len
index|[
name|total
index|]
operator|)
expr_stmt|;
name|data
operator|->
name|rr_ttl
operator|=
operator|(
name|time_t
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|rr_data
index|[
name|total
index|]
operator|)
expr_stmt|;
name|nextrdata
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|rr_ttl
index|[
name|total
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|->
name|rr_len
index|[
name|i
index|]
operator|=
name|rr
operator|->
name|size
expr_stmt|;
name|data
operator|->
name|rr_data
index|[
name|i
index|]
operator|=
name|nextrdata
expr_stmt|;
name|nextrdata
operator|+=
name|rr
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|rdata_copy
argument_list|(
name|pkt
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|rr
argument_list|,
operator|&
name|data
operator|->
name|rr_ttl
index|[
name|i
index|]
argument_list|,
name|pset
operator|->
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|rr
operator|=
name|rr
operator|->
name|next
expr_stmt|;
block|}
comment|/* if rrsig, its rdata is at nextrdata */
name|rr
operator|=
name|pset
operator|->
name|rrsig_first
expr_stmt|;
for|for
control|(
name|i
operator|=
name|data
operator|->
name|count
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|->
name|rr_len
index|[
name|i
index|]
operator|=
name|rr
operator|->
name|size
expr_stmt|;
name|data
operator|->
name|rr_data
index|[
name|i
index|]
operator|=
name|nextrdata
expr_stmt|;
name|nextrdata
operator|+=
name|rr
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|rdata_copy
argument_list|(
name|pkt
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|rr
argument_list|,
operator|&
name|data
operator|->
name|rr_ttl
index|[
name|i
index|]
argument_list|,
name|LDNS_RR_TYPE_RRSIG
argument_list|)
condition|)
return|return
literal|0
return|;
name|rr
operator|=
name|rr
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** create rrset return 0 on failure */
end_comment

begin_function
specifier|static
name|int
name|parse_create_rrset
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|pset
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
modifier|*
name|data
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
comment|/* allocate */
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|+
operator|(
name|pset
operator|->
name|rr_count
operator|+
name|pset
operator|->
name|rrsig_count
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|)
operator|+
name|pset
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|region
condition|)
operator|*
name|data
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|data
operator|=
name|malloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|data
condition|)
return|return
literal|0
return|;
comment|/* copy& decompress */
if|if
condition|(
operator|!
name|parse_rr_copy
argument_list|(
name|pkt
argument_list|,
name|pset
argument_list|,
operator|*
name|data
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|region
condition|)
name|free
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** get trust value for rrset */
end_comment

begin_function
specifier|static
name|enum
name|rrset_trust
name|get_rrset_trust
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|)
block|{
name|uint16_t
name|AA
init|=
name|msg
operator|->
name|flags
operator|&
name|BIT_AA
decl_stmt|;
if|if
condition|(
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
condition|)
block|{
if|if
condition|(
name|AA
condition|)
block|{
comment|/* RFC2181 says remainder of CNAME chain is nonauth*/
if|if
condition|(
name|msg
operator|->
name|rrset_first
operator|&&
name|msg
operator|->
name|rrset_first
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
operator|&&
name|msg
operator|->
name|rrset_first
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
if|if
condition|(
name|rrset
operator|==
name|msg
operator|->
name|rrset_first
condition|)
return|return
name|rrset_trust_ans_AA
return|;
else|else
return|return
name|rrset_trust_ans_noAA
return|;
block|}
if|if
condition|(
name|msg
operator|->
name|rrset_first
operator|&&
name|msg
operator|->
name|rrset_first
operator|->
name|section
operator|==
name|LDNS_SECTION_ANSWER
operator|&&
name|msg
operator|->
name|rrset_first
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DNAME
condition|)
block|{
if|if
condition|(
name|rrset
operator|==
name|msg
operator|->
name|rrset_first
operator|||
name|rrset
operator|==
name|msg
operator|->
name|rrset_first
operator|->
name|rrset_all_next
condition|)
return|return
name|rrset_trust_ans_AA
return|;
else|else
return|return
name|rrset_trust_ans_noAA
return|;
block|}
return|return
name|rrset_trust_ans_AA
return|;
block|}
else|else
return|return
name|rrset_trust_ans_noAA
return|;
block|}
elseif|else
if|if
condition|(
name|rrset
operator|->
name|section
operator|==
name|LDNS_SECTION_AUTHORITY
condition|)
block|{
if|if
condition|(
name|AA
condition|)
return|return
name|rrset_trust_auth_AA
return|;
else|else
return|return
name|rrset_trust_auth_noAA
return|;
block|}
else|else
block|{
comment|/* addit section */
if|if
condition|(
name|AA
condition|)
return|return
name|rrset_trust_add_AA
return|;
else|else
return|return
name|rrset_trust_add_noAA
return|;
block|}
comment|/* NOTREACHED */
return|return
name|rrset_trust_none
return|;
block|}
end_function

begin_function
name|int
name|parse_copy_decompress_rrset
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|pset
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|pk
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|data
decl_stmt|;
name|pk
operator|->
name|rk
operator|.
name|flags
operator|=
name|pset
operator|->
name|flags
expr_stmt|;
name|pk
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|pset
operator|->
name|dname_len
expr_stmt|;
if|if
condition|(
name|region
condition|)
name|pk
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|pset
operator|->
name|dname_len
argument_list|)
expr_stmt|;
else|else
name|pk
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|pset
operator|->
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
operator|->
name|rk
operator|.
name|dname
condition|)
return|return
literal|0
return|;
comment|/** copy& decompress dname */
name|dname_pkt_copy
argument_list|(
name|pkt
argument_list|,
name|pk
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|pset
operator|->
name|dname
argument_list|)
expr_stmt|;
comment|/** copy over type and class */
name|pk
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|pset
operator|->
name|type
argument_list|)
expr_stmt|;
name|pk
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|pset
operator|->
name|rrset_class
expr_stmt|;
comment|/** read data part. */
if|if
condition|(
operator|!
name|parse_create_rrset
argument_list|(
name|pkt
argument_list|,
name|pset
argument_list|,
operator|&
name|data
argument_list|,
name|region
argument_list|)
condition|)
return|return
literal|0
return|;
name|pk
operator|->
name|entry
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|pk
operator|->
name|entry
operator|.
name|key
operator|=
operator|(
name|void
operator|*
operator|)
name|pk
expr_stmt|;
name|pk
operator|->
name|entry
operator|.
name|hash
operator|=
name|pset
operator|->
name|hash
expr_stmt|;
name|data
operator|->
name|trust
operator|=
name|get_rrset_trust
argument_list|(
name|msg
argument_list|,
name|pset
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**   * Copy and decompress rrs  * @param pkt: the packet for compression pointer resolution.  * @param msg: the parsed message  * @param rep: reply info to put rrs into.  * @param region: if not NULL, used for allocation.  * @return 0 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|parse_copy_decompress
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|pset
init|=
name|msg
operator|->
name|rrset_first
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|data
decl_stmt|;
name|log_assert
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|rep
operator|->
name|ttl
operator|=
name|MAX_TTL
expr_stmt|;
name|rep
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|rrset_count
operator|==
literal|0
condition|)
name|rep
operator|->
name|ttl
operator|=
name|NORR_TTL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|parse_copy_decompress_rrset
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|pset
argument_list|,
name|region
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|data
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ttl
operator|<
name|rep
operator|->
name|ttl
condition|)
name|rep
operator|->
name|ttl
operator|=
name|data
operator|->
name|ttl
expr_stmt|;
name|pset
operator|=
name|pset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
name|rep
operator|->
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|rep
operator|->
name|ttl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|parse_create_msg
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|struct
name|reply_info
modifier|*
modifier|*
name|rep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|log_assert
argument_list|(
name|pkt
operator|&&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_create_qinfo
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|qinf
argument_list|,
name|region
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|parse_create_repinfo
argument_list|(
name|msg
argument_list|,
name|rep
argument_list|,
name|region
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|repinfo_alloc_rrset_keys
argument_list|(
operator|*
name|rep
argument_list|,
name|alloc
argument_list|,
name|region
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|parse_copy_decompress
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
operator|*
name|rep
argument_list|,
name|region
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|reply_info_parse
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|,
name|struct
name|reply_info
modifier|*
modifier|*
name|rep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
comment|/* use scratch pad region-allocator during parsing. */
name|struct
name|msg_parse
modifier|*
name|msg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|qinf
operator|->
name|qname
operator|=
name|NULL
expr_stmt|;
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
name|LDNS_RCODE_SERVFAIL
return|;
block|}
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_packet
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|region
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_extract_edns
argument_list|(
name|msg
argument_list|,
name|edns
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* parse OK, allocate return structures */
comment|/* this also performs dname decompression */
if|if
condition|(
operator|!
name|parse_create_msg
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|alloc
argument_list|,
name|qinf
argument_list|,
name|rep
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|query_info_clear
argument_list|(
name|qinf
argument_list|)
expr_stmt|;
name|reply_info_parsedelete
argument_list|(
operator|*
name|rep
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|LDNS_RCODE_SERVFAIL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** helper compare function to sort in lock order */
end_comment

begin_function
specifier|static
name|int
name|reply_info_sortref_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|rrset_ref
modifier|*
name|x
init|=
operator|(
expr|struct
name|rrset_ref
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|rrset_ref
modifier|*
name|y
init|=
operator|(
expr|struct
name|rrset_ref
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|key
operator|<
name|y
operator|->
name|key
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|x
operator|->
name|key
operator|>
name|y
operator|->
name|key
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|reply_info_sortref
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|qsort
argument_list|(
operator|&
name|rep
operator|->
name|ref
index|[
literal|0
index|]
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
argument_list|,
name|reply_info_sortref_cmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reply_info_set_ttls
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|time_t
name|timenow
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rep
operator|->
name|ttl
operator|+=
name|timenow
expr_stmt|;
name|rep
operator|->
name|prefetch_ttl
operator|+=
name|timenow
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|==
name|rep
operator|->
name|ref
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|key
condition|)
continue|continue;
name|data
operator|->
name|ttl
operator|+=
name|timenow
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|data
operator|->
name|count
operator|+
name|data
operator|->
name|rrsig_count
condition|;
name|j
operator|++
control|)
block|{
name|data
operator|->
name|rr_ttl
index|[
name|j
index|]
operator|+=
name|timenow
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|reply_info_parsedelete
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rep
condition|)
return|return;
comment|/* no need to lock, since not shared in hashtables. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|ub_packed_rrset_parsedelete
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|query_info_parse
parameter_list|(
name|struct
name|query_info
modifier|*
name|m
parameter_list|,
name|sldns_buffer
modifier|*
name|query
parameter_list|)
block|{
name|uint8_t
modifier|*
name|q
init|=
name|sldns_buffer_begin
argument_list|(
name|query
argument_list|)
decl_stmt|;
comment|/* minimum size: header + \0 + qtype + qclass */
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|query
argument_list|)
operator|<
name|LDNS_HEADER_SIZE
operator|+
literal|5
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|LDNS_OPCODE_WIRE
argument_list|(
name|q
argument_list|)
operator|!=
name|LDNS_PACKET_QUERY
operator|||
name|LDNS_QDCOUNT
argument_list|(
name|q
argument_list|)
operator|!=
literal|1
operator|||
name|sldns_buffer_position
argument_list|(
name|query
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|sldns_buffer_skip
argument_list|(
name|query
argument_list|,
name|LDNS_HEADER_SIZE
argument_list|)
expr_stmt|;
name|m
operator|->
name|qname
operator|=
name|sldns_buffer_current
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|qname_len
operator|=
name|query_dname_len
argument_list|(
name|query
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* parse error */
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|query
argument_list|)
operator|<
literal|4
condition|)
return|return
literal|0
return|;
comment|/* need qtype, qclass */
name|m
operator|->
name|qtype
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|m
operator|->
name|qclass
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** tiny subroutine for msgreply_compare */
end_comment

begin_define
define|#
directive|define
name|COMPARE_IT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if( (x)< (y) ) return -1; \ 	else if( (x)> (y) ) return +1; \ 	log_assert( (x) == (y) );
end_define

begin_function
name|int
name|query_info_compare
parameter_list|(
name|void
modifier|*
name|m1
parameter_list|,
name|void
modifier|*
name|m2
parameter_list|)
block|{
name|struct
name|query_info
modifier|*
name|msg1
init|=
operator|(
expr|struct
name|query_info
operator|*
operator|)
name|m1
decl_stmt|;
name|struct
name|query_info
modifier|*
name|msg2
init|=
operator|(
expr|struct
name|query_info
operator|*
operator|)
name|m2
decl_stmt|;
name|int
name|mc
decl_stmt|;
comment|/* from most different to least different for speed */
name|COMPARE_IT
argument_list|(
name|msg1
operator|->
name|qtype
argument_list|,
name|msg2
operator|->
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mc
operator|=
name|query_dname_compare
argument_list|(
name|msg1
operator|->
name|qname
argument_list|,
name|msg2
operator|->
name|qname
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|mc
return|;
name|log_assert
argument_list|(
name|msg1
operator|->
name|qname_len
operator|==
name|msg2
operator|->
name|qname_len
argument_list|)
expr_stmt|;
name|COMPARE_IT
argument_list|(
name|msg1
operator|->
name|qclass
argument_list|,
name|msg2
operator|->
name|qclass
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|COMPARE_IT
block|}
end_function

begin_function
name|void
name|query_info_clear
parameter_list|(
name|struct
name|query_info
modifier|*
name|m
parameter_list|)
block|{
name|free
argument_list|(
name|m
operator|->
name|qname
argument_list|)
expr_stmt|;
name|m
operator|->
name|qname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|msgreply_sizefunc
parameter_list|(
name|void
modifier|*
name|k
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|msgreply_entry
modifier|*
name|q
init|=
operator|(
expr|struct
name|msgreply_entry
operator|*
operator|)
name|k
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|r
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|d
decl_stmt|;
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|msgreply_entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
operator|+
name|q
operator|->
name|key
operator|.
name|qname_len
operator|+
name|lock_get_mem
argument_list|(
operator|&
name|q
operator|->
name|entry
operator|.
name|lock
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
decl_stmt|;
name|s
operator|+=
name|r
operator|->
name|rrset_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
expr_stmt|;
name|s
operator|+=
name|r
operator|->
name|rrset_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|query_entry_delete
parameter_list|(
name|void
modifier|*
name|k
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|msgreply_entry
modifier|*
name|q
init|=
operator|(
expr|struct
name|msgreply_entry
operator|*
operator|)
name|k
decl_stmt|;
name|lock_rw_destroy
argument_list|(
operator|&
name|q
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|query_info_clear
argument_list|(
operator|&
name|q
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reply_info_delete
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|reply_info
modifier|*
name|r
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|d
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|hashvalue_t
name|query_info_hash
parameter_list|(
name|struct
name|query_info
modifier|*
name|q
parameter_list|)
block|{
name|hashvalue_t
name|h
init|=
literal|0xab
decl_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|q
operator|->
name|qtype
argument_list|,
sizeof|sizeof
argument_list|(
name|q
operator|->
name|qtype
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|q
operator|->
name|qclass
argument_list|,
sizeof|sizeof
argument_list|(
name|q
operator|->
name|qclass
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|dname_query_hash
argument_list|(
name|q
operator|->
name|qname
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
name|struct
name|msgreply_entry
modifier|*
name|query_info_entrysetup
parameter_list|(
name|struct
name|query_info
modifier|*
name|q
parameter_list|,
name|struct
name|reply_info
modifier|*
name|r
parameter_list|,
name|hashvalue_t
name|h
parameter_list|)
block|{
name|struct
name|msgreply_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|msgreply_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msgreply_entry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|&
name|e
operator|->
name|key
argument_list|,
name|q
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|entry
operator|.
name|hash
operator|=
name|h
expr_stmt|;
name|e
operator|->
name|entry
operator|.
name|key
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|entry
operator|.
name|data
operator|=
name|r
expr_stmt|;
name|lock_rw_init
argument_list|(
operator|&
name|e
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|e
operator|->
name|entry
operator|.
name|lock
argument_list|,
operator|&
name|e
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|e
operator|->
name|entry
operator|.
name|lock
argument_list|,
operator|&
name|e
operator|->
name|entry
operator|.
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|entry
operator|.
name|hash
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|e
operator|->
name|entry
operator|.
name|key
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|e
operator|->
name|entry
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|e
operator|->
name|entry
operator|.
name|lock
argument_list|,
name|e
operator|->
name|key
operator|.
name|qname
argument_list|,
name|e
operator|->
name|key
operator|.
name|qname_len
argument_list|)
expr_stmt|;
name|q
operator|->
name|qname
operator|=
name|NULL
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/** copy rrsets from replyinfo to dest replyinfo */
end_comment

begin_function
specifier|static
name|int
name|repinfo_copy_rrsets
parameter_list|(
name|struct
name|reply_info
modifier|*
name|dest
parameter_list|,
name|struct
name|reply_info
modifier|*
name|from
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|fd
decl_stmt|,
modifier|*
name|dd
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|fk
decl_stmt|,
modifier|*
name|dk
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dest
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|fk
operator|=
name|from
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|dk
operator|=
name|dest
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|fk
operator|->
name|entry
operator|.
name|data
expr_stmt|;
name|dk
operator|->
name|entry
operator|.
name|hash
operator|=
name|fk
operator|->
name|entry
operator|.
name|hash
expr_stmt|;
name|dk
operator|->
name|rk
operator|=
name|fk
operator|->
name|rk
expr_stmt|;
if|if
condition|(
name|region
condition|)
block|{
name|dk
operator|->
name|id
operator|=
name|fk
operator|->
name|id
expr_stmt|;
name|dk
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
block|}
else|else
name|dk
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|memdup
argument_list|(
name|fk
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dk
operator|->
name|rk
operator|.
name|dname
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|packed_rrset_sizeof
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
condition|)
name|dd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|fd
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|dd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|memdup
argument_list|(
name|fd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dd
condition|)
return|return
literal|0
return|;
name|packed_rrset_ptr_fixup
argument_list|(
name|dd
argument_list|)
expr_stmt|;
name|dk
operator|->
name|entry
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|dd
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|reply_info
modifier|*
name|reply_info_copy
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|reply_info
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|construct_reply_info_base
argument_list|(
name|region
argument_list|,
name|rep
operator|->
name|flags
argument_list|,
name|rep
operator|->
name|qdcount
argument_list|,
name|rep
operator|->
name|ttl
argument_list|,
name|rep
operator|->
name|prefetch_ttl
argument_list|,
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|rep
operator|->
name|ns_numrrsets
argument_list|,
name|rep
operator|->
name|ar_numrrsets
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|,
name|rep
operator|->
name|security
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|NULL
return|;
comment|/* allocate ub_key structures special or not */
if|if
condition|(
operator|!
name|repinfo_alloc_rrset_keys
argument_list|(
name|cp
argument_list|,
name|alloc
argument_list|,
name|region
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|region
condition|)
name|reply_info_parsedelete
argument_list|(
name|cp
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|repinfo_copy_rrsets
argument_list|(
name|cp
argument_list|,
name|rep
argument_list|,
name|region
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|region
condition|)
name|reply_info_parsedelete
argument_list|(
name|cp
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|reply_find_final_cname_target
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|uint8_t
modifier|*
name|sname
init|=
name|qinfo
operator|->
name|qname
decl_stmt|;
name|size_t
name|snamelen
init|=
name|qinfo
operator|->
name|qname_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
comment|/* follow CNAME chain (if any) */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|qinfo
operator|->
name|qclass
operator|&&
name|snamelen
operator|==
name|s
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|sname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|get_cname_target
argument_list|(
name|s
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|snamelen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sname
operator|!=
name|qinfo
operator|->
name|qname
condition|)
return|return
name|sname
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ub_packed_rrset_key
modifier|*
name|reply_find_answer_rrset
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|uint8_t
modifier|*
name|sname
init|=
name|qinfo
operator|->
name|qname
decl_stmt|;
name|size_t
name|snamelen
init|=
name|qinfo
operator|->
name|qname_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
comment|/* first match type, for query of qtype cname */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|qinfo
operator|->
name|qtype
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|qinfo
operator|->
name|qclass
operator|&&
name|snamelen
operator|==
name|s
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|sname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
comment|/* follow CNAME chain (if any) */
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|qinfo
operator|->
name|qclass
operator|&&
name|snamelen
operator|==
name|s
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|sname
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|get_cname_target
argument_list|(
name|s
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|snamelen
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ub_packed_rrset_key
modifier|*
name|reply_find_rrset_section_an
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|type
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|dclass
operator|&&
name|namelen
operator|==
name|s
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ub_packed_rrset_key
modifier|*
name|reply_find_rrset_section_ns
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|type
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|dclass
operator|&&
name|namelen
operator|==
name|s
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ub_packed_rrset_key
modifier|*
name|reply_find_rrset
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|s
init|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|type
operator|&&
name|ntohs
argument_list|(
name|s
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
operator|==
name|dclass
operator|&&
name|namelen
operator|==
name|s
operator|->
name|rk
operator|.
name|dname_len
operator|&&
name|query_dname_compare
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|log_dns_msg
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
comment|/* not particularly fast but flexible, make wireformat and print */
name|sldns_buffer
modifier|*
name|buf
init|=
name|sldns_buffer_new
argument_list|(
literal|65535
argument_list|)
decl_stmt|;
name|struct
name|regional
modifier|*
name|region
init|=
name|regional_create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|reply_info_encode
argument_list|(
name|qinfo
argument_list|,
name|rep
argument_list|,
literal|0
argument_list|,
name|rep
operator|->
name|flags
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|region
argument_list|,
literal|65535
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"%s: log_dns_msg: out of memory"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|str
init|=
name|sldns_wire2str_pkt
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|log_info
argument_list|(
literal|"%s: log_dns_msg: ldns tostr failed"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_info
argument_list|(
literal|"%s %s"
argument_list|,
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_query_info
parameter_list|(
name|enum
name|verbosity_value
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinf
parameter_list|)
block|{
name|log_nametypeclass
argument_list|(
name|v
argument_list|,
name|str
argument_list|,
name|qinf
operator|->
name|qname
argument_list|,
name|qinf
operator|->
name|qtype
argument_list|,
name|qinf
operator|->
name|qclass
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|reply_check_cname_chain
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
comment|/* check only answer section rrs for matching cname chain. 	 * the cache may return changed rdata, but owner names are untouched.*/
name|size_t
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|sname
init|=
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|dname
decl_stmt|;
name|size_t
name|snamelen
init|=
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|dname_len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|t
init|=
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_DNAME
condition|)
continue|continue;
comment|/* skip dnames; note TTL 0 not cached */
comment|/* verify that owner matches current sname */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|sname
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* cname chain broken */
return|return
literal|0
return|;
block|}
comment|/* if this is a cname; move on */
if|if
condition|(
name|t
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
name|get_cname_target
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|&
name|sname
argument_list|,
operator|&
name|snamelen
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|reply_all_rrsets_secure
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

