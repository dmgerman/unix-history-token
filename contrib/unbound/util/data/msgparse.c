begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * util/data/msgparse.c - parse wireformat DNS messages.  *   * Copyright (c) 2007, NLnet Labs. All rights reserved.  *   * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  * Routines for message parsing a packet buffer to a descriptive structure.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/lookup3.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"ldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_comment
comment|/** smart comparison of (compressed, valid) dnames from packet */
end_comment

begin_function
specifier|static
name|int
name|smart_compare
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|dnow
parameter_list|,
name|uint8_t
modifier|*
name|dprfirst
parameter_list|,
name|uint8_t
modifier|*
name|dprlast
parameter_list|)
block|{
if|if
condition|(
name|LABEL_IS_PTR
argument_list|(
operator|*
name|dnow
argument_list|)
condition|)
block|{
comment|/* ptr points to a previous dname */
name|uint8_t
modifier|*
name|p
init|=
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
name|PTR_OFFSET
argument_list|(
name|dnow
index|[
literal|0
index|]
argument_list|,
name|dnow
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|dprfirst
operator|||
name|p
operator|==
name|dprlast
condition|)
return|return
literal|0
return|;
comment|/* prev dname is also a ptr, both ptrs are the same. */
if|if
condition|(
name|LABEL_IS_PTR
argument_list|(
operator|*
name|dprlast
argument_list|)
operator|&&
name|dprlast
index|[
literal|0
index|]
operator|==
name|dnow
index|[
literal|0
index|]
operator|&&
name|dprlast
index|[
literal|1
index|]
operator|==
name|dnow
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
block|}
return|return
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|dnow
argument_list|,
name|dprlast
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate new rrset in region, fill with data.  */
end_comment

begin_function
specifier|static
name|struct
name|rrset_parse
modifier|*
name|new_rrset
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|,
name|size_t
name|dnamelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|uint32_t
name|rrset_flags
parameter_list|,
name|sldns_pkt_section
name|section
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|p
init|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|rrset_bucket_next
operator|=
name|msg
operator|->
name|hashtable
index|[
name|hash
operator|&
operator|(
name|PARSE_TABLE_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|msg
operator|->
name|hashtable
index|[
name|hash
operator|&
operator|(
name|PARSE_TABLE_SIZE
operator|-
literal|1
operator|)
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|rrset_all_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|rrset_last
condition|)
name|msg
operator|->
name|rrset_last
operator|->
name|rrset_all_next
operator|=
name|p
expr_stmt|;
else|else
name|msg
operator|->
name|rrset_first
operator|=
name|p
expr_stmt|;
name|msg
operator|->
name|rrset_last
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|p
operator|->
name|dname
operator|=
name|dname
expr_stmt|;
name|p
operator|->
name|dname_len
operator|=
name|dnamelen
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|rrset_class
operator|=
name|dclass
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|rrset_flags
expr_stmt|;
name|p
operator|->
name|rr_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rr_first
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rr_last
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rrsig_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rrsig_first
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rrsig_last
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/** See if next rrset is nsec at zone apex */
end_comment

begin_function
specifier|static
name|int
name|nsec_at_apex
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
comment|/* we are at ttl position in packet. */
name|size_t
name|pos
init|=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
decl_stmt|;
name|uint16_t
name|rdatalen
decl_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|7
condition|)
comment|/* ttl+len+root */
return|return
literal|0
return|;
comment|/* eek! */
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ttl */
empty_stmt|;
name|rdatalen
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|rdatalen
condition|)
block|{
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* parse error happens later */
block|}
comment|/* must validate the nsec next domain name format */
if|if
condition|(
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* parse error */
block|}
comment|/* see if SOA bit is set. */
if|if
condition|(
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
operator|<
name|pos
operator|+
literal|4
operator|+
name|rdatalen
condition|)
block|{
comment|/* nsec type bitmap contains items */
name|uint8_t
name|win
decl_stmt|,
name|blen
decl_stmt|,
name|bits
decl_stmt|;
comment|/* need: windownum, bitmap len, firstbyte */
if|if
condition|(
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
operator|+
literal|3
operator|>
name|pos
operator|+
literal|4
operator|+
name|rdatalen
condition|)
block|{
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* malformed nsec */
block|}
name|win
operator|=
name|sldns_buffer_read_u8
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|blen
operator|=
name|sldns_buffer_read_u8
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|bits
operator|=
name|sldns_buffer_read_u8
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 0window always first window. bitlen>=1 or parse 		   error really. bit 0x2 is SOA. */
if|if
condition|(
name|win
operator|==
literal|0
operator|&&
name|blen
operator|>=
literal|1
operator|&&
operator|(
name|bits
operator|&
literal|0x02
operator|)
condition|)
block|{
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Calculate rrset flags */
end_comment

begin_function
specifier|static
name|uint32_t
name|pkt_rrset_flags
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|sldns_pkt_section
name|sec
parameter_list|)
block|{
name|uint32_t
name|f
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_NSEC
operator|&&
name|nsec_at_apex
argument_list|(
name|pkt
argument_list|)
condition|)
block|{
name|f
operator||=
name|PACKED_RRSET_NSEC_AT_APEX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_SOA
operator|&&
name|sec
operator|==
name|LDNS_SECTION_AUTHORITY
condition|)
block|{
name|f
operator||=
name|PACKED_RRSET_SOA_NEG
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_function
name|hashvalue_t
name|pkt_hash_rrset
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|uint32_t
name|rrset_flags
parameter_list|)
block|{
comment|/* note this MUST be identical to rrset_key_hash in packed_rrset.c */
comment|/* this routine handles compressed names */
name|hashvalue_t
name|h
init|=
literal|0xab
decl_stmt|;
name|h
operator|=
name|dname_pkt_hash
argument_list|(
name|pkt
argument_list|,
name|dname
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* host order */
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|dclass
argument_list|,
sizeof|sizeof
argument_list|(
name|dclass
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* netw order */
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|rrset_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/** create partial dname hash for rrset hash */
end_comment

begin_function
specifier|static
name|hashvalue_t
name|pkt_hash_rrset_first
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|)
block|{
comment|/* works together with pkt_hash_rrset_rest */
comment|/* note this MUST be identical to rrset_key_hash in packed_rrset.c */
comment|/* this routine handles compressed names */
name|hashvalue_t
name|h
init|=
literal|0xab
decl_stmt|;
name|h
operator|=
name|dname_pkt_hash
argument_list|(
name|pkt
argument_list|,
name|dname
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/** create a rrset hash from a partial dname hash */
end_comment

begin_function
specifier|static
name|hashvalue_t
name|pkt_hash_rrset_rest
parameter_list|(
name|hashvalue_t
name|dname_h
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|uint32_t
name|rrset_flags
parameter_list|)
block|{
comment|/* works together with pkt_hash_rrset_first */
comment|/* note this MUST be identical to rrset_key_hash in packed_rrset.c */
name|hashvalue_t
name|h
decl_stmt|;
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|,
name|dname_h
argument_list|)
expr_stmt|;
comment|/* host order */
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|dclass
argument_list|,
sizeof|sizeof
argument_list|(
name|dclass
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* netw order */
name|h
operator|=
name|hashlittle
argument_list|(
operator|&
name|rrset_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/** compare rrset_parse with data */
end_comment

begin_function
specifier|static
name|int
name|rrset_parse_equals
parameter_list|(
name|struct
name|rrset_parse
modifier|*
name|p
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|hashvalue_t
name|h
parameter_list|,
name|uint32_t
name|rrset_flags
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|,
name|size_t
name|dnamelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|hash
operator|==
name|h
operator|&&
name|p
operator|->
name|dname_len
operator|==
name|dnamelen
operator|&&
name|p
operator|->
name|type
operator|==
name|type
operator|&&
name|p
operator|->
name|rrset_class
operator|==
name|dclass
operator|&&
name|p
operator|->
name|flags
operator|==
name|rrset_flags
operator|&&
name|dname_pkt_compare
argument_list|(
name|pkt
argument_list|,
name|dname
argument_list|,
name|p
operator|->
name|dname
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|rrset_parse
modifier|*
name|msgparse_hashtable_lookup
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|hashvalue_t
name|h
parameter_list|,
name|uint32_t
name|rrset_flags
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|,
name|size_t
name|dnamelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|p
init|=
name|msg
operator|->
name|hashtable
index|[
name|h
operator|&
operator|(
name|PARSE_TABLE_SIZE
operator|-
literal|1
operator|)
index|]
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|rrset_parse_equals
argument_list|(
name|p
argument_list|,
name|pkt
argument_list|,
name|h
argument_list|,
name|rrset_flags
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|)
condition|)
return|return
name|p
return|;
name|p
operator|=
name|p
operator|->
name|rrset_bucket_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** return type networkformat that rrsig in packet covers */
end_comment

begin_function
specifier|static
name|int
name|pkt_rrsig_covered
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|here
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|)
block|{
name|size_t
name|pos
init|=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
decl_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|here
operator|-
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ttl + len + size of small rrsig(rootlabel, no signature) */
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|4
operator|+
literal|2
operator|+
literal|19
condition|)
return|return
literal|0
return|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ttl */
if|if
condition|(
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
operator|<
literal|19
condition|)
comment|/* too short */
block|{
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|type
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** true if covered type equals prevtype */
end_comment

begin_function
specifier|static
name|int
name|pkt_rrsig_covered_equals
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|here
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|uint16_t
name|t
decl_stmt|;
if|if
condition|(
name|pkt_rrsig_covered
argument_list|(
name|pkt
argument_list|,
name|here
argument_list|,
operator|&
name|t
argument_list|)
operator|&&
name|t
operator|==
name|type
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|msgparse_bucket_remove
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|msg
operator|->
name|hashtable
index|[
name|rrset
operator|->
name|hash
operator|&
operator|(
name|PARSE_TABLE_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|rrset
condition|)
block|{
operator|*
name|p
operator|=
name|rrset
operator|->
name|rrset_bucket_next
expr_stmt|;
return|return;
block|}
name|p
operator|=
operator|&
operator|(
operator|(
operator|*
name|p
operator|)
operator|->
name|rrset_bucket_next
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** change section of rrset from previous to current section */
end_comment

begin_function
specifier|static
name|void
name|change_section
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|sldns_pkt_section
name|section
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* remove from list */
if|if
condition|(
name|section
operator|==
name|rrset
operator|->
name|section
condition|)
return|return;
name|p
operator|=
name|msg
operator|->
name|rrset_first
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|rrset
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|rrset_all_next
operator|=
name|p
operator|->
name|rrset_all_next
expr_stmt|;
else|else
name|msg
operator|->
name|rrset_first
operator|=
name|p
operator|->
name|rrset_all_next
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|rrset_last
operator|==
name|rrset
condition|)
name|msg
operator|->
name|rrset_last
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|rrset_all_next
expr_stmt|;
block|}
comment|/* remove from count */
switch|switch
condition|(
name|rrset
operator|->
name|section
condition|)
block|{
case|case
name|LDNS_SECTION_ANSWER
case|:
name|msg
operator|->
name|an_rrsets
operator|--
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_AUTHORITY
case|:
name|msg
operator|->
name|ns_rrsets
operator|--
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_ADDITIONAL
case|:
name|msg
operator|->
name|ar_rrsets
operator|--
expr_stmt|;
break|break;
default|default:
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* insert at end of list */
name|rrset
operator|->
name|rrset_all_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|rrset_last
condition|)
name|msg
operator|->
name|rrset_last
operator|->
name|rrset_all_next
operator|=
name|rrset
expr_stmt|;
else|else
name|msg
operator|->
name|rrset_first
operator|=
name|rrset
expr_stmt|;
name|msg
operator|->
name|rrset_last
operator|=
name|rrset
expr_stmt|;
comment|/* up count of new section */
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|LDNS_SECTION_AUTHORITY
case|:
name|msg
operator|->
name|ns_rrsets
operator|++
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_ADDITIONAL
case|:
name|msg
operator|->
name|ar_rrsets
operator|++
expr_stmt|;
break|break;
default|default:
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rrset
operator|->
name|section
operator|=
name|section
expr_stmt|;
block|}
end_function

begin_comment
comment|/** see if rrset of type RRSIG contains sig over given type */
end_comment

begin_function
specifier|static
name|int
name|rrset_has_sigover
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|int
modifier|*
name|hasother
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|rr
init|=
name|rrset
operator|->
name|rr_first
decl_stmt|;
name|log_assert
argument_list|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_RRSIG
argument_list|)
expr_stmt|;
while|while
condition|(
name|rr
condition|)
block|{
if|if
condition|(
name|pkt_rrsig_covered_equals
argument_list|(
name|pkt
argument_list|,
name|rr
operator|->
name|ttl_data
argument_list|,
name|type
argument_list|)
condition|)
name|res
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|hasother
operator|=
literal|1
expr_stmt|;
name|rr
operator|=
name|rr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/** move rrsigs from sigset to dataset */
end_comment

begin_function
specifier|static
name|int
name|moveover_rrsigs
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|sigset
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|dataset
parameter_list|,
name|int
name|duplicate
parameter_list|)
block|{
name|struct
name|rr_parse
modifier|*
name|sig
init|=
name|sigset
operator|->
name|rr_first
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|insert
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|nextsig
decl_stmt|;
while|while
condition|(
name|sig
condition|)
block|{
name|nextsig
operator|=
name|sig
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pkt_rrsig_covered_equals
argument_list|(
name|pkt
argument_list|,
name|sig
operator|->
name|ttl_data
argument_list|,
name|dataset
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|duplicate
condition|)
block|{
comment|/* new */
name|insert
operator|=
operator|(
expr|struct
name|rr_parse
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rr_parse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insert
condition|)
return|return
literal|0
return|;
name|insert
operator|->
name|outside_packet
operator|=
literal|0
expr_stmt|;
name|insert
operator|->
name|ttl_data
operator|=
name|sig
operator|->
name|ttl_data
expr_stmt|;
name|insert
operator|->
name|size
operator|=
name|sig
operator|->
name|size
expr_stmt|;
comment|/* prev not used */
block|}
else|else
block|{
comment|/* remove from sigset */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|sig
operator|->
name|next
expr_stmt|;
else|else
name|sigset
operator|->
name|rr_first
operator|=
name|sig
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sigset
operator|->
name|rr_last
operator|==
name|sig
condition|)
name|sigset
operator|->
name|rr_last
operator|=
name|prev
expr_stmt|;
name|sigset
operator|->
name|rr_count
operator|--
expr_stmt|;
name|sigset
operator|->
name|size
operator|-=
name|sig
operator|->
name|size
expr_stmt|;
name|insert
operator|=
name|sig
expr_stmt|;
comment|/* prev not changed */
block|}
comment|/* add to dataset */
name|dataset
operator|->
name|rrsig_count
operator|++
expr_stmt|;
name|insert
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dataset
operator|->
name|rrsig_last
condition|)
name|dataset
operator|->
name|rrsig_last
operator|->
name|next
operator|=
name|insert
expr_stmt|;
else|else
name|dataset
operator|->
name|rrsig_first
operator|=
name|insert
expr_stmt|;
name|dataset
operator|->
name|rrsig_last
operator|=
name|insert
expr_stmt|;
name|dataset
operator|->
name|size
operator|+=
name|insert
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|sig
expr_stmt|;
block|}
name|sig
operator|=
name|nextsig
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** change an rrsig rrset for use as data rrset */
end_comment

begin_function
specifier|static
name|struct
name|rrset_parse
modifier|*
name|change_rrsig_rrset
parameter_list|(
name|struct
name|rrset_parse
modifier|*
name|sigset
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint16_t
name|datatype
parameter_list|,
name|uint32_t
name|rrset_flags
parameter_list|,
name|int
name|hasother
parameter_list|,
name|sldns_pkt_section
name|section
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|dataset
init|=
name|sigset
decl_stmt|;
name|hashvalue_t
name|hash
init|=
name|pkt_hash_rrset
argument_list|(
name|pkt
argument_list|,
name|sigset
operator|->
name|dname
argument_list|,
name|datatype
argument_list|,
name|sigset
operator|->
name|rrset_class
argument_list|,
name|rrset_flags
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
name|sigset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_RRSIG
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|datatype
operator|!=
name|LDNS_RR_TYPE_RRSIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasother
condition|)
block|{
comment|/* need to make new rrset to hold data type */
name|dataset
operator|=
name|new_rrset
argument_list|(
name|msg
argument_list|,
name|sigset
operator|->
name|dname
argument_list|,
name|sigset
operator|->
name|dname_len
argument_list|,
name|datatype
argument_list|,
name|sigset
operator|->
name|rrset_class
argument_list|,
name|hash
argument_list|,
name|rrset_flags
argument_list|,
name|section
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dataset
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|LDNS_SECTION_ANSWER
case|:
name|msg
operator|->
name|an_rrsets
operator|++
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_AUTHORITY
case|:
name|msg
operator|->
name|ns_rrsets
operator|++
expr_stmt|;
break|break;
case|case
name|LDNS_SECTION_ADDITIONAL
case|:
name|msg
operator|->
name|ar_rrsets
operator|++
expr_stmt|;
break|break;
default|default:
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|moveover_rrsigs
argument_list|(
name|pkt
argument_list|,
name|region
argument_list|,
name|sigset
argument_list|,
name|dataset
argument_list|,
name|msg
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|||
operator|(
name|msg
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
operator|&&
name|section
operator|!=
name|LDNS_SECTION_ANSWER
operator|)
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|dataset
return|;
block|}
comment|/* changeover the type of the rrset to data set */
name|msgparse_bucket_remove
argument_list|(
name|msg
argument_list|,
name|dataset
argument_list|)
expr_stmt|;
comment|/* insert into new hash bucket */
name|dataset
operator|->
name|rrset_bucket_next
operator|=
name|msg
operator|->
name|hashtable
index|[
name|hash
operator|&
operator|(
name|PARSE_TABLE_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|msg
operator|->
name|hashtable
index|[
name|hash
operator|&
operator|(
name|PARSE_TABLE_SIZE
operator|-
literal|1
operator|)
index|]
operator|=
name|dataset
expr_stmt|;
name|dataset
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
comment|/* use section of data item for result */
name|change_section
argument_list|(
name|msg
argument_list|,
name|dataset
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|dataset
operator|->
name|type
operator|=
name|datatype
expr_stmt|;
name|dataset
operator|->
name|flags
operator|=
name|rrset_flags
expr_stmt|;
name|dataset
operator|->
name|rrsig_count
operator|+=
name|dataset
operator|->
name|rr_count
expr_stmt|;
name|dataset
operator|->
name|rr_count
operator|=
literal|0
expr_stmt|;
comment|/* move sigs to end of siglist */
if|if
condition|(
name|dataset
operator|->
name|rrsig_last
condition|)
name|dataset
operator|->
name|rrsig_last
operator|->
name|next
operator|=
name|dataset
operator|->
name|rr_first
expr_stmt|;
else|else
name|dataset
operator|->
name|rrsig_first
operator|=
name|dataset
operator|->
name|rr_first
expr_stmt|;
name|dataset
operator|->
name|rrsig_last
operator|=
name|dataset
operator|->
name|rr_last
expr_stmt|;
name|dataset
operator|->
name|rr_first
operator|=
literal|0
expr_stmt|;
name|dataset
operator|->
name|rr_last
operator|=
literal|0
expr_stmt|;
return|return
name|dataset
return|;
block|}
end_function

begin_comment
comment|/** Find rrset. If equal to previous it is fast. hash if not so.  * @param msg: the message with hash table.  * @param pkt: the packet in wireformat (needed for compression ptrs).  * @param dname: pointer to start of dname (compressed) in packet.  * @param dnamelen: uncompressed wirefmt length of dname.  * @param type: type of current rr.  * @param dclass: class of current rr.  * @param hash: hash value is returned if the rrset could not be found.  * @param rrset_flags: is returned if the rrset could not be found.  * @param prev_dname_first: dname of last seen RR. First seen dname.  * @param prev_dname_last: dname of last seen RR. Last seen dname.  * @param prev_dnamelen: dname len of last seen RR.  * @param prev_type: type of last seen RR.  * @param prev_dclass: class of last seen RR.  * @param rrset_prev: last seen RRset.  * @param section: the current section in the packet.  * @param region: used to allocate temporary parsing data.  * @return 0 on out of memory.  */
end_comment

begin_function
specifier|static
name|int
name|find_rrset
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|dname
parameter_list|,
name|size_t
name|dnamelen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|hashvalue_t
modifier|*
name|hash
parameter_list|,
name|uint32_t
modifier|*
name|rrset_flags
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|prev_dname_first
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|prev_dname_last
parameter_list|,
name|size_t
modifier|*
name|prev_dnamelen
parameter_list|,
name|uint16_t
modifier|*
name|prev_type
parameter_list|,
name|uint16_t
modifier|*
name|prev_dclass
parameter_list|,
name|struct
name|rrset_parse
modifier|*
modifier|*
name|rrset_prev
parameter_list|,
name|sldns_pkt_section
name|section
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|hashvalue_t
name|dname_h
init|=
name|pkt_hash_rrset_first
argument_list|(
name|pkt
argument_list|,
name|dname
argument_list|)
decl_stmt|;
name|uint16_t
name|covtype
decl_stmt|;
if|if
condition|(
operator|*
name|rrset_prev
condition|)
block|{
comment|/* check if equal to previous item */
if|if
condition|(
name|type
operator|==
operator|*
name|prev_type
operator|&&
name|dclass
operator|==
operator|*
name|prev_dclass
operator|&&
name|dnamelen
operator|==
operator|*
name|prev_dnamelen
operator|&&
name|smart_compare
argument_list|(
name|pkt
argument_list|,
name|dname
argument_list|,
operator|*
name|prev_dname_first
argument_list|,
operator|*
name|prev_dname_last
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
comment|/* same as previous */
operator|*
name|prev_dname_last
operator|=
name|dname
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* check if rrsig over previous item */
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|&&
name|dclass
operator|==
operator|*
name|prev_dclass
operator|&&
name|pkt_rrsig_covered_equals
argument_list|(
name|pkt
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|,
operator|*
name|prev_type
argument_list|)
operator|&&
name|smart_compare
argument_list|(
name|pkt
argument_list|,
name|dname
argument_list|,
operator|*
name|prev_dname_first
argument_list|,
operator|*
name|prev_dname_last
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* covers previous */
operator|*
name|prev_dname_last
operator|=
name|dname
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* find by hashing and lookup in hashtable */
operator|*
name|rrset_flags
operator|=
name|pkt_rrset_flags
argument_list|(
name|pkt
argument_list|,
name|type
argument_list|,
name|section
argument_list|)
expr_stmt|;
comment|/* if rrsig - try to lookup matching data set first */
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|&&
name|pkt_rrsig_covered
argument_list|(
name|pkt
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|,
operator|&
name|covtype
argument_list|)
condition|)
block|{
operator|*
name|hash
operator|=
name|pkt_hash_rrset_rest
argument_list|(
name|dname_h
argument_list|,
name|covtype
argument_list|,
name|dclass
argument_list|,
operator|*
name|rrset_flags
argument_list|)
expr_stmt|;
operator|*
name|rrset_prev
operator|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
operator|*
name|hash
argument_list|,
operator|*
name|rrset_flags
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|covtype
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rrset_prev
operator|&&
name|covtype
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
comment|/* if NSEC try with NSEC apex bit twiddled */
operator|*
name|rrset_flags
operator|^=
name|PACKED_RRSET_NSEC_AT_APEX
expr_stmt|;
operator|*
name|hash
operator|=
name|pkt_hash_rrset_rest
argument_list|(
name|dname_h
argument_list|,
name|covtype
argument_list|,
name|dclass
argument_list|,
operator|*
name|rrset_flags
argument_list|)
expr_stmt|;
operator|*
name|rrset_prev
operator|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
operator|*
name|hash
argument_list|,
operator|*
name|rrset_flags
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|covtype
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rrset_prev
condition|)
comment|/* untwiddle if not found */
operator|*
name|rrset_flags
operator|^=
name|PACKED_RRSET_NSEC_AT_APEX
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|rrset_prev
operator|&&
name|covtype
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
block|{
comment|/* if SOA try with SOA neg flag twiddled */
operator|*
name|rrset_flags
operator|^=
name|PACKED_RRSET_SOA_NEG
expr_stmt|;
operator|*
name|hash
operator|=
name|pkt_hash_rrset_rest
argument_list|(
name|dname_h
argument_list|,
name|covtype
argument_list|,
name|dclass
argument_list|,
operator|*
name|rrset_flags
argument_list|)
expr_stmt|;
operator|*
name|rrset_prev
operator|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
operator|*
name|hash
argument_list|,
operator|*
name|rrset_flags
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|covtype
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rrset_prev
condition|)
comment|/* untwiddle if not found */
operator|*
name|rrset_flags
operator|^=
name|PACKED_RRSET_SOA_NEG
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|rrset_prev
condition|)
block|{
operator|*
name|prev_dname_first
operator|=
operator|(
operator|*
name|rrset_prev
operator|)
operator|->
name|dname
expr_stmt|;
operator|*
name|prev_dname_last
operator|=
name|dname
expr_stmt|;
operator|*
name|prev_dnamelen
operator|=
name|dnamelen
expr_stmt|;
operator|*
name|prev_type
operator|=
name|covtype
expr_stmt|;
operator|*
name|prev_dclass
operator|=
name|dclass
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|type
operator|!=
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
name|int
name|hasother
init|=
literal|0
decl_stmt|;
comment|/* find matching rrsig */
operator|*
name|hash
operator|=
name|pkt_hash_rrset_rest
argument_list|(
name|dname_h
argument_list|,
name|LDNS_RR_TYPE_RRSIG
argument_list|,
name|dclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|rrset_prev
operator|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
operator|*
name|hash
argument_list|,
literal|0
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|LDNS_RR_TYPE_RRSIG
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rrset_prev
operator|&&
name|rrset_has_sigover
argument_list|(
name|pkt
argument_list|,
operator|*
name|rrset_prev
argument_list|,
name|type
argument_list|,
operator|&
name|hasother
argument_list|)
condition|)
block|{
comment|/* yes! */
operator|*
name|prev_dname_first
operator|=
operator|(
operator|*
name|rrset_prev
operator|)
operator|->
name|dname
expr_stmt|;
operator|*
name|prev_dname_last
operator|=
name|dname
expr_stmt|;
operator|*
name|prev_dnamelen
operator|=
name|dnamelen
expr_stmt|;
operator|*
name|prev_type
operator|=
name|type
expr_stmt|;
operator|*
name|prev_dclass
operator|=
name|dclass
expr_stmt|;
operator|*
name|rrset_prev
operator|=
name|change_rrsig_rrset
argument_list|(
operator|*
name|rrset_prev
argument_list|,
name|msg
argument_list|,
name|pkt
argument_list|,
name|type
argument_list|,
operator|*
name|rrset_flags
argument_list|,
name|hasother
argument_list|,
name|section
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rrset_prev
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
block|}
operator|*
name|hash
operator|=
name|pkt_hash_rrset_rest
argument_list|(
name|dname_h
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|,
operator|*
name|rrset_flags
argument_list|)
expr_stmt|;
operator|*
name|rrset_prev
operator|=
name|msgparse_hashtable_lookup
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
operator|*
name|hash
argument_list|,
operator|*
name|rrset_flags
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rrset_prev
condition|)
operator|*
name|prev_dname_first
operator|=
operator|(
operator|*
name|rrset_prev
operator|)
operator|->
name|dname
expr_stmt|;
else|else
operator|*
name|prev_dname_first
operator|=
name|dname
expr_stmt|;
operator|*
name|prev_dname_last
operator|=
name|dname
expr_stmt|;
operator|*
name|prev_dnamelen
operator|=
name|dnamelen
expr_stmt|;
operator|*
name|prev_type
operator|=
name|type
expr_stmt|;
operator|*
name|prev_dclass
operator|=
name|dclass
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Parse query section.   * @param pkt: packet, position at call must be at start of query section.  *	at end position is after query section.  * @param msg: store results here.  * @return: 0 if OK, or rcode on error.  */
end_comment

begin_function
specifier|static
name|int
name|parse_query_section
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|->
name|qdcount
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|msg
operator|->
name|qdcount
operator|>
literal|1
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
name|log_assert
argument_list|(
name|msg
operator|->
name|qdcount
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
name|msg
operator|->
name|qname
operator|=
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|qname_len
operator|=
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
literal|2
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
name|msg
operator|->
name|qtype
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|msg
operator|->
name|qclass
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|get_rdf_size
parameter_list|(
name|sldns_rdf_type
name|rdf
parameter_list|)
block|{
switch|switch
condition|(
name|rdf
condition|)
block|{
case|case
name|LDNS_RDF_TYPE_CLASS
case|:
case|case
name|LDNS_RDF_TYPE_ALG
case|:
case|case
name|LDNS_RDF_TYPE_INT8
case|:
return|return
literal|1
return|;
break|break;
case|case
name|LDNS_RDF_TYPE_INT16
case|:
case|case
name|LDNS_RDF_TYPE_TYPE
case|:
case|case
name|LDNS_RDF_TYPE_CERT_ALG
case|:
return|return
literal|2
return|;
break|break;
case|case
name|LDNS_RDF_TYPE_INT32
case|:
case|case
name|LDNS_RDF_TYPE_TIME
case|:
case|case
name|LDNS_RDF_TYPE_A
case|:
case|case
name|LDNS_RDF_TYPE_PERIOD
case|:
return|return
literal|4
return|;
break|break;
case|case
name|LDNS_RDF_TYPE_TSIGTIME
case|:
return|return
literal|6
return|;
break|break;
case|case
name|LDNS_RDF_TYPE_AAAA
case|:
return|return
literal|16
return|;
break|break;
default|default:
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* add type above */
comment|/* only types that appear before a domain  * 			 * name are needed. rest is simply copied. */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** calculate the size of one rr */
end_comment

begin_function
specifier|static
name|int
name|calc_size
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|struct
name|rr_parse
modifier|*
name|rr
parameter_list|)
block|{
specifier|const
name|sldns_rr_descriptor
modifier|*
name|desc
decl_stmt|;
name|uint16_t
name|pkt_len
decl_stmt|;
comment|/* length of rr inside the packet */
name|rr
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
comment|/* the rdatalen */
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* skip ttl */
name|pkt_len
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|pkt_len
condition|)
return|return
literal|0
return|;
name|desc
operator|=
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
operator|&&
name|desc
operator|&&
name|desc
operator|->
name|_dname_count
operator|>
literal|0
condition|)
block|{
name|int
name|count
init|=
operator|(
name|int
operator|)
name|desc
operator|->
name|_dname_count
decl_stmt|;
name|int
name|rdf
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|oldpos
decl_stmt|;
comment|/* skip first part. */
while|while
condition|(
name|pkt_len
operator|>
literal|0
operator|&&
name|count
condition|)
block|{
switch|switch
condition|(
name|desc
operator|->
name|_wireformat
index|[
name|rdf
index|]
condition|)
block|{
case|case
name|LDNS_RDF_TYPE_DNAME
case|:
comment|/* decompress every domain name */
name|oldpos
operator|=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* malformed dname */
if|if
condition|(
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
operator|-
name|oldpos
operator|>
name|pkt_len
condition|)
return|return
literal|0
return|;
comment|/* dname exceeds rdata */
name|pkt_len
operator|-=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
operator|-
name|oldpos
expr_stmt|;
name|rr
operator|->
name|size
operator|+=
name|len
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LDNS_RDF_TYPE_STR
case|:
if|if
condition|(
name|pkt_len
operator|<
literal|1
condition|)
block|{
comment|/* NOTREACHED, due to 'while(>0)' */
return|return
literal|0
return|;
comment|/* len byte exceeds rdata */
block|}
name|len
operator|=
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|len
operator|=
name|get_rdf_size
argument_list|(
name|desc
operator|->
name|_wireformat
index|[
name|rdf
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|pkt_len
operator|<
name|len
condition|)
return|return
literal|0
return|;
comment|/* exceeds rdata */
name|pkt_len
operator|-=
name|len
expr_stmt|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|rr
operator|->
name|size
operator|+=
name|len
expr_stmt|;
block|}
name|rdf
operator|++
expr_stmt|;
block|}
block|}
comment|/* remaining rdata */
name|rr
operator|->
name|size
operator|+=
name|pkt_len
expr_stmt|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
name|pkt_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** skip rr ttl and rdata */
end_comment

begin_function
specifier|static
name|int
name|skip_ttl_rdata
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|uint16_t
name|rdatalen
decl_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|6
condition|)
comment|/* ttl + rdatalen */
return|return
literal|0
return|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ttl */
name|rdatalen
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|rdatalen
condition|)
return|return
literal|0
return|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
name|rdatalen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** see if RRSIG is a duplicate of another */
end_comment

begin_function
specifier|static
name|int
name|sig_is_double
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|uint8_t
modifier|*
name|ttldata
parameter_list|)
block|{
name|uint16_t
name|rlen
decl_stmt|,
name|siglen
decl_stmt|;
name|size_t
name|pos
init|=
name|sldns_buffer_position
argument_list|(
name|pkt
argument_list|)
decl_stmt|;
name|struct
name|rr_parse
modifier|*
name|sig
decl_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|6
condition|)
return|return
literal|0
return|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ttl */
name|rlen
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|rlen
condition|)
block|{
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_set_position
argument_list|(
name|pkt
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|sig
operator|=
name|rrset
operator|->
name|rrsig_first
expr_stmt|;
while|while
condition|(
name|sig
condition|)
block|{
comment|/* check if rdatalen is same */
name|memmove
argument_list|(
operator|&
name|siglen
argument_list|,
name|sig
operator|->
name|ttl_data
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|siglen
argument_list|)
argument_list|)
expr_stmt|;
name|siglen
operator|=
name|ntohs
argument_list|(
name|siglen
argument_list|)
expr_stmt|;
comment|/* checks if data in packet is exactly the same, this means 		 * also dname in rdata is the same, but rrsig is not allowed 		 * to have compressed dnames anyway. If it is compressed anyway 		 * it will lead to duplicate rrs for qtype=RRSIG. (or ANY). 		 * 		 * Cannot use sig->size because size of the other one is not  		 * calculated yet. 		 */
if|if
condition|(
name|siglen
operator|==
name|rlen
condition|)
block|{
if|if
condition|(
name|siglen
operator|>
literal|0
operator|&&
name|memcmp
argument_list|(
name|sig
operator|->
name|ttl_data
operator|+
literal|6
argument_list|,
name|ttldata
operator|+
literal|6
argument_list|,
name|siglen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* same! */
return|return
literal|1
return|;
block|}
block|}
name|sig
operator|=
name|sig
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Add rr (from packet here) to rrset, skips rr */
end_comment

begin_function
specifier|static
name|int
name|add_rr_to_rrset
parameter_list|(
name|struct
name|rrset_parse
modifier|*
name|rrset
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|sldns_pkt_section
name|section
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|rr_parse
modifier|*
name|rr
decl_stmt|;
comment|/* check section of rrset. */
if|if
condition|(
name|rrset
operator|->
name|section
operator|!=
name|section
operator|&&
name|type
operator|!=
name|LDNS_RR_TYPE_RRSIG
operator|&&
name|rrset
operator|->
name|type
operator|!=
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
comment|/* silently drop it - we drop the last part, since 		 * trust in rr data depends on the section it is in.  		 * the less trustworthy part is discarded.  		 * also the last part is more likely to be incomplete. 		 * RFC 2181: must put RRset only once in response. */
comment|/* 		verbose(VERB_QUERY, "Packet contains rrset data in " 			"multiple sections, dropped last part."); 		log_buf(VERB_QUERY, "packet was", pkt); 		*/
comment|/* forwards */
if|if
condition|(
operator|!
name|skip_ttl_rdata
argument_list|(
name|pkt
argument_list|)
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|msg
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|||
name|msg
operator|->
name|qtype
operator|==
name|LDNS_RR_TYPE_ANY
operator|)
operator|&&
name|sig_is_double
argument_list|(
name|pkt
argument_list|,
name|rrset
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|skip_ttl_rdata
argument_list|(
name|pkt
argument_list|)
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
return|return
literal|0
return|;
block|}
comment|/* create rr */
if|if
condition|(
operator|!
operator|(
name|rr
operator|=
operator|(
expr|struct
name|rr_parse
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|LDNS_RCODE_SERVFAIL
return|;
name|rr
operator|->
name|outside_packet
operator|=
literal|0
expr_stmt|;
name|rr
operator|->
name|ttl_data
operator|=
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|rr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|&&
name|rrset
operator|->
name|type
operator|!=
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rrsig_last
condition|)
name|rrset
operator|->
name|rrsig_last
operator|->
name|next
operator|=
name|rr
expr_stmt|;
else|else
name|rrset
operator|->
name|rrsig_first
operator|=
name|rr
expr_stmt|;
name|rrset
operator|->
name|rrsig_last
operator|=
name|rr
expr_stmt|;
name|rrset
operator|->
name|rrsig_count
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_last
condition|)
name|rrset
operator|->
name|rr_last
operator|->
name|next
operator|=
name|rr
expr_stmt|;
else|else
name|rrset
operator|->
name|rr_first
operator|=
name|rr
expr_stmt|;
name|rrset
operator|->
name|rr_last
operator|=
name|rr
expr_stmt|;
name|rrset
operator|->
name|rr_count
operator|++
expr_stmt|;
block|}
comment|/* calc decompressed size */
if|if
condition|(
operator|!
name|calc_size
argument_list|(
name|pkt
argument_list|,
name|type
argument_list|,
name|rr
argument_list|)
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
name|rrset
operator|->
name|size
operator|+=
name|rr
operator|->
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Parse packet RR section, for answer, authority and additional sections.   * @param pkt: packet, position at call must be at start of section.  *	at end position is after section.  * @param msg: store results here.  * @param region: how to alloc results.  * @param section: section enum.  * @param num_rrs: how many rrs are in the section.  * @param num_rrsets: returns number of rrsets in the section.  * @return: 0 if OK, or rcode on error.  */
end_comment

begin_function
specifier|static
name|int
name|parse_section
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|sldns_pkt_section
name|section
parameter_list|,
name|uint16_t
name|num_rrs
parameter_list|,
name|size_t
modifier|*
name|num_rrsets
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|dname
decl_stmt|,
modifier|*
name|prev_dname_f
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev_dname_l
init|=
name|NULL
decl_stmt|;
name|size_t
name|dnamelen
decl_stmt|,
name|prev_dnamelen
init|=
literal|0
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|prev_type
init|=
literal|0
decl_stmt|;
name|uint16_t
name|dclass
decl_stmt|,
name|prev_dclass
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rrset_flags
init|=
literal|0
decl_stmt|;
name|hashvalue_t
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|rrset
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|num_rrs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rrs
condition|;
name|i
operator|++
control|)
block|{
comment|/* parse this RR. */
name|dname
operator|=
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dnamelen
operator|=
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|10
condition|)
comment|/* type, class, ttl, len */
return|return
name|LDNS_RCODE_FORMERR
return|;
name|type
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sldns_buffer_read
argument_list|(
name|pkt
argument_list|,
operator|&
name|dclass
argument_list|,
sizeof|sizeof
argument_list|(
name|dclass
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
comment|/* debug show what is being parsed. */
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
name|uint16_t
name|t
decl_stmt|;
if|if
condition|(
name|pkt_rrsig_covered
argument_list|(
name|pkt
argument_list|,
name|sldns_buffer_current
argument_list|(
name|pkt
argument_list|)
argument_list|,
operator|&
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parse of %s(%d) [%s(%d)]"
argument_list|,
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
condition|?
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
operator|->
name|_name
else|:
literal|"??"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|,
name|sldns_rr_descript
argument_list|(
name|t
argument_list|)
condition|?
name|sldns_rr_descript
argument_list|(
name|t
argument_list|)
operator|->
name|_name
else|:
literal|"??"
argument_list|,
operator|(
name|int
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parse of %s(%d)"
argument_list|,
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
condition|?
name|sldns_rr_descript
argument_list|(
name|type
argument_list|)
operator|->
name|_name
else|:
literal|"??"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s(%d) "
argument_list|,
name|sldns_lookup_by_id
argument_list|(
name|sldns_rr_classes
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|dclass
argument_list|)
argument_list|)
condition|?
name|sldns_lookup_by_id
argument_list|(
name|sldns_rr_classes
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|dclass
argument_list|)
argument_list|)
operator|->
name|name
else|:
literal|"??"
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|dclass
argument_list|)
argument_list|)
expr_stmt|;
name|dname_print
argument_list|(
name|stderr
argument_list|,
name|pkt
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* see if it is part of an existing RR set */
if|if
condition|(
operator|!
name|find_rrset
argument_list|(
name|msg
argument_list|,
name|pkt
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|,
operator|&
name|hash
argument_list|,
operator|&
name|rrset_flags
argument_list|,
operator|&
name|prev_dname_f
argument_list|,
operator|&
name|prev_dname_l
argument_list|,
operator|&
name|prev_dnamelen
argument_list|,
operator|&
name|prev_type
argument_list|,
operator|&
name|prev_dclass
argument_list|,
operator|&
name|rrset
argument_list|,
name|section
argument_list|,
name|region
argument_list|)
condition|)
return|return
name|LDNS_RCODE_SERVFAIL
return|;
if|if
condition|(
operator|!
name|rrset
condition|)
block|{
comment|/* it is a new RR set. hash&flags already calculated.*/
operator|(
operator|*
name|num_rrsets
operator|)
operator|++
expr_stmt|;
name|rrset
operator|=
name|new_rrset
argument_list|(
name|msg
argument_list|,
name|dname
argument_list|,
name|dnamelen
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|,
name|hash
argument_list|,
name|rrset_flags
argument_list|,
name|section
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrset
condition|)
return|return
name|LDNS_RCODE_SERVFAIL
return|;
block|}
elseif|else
if|if
condition|(
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"is part of existing: "
argument_list|)
expr_stmt|;
name|dname_print
argument_list|(
name|stderr
argument_list|,
name|pkt
argument_list|,
name|rrset
operator|->
name|dname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type %s(%d)\n"
argument_list|,
name|sldns_rr_descript
argument_list|(
name|rrset
operator|->
name|type
argument_list|)
condition|?
name|sldns_rr_descript
argument_list|(
name|rrset
operator|->
name|type
argument_list|)
operator|->
name|_name
else|:
literal|"??"
argument_list|,
operator|(
name|int
operator|)
name|rrset
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* add to rrset. */
if|if
condition|(
operator|(
name|r
operator|=
name|add_rr_to_rrset
argument_list|(
name|rrset
argument_list|,
name|pkt
argument_list|,
name|msg
argument_list|,
name|region
argument_list|,
name|section
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|parse_packet
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|LDNS_HEADER_SIZE
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
comment|/* read the header */
name|sldns_buffer_read
argument_list|(
name|pkt
argument_list|,
operator|&
name|msg
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|flags
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|msg
operator|->
name|qdcount
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|msg
operator|->
name|ancount
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|msg
operator|->
name|nscount
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|msg
operator|->
name|arcount
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|qdcount
operator|>
literal|1
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_query_section
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_section
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|region
argument_list|,
name|LDNS_SECTION_ANSWER
argument_list|,
name|msg
operator|->
name|ancount
argument_list|,
operator|&
name|msg
operator|->
name|an_rrsets
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_section
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|region
argument_list|,
name|LDNS_SECTION_AUTHORITY
argument_list|,
name|msg
operator|->
name|nscount
argument_list|,
operator|&
name|msg
operator|->
name|ns_rrsets
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|==
literal|0
operator|&&
name|msg
operator|->
name|arcount
operator|==
literal|1
condition|)
block|{
comment|/* BIND accepts leniently that an EDNS record is missing. 		 * so, we do too. */
block|}
elseif|else
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_section
argument_list|(
name|pkt
argument_list|,
name|msg
argument_list|,
name|region
argument_list|,
name|LDNS_SECTION_ADDITIONAL
argument_list|,
name|msg
operator|->
name|arcount
argument_list|,
operator|&
name|msg
operator|->
name|ar_rrsets
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* if(sldns_buffer_remaining(pkt)> 0) { */
comment|/* there is spurious data at end of packet. ignore */
comment|/* } */
name|msg
operator|->
name|rrset_count
operator|=
name|msg
operator|->
name|an_rrsets
operator|+
name|msg
operator|->
name|ns_rrsets
operator|+
name|msg
operator|->
name|ar_rrsets
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|parse_extract_edns
parameter_list|(
name|struct
name|msg_parse
modifier|*
name|msg
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
name|struct
name|rrset_parse
modifier|*
name|rrset
init|=
name|msg
operator|->
name|rrset_first
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|rrset_parse
modifier|*
name|found_prev
init|=
literal|0
decl_stmt|;
comment|/* since the class encodes the UDP size, we cannot use hash table to 	 * find the EDNS OPT record. Scan the packet. */
while|while
condition|(
name|rrset
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_OPT
condition|)
block|{
comment|/* only one OPT RR allowed. */
if|if
condition|(
name|found
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
comment|/* found it! */
name|found_prev
operator|=
name|prev
expr_stmt|;
name|found
operator|=
name|rrset
expr_stmt|;
block|}
name|prev
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rrset_all_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|memset
argument_list|(
name|edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|edns
argument_list|)
argument_list|)
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
literal|512
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check the found RRset */
comment|/* most lenient check possible. ignore dname, use last opt */
if|if
condition|(
name|found
operator|->
name|section
operator|!=
name|LDNS_SECTION_ADDITIONAL
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
name|found
operator|->
name|rr_count
operator|==
literal|0
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
literal|0
condition|)
block|{
comment|/* strict checking of dname and RRcount */
if|if
condition|(
name|found
operator|->
name|dname_len
operator|!=
literal|1
operator|||
operator|!
name|found
operator|->
name|dname
operator|||
name|found
operator|->
name|dname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
name|found
operator|->
name|rr_count
operator|!=
literal|1
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
block|}
name|log_assert
argument_list|(
name|found
operator|->
name|rr_first
operator|&&
name|found
operator|->
name|rr_last
argument_list|)
expr_stmt|;
comment|/* remove from packet */
if|if
condition|(
name|found_prev
condition|)
name|found_prev
operator|->
name|rrset_all_next
operator|=
name|found
operator|->
name|rrset_all_next
expr_stmt|;
else|else
name|msg
operator|->
name|rrset_first
operator|=
name|found
operator|->
name|rrset_all_next
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|msg
operator|->
name|rrset_last
condition|)
name|msg
operator|->
name|rrset_last
operator|=
name|found_prev
expr_stmt|;
name|msg
operator|->
name|arcount
operator|--
expr_stmt|;
name|msg
operator|->
name|ar_rrsets
operator|--
expr_stmt|;
name|msg
operator|->
name|rrset_count
operator|--
expr_stmt|;
comment|/* take the data ! */
name|edns
operator|->
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
name|found
operator|->
name|rr_last
operator|->
name|ttl_data
index|[
literal|0
index|]
expr_stmt|;
name|edns
operator|->
name|edns_version
operator|=
name|found
operator|->
name|rr_last
operator|->
name|ttl_data
index|[
literal|1
index|]
expr_stmt|;
name|edns
operator|->
name|bits
operator|=
name|sldns_read_uint16
argument_list|(
operator|&
name|found
operator|->
name|rr_last
operator|->
name|ttl_data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|ntohs
argument_list|(
name|found
operator|->
name|rrset_class
argument_list|)
expr_stmt|;
comment|/* ignore rdata and rrsigs */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|parse_edns_from_pkt
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
name|log_assert
argument_list|(
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|LDNS_ANCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|LDNS_NSCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* check edns section is present */
if|if
condition|(
name|LDNS_ARCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
return|return
name|LDNS_RCODE_FORMERR
return|;
block|}
if|if
condition|(
name|LDNS_ARCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|edns
argument_list|)
argument_list|)
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
literal|512
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* domain name must be the root of length 1. */
if|if
condition|(
name|pkt_dname_len
argument_list|(
name|pkt
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|10
condition|)
comment|/* type, class, ttl, rdatalen */
return|return
name|LDNS_RCODE_FORMERR
return|;
if|if
condition|(
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
operator|!=
name|LDNS_RR_TYPE_OPT
condition|)
return|return
name|LDNS_RCODE_FORMERR
return|;
name|edns
operator|->
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* class is udp size */
name|edns
operator|->
name|ext_rcode
operator|=
name|sldns_buffer_read_u8
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* ttl used for bits */
name|edns
operator|->
name|edns_version
operator|=
name|sldns_buffer_read_u8
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|edns
operator|->
name|bits
operator|=
name|sldns_buffer_read_u16
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* ignore rdata and rrsigs */
return|return
literal|0
return|;
block|}
end_function

end_unit

