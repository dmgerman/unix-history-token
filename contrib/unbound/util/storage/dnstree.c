begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/storage/dnstree.c - support for rbtree types suitable for DNS code.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains structures combining types and functions to  * manipulate those structures that help building DNS lookup trees.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/dnstree.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_function
name|int
name|name_tree_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|struct
name|name_tree_node
modifier|*
name|x
init|=
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|k1
decl_stmt|;
name|struct
name|name_tree_node
modifier|*
name|y
init|=
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|k2
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|dclass
operator|!=
name|y
operator|->
name|dclass
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|dclass
operator|<
name|y
operator|->
name|dclass
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|dname_lab_cmp
argument_list|(
name|x
operator|->
name|name
argument_list|,
name|x
operator|->
name|labs
argument_list|,
name|y
operator|->
name|name
argument_list|,
name|y
operator|->
name|labs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|addr_tree_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|struct
name|addr_tree_node
modifier|*
name|n1
init|=
operator|(
expr|struct
name|addr_tree_node
operator|*
operator|)
name|k1
decl_stmt|;
name|struct
name|addr_tree_node
modifier|*
name|n2
init|=
operator|(
expr|struct
name|addr_tree_node
operator|*
operator|)
name|k2
decl_stmt|;
name|int
name|r
init|=
name|sockaddr_cmp_addr
argument_list|(
operator|&
name|n1
operator|->
name|addr
argument_list|,
name|n1
operator|->
name|addrlen
argument_list|,
operator|&
name|n2
operator|->
name|addr
argument_list|,
name|n2
operator|->
name|addrlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|n1
operator|->
name|net
operator|<
name|n2
operator|->
name|net
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n1
operator|->
name|net
operator|>
name|n2
operator|->
name|net
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|name_tree_init
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|)
block|{
name|rbtree_init
argument_list|(
name|tree
argument_list|,
operator|&
name|name_tree_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|addr_tree_init
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|)
block|{
name|rbtree_init
argument_list|(
name|tree
argument_list|,
operator|&
name|addr_tree_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|name_tree_insert
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|struct
name|name_tree_node
modifier|*
name|node
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|node
operator|->
name|node
operator|.
name|key
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|node
operator|->
name|labs
operator|=
name|labs
expr_stmt|;
name|node
operator|->
name|dclass
operator|=
name|dclass
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
return|return
name|rbtree_insert
argument_list|(
name|tree
argument_list|,
operator|&
name|node
operator|->
name|node
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|addr_tree_insert
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|struct
name|addr_tree_node
modifier|*
name|node
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|net
parameter_list|)
block|{
name|node
operator|->
name|node
operator|.
name|key
operator|=
name|node
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|node
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|node
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|node
operator|->
name|net
operator|=
name|net
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
return|return
name|rbtree_insert
argument_list|(
name|tree
argument_list|,
operator|&
name|node
operator|->
name|node
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|addr_tree_init_parents
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|addr_tree_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|m
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|node
argument_list|,
argument|struct addr_tree_node*
argument_list|,
argument|tree
argument_list|)
block|{
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
name|prev
operator|->
name|addrlen
operator|!=
name|node
operator|->
name|addrlen
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|addr_in_common
argument_list|(
operator|&
name|prev
operator|->
name|addr
argument_list|,
name|prev
operator|->
name|net
argument_list|,
operator|&
name|node
operator|->
name|addr
argument_list|,
name|node
operator|->
name|net
argument_list|,
name|node
operator|->
name|addrlen
argument_list|)
expr_stmt|;
comment|/* sort order like: ::/0, 1::/2, 1::/4, ... 2::/2 */
comment|/* find the previous, or parent-parent-parent */
for|for
control|(
name|p
operator|=
name|prev
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
if|if
condition|(
name|p
operator|->
name|net
operator|<=
name|m
condition|)
block|{
comment|/* ==: since prev matched m, this is closest*/
comment|/*<: prev matches more, but is not a parent, 				 * this one is a (grand)parent */
name|node
operator|->
name|parent
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|name_tree_init_parents
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|name_tree_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|m
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|node
argument_list|,
argument|struct name_tree_node*
argument_list|,
argument|tree
argument_list|)
block|{
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
name|prev
operator|->
name|dclass
operator|!=
name|node
operator|->
name|dclass
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|prev
operator|->
name|name
argument_list|,
name|prev
operator|->
name|labs
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|labs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* we know prev is smaller */
comment|/* sort order like: . com. bla.com. zwb.com. net. */
comment|/* find the previous, or parent-parent-parent */
for|for
control|(
name|p
operator|=
name|prev
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
if|if
condition|(
name|p
operator|->
name|labs
operator|<=
name|m
condition|)
block|{
comment|/* ==: since prev matched m, this is closest*/
comment|/*<: prev matches more, but is not a parent, 				 * this one is a (grand)parent */
name|node
operator|->
name|parent
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|name_tree_node
modifier|*
name|name_tree_find
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|name_tree_node
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|key
operator|.
name|labs
operator|=
name|labs
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|dclass
expr_stmt|;
return|return
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|rbtree_search
argument_list|(
name|tree
argument_list|,
operator|&
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|name_tree_node
modifier|*
name|name_tree_lookup
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|name_tree_node
modifier|*
name|result
decl_stmt|;
name|struct
name|name_tree_node
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|key
operator|.
name|labs
operator|=
name|labs
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|dclass
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact */
name|result
operator|=
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|res
expr_stmt|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|dclass
operator|!=
name|dclass
condition|)
return|return
name|NULL
return|;
comment|/* count number of labels matched */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|result
operator|->
name|labs
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|labs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until qname is subdomain of stub */
if|if
condition|(
name|result
operator|->
name|labs
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|struct
name|addr_tree_node
modifier|*
name|addr_tree_lookup
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|addr_tree_node
modifier|*
name|result
decl_stmt|;
name|struct
name|addr_tree_node
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|key
operator|.
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|key
operator|.
name|net
operator|=
operator|(
name|addr_is_ip6
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|?
literal|128
else|:
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact */
return|return
operator|(
expr|struct
name|addr_tree_node
operator|*
operator|)
name|res
return|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|addr_tree_node
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|addrlen
operator|!=
name|addrlen
condition|)
return|return
literal|0
return|;
comment|/* count number of bits matched */
name|m
operator|=
name|addr_in_common
argument_list|(
operator|&
name|result
operator|->
name|addr
argument_list|,
name|result
operator|->
name|net
argument_list|,
name|addr
argument_list|,
name|key
operator|.
name|net
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until addr is inside netblock */
if|if
condition|(
name|result
operator|->
name|net
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|struct
name|addr_tree_node
modifier|*
name|addr_tree_find
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|net
parameter_list|)
block|{
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|addr_tree_node
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|key
operator|.
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|key
operator|.
name|net
operator|=
name|net
expr_stmt|;
name|res
operator|=
name|rbtree_search
argument_list|(
name|tree
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|addr_tree_node
operator|*
operator|)
name|res
return|;
block|}
end_function

begin_function
name|int
name|name_tree_next_root
parameter_list|(
name|rbtree_t
modifier|*
name|tree
parameter_list|,
name|uint16_t
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|name_tree_node
name|key
decl_stmt|;
name|rbnode_t
modifier|*
name|n
decl_stmt|;
name|struct
name|name_tree_node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|dclass
operator|==
literal|0
condition|)
block|{
comment|/* first root item is first item in tree */
name|n
operator|=
name|rbtree_first
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|RBTREE_NULL
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|dname_is_root
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* root not first item? search for higher items */
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
operator|+
literal|1
expr_stmt|;
return|return
name|name_tree_next_root
argument_list|(
name|tree
argument_list|,
name|dclass
argument_list|)
return|;
block|}
comment|/* find class n in tree, we may get a direct hit, or if we don't 	 * this is the last item of the previous class so rbtree_next() takes 	 * us to the next root (if any) */
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
operator|(
name|uint8_t
operator|*
operator|)
literal|"\000"
expr_stmt|;
name|key
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|key
operator|.
name|labs
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
operator|*
name|dclass
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
comment|/* exact */
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* smaller element */
if|if
condition|(
operator|!
name|n
operator|||
name|n
operator|==
name|RBTREE_NULL
condition|)
return|return
literal|0
return|;
comment|/* nothing found */
name|n
operator|=
name|rbtree_next
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|RBTREE_NULL
condition|)
return|return
literal|0
return|;
comment|/* no higher */
name|p
operator|=
operator|(
expr|struct
name|name_tree_node
operator|*
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|dname_is_root
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* not a root node, return next higher item */
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
operator|+
literal|1
expr_stmt|;
return|return
name|name_tree_next_root
argument_list|(
name|tree
argument_list|,
name|dclass
argument_list|)
return|;
block|}
block|}
end_function

end_unit

