begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/alloc.c - memory allocation service.   *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains memory allocation functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_comment
comment|/** custom size of cached regional blocks */
end_comment

begin_define
define|#
directive|define
name|ALLOC_REG_SIZE
value|16384
end_define

begin_comment
comment|/** number of bits for ID part of uint64, rest for number of threads. */
end_comment

begin_define
define|#
directive|define
name|THRNUM_SHIFT
value|48
end_define

begin_comment
comment|/* for 65k threads, 2^48 rrsets per thr. */
end_comment

begin_comment
comment|/** setup new special type */
end_comment

begin_function
specifier|static
name|void
name|alloc_setup_special
parameter_list|(
name|alloc_special_t
modifier|*
name|t
parameter_list|)
block|{
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|lock_rw_init
argument_list|(
operator|&
name|t
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|t
operator|->
name|entry
operator|.
name|key
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/** prealloc some entries in the cache. To minimize contention.   * Result is 1 lock per alloc_max newly created entries.  * @param alloc: the structure to fill up.  */
end_comment

begin_function
specifier|static
name|void
name|prealloc_setup
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|alloc_special_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALLOC_SPECIAL_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
name|alloc_special_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|alloc_special_t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"prealloc: out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|alloc_setup_special
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|alloc_set_special_next
argument_list|(
name|p
argument_list|,
name|alloc
operator|->
name|quar
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|quar
operator|=
name|p
expr_stmt|;
name|alloc
operator|->
name|num_quar
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** prealloc region blocks */
end_comment

begin_function
specifier|static
name|void
name|prealloc_blocks
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|regional
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|regional_create_custom
argument_list|(
name|ALLOC_REG_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|log_err
argument_list|(
literal|"prealloc blocks: out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|->
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|alloc
operator|->
name|reg_list
expr_stmt|;
name|alloc
operator|->
name|reg_list
operator|=
name|r
expr_stmt|;
name|alloc
operator|->
name|num_reg_blocks
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|alloc_init
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|super
parameter_list|,
name|int
name|thread_num
parameter_list|)
block|{
name|memset
argument_list|(
name|alloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alloc
argument_list|)
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|super
operator|=
name|super
expr_stmt|;
name|alloc
operator|->
name|thread_num
operator|=
name|thread_num
expr_stmt|;
name|alloc
operator|->
name|next_id
operator|=
operator|(
name|uint64_t
operator|)
name|thread_num
expr_stmt|;
comment|/* in steps, so that type */
name|alloc
operator|->
name|next_id
operator|<<=
name|THRNUM_SHIFT
expr_stmt|;
comment|/* of *_id is used. */
name|alloc
operator|->
name|last_id
operator|=
literal|1
expr_stmt|;
comment|/* so no 64bit constants, */
name|alloc
operator|->
name|last_id
operator|<<=
name|THRNUM_SHIFT
expr_stmt|;
comment|/* or implicit 'int' ops. */
name|alloc
operator|->
name|last_id
operator|-=
literal|1
expr_stmt|;
comment|/* for compiler portability. */
name|alloc
operator|->
name|last_id
operator||=
name|alloc
operator|->
name|next_id
expr_stmt|;
name|alloc
operator|->
name|next_id
operator|+=
literal|1
expr_stmt|;
comment|/* because id=0 is special. */
name|alloc
operator|->
name|max_reg_blocks
operator|=
literal|100
expr_stmt|;
name|alloc
operator|->
name|num_reg_blocks
operator|=
literal|0
expr_stmt|;
name|alloc
operator|->
name|reg_list
operator|=
name|NULL
expr_stmt|;
name|alloc
operator|->
name|cleanup
operator|=
name|NULL
expr_stmt|;
name|alloc
operator|->
name|cleanup_arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|alloc
operator|->
name|super
condition|)
name|prealloc_blocks
argument_list|(
name|alloc
argument_list|,
name|alloc
operator|->
name|max_reg_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alloc
operator|->
name|super
condition|)
block|{
name|lock_quick_init
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|,
name|alloc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alloc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|alloc_clear
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|alloc_special_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|regional
modifier|*
name|r
decl_stmt|,
modifier|*
name|nr
decl_stmt|;
if|if
condition|(
operator|!
name|alloc
condition|)
return|return;
if|if
condition|(
operator|!
name|alloc
operator|->
name|super
condition|)
block|{
name|lock_quick_destroy
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloc
operator|->
name|super
operator|&&
name|alloc
operator|->
name|quar
condition|)
block|{
comment|/* push entire list into super */
name|p
operator|=
name|alloc
operator|->
name|quar
expr_stmt|;
while|while
condition|(
name|alloc_special_next
argument_list|(
name|p
argument_list|)
condition|)
comment|/* find last */
name|p
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|alloc
operator|->
name|super
operator|->
name|lock
argument_list|)
expr_stmt|;
name|alloc_set_special_next
argument_list|(
name|p
argument_list|,
name|alloc
operator|->
name|super
operator|->
name|quar
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|super
operator|->
name|quar
operator|=
name|alloc
operator|->
name|quar
expr_stmt|;
name|alloc
operator|->
name|super
operator|->
name|num_quar
operator|+=
name|alloc
operator|->
name|num_quar
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|alloc
operator|->
name|super
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* free */
name|p
operator|=
name|alloc
operator|->
name|quar
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* deinit special type */
name|lock_rw_destroy
argument_list|(
operator|&
name|p
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
name|alloc
operator|->
name|quar
operator|=
literal|0
expr_stmt|;
name|alloc
operator|->
name|num_quar
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|alloc
operator|->
name|reg_list
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|nr
operator|=
operator|(
expr|struct
name|regional
operator|*
operator|)
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|nr
expr_stmt|;
block|}
name|alloc
operator|->
name|reg_list
operator|=
name|NULL
expr_stmt|;
name|alloc
operator|->
name|num_reg_blocks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|alloc_get_id
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|uint64_t
name|id
init|=
name|alloc
operator|->
name|next_id
operator|++
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|alloc
operator|->
name|last_id
condition|)
block|{
name|log_warn
argument_list|(
literal|"rrset alloc: out of 64bit ids. Clearing cache."
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_alloc_cleanup
argument_list|(
name|alloc
operator|->
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|alloc
operator|->
name|cleanup
call|)
argument_list|(
name|alloc
operator|->
name|cleanup_arg
argument_list|)
expr_stmt|;
comment|/* start back at first number */
comment|/* like in alloc_init*/
name|alloc
operator|->
name|next_id
operator|=
operator|(
name|uint64_t
operator|)
name|alloc
operator|->
name|thread_num
expr_stmt|;
name|alloc
operator|->
name|next_id
operator|<<=
name|THRNUM_SHIFT
expr_stmt|;
comment|/* in steps for comp. */
name|alloc
operator|->
name|next_id
operator|+=
literal|1
expr_stmt|;
comment|/* portability. */
comment|/* and generate new and safe id */
name|id
operator|=
name|alloc
operator|->
name|next_id
operator|++
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_function
name|alloc_special_t
modifier|*
name|alloc_special_obtain
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|alloc_special_t
modifier|*
name|p
decl_stmt|;
name|log_assert
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
comment|/* see if in local cache */
if|if
condition|(
name|alloc
operator|->
name|quar
condition|)
block|{
name|p
operator|=
name|alloc
operator|->
name|quar
expr_stmt|;
name|alloc
operator|->
name|quar
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|num_quar
operator|--
expr_stmt|;
name|p
operator|->
name|id
operator|=
name|alloc_get_id
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* see if in global cache */
if|if
condition|(
name|alloc
operator|->
name|super
condition|)
block|{
comment|/* could maybe grab alloc_max/2 entries in one go, 		 * but really, isn't that just as fast as this code? */
name|lock_quick_lock
argument_list|(
operator|&
name|alloc
operator|->
name|super
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|alloc
operator|->
name|super
operator|->
name|quar
operator|)
condition|)
block|{
name|alloc
operator|->
name|super
operator|->
name|quar
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|super
operator|->
name|num_quar
operator|--
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|alloc
operator|->
name|super
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|id
operator|=
name|alloc_get_id
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
comment|/* allocate new */
name|prealloc_setup
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
name|alloc_special_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|alloc_special_t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"alloc_special_obtain: out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|alloc_setup_special
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|id
operator|=
name|alloc_get_id
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/** push mem and some more items to the super */
end_comment

begin_function
specifier|static
name|void
name|pushintosuper
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|alloc_special_t
modifier|*
name|mem
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|alloc_special_t
modifier|*
name|p
init|=
name|alloc
operator|->
name|quar
decl_stmt|;
name|log_assert
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|alloc
operator|&&
name|alloc
operator|->
name|super
operator|&&
name|alloc
operator|->
name|num_quar
operator|>=
name|ALLOC_SPECIAL_MAX
argument_list|)
expr_stmt|;
comment|/* push ALLOC_SPECIAL_MAX/2 after mem */
name|alloc_set_special_next
argument_list|(
name|mem
argument_list|,
name|alloc
operator|->
name|quar
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ALLOC_SPECIAL_MAX
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|alloc
operator|->
name|quar
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|num_quar
operator|-=
name|ALLOC_SPECIAL_MAX
operator|/
literal|2
expr_stmt|;
comment|/* dump mem+list into the super quar list */
name|lock_quick_lock
argument_list|(
operator|&
name|alloc
operator|->
name|super
operator|->
name|lock
argument_list|)
expr_stmt|;
name|alloc_set_special_next
argument_list|(
name|p
argument_list|,
name|alloc
operator|->
name|super
operator|->
name|quar
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|super
operator|->
name|quar
operator|=
name|mem
expr_stmt|;
name|alloc
operator|->
name|super
operator|->
name|num_quar
operator|+=
name|ALLOC_SPECIAL_MAX
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|alloc
operator|->
name|super
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* so 1 lock per mem+alloc/2 deletes */
block|}
end_function

begin_function
name|void
name|alloc_special_release
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|alloc_special_t
modifier|*
name|mem
parameter_list|)
block|{
name|log_assert
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
return|return;
if|if
condition|(
operator|!
name|alloc
operator|->
name|super
condition|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* superalloc needs locking */
block|}
name|alloc_special_clean
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc
operator|->
name|super
operator|&&
name|alloc
operator|->
name|num_quar
operator|>=
name|ALLOC_SPECIAL_MAX
condition|)
block|{
comment|/* push it to the super structure */
name|pushintosuper
argument_list|(
name|alloc
argument_list|,
name|mem
argument_list|)
expr_stmt|;
return|return;
block|}
name|alloc_set_special_next
argument_list|(
name|mem
argument_list|,
name|alloc
operator|->
name|quar
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|quar
operator|=
name|mem
expr_stmt|;
name|alloc
operator|->
name|num_quar
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|alloc
operator|->
name|super
condition|)
block|{
name|lock_quick_unlock
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|alloc_stats
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|log_info
argument_list|(
literal|"%salloc: %d in cache, %d blocks."
argument_list|,
name|alloc
operator|->
name|super
condition|?
literal|""
else|:
literal|"sup"
argument_list|,
operator|(
name|int
operator|)
name|alloc
operator|->
name|num_quar
argument_list|,
operator|(
name|int
operator|)
name|alloc
operator|->
name|num_reg_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|alloc_get_mem
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|alloc_special_t
modifier|*
name|p
decl_stmt|;
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
operator|*
name|alloc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alloc
operator|->
name|super
condition|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* superalloc needs locking */
block|}
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|alloc_special_t
argument_list|)
operator|*
name|alloc
operator|->
name|num_quar
expr_stmt|;
for|for
control|(
name|p
operator|=
name|alloc
operator|->
name|quar
init|;
name|p
condition|;
name|p
operator|=
name|alloc_special_next
argument_list|(
name|p
argument_list|)
control|)
block|{
name|s
operator|+=
name|lock_get_mem
argument_list|(
operator|&
name|p
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|alloc
operator|->
name|num_reg_blocks
operator|*
name|ALLOC_REG_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|alloc
operator|->
name|super
condition|)
block|{
name|lock_quick_unlock
argument_list|(
operator|&
name|alloc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|struct
name|regional
modifier|*
name|alloc_reg_obtain
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
if|if
condition|(
name|alloc
operator|->
name|num_reg_blocks
operator|>
literal|0
condition|)
block|{
name|struct
name|regional
modifier|*
name|r
init|=
name|alloc
operator|->
name|reg_list
decl_stmt|;
name|alloc
operator|->
name|reg_list
operator|=
operator|(
expr|struct
name|regional
operator|*
operator|)
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|alloc
operator|->
name|num_reg_blocks
operator|--
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
name|regional_create_custom
argument_list|(
name|ALLOC_REG_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|alloc_reg_release
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|struct
name|regional
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|alloc
operator|->
name|num_reg_blocks
operator|>=
name|alloc
operator|->
name|max_reg_blocks
condition|)
block|{
name|regional_destroy
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|r
condition|)
return|return;
name|regional_free_all
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|r
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|alloc
operator|->
name|reg_list
expr_stmt|;
name|alloc
operator|->
name|reg_list
operator|=
name|r
expr_stmt|;
name|alloc
operator|->
name|num_reg_blocks
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alloc_set_id_cleanup
parameter_list|(
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|void
function_decl|(
modifier|*
name|cleanup
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|alloc
operator|->
name|cleanup
operator|=
name|cleanup
expr_stmt|;
name|alloc
operator|->
name|cleanup_arg
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/** global debug value to keep track of total memory mallocs */
end_comment

begin_decl_stmt
name|size_t
name|unbound_mem_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** global debug value to keep track of total memory frees */
end_comment

begin_decl_stmt
name|size_t
name|unbound_mem_freed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_STATS
end_ifdef

begin_comment
comment|/** special value to know if the memory is being tracked */
end_comment

begin_decl_stmt
name|uint64_t
name|mem_special
init|=
operator|(
name|uint64_t
operator|)
literal|0xfeed43327766abcdLL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|malloc
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** malloc with stats */
end_comment

begin_function
name|void
modifier|*
name|unbound_stat_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|res
operator|=
name|malloc
argument_list|(
name|size
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|unbound_mem_alloc
operator|+=
name|size
expr_stmt|;
name|log_info
argument_list|(
literal|"stat %p=malloc(%u)"
argument_list|,
name|res
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
literal|8
argument_list|,
operator|&
name|mem_special
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_special
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
operator|+
literal|16
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|calloc
end_ifdef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_MAX
end_ifndef

begin_define
define|#
directive|define
name|INT_MAX
value|(((int)-1)>>1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** calloc with stats */
end_comment

begin_function
name|void
modifier|*
name|unbound_stat_calloc
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
name|void
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|nmemb
operator|!=
literal|0
operator|&&
name|INT_MAX
operator|/
name|nmemb
operator|<
name|size
condition|)
return|return
name|NULL
return|;
comment|/* integer overflow check */
name|s
operator|=
operator|(
name|nmemb
operator|*
name|size
operator|==
literal|0
operator|)
condition|?
operator|(
name|size_t
operator|)
literal|1
else|:
name|nmemb
operator|*
name|size
expr_stmt|;
name|res
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|s
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|log_info
argument_list|(
literal|"stat %p=calloc(%u, %u)"
argument_list|,
name|res
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
operator|)
name|nmemb
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
name|unbound_mem_alloc
operator|+=
name|s
expr_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
literal|8
argument_list|,
operator|&
name|mem_special
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_special
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
operator|+
literal|16
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|free
end_ifdef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** free with stats */
end_comment

begin_function
name|void
name|unbound_stat_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
operator|-
literal|8
argument_list|,
operator|&
name|mem_special
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_special
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|-=
literal|16
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|s
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"stat free(%p) size %u"
argument_list|,
name|ptr
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
operator|)
name|s
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|unbound_mem_freed
operator|+=
name|s
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|realloc
end_ifdef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** realloc with stats */
end_comment

begin_function
name|void
modifier|*
name|unbound_stat_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|cursz
decl_stmt|;
name|void
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|unbound_stat_malloc
argument_list|(
name|size
argument_list|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
operator|-
literal|8
argument_list|,
operator|&
name|mem_special
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_special
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|unbound_stat_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptr
operator|-=
literal|16
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|cursz
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|cursz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursz
operator|==
name|size
condition|)
block|{
comment|/* nothing changes */
return|return
name|ptr
return|;
block|}
name|res
operator|=
name|malloc
argument_list|(
name|size
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|unbound_mem_alloc
operator|+=
name|size
expr_stmt|;
name|unbound_mem_freed
operator|+=
name|cursz
expr_stmt|;
name|log_info
argument_list|(
literal|"stat realloc(%p, %u) from %u"
argument_list|,
name|ptr
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|,
operator|(
name|unsigned
operator|)
name|cursz
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursz
operator|>
name|size
condition|)
block|{
name|memcpy
argument_list|(
name|res
operator|+
literal|16
argument_list|,
name|ptr
operator|+
literal|16
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
name|cursz
condition|)
block|{
name|memcpy
argument_list|(
name|res
operator|+
literal|16
argument_list|,
name|ptr
operator|+
literal|16
argument_list|,
name|cursz
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|ptr
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
literal|8
argument_list|,
operator|&
name|mem_special
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_special
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
operator|+
literal|16
return|;
block|}
end_function

begin_comment
comment|/** log to file where alloc was done */
end_comment

begin_function
name|void
modifier|*
name|unbound_stat_malloc_log
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|log_info
argument_list|(
literal|"%s:%d %s malloc(%u)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|unbound_stat_malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** log to file where alloc was done */
end_comment

begin_function
name|void
modifier|*
name|unbound_stat_calloc_log
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|log_info
argument_list|(
literal|"%s:%d %s calloc(%u, %u)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
operator|(
name|unsigned
operator|)
name|nmemb
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|unbound_stat_calloc
argument_list|(
name|nmemb
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** log to file where free was done */
end_comment

begin_function
name|void
name|unbound_stat_free_log
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|&&
name|memcmp
argument_list|(
name|ptr
operator|-
literal|8
argument_list|,
operator|&
name|mem_special
argument_list|,
sizeof|sizeof
argument_list|(
name|mem_special
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|s
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|s
argument_list|,
name|ptr
operator|-
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"%s:%d %s free(%p) size %u"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|log_info
argument_list|(
literal|"%s:%d %s unmatched free(%p)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|unbound_stat_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** log to file where alloc was done */
end_comment

begin_function
name|void
modifier|*
name|unbound_stat_realloc_log
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|log_info
argument_list|(
literal|"%s:%d %s realloc(%p, %u)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|unbound_stat_realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNBOUND_ALLOC_STATS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_LITE
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_comment
comment|/** length of prefix and suffix */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|lite_pad
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** prefix value to check */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lite_pre
init|=
literal|"checkfront123456"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** suffix value to check */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lite_post
init|=
literal|"checkafter123456"
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|unbound_stat_malloc_lite
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
comment|/*  [prefix .. len .. actual data .. suffix] */
name|void
modifier|*
name|res
init|=
name|malloc
argument_list|(
name|size
operator|+
name|lite_pad
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|memmove
argument_list|(
name|res
argument_list|,
name|lite_pre
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|res
operator|+
name|lite_pad
argument_list|,
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
operator|+
name|lite_pad
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
literal|0x1a
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* init the memory */
name|memmove
argument_list|(
name|res
operator|+
name|lite_pad
operator|+
name|size
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|lite_post
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
return|return
name|res
operator|+
name|lite_pad
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|unbound_stat_calloc_lite
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|size_t
name|req
decl_stmt|;
name|void
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|nmemb
operator|!=
literal|0
operator|&&
name|INT_MAX
operator|/
name|nmemb
operator|<
name|size
condition|)
return|return
name|NULL
return|;
comment|/* integer overflow check */
name|req
operator|=
name|nmemb
operator|*
name|size
expr_stmt|;
name|res
operator|=
name|malloc
argument_list|(
name|req
operator|+
name|lite_pad
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|memmove
argument_list|(
name|res
argument_list|,
name|lite_pre
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|res
operator|+
name|lite_pad
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
operator|+
name|lite_pad
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|res
operator|+
name|lite_pad
operator|+
name|req
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|lite_post
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
return|return
name|res
operator|+
name|lite_pad
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|unbound_stat_free_lite
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|void
modifier|*
name|real
decl_stmt|;
name|size_t
name|orig
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
name|real
operator|=
name|ptr
operator|-
name|lite_pad
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|real
argument_list|,
name|lite_pre
argument_list|,
name|lite_pad
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"free(): prefix failed %s:%d %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"prefix here"
argument_list|,
name|real
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"  should be"
argument_list|,
name|lite_pre
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"alloc assertion failed"
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
operator|&
name|orig
argument_list|,
name|real
operator|+
name|lite_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|real
operator|+
name|lite_pad
operator|+
name|orig
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|lite_post
argument_list|,
name|lite_pad
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"free(): suffix failed %s:%d %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"alloc size is %d"
argument_list|,
operator|(
name|int
operator|)
name|orig
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"suffix here"
argument_list|,
name|real
operator|+
name|lite_pad
operator|+
name|orig
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"  should be"
argument_list|,
name|lite_post
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"alloc assertion failed"
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|real
argument_list|,
literal|0xdd
argument_list|,
name|orig
operator|+
name|lite_pad
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark it */
name|free
argument_list|(
name|real
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|unbound_stat_realloc_lite
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
comment|/* always free and realloc (no growing) */
name|void
modifier|*
name|real
decl_stmt|,
modifier|*
name|newa
decl_stmt|;
name|size_t
name|orig
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
comment|/* like malloc() */
return|return
name|unbound_stat_malloc_lite
argument_list|(
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
comment|/* like free() */
name|unbound_stat_free_lite
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* change allocation size and copy */
name|real
operator|=
name|ptr
operator|-
name|lite_pad
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|real
argument_list|,
name|lite_pre
argument_list|,
name|lite_pad
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"realloc(): prefix failed %s:%d %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"prefix here"
argument_list|,
name|real
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"  should be"
argument_list|,
name|lite_pre
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"alloc assertion failed"
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
operator|&
name|orig
argument_list|,
name|real
operator|+
name|lite_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|real
operator|+
name|lite_pad
operator|+
name|orig
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|lite_post
argument_list|,
name|lite_pad
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"realloc(): suffix failed %s:%d %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"alloc size is %d"
argument_list|,
operator|(
name|int
operator|)
name|orig
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"suffix here"
argument_list|,
name|real
operator|+
name|lite_pad
operator|+
name|orig
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|log_hex
argument_list|(
literal|"  should be"
argument_list|,
name|lite_post
argument_list|,
name|lite_pad
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"alloc assertion failed"
argument_list|)
expr_stmt|;
block|}
comment|/* new alloc and copy over */
name|newa
operator|=
name|unbound_stat_malloc_lite
argument_list|(
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newa
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|orig
operator|<
name|size
condition|)
name|memmove
argument_list|(
name|newa
argument_list|,
name|ptr
argument_list|,
name|orig
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
name|newa
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|real
argument_list|,
literal|0xdd
argument_list|,
name|orig
operator|+
name|lite_pad
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark it */
name|free
argument_list|(
name|real
argument_list|)
expr_stmt|;
return|return
name|newa
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unbound_strdup_lite
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
comment|/* this routine is made to make sure strdup() uses the malloc_lite */
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|n
init|=
operator|(
name|char
operator|*
operator|)
name|unbound_stat_malloc_lite
argument_list|(
name|l
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
name|memmove
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unbound_lite_wrapstr
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|n
init|=
name|unbound_strdup_lite
argument_list|(
name|s
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|sldns_pkt2wire
end_undef

begin_function
name|sldns_status
name|unbound_lite_pkt2wire
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|sldns_pkt
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|md
init|=
name|NULL
decl_stmt|;
name|size_t
name|ms
init|=
literal|0
decl_stmt|;
name|sldns_status
name|s
init|=
name|sldns_pkt2wire
argument_list|(
operator|&
name|md
argument_list|,
name|p
argument_list|,
operator|&
name|ms
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
condition|)
block|{
operator|*
name|dest
operator|=
name|unbound_stat_malloc_lite
argument_list|(
name|ms
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|ms
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|dest
condition|)
block|{
name|free
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|dest
argument_list|,
name|md
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dest
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|i2d_DSA_SIG
end_undef

begin_function
name|int
name|unbound_lite_i2d_DSA_SIG
parameter_list|(
name|DSA_SIG
modifier|*
name|dsasig
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|sig
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|int
name|r
init|=
name|i2d_DSA_SIG
argument_list|(
name|dsasig
argument_list|,
operator|&
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
operator|*
name|sig
operator|=
name|unbound_stat_malloc_lite
argument_list|(
operator|(
name|size_t
operator|)
name|r
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sig
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
operator|*
name|sig
argument_list|,
name|n
argument_list|,
operator|(
name|size_t
operator|)
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
operator|*
name|sig
operator|=
name|NULL
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNBOUND_ALLOC_LITE */
end_comment

end_unit

