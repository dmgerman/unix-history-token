begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/ub_event_pluggable.c - call registered pluggable event functions  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains an implementation for the indirection layer for pluggable  * events that calls the registered pluggable event loop.  It also defines a  * default pluggable event loop based on the default libevent (compatibility)  * functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"util/ub_event.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/unbound-event.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_comment
comment|/* We define libevent structures here to hide the libevent stuff. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_include
include|#
directive|include
file|"util/winsock_event.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"util/mini_event.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WINSOCK */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_comment
comment|/* we use libevent */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EVENT_H
end_ifdef

begin_include
include|#
directive|include
file|<event.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_compat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_if
if|#
directive|if
name|UB_EV_TIMEOUT
operator|!=
name|EV_TIMEOUT
operator|||
name|UB_EV_READ
operator|!=
name|EV_READ
operator|||
expr|\
name|UB_EV_WRITE
operator|!=
name|EV_WRITE
operator|||
name|UB_EV_SIGNAL
operator|!=
name|EV_SIGNAL
operator|||
expr|\
name|UB_EV_PERSIST
operator|!=
name|EV_PERSIST
end_if

begin_comment
comment|/* Only necessary for libev */
end_comment

begin_define
define|#
directive|define
name|NATIVE_BITS
parameter_list|(
name|b
parameter_list|)
value|( \ 	  (((b)& UB_EV_TIMEOUT) ? EV_TIMEOUT : 0) \ 	| (((b)& UB_EV_READ   ) ? EV_READ    : 0) \ 	| (((b)& UB_EV_WRITE  ) ? EV_WRITE   : 0) \ 	| (((b)& UB_EV_SIGNAL ) ? EV_SIGNAL  : 0) \ 	| (((b)& UB_EV_PERSIST) ? EV_PERSIST : 0))
end_define

begin_define
define|#
directive|define
name|UB_EV_BITS
parameter_list|(
name|b
parameter_list|)
value|( \ 	  (((b)& EV_TIMEOUT) ? UB_EV_TIMEOUT : 0) \ 	| (((b)& EV_READ   ) ? UB_EV_READ    : 0) \ 	| (((b)& EV_WRITE  ) ? UB_EV_WRITE   : 0) \ 	| (((b)& EV_SIGNAL ) ? UB_EV_SIGNAL  : 0) \ 	| (((b)& EV_PERSIST) ? UB_EV_PERSIST : 0))
end_define

begin_define
define|#
directive|define
name|UB_EV_BITS_CB
parameter_list|(
name|C
parameter_list|)
value|void my_ ## C (int fd, short bits, void *arg) \ 	{ (C)(fd, UB_EV_BITS(bits), arg); }
end_define

begin_expr_stmt
name|UB_EV_BITS_CB
argument_list|(
name|comm_point_udp_callback
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_udp_ancil_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_tcp_accept_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_tcp_handle_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_timer_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_signal_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_local_handle_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_raw_handle_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|tube_handle_signal
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_base_handle_slow_accept
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*NATIVE_BITS_CB(void (*cb)(int, short, void*))
argument_list|)
operator|(
name|int
operator|,
name|short
operator|,
name|void
operator|*
operator|)
block|{
if|if
condition|(
name|cb
operator|==
name|comm_point_udp_callback
condition|)
return|return
name|my_comm_point_udp_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_udp_ancil_callback
condition|)
return|return
name|my_comm_point_udp_ancil_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_tcp_accept_callback
condition|)
return|return
name|my_comm_point_tcp_accept_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_tcp_handle_callback
condition|)
return|return
name|my_comm_point_tcp_handle_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_timer_callback
condition|)
return|return
name|my_comm_timer_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_signal_callback
condition|)
return|return
name|my_comm_signal_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_local_handle_callback
condition|)
return|return
name|my_comm_point_local_handle_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_raw_handle_callback
condition|)
return|return
name|my_comm_point_raw_handle_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|tube_handle_signal
condition|)
return|return
name|my_tube_handle_signal
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_base_handle_slow_accept
condition|)
return|return
name|my_comm_base_handle_slow_accept
return|;
else|else
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NATIVE_BITS
parameter_list|(
name|b
parameter_list|)
value|(b)
end_define

begin_define
define|#
directive|define
name|NATIVE_BITS_CB
parameter_list|(
name|c
parameter_list|)
value|(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EVFLAG_AUTO
end_ifndef

begin_define
define|#
directive|define
name|EVFLAG_AUTO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|my_event_base
block|{
name|struct
name|ub_event_base
name|super
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|my_event
block|{
name|struct
name|ub_event
name|super
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AS_MY_EVENT_BASE
parameter_list|(
name|x
parameter_list|)
value|((struct my_event_base*)x)
end_define

begin_define
define|#
directive|define
name|AS_MY_EVENT
parameter_list|(
name|x
parameter_list|)
value|((struct my_event*)x)
end_define

begin_function
specifier|const
name|char
modifier|*
name|ub_event_get_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"pluggable-event"
name|PACKAGE_VERSION
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_event_add_bits
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|short
name|bits
parameter_list|)
block|{
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
operator|.
name|ev_events
operator||=
name|NATIVE_BITS
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_event_del_bits
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|short
name|bits
parameter_list|)
block|{
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
operator|.
name|ev_events
operator|&=
operator|~
name|NATIVE_BITS
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_event_set_fd
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
operator|.
name|ev_fd
operator|=
name|fd
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_event_free
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
name|free
argument_list|(
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_event_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|event_add
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_event_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|event_del
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_timer_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|event_set
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|NATIVE_BITS_CB
argument_list|(
name|cb
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|,
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|evtimer_add
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_timer_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|evtimer_del
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_signal_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|signal_add
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_signal_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|signal_del
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_winsock_unregister_wsaevent
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
name|winsock_unregister_wsaevent
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ev
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|my_winsock_tcp_wouldblock
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|int
name|eventbits
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|AS_MY_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev
argument_list|,
name|NATIVE_BITS
argument_list|(
name|eventbits
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ev
expr_stmt|;
operator|(
name|void
operator|)
name|eventbits
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ub_event_vmt
name|default_event_vmt
init|=
block|{
name|my_event_add_bits
block|,
name|my_event_del_bits
block|,
name|my_event_set_fd
block|,
name|my_event_free
block|,
name|my_event_add
block|,
name|my_event_del
block|,
name|my_timer_add
block|,
name|my_timer_del
block|,
name|my_signal_add
block|,
name|my_signal_del
block|,
name|my_winsock_unregister_wsaevent
block|,
name|my_winsock_tcp_wouldblock
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|my_event_base_free
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
name|event_base_free
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EVENT_BASE_FREE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_EVENT_BASE_ONCE
argument_list|)
comment|/* only libevent 1.2+ has it, but in 1.2 it is broken -  	   assertion fails on signal handling ev that is not deleted  	   in libevent 1.3c (event_base_once appears) this is fixed. */
name|event_base_free
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_EVENT_BASE_FREE and HAVE_EVENT_BASE_ONCE */
name|free
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_event_base_dispatch
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
return|return
name|event_base_dispatch
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_event_base_loopexit
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|event_base_loopexit
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ub_event
modifier|*
name|my_event_new
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|bits
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|my_event
modifier|*
name|my_ev
init|=
operator|(
expr|struct
name|my_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_event
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|my_ev
condition|)
return|return
name|NULL
return|;
name|event_set
argument_list|(
operator|&
name|my_ev
operator|->
name|ev
argument_list|,
name|fd
argument_list|,
name|NATIVE_BITS
argument_list|(
name|bits
argument_list|)
argument_list|,
name|NATIVE_BITS_CB
argument_list|(
name|cb
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|,
operator|&
name|my_ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|my_ev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|my_ev
operator|->
name|super
operator|.
name|magic
operator|=
name|UB_EVENT_MAGIC
expr_stmt|;
name|my_ev
operator|->
name|super
operator|.
name|vmt
operator|=
operator|&
name|default_event_vmt
expr_stmt|;
return|return
operator|&
name|my_ev
operator|->
name|super
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ub_event
modifier|*
name|my_signal_new
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|my_event
modifier|*
name|my_ev
init|=
operator|(
expr|struct
name|my_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_event
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|my_ev
condition|)
return|return
name|NULL
return|;
name|signal_set
argument_list|(
operator|&
name|my_ev
operator|->
name|ev
argument_list|,
name|fd
argument_list|,
name|NATIVE_BITS_CB
argument_list|(
name|cb
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|,
operator|&
name|my_ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|my_ev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|my_ev
operator|->
name|super
operator|.
name|magic
operator|=
name|UB_EVENT_MAGIC
expr_stmt|;
name|my_ev
operator|->
name|super
operator|.
name|vmt
operator|=
operator|&
name|default_event_vmt
expr_stmt|;
return|return
operator|&
name|my_ev
operator|->
name|super
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ub_event
modifier|*
name|my_winsock_register_wsaevent
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|void
modifier|*
name|wsaevent
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
name|struct
name|my_event
modifier|*
name|my_ev
init|=
operator|(
expr|struct
name|my_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_event
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|my_ev
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|winsock_register_wsaevent
argument_list|(
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
argument_list|,
operator|&
name|my_ev
operator|->
name|ev
argument_list|,
name|wsaevent
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|my_ev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|my_ev
operator|->
name|super
operator|.
name|magic
operator|=
name|UB_EVENT_MAGIC
expr_stmt|;
name|my_ev
operator|->
name|super
operator|.
name|vmt
operator|=
operator|&
name|default_event_vmt
expr_stmt|;
return|return
operator|&
name|my_ev
operator|->
name|super
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|base
expr_stmt|;
operator|(
name|void
operator|)
name|wsaevent
expr_stmt|;
operator|(
name|void
operator|)
name|cb
expr_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ub_event_base_vmt
name|default_event_base_vmt
init|=
block|{
name|my_event_base_free
block|,
name|my_event_base_dispatch
block|,
name|my_event_base_loopexit
block|,
name|my_event_new
block|,
name|my_signal_new
block|,
name|my_winsock_register_wsaevent
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|ub_event_base
modifier|*
name|ub_default_event_base
parameter_list|(
name|int
name|sigs
parameter_list|,
name|time_t
modifier|*
name|time_secs
parameter_list|,
name|struct
name|timeval
modifier|*
name|time_tv
parameter_list|)
block|{
name|struct
name|my_event_base
modifier|*
name|my_base
init|=
operator|(
expr|struct
name|my_event_base
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_event_base
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|my_base
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
operator|(
name|void
operator|)
name|sigs
expr_stmt|;
comment|/* use mini event time-sharing feature */
name|my_base
operator|->
name|base
operator|=
name|event_init
argument_list|(
name|time_secs
argument_list|,
name|time_tv
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|time_secs
expr_stmt|;
operator|(
name|void
operator|)
name|time_tv
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
comment|/* libev */
if|if
condition|(
name|sigs
condition|)
name|my_base
operator|->
name|base
operator|=
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|ev_default_loop
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
else|else
name|my_base
operator|->
name|base
operator|=
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|ev_loop_new
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigs
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_NEW
name|my_base
operator|->
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
else|#
directive|else
name|my_base
operator|->
name|base
operator|=
name|event_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|my_base
operator|->
name|base
condition|)
block|{
name|free
argument_list|(
name|my_base
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|my_base
operator|->
name|super
operator|.
name|magic
operator|=
name|UB_EVENT_MAGIC
expr_stmt|;
name|my_base
operator|->
name|super
operator|.
name|vmt
operator|=
operator|&
name|default_event_base_vmt
expr_stmt|;
return|return
operator|&
name|my_base
operator|->
name|super
return|;
block|}
end_function

begin_function
name|struct
name|ub_event_base
modifier|*
name|ub_libevent_event_base
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
operator|(
name|void
operator|)
name|base
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
name|struct
name|my_event_base
modifier|*
name|my_base
init|=
operator|(
expr|struct
name|my_event_base
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|my_event_base
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|my_base
condition|)
return|return
name|NULL
return|;
name|my_base
operator|->
name|super
operator|.
name|magic
operator|=
name|UB_EVENT_MAGIC
expr_stmt|;
name|my_base
operator|->
name|super
operator|.
name|vmt
operator|=
operator|&
name|default_event_base_vmt
expr_stmt|;
name|my_base
operator|->
name|base
operator|=
name|base
expr_stmt|;
return|return
operator|&
name|my_base
operator|->
name|super
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|ub_libevent_get_event_base
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_MINI_EVENT
if|if
condition|(
name|base
operator|->
name|vmt
operator|==
operator|&
name|default_event_base_vmt
condition|)
return|return
name|AS_MY_EVENT_BASE
argument_list|(
name|base
argument_list|)
operator|->
name|base
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|base
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|EVBACKEND_SELECT
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ub_ev_backend2str_pluggable
parameter_list|(
name|int
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
name|EVBACKEND_SELECT
case|:
return|return
literal|"select"
return|;
case|case
name|EVBACKEND_POLL
case|:
return|return
literal|"poll"
return|;
case|case
name|EVBACKEND_EPOLL
case|:
return|return
literal|"epoll"
return|;
case|case
name|EVBACKEND_KQUEUE
case|:
return|return
literal|"kqueue"
return|;
case|case
name|EVBACKEND_DEVPOLL
case|:
return|return
literal|"devpoll"
return|;
case|case
name|EVBACKEND_PORT
case|:
return|return
literal|"evport"
return|;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ub_get_event_sys
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|ub_base
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_WINSOCK
operator|(
name|void
operator|)
name|ub_base
expr_stmt|;
operator|*
name|n
operator|=
literal|"pluggable-event"
expr_stmt|;
operator|*
name|s
operator|=
literal|"winsock"
expr_stmt|;
operator|*
name|m
operator|=
literal|"WSAWaitForMultipleEvents"
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|(
name|void
operator|)
name|ub_base
expr_stmt|;
operator|*
name|n
operator|=
literal|"pluggable-event"
expr_stmt|;
operator|*
name|s
operator|=
literal|"internal"
expr_stmt|;
operator|*
name|m
operator|=
literal|"select"
expr_stmt|;
else|#
directive|else
name|struct
name|event_base
modifier|*
name|b
init|=
name|ub_libevent_get_event_base
argument_list|(
name|ub_base
argument_list|)
decl_stmt|;
comment|/* This function is only called from comm_base_create, so 	 * ub_base is guaranteed to exist and to be the default 	 * event base. 	 */
name|assert
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
literal|"pluggable-event"
expr_stmt|;
operator|*
name|s
operator|=
name|event_get_version
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|*
name|n
operator|=
literal|"pluggable-libev"
expr_stmt|;
ifdef|#
directive|ifdef
name|EVBACKEND_SELECT
operator|*
name|m
operator|=
name|ub_ev_backend2str_pluggable
argument_list|(
name|ev_backend
argument_list|(
operator|(
expr|struct
name|ev_loop
operator|*
operator|)
name|b
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|m
operator|=
literal|"not obtainable"
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EVENT_BASE_GET_METHOD
argument_list|)
operator|*
name|n
operator|=
literal|"pluggable-libevent"
expr_stmt|;
operator|*
name|m
operator|=
name|event_base_get_method
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|m
operator|=
literal|"not obtainable"
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ub_event_base_free
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
if|if
condition|(
name|base
operator|&&
name|base
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|base
operator|->
name|vmt
operator|!=
operator|&
name|default_event_base_vmt
operator|||
name|base
operator|->
name|vmt
operator|->
name|free
operator|==
name|my_event_base_free
argument_list|)
expr_stmt|;
call|(
modifier|*
name|base
operator|->
name|vmt
operator|->
name|free
call|)
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ub_event_base_dispatch
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
if|if
condition|(
name|base
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|base
operator|->
name|vmt
operator|!=
operator|&
name|default_event_base_vmt
operator|||
name|base
operator|->
name|vmt
operator|->
name|dispatch
operator|==
name|my_event_base_dispatch
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|base
operator|->
name|vmt
operator|->
name|dispatch
call|)
argument_list|(
name|base
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ub_event_base_loopexit
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
if|if
condition|(
name|base
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|base
operator|->
name|vmt
operator|!=
operator|&
name|default_event_base_vmt
operator|||
name|base
operator|->
name|vmt
operator|->
name|loopexit
operator|==
name|my_event_base_loopexit
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|base
operator|->
name|vmt
operator|->
name|loopexit
call|)
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|ub_event
modifier|*
name|ub_event_new
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|bits
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|base
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|base
operator|->
name|vmt
operator|!=
operator|&
name|default_event_base_vmt
operator|||
name|base
operator|->
name|vmt
operator|->
name|new_event
operator|==
name|my_event_new
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|base
operator|->
name|vmt
operator|->
name|new_event
call|)
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
name|bits
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ub_event
modifier|*
name|ub_signal_new
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|base
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|base
operator|->
name|vmt
operator|!=
operator|&
name|default_event_base_vmt
operator|||
name|base
operator|->
name|vmt
operator|->
name|new_signal
operator|==
name|my_signal_new
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|base
operator|->
name|vmt
operator|->
name|new_signal
call|)
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ub_event
modifier|*
name|ub_winsock_register_wsaevent
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|void
modifier|*
name|wsaevent
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|base
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|base
operator|->
name|vmt
operator|!=
operator|&
name|default_event_base_vmt
operator|||
name|base
operator|->
name|vmt
operator|->
name|winsock_register_wsaevent
operator|==
name|my_winsock_register_wsaevent
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|base
operator|->
name|vmt
operator|->
name|winsock_register_wsaevent
call|)
argument_list|(
name|base
argument_list|,
name|wsaevent
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ub_event_add_bits
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|short
name|bits
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|add_bits
operator|==
name|my_event_add_bits
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|add_bits
call|)
argument_list|(
name|ev
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ub_event_del_bits
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|short
name|bits
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|del_bits
operator|==
name|my_event_del_bits
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|del_bits
call|)
argument_list|(
name|ev
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ub_event_set_fd
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|set_fd
operator|==
name|my_event_set_fd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|set_fd
call|)
argument_list|(
name|ev
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ub_event_free
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|&&
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|free
operator|==
name|my_event_free
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|free
call|)
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ub_event_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|add
operator|==
name|my_event_add
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|add
call|)
argument_list|(
name|ev
argument_list|,
name|tv
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ub_event_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|&&
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|del
operator|==
name|my_event_del
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|del
call|)
argument_list|(
name|ev
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ub_timer_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|add_timer
operator|==
name|my_timer_add
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|add_timer
call|)
argument_list|(
name|ev
argument_list|,
name|base
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|,
name|tv
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ub_timer_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|&&
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|del_timer
operator|==
name|my_timer_del
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|del_timer
call|)
argument_list|(
name|ev
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ub_signal_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|add_signal
operator|==
name|my_signal_add
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|add_signal
call|)
argument_list|(
name|ev
argument_list|,
name|tv
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ub_signal_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|&&
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|del_signal
operator|==
name|my_signal_del
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|del_signal
call|)
argument_list|(
name|ev
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ub_winsock_unregister_wsaevent
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|&&
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|winsock_unregister_wsaevent
operator|==
name|my_winsock_unregister_wsaevent
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|winsock_unregister_wsaevent
call|)
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ub_winsock_tcp_wouldblock
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|int
name|eventbits
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
condition|)
block|{
name|fptr_ok
argument_list|(
name|ev
operator|->
name|vmt
operator|!=
operator|&
name|default_event_vmt
operator|||
name|ev
operator|->
name|vmt
operator|->
name|winsock_tcp_wouldblock
operator|==
name|my_winsock_tcp_wouldblock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|vmt
operator|->
name|winsock_tcp_wouldblock
call|)
argument_list|(
name|ev
argument_list|,
name|eventbits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ub_comm_base_now
parameter_list|(
name|struct
name|comm_base
modifier|*
name|cb
parameter_list|)
block|{
name|time_t
modifier|*
name|tt
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
comment|/** minievent updates the time when it blocks. */
if|if
condition|(
name|comm_base_internal
argument_list|(
name|cb
argument_list|)
operator|->
name|magic
operator|==
name|UB_EVENT_MAGIC
operator|&&
name|comm_base_internal
argument_list|(
name|cb
argument_list|)
operator|->
name|vmt
operator|==
operator|&
name|default_event_base_vmt
condition|)
return|return;
comment|/* Actually using mini event, so do not set time */
endif|#
directive|endif
comment|/* USE_MINI_EVENT */
comment|/** fillup the time values in the event base */
name|comm_base_timept
argument_list|(
name|cb
argument_list|,
operator|&
name|tt
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|tt
operator|=
name|tv
operator|->
name|tv_sec
expr_stmt|;
block|}
end_function

end_unit

