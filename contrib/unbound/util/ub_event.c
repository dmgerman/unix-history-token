begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/ub_event.c - directly call libevent (compatability) functions  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains and implementation for the indirection layer for pluggable  * events that transparently passes it either directly to libevent, or calls  * the libevent compatibility layer functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"util/ub_event.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/tube.h"
end_include

begin_comment
comment|/* We define libevent structures here to hide the libevent stuff. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_include
include|#
directive|include
file|"util/winsock_event.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"util/mini_event.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WINSOCK */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_comment
comment|/* we use libevent */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EVENT_H
end_ifdef

begin_include
include|#
directive|include
file|<event.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_compat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_if
if|#
directive|if
name|UB_EV_TIMEOUT
operator|!=
name|EV_TIMEOUT
operator|||
name|UB_EV_READ
operator|!=
name|EV_READ
operator|||
expr|\
name|UB_EV_WRITE
operator|!=
name|EV_WRITE
operator|||
name|UB_EV_SIGNAL
operator|!=
name|EV_SIGNAL
operator|||
expr|\
name|UB_EV_PERSIST
operator|!=
name|EV_PERSIST
end_if

begin_comment
comment|/* Only necessary for libev */
end_comment

begin_define
define|#
directive|define
name|NATIVE_BITS
parameter_list|(
name|b
parameter_list|)
value|( \ 	  (((b)& UB_EV_TIMEOUT) ? EV_TIMEOUT : 0) \ 	| (((b)& UB_EV_READ   ) ? EV_READ    : 0) \ 	| (((b)& UB_EV_WRITE  ) ? EV_WRITE   : 0) \ 	| (((b)& UB_EV_SIGNAL ) ? EV_SIGNAL  : 0) \ 	| (((b)& UB_EV_PERSIST) ? EV_PERSIST : 0))
end_define

begin_define
define|#
directive|define
name|UB_EV_BITS
parameter_list|(
name|b
parameter_list|)
value|( \ 	  (((b)& EV_TIMEOUT) ? UB_EV_TIMEOUT : 0) \ 	| (((b)& EV_READ   ) ? UB_EV_READ    : 0) \ 	| (((b)& EV_WRITE  ) ? UB_EV_WRITE   : 0) \ 	| (((b)& EV_SIGNAL ) ? UB_EV_SIGNAL  : 0) \ 	| (((b)& EV_PERSIST) ? UB_EV_PERSIST : 0))
end_define

begin_define
define|#
directive|define
name|UB_EV_BITS_CB
parameter_list|(
name|C
parameter_list|)
value|void my_ ## C (int fd, short bits, void *arg) \ 	{ (C)(fd, UB_EV_BITS(bits), arg); }
end_define

begin_expr_stmt
name|UB_EV_BITS_CB
argument_list|(
name|comm_point_udp_callback
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_udp_ancil_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_tcp_accept_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_tcp_handle_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_timer_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_signal_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_local_handle_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_point_raw_handle_callback
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|tube_handle_signal
argument_list|)
end_macro

begin_macro
name|UB_EV_BITS_CB
argument_list|(
argument|comm_base_handle_slow_accept
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*NATIVE_BITS_CB(void (*cb)(int, short, void*))
argument_list|)
operator|(
name|int
operator|,
name|short
operator|,
name|void
operator|*
operator|)
block|{
if|if
condition|(
name|cb
operator|==
name|comm_point_udp_callback
condition|)
return|return
name|my_comm_point_udp_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_udp_ancil_callback
condition|)
return|return
name|my_comm_point_udp_ancil_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_tcp_accept_callback
condition|)
return|return
name|my_comm_point_tcp_accept_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_tcp_handle_callback
condition|)
return|return
name|my_comm_point_tcp_handle_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_timer_callback
condition|)
return|return
name|my_comm_timer_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_signal_callback
condition|)
return|return
name|my_comm_signal_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_local_handle_callback
condition|)
return|return
name|my_comm_point_local_handle_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_point_raw_handle_callback
condition|)
return|return
name|my_comm_point_raw_handle_callback
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|tube_handle_signal
condition|)
return|return
name|my_tube_handle_signal
return|;
elseif|else
if|if
condition|(
name|cb
operator|==
name|comm_base_handle_slow_accept
condition|)
return|return
name|my_comm_base_handle_slow_accept
return|;
else|else
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NATIVE_BITS
parameter_list|(
name|b
parameter_list|)
value|(b)
end_define

begin_define
define|#
directive|define
name|NATIVE_BITS_CB
parameter_list|(
name|c
parameter_list|)
value|(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EVFLAG_AUTO
end_ifndef

begin_define
define|#
directive|define
name|EVFLAG_AUTO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AS_EVENT_BASE
parameter_list|(
name|x
parameter_list|)
value|((struct event_base*)x)
end_define

begin_define
define|#
directive|define
name|AS_UB_EVENT_BASE
parameter_list|(
name|x
parameter_list|)
value|((struct ub_event_base*)x)
end_define

begin_define
define|#
directive|define
name|AS_EVENT
parameter_list|(
name|x
parameter_list|)
value|((struct event*)x)
end_define

begin_define
define|#
directive|define
name|AS_UB_EVENT
parameter_list|(
name|x
parameter_list|)
value|((struct ub_event*)x)
end_define

begin_function
specifier|const
name|char
modifier|*
name|ub_event_get_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|event_get_version
argument_list|()
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|EVBACKEND_SELECT
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ub_ev_backend2str
parameter_list|(
name|int
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
name|EVBACKEND_SELECT
case|:
return|return
literal|"select"
return|;
case|case
name|EVBACKEND_POLL
case|:
return|return
literal|"poll"
return|;
case|case
name|EVBACKEND_EPOLL
case|:
return|return
literal|"epoll"
return|;
case|case
name|EVBACKEND_KQUEUE
case|:
return|return
literal|"kqueue"
return|;
case|case
name|EVBACKEND_DEVPOLL
case|:
return|return
literal|"devpoll"
return|;
case|case
name|EVBACKEND_PORT
case|:
return|return
literal|"evport"
return|;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ub_get_event_sys
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_WINSOCK
operator|(
name|void
operator|)
name|base
expr_stmt|;
operator|*
name|n
operator|=
literal|"event"
expr_stmt|;
operator|*
name|s
operator|=
literal|"winsock"
expr_stmt|;
operator|*
name|m
operator|=
literal|"WSAWaitForMultipleEvents"
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|(
name|void
operator|)
name|base
expr_stmt|;
operator|*
name|n
operator|=
literal|"mini-event"
expr_stmt|;
operator|*
name|s
operator|=
literal|"internal"
expr_stmt|;
operator|*
name|m
operator|=
literal|"select"
expr_stmt|;
else|#
directive|else
name|struct
name|event_base
modifier|*
name|b
init|=
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
decl_stmt|;
operator|*
name|s
operator|=
name|event_get_version
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
operator|*
name|n
operator|=
literal|"libev"
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|b
operator|=
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|ev_default_loop
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVBACKEND_SELECT
operator|*
name|m
operator|=
name|ub_ev_backend2str
argument_list|(
name|ev_backend
argument_list|(
operator|(
expr|struct
name|ev_loop
operator|*
operator|)
name|b
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|m
operator|=
literal|"not obtainable"
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EVENT_BASE_GET_METHOD
argument_list|)
operator|*
name|n
operator|=
literal|"libevent"
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|b
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
operator|*
name|m
operator|=
name|event_base_get_method
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|n
operator|=
literal|"unknown"
expr_stmt|;
operator|*
name|m
operator|=
literal|"not obtainable"
expr_stmt|;
operator|(
name|void
operator|)
name|b
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_FREE
if|if
condition|(
name|b
operator|&&
name|b
operator|!=
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
condition|)
name|event_base_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|ub_event_base
modifier|*
name|ub_default_event_base
parameter_list|(
name|int
name|sigs
parameter_list|,
name|time_t
modifier|*
name|time_secs
parameter_list|,
name|struct
name|timeval
modifier|*
name|time_tv
parameter_list|)
block|{
name|void
modifier|*
name|base
decl_stmt|;
operator|(
name|void
operator|)
name|base
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
operator|(
name|void
operator|)
name|sigs
expr_stmt|;
comment|/* use mini event time-sharing feature */
name|base
operator|=
name|event_init
argument_list|(
name|time_secs
argument_list|,
name|time_tv
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|time_secs
expr_stmt|;
operator|(
name|void
operator|)
name|time_tv
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
comment|/* libev */
if|if
condition|(
name|sigs
condition|)
name|base
operator|=
name|ev_default_loop
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|ev_loop_new
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigs
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_NEW
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
else|#
directive|else
name|base
operator|=
name|event_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
expr|struct
name|ub_event_base
operator|*
operator|)
name|base
return|;
block|}
end_function

begin_function
name|struct
name|ub_event_base
modifier|*
name|ub_libevent_event_base
parameter_list|(
name|struct
name|event_base
modifier|*
name|libevent_base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
operator|(
name|void
operator|)
name|libevent_base
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
return|return
name|AS_UB_EVENT_BASE
argument_list|(
name|libevent_base
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|ub_libevent_get_event_base
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
operator|(
name|void
operator|)
name|base
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
return|return
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ub_event_base_free
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
name|event_base_free
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EVENT_BASE_FREE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_EVENT_BASE_ONCE
argument_list|)
comment|/* only libevent 1.2+ has it, but in 1.2 it is broken -  	   assertion fails on signal handling ev that is not deleted  	   in libevent 1.3c (event_base_once appears) this is fixed. */
name|event_base_free
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|base
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_EVENT_BASE_FREE and HAVE_EVENT_BASE_ONCE */
block|}
end_function

begin_function
name|int
name|ub_event_base_dispatch
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
return|return
name|event_base_dispatch
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_event_base_loopexit
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|)
block|{
return|return
name|event_base_loopexit
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ub_event
modifier|*
name|ub_event_new
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|bits
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
operator|(
expr|struct
name|event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ev
condition|)
return|return
name|NULL
return|;
name|event_set
argument_list|(
name|ev
argument_list|,
name|fd
argument_list|,
name|NATIVE_BITS
argument_list|(
name|bits
argument_list|)
argument_list|,
name|NATIVE_BITS_CB
argument_list|(
name|cb
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|,
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|AS_UB_EVENT
argument_list|(
name|ev
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ub_event
modifier|*
name|ub_signal_new
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
operator|(
expr|struct
name|event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ev
condition|)
return|return
name|NULL
return|;
name|signal_set
argument_list|(
name|ev
argument_list|,
name|fd
argument_list|,
name|NATIVE_BITS_CB
argument_list|(
name|cb
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|,
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|AS_UB_EVENT
argument_list|(
name|ev
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ub_event
modifier|*
name|ub_winsock_register_wsaevent
parameter_list|(
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|void
modifier|*
name|wsaevent
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
name|struct
name|event
modifier|*
name|ev
init|=
operator|(
expr|struct
name|event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ev
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|winsock_register_wsaevent
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|,
name|ev
argument_list|,
name|wsaevent
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|AS_UB_EVENT
argument_list|(
name|ev
argument_list|)
return|;
name|free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|base
expr_stmt|;
operator|(
name|void
operator|)
name|wsaevent
expr_stmt|;
operator|(
name|void
operator|)
name|cb
expr_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ub_event_add_bits
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|short
name|bits
parameter_list|)
block|{
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev_events
operator||=
name|NATIVE_BITS
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ub_event_del_bits
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|short
name|bits
parameter_list|)
block|{
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev_events
operator|&=
operator|~
name|NATIVE_BITS
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ub_event_set_fd
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
operator|->
name|ev_fd
operator|=
name|fd
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ub_event_free
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|ev
condition|)
name|free
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ub_event_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|event_add
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_event_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|event_del
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_timer_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|ub_event_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|event_set
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|NATIVE_BITS_CB
argument_list|(
name|cb
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|AS_EVENT_BASE
argument_list|(
name|base
argument_list|)
argument_list|,
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|evtimer_add
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_timer_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|evtimer_del
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_signal_add
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|signal_add
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_signal_del
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|signal_del
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ub_winsock_unregister_wsaevent
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
name|winsock_unregister_wsaevent
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ev
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ub_winsock_tcp_wouldblock
parameter_list|(
name|struct
name|ub_event
modifier|*
name|ev
parameter_list|,
name|int
name|eventbits
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
name|winsock_tcp_wouldblock
argument_list|(
name|AS_EVENT
argument_list|(
name|ev
argument_list|)
argument_list|,
name|NATIVE_BITS
argument_list|(
name|eventbits
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ev
expr_stmt|;
operator|(
name|void
operator|)
name|eventbits
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ub_comm_base_now
parameter_list|(
name|struct
name|comm_base
modifier|*
name|cb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
comment|/** minievent updates the time when it blocks. */
operator|(
name|void
operator|)
name|cb
expr_stmt|;
comment|/* nothing to do */
else|#
directive|else
comment|/* !USE_MINI_EVENT */
comment|/** fillup the time values in the event base */
name|time_t
modifier|*
name|tt
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
name|comm_base_timept
argument_list|(
name|cb
argument_list|,
operator|&
name|tt
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|tt
operator|=
name|tv
operator|->
name|tv_sec
expr_stmt|;
endif|#
directive|endif
comment|/* USE_MINI_EVENT */
block|}
end_function

end_unit

