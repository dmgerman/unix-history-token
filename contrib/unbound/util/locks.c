begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * util/locks.c - unbound locking primitives  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *   * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  * Implementation of locking and threading support.  * A place for locking debug code since most locking functions are macros.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/locks.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** block all signals, masks them away. */
end_comment

begin_function
name|void
name|ub_thread_blocksigs
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PTHREAD
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SOLARIS_THREADS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SIGPROCMASK
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PTHREAD
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SOLARIS_THREADS
argument_list|)
name|int
name|err
decl_stmt|;
endif|#
directive|endif
name|sigset_t
name|sigset
decl_stmt|;
name|sigfillset
argument_list|(
operator|&
name|sigset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PTHREAD
if|if
condition|(
operator|(
name|err
operator|=
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"pthread_sigmask: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_SOLARIS_THREADS
if|if
condition|(
operator|(
name|err
operator|=
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"thr_sigsetmask: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* have nothing, do single process signal mask */
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"sigprocmask: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SOLARIS_THREADS */
endif|#
directive|endif
comment|/* HAVE_PTHREAD */
endif|#
directive|endif
comment|/* have signal stuff */
block|}
end_function

begin_comment
comment|/** unblock one signal, so we can catch it */
end_comment

begin_function
name|void
name|ub_thread_sig_unblock
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PTHREAD
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SOLARIS_THREADS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SIGPROCMASK
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PTHREAD
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SOLARIS_THREADS
argument_list|)
name|int
name|err
decl_stmt|;
endif|#
directive|endif
name|sigset_t
name|sigset
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigset
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sigset
argument_list|,
name|sig
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PTHREAD
if|if
condition|(
operator|(
name|err
operator|=
name|pthread_sigmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"pthread_sigmask: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_SOLARIS_THREADS
if|if
condition|(
operator|(
name|err
operator|=
name|thr_sigsetmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|fatal_exit
argument_list|(
literal|"thr_sigsetmask: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* have nothing, do single thread case */
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"sigprocmask: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SOLARIS_THREADS */
endif|#
directive|endif
comment|/* HAVE_PTHREAD */
else|#
directive|else
operator|(
name|void
operator|)
name|sig
expr_stmt|;
endif|#
directive|endif
comment|/* have signal stuff */
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PTHREAD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SOLARIS_THREADS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_WINDOWS_THREADS
argument_list|)
end_if

begin_comment
comment|/**  * No threading available: fork a new process.  * This means no shared data structure, and no locking.  * Only the main thread ever returns. Exits on errors.  * @param thr: the location where to store the thread-id.  * @param func: function body of the thread. Return value of func is lost.  * @param arg: user argument to func.  */
end_comment

begin_function
name|void
name|ub_thr_fork_create
parameter_list|(
name|ub_thread_t
modifier|*
name|thr
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|pid_t
name|pid
init|=
name|fork
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
default|default:
comment|/* main */
operator|*
name|thr
operator|=
operator|(
name|ub_thread_t
operator|)
name|pid
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* child */
operator|*
name|thr
operator|=
operator|(
name|ub_thread_t
operator|)
name|getpid
argument_list|()
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
comment|/* error */
name|fatal_exit
argument_list|(
literal|"could not fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * There is no threading. Wait for a process to terminate.  * Note that ub_thread_t is defined as pid_t.  * @param thread: the process id to wait for.  */
end_comment

begin_function
name|void
name|ub_thr_fork_wait
parameter_list|(
name|ub_thread_t
name|thread
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
name|thread
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_err
argument_list|(
literal|"waitpid(%d): %s"
argument_list|,
operator|(
name|int
operator|)
name|thread
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|log_warn
argument_list|(
literal|"process %d abnormal exit with status %d"
argument_list|,
operator|(
name|int
operator|)
name|thread
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_PTHREAD)&& !defined(HAVE_SOLARIS_THREADS)&& !defined(HAVE_WINDOWS_THREADS) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOLARIS_THREADS
end_ifdef

begin_function
name|void
modifier|*
name|ub_thread_key_get
parameter_list|(
name|ub_thread_key_t
name|key
parameter_list|)
block|{
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|LOCKRET
argument_list|(
name|thr_getspecific
argument_list|(
name|key
argument_list|,
operator|&
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINDOWS_THREADS
end_ifdef

begin_comment
comment|/** log a windows GetLastError message */
end_comment

begin_function
specifier|static
name|void
name|log_win_err
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|DWORD
name|err
parameter_list|)
block|{
name|LPTSTR
name|buf
decl_stmt|;
if|if
condition|(
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
operator||
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|,
literal|0
argument_list|,
operator|(
name|LPTSTR
operator|)
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* could not format error message */
name|log_err
argument_list|(
literal|"%s, GetLastError=%d"
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_err
argument_list|(
literal|"%s, (err=%d): %s"
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|LocalFree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lock_basic_init
parameter_list|(
name|lock_basic_t
modifier|*
name|lock
parameter_list|)
block|{
comment|/* implement own lock, because windows HANDLE as Mutex usage 	 * uses too many handles and would bog down the whole system. */
operator|(
name|void
operator|)
name|InterlockedExchange
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lock_basic_destroy
parameter_list|(
name|lock_basic_t
modifier|*
name|lock
parameter_list|)
block|{
operator|(
name|void
operator|)
name|InterlockedExchange
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lock_basic_lock
parameter_list|(
name|lock_basic_t
modifier|*
name|lock
parameter_list|)
block|{
name|LONG
name|wait
init|=
literal|1
decl_stmt|;
comment|/* wait 1 msec at first */
while|while
condition|(
name|InterlockedExchange
argument_list|(
name|lock
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* if the old value was 1 then if was already locked */
name|Sleep
argument_list|(
name|wait
argument_list|)
expr_stmt|;
comment|/* wait with sleep */
name|wait
operator|*=
literal|2
expr_stmt|;
comment|/* exponential backoff for waiting */
block|}
comment|/* the old value was 0, but we inserted 1, we locked it! */
block|}
end_function

begin_function
name|void
name|lock_basic_unlock
parameter_list|(
name|lock_basic_t
modifier|*
name|lock
parameter_list|)
block|{
comment|/* unlock it by inserting the value of 0. xchg for cache coherency. */
operator|(
name|void
operator|)
name|InterlockedExchange
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ub_thread_key_create
parameter_list|(
name|ub_thread_key_t
modifier|*
name|key
parameter_list|,
name|void
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|key
operator|=
name|TlsAlloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
name|TLS_OUT_OF_INDEXES
condition|)
block|{
operator|*
name|key
operator|=
literal|0
expr_stmt|;
name|log_win_err
argument_list|(
literal|"TlsAlloc Failed(OUT_OF_INDEXES)"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|ub_thread_key_set
argument_list|(
operator|*
name|key
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ub_thread_key_set
parameter_list|(
name|ub_thread_key_t
name|key
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TlsSetValue
argument_list|(
name|key
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|log_win_err
argument_list|(
literal|"TlsSetValue failed"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|ub_thread_key_get
parameter_list|(
name|ub_thread_key_t
name|key
parameter_list|)
block|{
name|void
modifier|*
name|ret
init|=
operator|(
name|void
operator|*
operator|)
name|TlsGetValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
name|GetLastError
argument_list|()
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|log_win_err
argument_list|(
literal|"TlsGetValue failed"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ub_thread_create
parameter_list|(
name|ub_thread_t
modifier|*
name|thr
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE__BEGINTHREADEX
operator|*
name|thr
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
comment|/* default security (no inherit handle) */
literal|0
argument_list|,
comment|/* default stack size */
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|func
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
comment|/* default flags, run immediately */
name|NULL
argument_list|)
expr_stmt|;
comment|/* do not store thread identifier anywhere */
else|#
directive|else
comment|/* the beginthreadex routine setups for the C lib; aligns stack */
operator|*
name|thr
operator|=
operator|(
name|ub_thread_t
operator|)
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|func
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|thr
operator|==
name|NULL
condition|)
block|{
name|log_win_err
argument_list|(
literal|"CreateThread failed"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"thread create failed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ub_thread_t
name|ub_thread_self
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|GetCurrentThread
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|ub_thread_join
parameter_list|(
name|ub_thread_t
name|thr
parameter_list|)
block|{
name|DWORD
name|ret
init|=
name|WaitForSingleObject
argument_list|(
name|thr
argument_list|,
name|INFINITE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|WAIT_FAILED
condition|)
block|{
name|log_win_err
argument_list|(
literal|"WaitForSingleObject(Thread):WAIT_FAILED"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|WAIT_TIMEOUT
condition|)
block|{
name|log_win_err
argument_list|(
literal|"WaitForSingleObject(Thread):WAIT_TIMEOUT"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* and close the handle to the thread */
if|if
condition|(
operator|!
name|CloseHandle
argument_list|(
name|thr
argument_list|)
condition|)
block|{
name|log_win_err
argument_list|(
literal|"CloseHandle(Thread) failed"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_WINDOWS_THREADS */
end_comment

end_unit

