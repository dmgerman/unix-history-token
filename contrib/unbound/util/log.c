begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/log.c - implementation of the log code  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  * Implementation of log.h.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/locks.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/**define LOG_ constants */
end_comment

begin_define
define|#
directive|define
name|LOG_CRIT
value|2
end_define

begin_define
define|#
directive|define
name|LOG_ERR
value|3
end_define

begin_define
define|#
directive|define
name|LOG_WARNING
value|4
end_define

begin_define
define|#
directive|define
name|LOG_NOTICE
value|5
end_define

begin_define
define|#
directive|define
name|LOG_INFO
value|6
end_define

begin_define
define|#
directive|define
name|LOG_DEBUG
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
end_ifdef

begin_include
include|#
directive|include
file|"winrc/win_svc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* default verbosity */
end_comment

begin_decl_stmt
name|enum
name|verbosity_value
name|verbosity
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** the file logged to. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** if key has been created */
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_created
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** pthread key for thread ids in logfile */
end_comment

begin_decl_stmt
specifier|static
name|ub_thread_key_t
name|logkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** the identity of this executable/process */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ident
init|=
literal|"unbound"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSLOG_H
argument_list|)
operator|||
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
end_if

begin_comment
comment|/** are we using syslog(3) to log to */
end_comment

begin_decl_stmt
specifier|static
name|int
name|logging_to_syslog
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSLOG_H */
end_comment

begin_comment
comment|/** time to print in log, if NULL, use time(2) */
end_comment

begin_decl_stmt
specifier|static
name|time_t
modifier|*
name|log_now
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** print time in UTC or in secondsfrom1970 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|log_time_asc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|log_init
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|use_syslog
parameter_list|,
specifier|const
name|char
modifier|*
name|chrootdir
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|key_created
condition|)
block|{
name|key_created
operator|=
literal|1
expr_stmt|;
name|ub_thread_key_create
argument_list|(
operator|&
name|logkey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logfile
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSLOG_H
argument_list|)
operator|||
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
operator|||
name|logging_to_syslog
endif|#
directive|endif
condition|)
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"switching log to %s"
argument_list|,
name|use_syslog
condition|?
literal|"syslog"
else|:
operator|(
name|filename
operator|&&
name|filename
index|[
literal|0
index|]
condition|?
name|filename
else|:
literal|"stderr"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|&&
name|logfile
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
if|if
condition|(
name|logging_to_syslog
condition|)
block|{
name|closelog
argument_list|()
expr_stmt|;
name|logging_to_syslog
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|use_syslog
condition|)
block|{
comment|/* do not delay opening until first write, because we may 		 * chroot and no longer be able to access dev/log and so on */
name|openlog
argument_list|(
name|ident
argument_list|,
name|LOG_NDELAY
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|logging_to_syslog
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
if|if
condition|(
name|logging_to_syslog
condition|)
block|{
name|logging_to_syslog
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|use_syslog
condition|)
block|{
name|logging_to_syslog
operator|=
literal|1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSLOG_H */
if|if
condition|(
operator|!
name|filename
operator|||
operator|!
name|filename
index|[
literal|0
index|]
condition|)
block|{
name|logfile
operator|=
name|stderr
expr_stmt|;
return|return;
block|}
comment|/* open the file for logging */
if|if
condition|(
name|chrootdir
operator|&&
name|chrootdir
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|filename
argument_list|,
name|chrootdir
argument_list|,
name|strlen
argument_list|(
name|chrootdir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|+=
name|strlen
argument_list|(
name|chrootdir
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not open logfile %s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|UB_ON_WINDOWS
comment|/* line buffering does not work on windows */
name|setvbuf
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|,
operator|(
name|int
operator|)
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|logfile
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_file
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|logfile
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_thread_set
parameter_list|(
name|int
modifier|*
name|num
parameter_list|)
block|{
name|ub_thread_key_set
argument_list|(
name|logkey
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_ident_set
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ident
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_set_time
parameter_list|(
name|time_t
modifier|*
name|t
parameter_list|)
block|{
name|log_now
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_set_time_asc
parameter_list|(
name|int
name|use_asc
parameter_list|)
block|{
name|log_time_asc
operator|=
name|use_asc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_vmsg
parameter_list|(
name|int
name|pri
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
name|message
index|[
name|MAXSYSLOGMSGLEN
index|]
decl_stmt|;
name|unsigned
name|int
modifier|*
name|tid
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ub_thread_key_get
argument_list|(
name|logkey
argument_list|)
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRFTIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LOCALTIME_R
argument_list|)
name|char
name|tmbuf
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
name|char
name|tmbuf
index|[
literal|128
index|]
decl_stmt|,
name|dtbuf
index|[
literal|128
index|]
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|pri
expr_stmt|;
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
if|if
condition|(
name|logging_to_syslog
condition|)
block|{
name|syslog
argument_list|(
name|pri
argument_list|,
literal|"[%d:%x] %s: %s"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|tid
condition|?
operator|*
name|tid
else|:
literal|0
argument_list|,
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
if|if
condition|(
name|logging_to_syslog
condition|)
block|{
name|char
name|m
index|[
literal|32768
index|]
decl_stmt|;
name|HANDLE
modifier|*
name|s
decl_stmt|;
name|LPCTSTR
name|str
init|=
name|m
decl_stmt|;
name|DWORD
name|tp
init|=
name|MSG_GENERIC_ERR
decl_stmt|;
name|WORD
name|wt
init|=
name|EVENTLOG_ERROR_TYPE
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|=
name|MSG_GENERIC_INFO
expr_stmt|;
name|wt
operator|=
name|EVENTLOG_INFORMATION_TYPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"warning"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|=
name|MSG_GENERIC_WARN
expr_stmt|;
name|wt
operator|=
name|EVENTLOG_WARNING_TYPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"notice"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"debug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|=
name|MSG_GENERIC_SUCCESS
expr_stmt|;
name|wt
operator|=
name|EVENTLOG_SUCCESS
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|,
literal|"[%s:%x] %s: %s"
argument_list|,
name|ident
argument_list|,
name|tid
condition|?
operator|*
name|tid
else|:
literal|0
argument_list|,
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|s
operator|=
name|RegisterEventSource
argument_list|(
name|NULL
argument_list|,
name|SERVICE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
name|ReportEvent
argument_list|(
name|s
argument_list|,
name|wt
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DeregisterEventSource
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSLOG_H */
if|if
condition|(
operator|!
name|logfile
condition|)
return|return;
if|if
condition|(
name|log_now
condition|)
name|now
operator|=
operator|(
name|time_t
operator|)
operator|*
name|log_now
expr_stmt|;
else|else
name|now
operator|=
operator|(
name|time_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRFTIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LOCALTIME_R
argument_list|)
if|if
condition|(
name|log_time_asc
operator|&&
name|strftime
argument_list|(
name|tmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmbuf
argument_list|)
argument_list|,
literal|"%b %d %H:%M:%S"
argument_list|,
name|localtime_r
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tm
argument_list|)
argument_list|)
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|tmbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* %sizeof buf!=0 because old strftime returned max on error */
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s %s[%d:%x] %s: %s\n"
argument_list|,
name|tmbuf
argument_list|,
name|ident
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|tid
condition|?
operator|*
name|tid
else|:
literal|0
argument_list|,
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
elseif|else
elif|#
directive|elif
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
if|if
condition|(
name|log_time_asc
operator|&&
name|GetTimeFormat
argument_list|(
name|LOCALE_USER_DEFAULT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmbuf
argument_list|)
argument_list|)
operator|&&
name|GetDateFormat
argument_list|(
name|LOCALE_USER_DEFAULT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dtbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dtbuf
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s %s %s[%d:%x] %s: %s\n"
argument_list|,
name|dtbuf
argument_list|,
name|tmbuf
argument_list|,
name|ident
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|tid
condition|?
operator|*
name|tid
else|:
literal|0
argument_list|,
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"["
name|ARG_LL
literal|"d] %s[%d:%x] %s: %s\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|now
argument_list|,
name|ident
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|tid
condition|?
operator|*
name|tid
else|:
literal|0
argument_list|,
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
comment|/* line buffering does not work on windows */
name|fflush
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * implementation of log_info  * @param format: format string printf-style.  */
end_comment

begin_function
name|void
name|log_info
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|log_vmsg
argument_list|(
name|LOG_INFO
argument_list|,
literal|"info"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * implementation of log_err  * @param format: format string printf-style.  */
end_comment

begin_function
name|void
name|log_err
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|log_vmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * implementation of log_warn  * @param format: format string printf-style.  */
end_comment

begin_function
name|void
name|log_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|log_vmsg
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * implementation of fatal_exit  * @param format: format string printf-style.  */
end_comment

begin_function
name|void
name|fatal_exit
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|log_vmsg
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"fatal error"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * implementation of verbose  * @param level: verbose level for the message.  * @param format: format string printf-style.  */
end_comment

begin_function
name|void
name|verbose
parameter_list|(
name|enum
name|verbosity_value
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|level
condition|)
block|{
if|if
condition|(
name|level
operator|==
name|VERB_OPS
condition|)
name|log_vmsg
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"notice"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|VERB_DETAIL
condition|)
name|log_vmsg
argument_list|(
name|LOG_INFO
argument_list|,
literal|"info"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|log_vmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"debug"
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** log hex data */
end_comment

begin_function
specifier|static
name|void
name|log_hex_f
parameter_list|(
name|enum
name|verbosity_value
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint8_t
modifier|*
name|data8
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|hexchar
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|char
name|buf
index|[
literal|1024
operator|+
literal|1
index|]
decl_stmt|;
comment|/* alloc blocksize hex chars + \0 */
specifier|const
name|size_t
name|blocksize
init|=
literal|512
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|v
argument_list|,
literal|"%s[%u]"
argument_list|,
name|msg
argument_list|,
operator|(
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|+=
name|blocksize
operator|/
literal|2
control|)
block|{
name|len
operator|=
name|blocksize
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|-
name|i
operator|<
name|blocksize
operator|/
literal|2
condition|)
name|len
operator|=
name|length
operator|-
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|buf
index|[
name|j
operator|*
literal|2
index|]
operator|=
name|hexchar
index|[
name|data8
index|[
name|i
operator|+
name|j
index|]
operator|>>
literal|4
index|]
expr_stmt|;
name|buf
index|[
name|j
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|hexchar
index|[
name|data8
index|[
name|i
operator|+
name|j
index|]
operator|&
literal|0xF
index|]
expr_stmt|;
block|}
name|buf
index|[
name|len
operator|*
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|verbose
argument_list|(
name|v
argument_list|,
literal|"%s[%u:%u] %.*s"
argument_list|,
name|msg
argument_list|,
operator|(
name|unsigned
operator|)
name|length
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|,
operator|(
name|int
operator|)
name|len
operator|*
literal|2
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|log_hex
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|log_hex_f
argument_list|(
name|verbosity
argument_list|,
name|msg
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_buf
parameter_list|(
name|enum
name|verbosity_value
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|verbosity
operator|<
name|level
condition|)
return|return;
name|log_hex_f
argument_list|(
name|level
argument_list|,
name|msg
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_function
name|char
modifier|*
name|wsa_strerror
parameter_list|(
name|DWORD
name|err
parameter_list|)
block|{
specifier|static
name|char
name|unknown
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|WSA_INVALID_HANDLE
case|:
return|return
literal|"Specified event object handle is invalid."
return|;
case|case
name|WSA_NOT_ENOUGH_MEMORY
case|:
return|return
literal|"Insufficient memory available."
return|;
case|case
name|WSA_INVALID_PARAMETER
case|:
return|return
literal|"One or more parameters are invalid."
return|;
case|case
name|WSA_OPERATION_ABORTED
case|:
return|return
literal|"Overlapped operation aborted."
return|;
case|case
name|WSA_IO_INCOMPLETE
case|:
return|return
literal|"Overlapped I/O event object not in signaled state."
return|;
case|case
name|WSA_IO_PENDING
case|:
return|return
literal|"Overlapped operations will complete later."
return|;
case|case
name|WSAEINTR
case|:
return|return
literal|"Interrupted function call."
return|;
case|case
name|WSAEBADF
case|:
return|return
literal|"File handle is not valid."
return|;
case|case
name|WSAEACCES
case|:
return|return
literal|"Permission denied."
return|;
case|case
name|WSAEFAULT
case|:
return|return
literal|"Bad address."
return|;
case|case
name|WSAEINVAL
case|:
return|return
literal|"Invalid argument."
return|;
case|case
name|WSAEMFILE
case|:
return|return
literal|"Too many open files."
return|;
case|case
name|WSAEWOULDBLOCK
case|:
return|return
literal|"Resource temporarily unavailable."
return|;
case|case
name|WSAEINPROGRESS
case|:
return|return
literal|"Operation now in progress."
return|;
case|case
name|WSAEALREADY
case|:
return|return
literal|"Operation already in progress."
return|;
case|case
name|WSAENOTSOCK
case|:
return|return
literal|"Socket operation on nonsocket."
return|;
case|case
name|WSAEDESTADDRREQ
case|:
return|return
literal|"Destination address required."
return|;
case|case
name|WSAEMSGSIZE
case|:
return|return
literal|"Message too long."
return|;
case|case
name|WSAEPROTOTYPE
case|:
return|return
literal|"Protocol wrong type for socket."
return|;
case|case
name|WSAENOPROTOOPT
case|:
return|return
literal|"Bad protocol option."
return|;
case|case
name|WSAEPROTONOSUPPORT
case|:
return|return
literal|"Protocol not supported."
return|;
case|case
name|WSAESOCKTNOSUPPORT
case|:
return|return
literal|"Socket type not supported."
return|;
case|case
name|WSAEOPNOTSUPP
case|:
return|return
literal|"Operation not supported."
return|;
case|case
name|WSAEPFNOSUPPORT
case|:
return|return
literal|"Protocol family not supported."
return|;
case|case
name|WSAEAFNOSUPPORT
case|:
return|return
literal|"Address family not supported by protocol family."
return|;
case|case
name|WSAEADDRINUSE
case|:
return|return
literal|"Address already in use."
return|;
case|case
name|WSAEADDRNOTAVAIL
case|:
return|return
literal|"Cannot assign requested address."
return|;
case|case
name|WSAENETDOWN
case|:
return|return
literal|"Network is down."
return|;
case|case
name|WSAENETUNREACH
case|:
return|return
literal|"Network is unreachable."
return|;
case|case
name|WSAENETRESET
case|:
return|return
literal|"Network dropped connection on reset."
return|;
case|case
name|WSAECONNABORTED
case|:
return|return
literal|"Software caused connection abort."
return|;
case|case
name|WSAECONNRESET
case|:
return|return
literal|"Connection reset by peer."
return|;
case|case
name|WSAENOBUFS
case|:
return|return
literal|"No buffer space available."
return|;
case|case
name|WSAEISCONN
case|:
return|return
literal|"Socket is already connected."
return|;
case|case
name|WSAENOTCONN
case|:
return|return
literal|"Socket is not connected."
return|;
case|case
name|WSAESHUTDOWN
case|:
return|return
literal|"Cannot send after socket shutdown."
return|;
case|case
name|WSAETOOMANYREFS
case|:
return|return
literal|"Too many references."
return|;
case|case
name|WSAETIMEDOUT
case|:
return|return
literal|"Connection timed out."
return|;
case|case
name|WSAECONNREFUSED
case|:
return|return
literal|"Connection refused."
return|;
case|case
name|WSAELOOP
case|:
return|return
literal|"Cannot translate name."
return|;
case|case
name|WSAENAMETOOLONG
case|:
return|return
literal|"Name too long."
return|;
case|case
name|WSAEHOSTDOWN
case|:
return|return
literal|"Host is down."
return|;
case|case
name|WSAEHOSTUNREACH
case|:
return|return
literal|"No route to host."
return|;
case|case
name|WSAENOTEMPTY
case|:
return|return
literal|"Directory not empty."
return|;
case|case
name|WSAEPROCLIM
case|:
return|return
literal|"Too many processes."
return|;
case|case
name|WSAEUSERS
case|:
return|return
literal|"User quota exceeded."
return|;
case|case
name|WSAEDQUOT
case|:
return|return
literal|"Disk quota exceeded."
return|;
case|case
name|WSAESTALE
case|:
return|return
literal|"Stale file handle reference."
return|;
case|case
name|WSAEREMOTE
case|:
return|return
literal|"Item is remote."
return|;
case|case
name|WSASYSNOTREADY
case|:
return|return
literal|"Network subsystem is unavailable."
return|;
case|case
name|WSAVERNOTSUPPORTED
case|:
return|return
literal|"Winsock.dll version out of range."
return|;
case|case
name|WSANOTINITIALISED
case|:
return|return
literal|"Successful WSAStartup not yet performed."
return|;
case|case
name|WSAEDISCON
case|:
return|return
literal|"Graceful shutdown in progress."
return|;
case|case
name|WSAENOMORE
case|:
return|return
literal|"No more results."
return|;
case|case
name|WSAECANCELLED
case|:
return|return
literal|"Call has been canceled."
return|;
case|case
name|WSAEINVALIDPROCTABLE
case|:
return|return
literal|"Procedure call table is invalid."
return|;
case|case
name|WSAEINVALIDPROVIDER
case|:
return|return
literal|"Service provider is invalid."
return|;
case|case
name|WSAEPROVIDERFAILEDINIT
case|:
return|return
literal|"Service provider failed to initialize."
return|;
case|case
name|WSASYSCALLFAILURE
case|:
return|return
literal|"System call failure."
return|;
case|case
name|WSASERVICE_NOT_FOUND
case|:
return|return
literal|"Service not found."
return|;
case|case
name|WSATYPE_NOT_FOUND
case|:
return|return
literal|"Class type not found."
return|;
case|case
name|WSA_E_NO_MORE
case|:
return|return
literal|"No more results."
return|;
case|case
name|WSA_E_CANCELLED
case|:
return|return
literal|"Call was canceled."
return|;
case|case
name|WSAEREFUSED
case|:
return|return
literal|"Database query was refused."
return|;
case|case
name|WSAHOST_NOT_FOUND
case|:
return|return
literal|"Host not found."
return|;
case|case
name|WSATRY_AGAIN
case|:
return|return
literal|"Nonauthoritative host not found."
return|;
case|case
name|WSANO_RECOVERY
case|:
return|return
literal|"This is a nonrecoverable error."
return|;
case|case
name|WSANO_DATA
case|:
return|return
literal|"Valid name, no data record of requested type."
return|;
case|case
name|WSA_QOS_RECEIVERS
case|:
return|return
literal|"QOS receivers."
return|;
case|case
name|WSA_QOS_SENDERS
case|:
return|return
literal|"QOS senders."
return|;
case|case
name|WSA_QOS_NO_SENDERS
case|:
return|return
literal|"No QOS senders."
return|;
case|case
name|WSA_QOS_NO_RECEIVERS
case|:
return|return
literal|"QOS no receivers."
return|;
case|case
name|WSA_QOS_REQUEST_CONFIRMED
case|:
return|return
literal|"QOS request confirmed."
return|;
case|case
name|WSA_QOS_ADMISSION_FAILURE
case|:
return|return
literal|"QOS admission error."
return|;
case|case
name|WSA_QOS_POLICY_FAILURE
case|:
return|return
literal|"QOS policy failure."
return|;
case|case
name|WSA_QOS_BAD_STYLE
case|:
return|return
literal|"QOS bad style."
return|;
case|case
name|WSA_QOS_BAD_OBJECT
case|:
return|return
literal|"QOS bad object."
return|;
case|case
name|WSA_QOS_TRAFFIC_CTRL_ERROR
case|:
return|return
literal|"QOS traffic control error."
return|;
case|case
name|WSA_QOS_GENERIC_ERROR
case|:
return|return
literal|"QOS generic error."
return|;
case|case
name|WSA_QOS_ESERVICETYPE
case|:
return|return
literal|"QOS service type error."
return|;
case|case
name|WSA_QOS_EFLOWSPEC
case|:
return|return
literal|"QOS flowspec error."
return|;
case|case
name|WSA_QOS_EPROVSPECBUF
case|:
return|return
literal|"Invalid QOS provider buffer."
return|;
case|case
name|WSA_QOS_EFILTERSTYLE
case|:
return|return
literal|"Invalid QOS filter style."
return|;
case|case
name|WSA_QOS_EFILTERTYPE
case|:
return|return
literal|"Invalid QOS filter type."
return|;
case|case
name|WSA_QOS_EFILTERCOUNT
case|:
return|return
literal|"Incorrect QOS filter count."
return|;
case|case
name|WSA_QOS_EOBJLENGTH
case|:
return|return
literal|"Invalid QOS object length."
return|;
case|case
name|WSA_QOS_EFLOWCOUNT
case|:
return|return
literal|"Incorrect QOS flow count."
return|;
comment|/*case WSA_QOS_EUNKOWNPSOBJ: return "Unrecognized QOS object.";*/
case|case
name|WSA_QOS_EPOLICYOBJ
case|:
return|return
literal|"Invalid QOS policy object."
return|;
case|case
name|WSA_QOS_EFLOWDESC
case|:
return|return
literal|"Invalid QOS flow descriptor."
return|;
case|case
name|WSA_QOS_EPSFLOWSPEC
case|:
return|return
literal|"Invalid QOS provider-specific flowspec."
return|;
case|case
name|WSA_QOS_EPSFILTERSPEC
case|:
return|return
literal|"Invalid QOS provider-specific filterspec."
return|;
case|case
name|WSA_QOS_ESDMODEOBJ
case|:
return|return
literal|"Invalid QOS shape discard mode object."
return|;
case|case
name|WSA_QOS_ESHAPERATEOBJ
case|:
return|return
literal|"Invalid QOS shaping rate object."
return|;
case|case
name|WSA_QOS_RESERVED_PETYPE
case|:
return|return
literal|"Reserved policy QOS element type."
return|;
default|default:
name|snprintf
argument_list|(
name|unknown
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown
argument_list|)
argument_list|,
literal|"unknown WSA error code %d"
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|)
expr_stmt|;
return|return
name|unknown
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WINSOCK */
end_comment

end_unit

