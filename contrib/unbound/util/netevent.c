begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/netevent.c - event notification  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains event notification functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"ldns/pkthdr.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_SSL_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* -------- Start of local definitions -------- */
end_comment

begin_comment
comment|/** if CMSG_ALIGN is not defined on this platform, a workaround */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CMSG_ALIGN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_CMSG_DATA_ALIGN
end_ifdef

begin_define
define|#
directive|define
name|CMSG_ALIGN
value|_CMSG_DATA_ALIGN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CMSG_ALIGN
parameter_list|(
name|len
parameter_list|)
value|(((len)+sizeof(long)-1)& ~(sizeof(long)-1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** if CMSG_LEN is not defined on this platform, a workaround */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CMSG_LEN
end_ifndef

begin_define
define|#
directive|define
name|CMSG_LEN
parameter_list|(
name|len
parameter_list|)
value|(CMSG_ALIGN(sizeof(struct cmsghdr))+(len))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** if CMSG_SPACE is not defined on this platform, a workaround */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CMSG_SPACE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_CMSG_HDR_ALIGN
end_ifdef

begin_define
define|#
directive|define
name|CMSG_SPACE
parameter_list|(
name|l
parameter_list|)
value|(CMSG_ALIGN(l)+_CMSG_HDR_ALIGN(sizeof(struct cmsghdr)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CMSG_SPACE
parameter_list|(
name|l
parameter_list|)
value|(CMSG_ALIGN(l)+CMSG_ALIGN(sizeof(struct cmsghdr)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** The TCP reading or writing query timeout in seconds */
end_comment

begin_define
define|#
directive|define
name|TCP_QUERY_TIMEOUT
value|120
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NONBLOCKING_IS_BROKEN
end_ifndef

begin_comment
comment|/** number of UDP reads to perform per read indication from select */
end_comment

begin_define
define|#
directive|define
name|NUM_UDP_PER_SELECT
value|100
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_UDP_PER_SELECT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We define libevent structures here to hide the libevent stuff. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_include
include|#
directive|include
file|"util/winsock_event.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"util/mini_event.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WINSOCK */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_comment
comment|/* we use libevent */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EVENT_H
end_ifdef

begin_include
include|#
directive|include
file|<event.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_compat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_comment
comment|/**  * The internal event structure for keeping libevent info for the event.  * Possibly other structures (list, tree) this is part of.  */
end_comment

begin_struct
struct|struct
name|internal_event
block|{
comment|/** the comm base */
name|struct
name|comm_base
modifier|*
name|base
decl_stmt|;
comment|/** libevent event type, alloced here */
name|struct
name|event
name|ev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Internal base structure, so that every thread has its own events.  */
end_comment

begin_struct
struct|struct
name|internal_base
block|{
comment|/** libevent event_base type. */
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
comment|/** seconds time pointer points here */
name|time_t
name|secs
decl_stmt|;
comment|/** timeval with current time */
name|struct
name|timeval
name|now
decl_stmt|;
comment|/** the event used for slow_accept timeouts */
name|struct
name|event
name|slow_accept
decl_stmt|;
comment|/** true if slow_accept is enabled */
name|int
name|slow_accept_enabled
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Internal timer structure, to store timer event in.  */
end_comment

begin_struct
struct|struct
name|internal_timer
block|{
comment|/** the comm base */
name|struct
name|comm_base
modifier|*
name|base
decl_stmt|;
comment|/** libevent event type, alloced here */
name|struct
name|event
name|ev
decl_stmt|;
comment|/** is timer enabled */
name|uint8_t
name|enabled
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Internal signal structure, to store signal event in.  */
end_comment

begin_struct
struct|struct
name|internal_signal
block|{
comment|/** libevent event type, alloced here */
name|struct
name|event
name|ev
decl_stmt|;
comment|/** next in signal list */
name|struct
name|internal_signal
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** create a tcp handler with a parent */
end_comment

begin_function_decl
specifier|static
name|struct
name|comm_point
modifier|*
name|comm_point_create_tcp_handler
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|struct
name|comm_point
modifier|*
name|parent
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -------- End of local definitions -------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
end_ifdef

begin_comment
comment|/** minievent updates the time when it blocks. */
end_comment

begin_define
define|#
directive|define
name|comm_base_now
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* nothing to do */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_MINI_EVENT */
end_comment

begin_comment
comment|/** fillup the time values in the event base */
end_comment

begin_function
specifier|static
name|void
name|comm_base_now
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|b
operator|->
name|eb
operator|->
name|now
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|eb
operator|->
name|secs
operator|=
operator|(
name|time_t
operator|)
name|b
operator|->
name|eb
operator|->
name|now
operator|.
name|tv_sec
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MINI_EVENT */
end_comment

begin_function
name|struct
name|comm_base
modifier|*
name|comm_base_create
parameter_list|(
name|int
name|sigs
parameter_list|)
block|{
name|struct
name|comm_base
modifier|*
name|b
init|=
operator|(
expr|struct
name|comm_base
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_base
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return
name|NULL
return|;
name|b
operator|->
name|eb
operator|=
operator|(
expr|struct
name|internal_base
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|eb
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
operator|(
name|void
operator|)
name|sigs
expr_stmt|;
comment|/* use mini event time-sharing feature */
name|b
operator|->
name|eb
operator|->
name|base
operator|=
name|event_init
argument_list|(
operator|&
name|b
operator|->
name|eb
operator|->
name|secs
argument_list|,
operator|&
name|b
operator|->
name|eb
operator|->
name|now
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
comment|/* libev */
if|if
condition|(
name|sigs
condition|)
name|b
operator|->
name|eb
operator|->
name|base
operator|=
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|ev_default_loop
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|eb
operator|->
name|base
operator|=
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|ev_loop_new
argument_list|(
name|EVFLAG_AUTO
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigs
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_NEW
name|b
operator|->
name|eb
operator|->
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
else|#
directive|else
name|b
operator|->
name|eb
operator|->
name|base
operator|=
name|event_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|b
operator|->
name|eb
operator|->
name|base
condition|)
block|{
name|free
argument_list|(
name|b
operator|->
name|eb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|comm_base_now
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* avoid event_get_method call which causes crashes even when 	 * not printing, because its result is passed */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EV_LOOP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EV_DEFAULT_LOOP
argument_list|)
literal|"libev"
elif|#
directive|elif
name|defined
argument_list|(
name|USE_MINI_EVENT
argument_list|)
literal|"event "
else|#
directive|else
literal|"libevent "
endif|#
directive|endif
literal|"%s uses %s method."
argument_list|,
name|event_get_version
argument_list|()
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_EVENT_BASE_GET_METHOD
name|event_base_get_method
argument_list|(
name|b
operator|->
name|eb
operator|->
name|base
argument_list|)
else|#
directive|else
literal|"not_obtainable"
endif|#
directive|endif
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|struct
name|comm_base
modifier|*
name|comm_base_create_event
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|comm_base
modifier|*
name|b
init|=
operator|(
expr|struct
name|comm_base
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_base
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return
name|NULL
return|;
name|b
operator|->
name|eb
operator|=
operator|(
expr|struct
name|internal_base
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|eb
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|b
operator|->
name|eb
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|comm_base_now
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|void
name|comm_base_delete
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return;
if|if
condition|(
name|b
operator|->
name|eb
operator|->
name|slow_accept_enabled
condition|)
block|{
if|if
condition|(
name|event_del
argument_list|(
operator|&
name|b
operator|->
name|eb
operator|->
name|slow_accept
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not event_del slow_accept"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_MINI_EVENT
name|event_base_free
argument_list|(
name|b
operator|->
name|eb
operator|->
name|base
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EVENT_BASE_FREE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_EVENT_BASE_ONCE
argument_list|)
comment|/* only libevent 1.2+ has it, but in 1.2 it is broken -  	   assertion fails on signal handling ev that is not deleted  	   in libevent 1.3c (event_base_once appears) this is fixed. */
name|event_base_free
argument_list|(
name|b
operator|->
name|eb
operator|->
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_EVENT_BASE_FREE and HAVE_EVENT_BASE_ONCE */
name|b
operator|->
name|eb
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|eb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_delete_no_base
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return;
if|if
condition|(
name|b
operator|->
name|eb
operator|->
name|slow_accept_enabled
condition|)
block|{
if|if
condition|(
name|event_del
argument_list|(
operator|&
name|b
operator|->
name|eb
operator|->
name|slow_accept
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not event_del slow_accept"
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|->
name|eb
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|eb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_timept
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|,
name|time_t
modifier|*
modifier|*
name|tt
parameter_list|,
name|struct
name|timeval
modifier|*
modifier|*
name|tv
parameter_list|)
block|{
operator|*
name|tt
operator|=
operator|&
name|b
operator|->
name|eb
operator|->
name|secs
expr_stmt|;
operator|*
name|tv
operator|=
operator|&
name|b
operator|->
name|eb
operator|->
name|now
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_dispatch
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|event_base_dispatch
argument_list|(
name|b
operator|->
name|eb
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"event_dispatch returned error %d, "
literal|"errno is %s"
argument_list|,
name|retval
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|comm_base_exit
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|event_base_loopexit
argument_list|(
name|b
operator|->
name|eb
operator|->
name|base
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not loopexit"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|comm_base_set_slow_accept_handlers
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|,
name|void
function_decl|(
modifier|*
name|stop_acc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|start_acc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|b
operator|->
name|stop_accept
operator|=
name|stop_acc
expr_stmt|;
name|b
operator|->
name|start_accept
operator|=
name|start_acc
expr_stmt|;
name|b
operator|->
name|cb_arg
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|comm_base_internal
parameter_list|(
name|struct
name|comm_base
modifier|*
name|b
parameter_list|)
block|{
return|return
name|b
operator|->
name|eb
operator|->
name|base
return|;
block|}
end_function

begin_comment
comment|/** see if errno for udp has to be logged or not uses globals */
end_comment

begin_function
specifier|static
name|int
name|udp_send_errno_needs_log
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
comment|/* do not log transient errors (unless high verbosity) */
if|#
directive|if
name|defined
argument_list|(
name|ENETUNREACH
argument_list|)
operator|||
name|defined
argument_list|(
name|EHOSTDOWN
argument_list|)
operator|||
name|defined
argument_list|(
name|EHOSTUNREACH
argument_list|)
operator|||
name|defined
argument_list|(
name|ENETDOWN
argument_list|)
switch|switch
condition|(
name|errno
condition|)
block|{
ifdef|#
directive|ifdef
name|ENETUNREACH
case|case
name|ENETUNREACH
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EHOSTDOWN
case|case
name|EHOSTDOWN
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EHOSTUNREACH
case|case
name|EHOSTUNREACH
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENETDOWN
case|case
name|ENETDOWN
case|:
endif|#
directive|endif
if|if
condition|(
name|verbosity
operator|<
name|VERB_ALGO
condition|)
return|return
literal|0
return|;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* permission denied is gotten for every send if the 	 * network is disconnected (on some OS), squelch it */
if|if
condition|(
name|errno
operator|==
name|EPERM
operator|&&
name|verbosity
operator|<
name|VERB_DETAIL
condition|)
return|return
literal|0
return|;
comment|/* squelch errors where people deploy AAAA ::ffff:bla for 	 * authority servers, which we try for intranets. */
if|if
condition|(
name|errno
operator|==
name|EINVAL
operator|&&
name|addr_is_ip4mapped
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|&&
name|verbosity
operator|<
name|VERB_DETAIL
condition|)
return|return
literal|0
return|;
comment|/* SO_BROADCAST sockopt can give access to 255.255.255.255, 	 * but a dns cache does not need it. */
if|if
condition|(
name|errno
operator|==
name|EACCES
operator|&&
name|addr_is_broadcast
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|&&
name|verbosity
operator|<
name|VERB_DETAIL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|tcp_connect_errno_needs_log
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
return|return
name|udp_send_errno_needs_log
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* send a UDP reply */
end_comment

begin_function
name|int
name|comm_point_send_udp_msg
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|ssize_t
name|sent
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|log_err
argument_list|(
literal|"error: send empty UDP packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_assert
argument_list|(
name|addr
operator|&&
name|addrlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sent
operator|=
name|sendto
argument_list|(
name|c
operator|->
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|udp_send_errno_needs_log
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"sendto failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"sendto failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
name|VERB_OPS
argument_list|,
literal|"remote address is"
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|sent
operator|!=
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"sent %d in place of %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|sent
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AF_INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_PKTINFO
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|HAVE_RECVMSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SENDMSG
argument_list|)
operator|)
end_if

begin_comment
comment|/** print debug ancillary info */
end_comment

begin_function
specifier|static
name|void
name|p_ancil
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|->
name|srctype
operator|!=
literal|4
operator|&&
name|r
operator|->
name|srctype
operator|!=
literal|6
condition|)
block|{
name|log_info
argument_list|(
literal|"%s: unknown srctype %d"
argument_list|,
name|str
argument_list|,
name|r
operator|->
name|srctype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|->
name|srctype
operator|==
literal|6
condition|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v6info
operator|.
name|ipi6_addr
argument_list|,
name|buf
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"(inet_ntop error)"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|log_info
argument_list|(
literal|"%s: %s %d"
argument_list|,
name|str
argument_list|,
name|buf
argument_list|,
name|r
operator|->
name|pktinfo
operator|.
name|v6info
operator|.
name|ipi6_ifindex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|srctype
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|IP_PKTINFO
name|char
name|buf1
index|[
literal|1024
index|]
decl_stmt|,
name|buf2
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v4info
operator|.
name|ipi_addr
argument_list|,
name|buf1
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf1
argument_list|,
literal|"(inet_ntop error)"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf1
index|[
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_IN_PKTINFO_IPI_SPEC_DST
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v4info
operator|.
name|ipi_spec_dst
argument_list|,
name|buf2
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf2
argument_list|,
literal|"(inet_ntop error)"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf2
index|[
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|buf2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|log_info
argument_list|(
literal|"%s: %d %s %s"
argument_list|,
name|str
argument_list|,
name|r
operator|->
name|pktinfo
operator|.
name|v4info
operator|.
name|ipi_ifindex
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|IP_RECVDSTADDR
argument_list|)
name|char
name|buf1
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v4addr
argument_list|,
name|buf1
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf1
argument_list|,
literal|"(inet_ntop error)"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf1
index|[
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|log_info
argument_list|(
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IP_PKTINFO or PI_RECVDSTDADDR */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AF_INET6&& IPV6_PKTINFO&& HAVE_RECVMSG||HAVE_SENDMSG */
end_comment

begin_comment
comment|/** send a UDP reply over specified interface*/
end_comment

begin_function
specifier|static
name|int
name|comm_point_send_udp_msg_if
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|r
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|AF_INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_PKTINFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SENDMSG
argument_list|)
name|ssize_t
name|sent
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|char
name|control
index|[
literal|256
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
endif|#
directive|endif
comment|/* S_SPLINT_S */
name|log_assert
argument_list|(
name|c
operator|->
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|log_err
argument_list|(
literal|"error: send empty UDP packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_assert
argument_list|(
name|addr
operator|&&
name|addrlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
name|addr
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
name|addrlen
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|control
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* S_SPLINT_S */
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|cmsg
operator|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|srctype
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|IP_PKTINFO
name|msg
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|msg
operator|.
name|msg_controllen
operator|<=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|IP_PKTINFO
expr_stmt|;
name|memmove
argument_list|(
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v4info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|IP_SENDSRCADDR
argument_list|)
name|msg
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|msg
operator|.
name|msg_controllen
operator|<=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|IP_SENDSRCADDR
expr_stmt|;
name|memmove
argument_list|(
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v4addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no IP_PKTINFO or IP_SENDSRCADDR"
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* IP_PKTINFO or IP_SENDSRCADDR */
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|srctype
operator|==
literal|6
condition|)
block|{
name|msg
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|msg
operator|.
name|msg_controllen
operator|<=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|memmove
argument_list|(
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|pktinfo
operator|.
name|v6info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* try to pass all 0 to use default route */
name|msg
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|msg
operator|.
name|msg_controllen
operator|<=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|memset
argument_list|(
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* S_SPLINT_S */
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|p_ancil
argument_list|(
literal|"send_udp over interface"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|sent
operator|=
name|sendmsg
argument_list|(
name|c
operator|->
name|fd
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|udp_send_errno_needs_log
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|)
return|return
literal|0
return|;
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"sendmsg failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_OPS
argument_list|,
literal|"remote address is"
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|sent
operator|!=
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"sent %d in place of %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|sent
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_remaining
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|c
expr_stmt|;
operator|(
name|void
operator|)
name|packet
expr_stmt|;
operator|(
name|void
operator|)
name|addr
expr_stmt|;
operator|(
name|void
operator|)
name|addrlen
expr_stmt|;
operator|(
name|void
operator|)
name|r
expr_stmt|;
name|log_err
argument_list|(
literal|"sendmsg: IPV6_PKTINFO not supported"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* AF_INET6&& IPV6_PKTINFO&& HAVE_SENDMSG */
block|}
end_function

begin_function
name|void
name|comm_point_udp_ancil_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|AF_INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_PKTINFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_RECVMSG
argument_list|)
name|struct
name|comm_reply
name|rep
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|ssize_t
name|rcv
decl_stmt|;
name|char
name|ancil
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
endif|#
directive|endif
comment|/* S_SPLINT_S */
name|rep
operator|.
name|c
operator|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|arg
expr_stmt|;
name|log_assert
argument_list|(
name|rep
operator|.
name|c
operator|->
name|type
operator|==
name|comm_udp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|EV_READ
operator|)
condition|)
return|return;
name|log_assert
argument_list|(
name|rep
operator|.
name|c
operator|&&
name|rep
operator|.
name|c
operator|->
name|buffer
operator|&&
name|rep
operator|.
name|c
operator|->
name|fd
operator|==
name|fd
argument_list|)
expr_stmt|;
name|comm_base_now
argument_list|(
name|rep
operator|.
name|c
operator|->
name|ev
operator|->
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_UDP_PER_SELECT
condition|;
name|i
operator|++
control|)
block|{
name|sldns_buffer_clear
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|rep
operator|.
name|addrlen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|addr
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|sldns_buffer_remaining
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
operator|&
name|rep
operator|.
name|addr
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|addr
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|sldns_buffer_begin
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|sldns_buffer_remaining
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|ancil
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|ancil
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* S_SPLINT_S */
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|rcv
operator|=
name|recvmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcv
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|log_err
argument_list|(
literal|"recvmsg failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|rep
operator|.
name|addrlen
operator|=
name|msg
operator|.
name|msg_namelen
expr_stmt|;
name|sldns_buffer_skip
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|,
name|rcv
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|rep
operator|.
name|srctype
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
for|for
control|(
name|cmsg
operator|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|msg
argument_list|)
init|;
name|cmsg
operator|!=
name|NULL
condition|;
name|cmsg
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|msg
argument_list|,
name|cmsg
argument_list|)
control|)
block|{
if|if
condition|(
name|cmsg
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cmsg
operator|->
name|cmsg_type
operator|==
name|IPV6_PKTINFO
condition|)
block|{
name|rep
operator|.
name|srctype
operator|=
literal|6
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|rep
operator|.
name|pktinfo
operator|.
name|v6info
argument_list|,
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IP_PKTINFO
block|}
elseif|else
if|if
condition|(
name|cmsg
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IP
operator|&&
name|cmsg
operator|->
name|cmsg_type
operator|==
name|IP_PKTINFO
condition|)
block|{
name|rep
operator|.
name|srctype
operator|=
literal|4
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|rep
operator|.
name|pktinfo
operator|.
name|v4info
argument_list|,
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
elif|#
directive|elif
name|defined
argument_list|(
name|IP_RECVDSTADDR
argument_list|)
block|}
elseif|else
if|if
condition|(
name|cmsg
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IP
operator|&&
name|cmsg
operator|->
name|cmsg_type
operator|==
name|IP_RECVDSTADDR
condition|)
block|{
name|rep
operator|.
name|srctype
operator|=
literal|4
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|rep
operator|.
name|pktinfo
operator|.
name|v4addr
argument_list|,
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* IP_PKTINFO or IP_RECVDSTADDR */
block|}
block|}
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
name|p_ancil
argument_list|(
literal|"receive_udp on interface"
argument_list|,
operator|&
name|rep
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* S_SPLINT_S */
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|rep
operator|.
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|rep
operator|.
name|c
operator|->
name|callback
call|)
argument_list|(
name|rep
operator|.
name|c
argument_list|,
name|rep
operator|.
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
operator|&
name|rep
argument_list|)
condition|)
block|{
comment|/* send back immediate reply */
operator|(
name|void
operator|)
name|comm_point_send_udp_msg_if
argument_list|(
name|rep
operator|.
name|c
argument_list|,
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rep
operator|.
name|addr
argument_list|,
name|rep
operator|.
name|addrlen
argument_list|,
operator|&
name|rep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|.
name|c
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
comment|/* commpoint closed */
break|break;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|event
expr_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"recvmsg: No support for IPV6_PKTINFO. "
literal|"Please disable interface-automatic"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AF_INET6&& IPV6_PKTINFO&& HAVE_RECVMSG */
block|}
end_function

begin_function
name|void
name|comm_point_udp_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_reply
name|rep
decl_stmt|;
name|ssize_t
name|rcv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rep
operator|.
name|c
operator|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|arg
expr_stmt|;
name|log_assert
argument_list|(
name|rep
operator|.
name|c
operator|->
name|type
operator|==
name|comm_udp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|EV_READ
operator|)
condition|)
return|return;
name|log_assert
argument_list|(
name|rep
operator|.
name|c
operator|&&
name|rep
operator|.
name|c
operator|->
name|buffer
operator|&&
name|rep
operator|.
name|c
operator|->
name|fd
operator|==
name|fd
argument_list|)
expr_stmt|;
name|comm_base_now
argument_list|(
name|rep
operator|.
name|c
operator|->
name|ev
operator|->
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_UDP_PER_SELECT
condition|;
name|i
operator|++
control|)
block|{
name|sldns_buffer_clear
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|rep
operator|.
name|addrlen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|addr
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|sldns_buffer_remaining
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_remaining
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rep
operator|.
name|addr
argument_list|,
operator|&
name|rep
operator|.
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcv
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|log_err
argument_list|(
literal|"recvfrom %d failed: %s"
argument_list|,
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEINPROGRESS
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAECONNRESET
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEWOULDBLOCK
condition|)
name|log_err
argument_list|(
literal|"recvfrom failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|sldns_buffer_skip
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|,
name|rcv
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|rep
operator|.
name|srctype
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|rep
operator|.
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|rep
operator|.
name|c
operator|->
name|callback
call|)
argument_list|(
name|rep
operator|.
name|c
argument_list|,
name|rep
operator|.
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
operator|&
name|rep
argument_list|)
condition|)
block|{
comment|/* send back immediate reply */
operator|(
name|void
operator|)
name|comm_point_send_udp_msg
argument_list|(
name|rep
operator|.
name|c
argument_list|,
name|rep
operator|.
name|c
operator|->
name|buffer
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rep
operator|.
name|addr
argument_list|,
name|rep
operator|.
name|addrlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|.
name|c
operator|->
name|fd
operator|!=
name|fd
condition|)
comment|/* commpoint closed to -1 or reused for 		another UDP port. Note rep.c cannot be reused with TCP fd. */
break|break;
block|}
block|}
end_function

begin_comment
comment|/** Use a new tcp handler for new query fd, set to read query */
end_comment

begin_function
specifier|static
name|void
name|setup_tcp_handler
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|fd
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|comm_point_start_listening
argument_list|(
name|c
argument_list|,
name|fd
argument_list|,
name|TCP_QUERY_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|comm_base_handle_slow_accept
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|event
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_base
modifier|*
name|b
init|=
operator|(
expr|struct
name|comm_base
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* timeout for the slow accept, re-enable accepts again */
if|if
condition|(
name|b
operator|->
name|start_accept
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"wait is over, slow accept disabled"
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_start_accept
argument_list|(
name|b
operator|->
name|start_accept
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|b
operator|->
name|start_accept
call|)
argument_list|(
name|b
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|b
operator|->
name|eb
operator|->
name|slow_accept_enabled
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|comm_point_perform_accept
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
modifier|*
name|addrlen
parameter_list|)
block|{
name|int
name|new_fd
decl_stmt|;
operator|*
name|addrlen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|new_fd
operator|=
name|accept
argument_list|(
name|c
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fd
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
comment|/* EINTR is signal interrupt. others are closed connection. */
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECONNABORTED
operator|||
name|errno
operator|==
name|ECONNABORTED
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROTO
operator|||
name|errno
operator|==
name|EPROTO
endif|#
directive|endif
comment|/* EPROTO */
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
name|defined
argument_list|(
name|ENFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|EMFILE
argument_list|)
if|if
condition|(
name|errno
operator|==
name|ENFILE
operator|||
name|errno
operator|==
name|EMFILE
condition|)
block|{
comment|/* out of file descriptors, likely outside of our 			 * control. stop accept() calls for some time */
if|if
condition|(
name|c
operator|->
name|ev
operator|->
name|base
operator|->
name|stop_accept
condition|)
block|{
name|struct
name|comm_base
modifier|*
name|b
init|=
name|c
operator|->
name|ev
operator|->
name|base
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"out of file descriptors: "
literal|"slow accept"
argument_list|)
expr_stmt|;
name|b
operator|->
name|eb
operator|->
name|slow_accept_enabled
operator|=
literal|1
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_stop_accept
argument_list|(
name|b
operator|->
name|stop_accept
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|b
operator|->
name|stop_accept
call|)
argument_list|(
name|b
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
comment|/* set timeout, no mallocs */
name|tv
operator|.
name|tv_sec
operator|=
name|NETEVENT_SLOW_ACCEPT_TIME
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|NETEVENT_SLOW_ACCEPT_TIME
operator|%
literal|1000
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|b
operator|->
name|eb
operator|->
name|slow_accept
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|comm_base_handle_slow_accept
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|b
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|b
operator|->
name|eb
operator|->
name|slow_accept
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* we do not want to log here, because 					 * that would spam the logfiles. 					 * error: "event_base_set failed." */
block|}
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|b
operator|->
name|eb
operator|->
name|slow_accept
argument_list|,
operator|&
name|tv
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* we do not want to log here, 					 * error: "event_add failed." */
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|log_err
argument_list|(
literal|"accept failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAECONNRESET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
block|{
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"accept failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"remote address is"
argument_list|,
name|addr
argument_list|,
operator|*
name|addrlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fd_set_nonblock
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
return|return
name|new_fd
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINSOCK
end_ifdef

begin_function
specifier|static
name|long
name|win_bio_cb
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|oper
parameter_list|,
specifier|const
name|char
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|argp
parameter_list|)
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|argi
parameter_list|)
parameter_list|,
name|long
name|argl
parameter_list|,
name|long
name|retvalue
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"bio_cb %d, %s %s %s"
argument_list|,
name|oper
argument_list|,
operator|(
name|oper
operator|&
name|BIO_CB_RETURN
operator|)
condition|?
literal|"return"
else|:
literal|"before"
argument_list|,
operator|(
name|oper
operator|&
name|BIO_CB_READ
operator|)
condition|?
literal|"read"
else|:
operator|(
operator|(
name|oper
operator|&
name|BIO_CB_WRITE
operator|)
condition|?
literal|"write"
else|:
literal|"other"
operator|)
argument_list|,
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|?
literal|"wsawb"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* on windows, check if previous operation caused EWOULDBLOCK */
if|if
condition|(
operator|(
name|oper
operator|==
operator|(
name|BIO_CB_READ
operator||
name|BIO_CB_RETURN
operator|)
operator|&&
name|argl
operator|==
literal|0
operator|)
operator|||
operator|(
name|oper
operator|==
operator|(
name|BIO_CB_GETS
operator||
name|BIO_CB_RETURN
operator|)
operator|&&
name|argl
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
name|winsock_tcp_wouldblock
argument_list|(
operator|(
expr|struct
name|event
operator|*
operator|)
name|BIO_get_callback_arg
argument_list|(
name|b
argument_list|)
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oper
operator|==
operator|(
name|BIO_CB_WRITE
operator||
name|BIO_CB_RETURN
operator|)
operator|&&
name|argl
operator|==
literal|0
operator|)
operator|||
operator|(
name|oper
operator|==
operator|(
name|BIO_CB_PUTS
operator||
name|BIO_CB_RETURN
operator|)
operator|&&
name|argl
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
name|winsock_tcp_wouldblock
argument_list|(
operator|(
expr|struct
name|event
operator|*
operator|)
name|BIO_get_callback_arg
argument_list|(
name|b
argument_list|)
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
block|}
comment|/* return original return value */
return|return
name|retvalue
return|;
block|}
end_function

begin_comment
comment|/** set win bio callbacks for nonblocking operations */
end_comment

begin_function
name|void
name|comm_point_tcp_win_bio_cb
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|thessl
parameter_list|)
block|{
name|SSL
modifier|*
name|ssl
init|=
operator|(
name|SSL
operator|*
operator|)
name|thessl
decl_stmt|;
comment|/* set them both just in case, but usually they are the same BIO */
name|BIO_set_callback
argument_list|(
name|SSL_get_rbio
argument_list|(
name|ssl
argument_list|)
argument_list|,
operator|&
name|win_bio_cb
argument_list|)
expr_stmt|;
name|BIO_set_callback_arg
argument_list|(
name|SSL_get_rbio
argument_list|(
name|ssl
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
expr_stmt|;
name|BIO_set_callback
argument_list|(
name|SSL_get_wbio
argument_list|(
name|ssl
argument_list|)
argument_list|,
operator|&
name|win_bio_cb
argument_list|)
expr_stmt|;
name|BIO_set_callback_arg
argument_list|(
name|SSL_get_wbio
argument_list|(
name|ssl
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|comm_point_tcp_accept_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|arg
decl_stmt|,
modifier|*
name|c_hdl
decl_stmt|;
name|int
name|new_fd
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp_accept
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|EV_READ
operator|)
condition|)
block|{
name|log_info
argument_list|(
literal|"ignoring tcp accept event %d"
argument_list|,
operator|(
name|int
operator|)
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|comm_base_now
argument_list|(
name|c
operator|->
name|ev
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* find free tcp handler. */
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_free
condition|)
block|{
name|log_warn
argument_list|(
literal|"accepted too many tcp, connections full"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* accept incoming connection. */
name|c_hdl
operator|=
name|c
operator|->
name|tcp_free
expr_stmt|;
name|log_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new_fd
operator|=
name|comm_point_perform_accept
argument_list|(
name|c
argument_list|,
operator|&
name|c_hdl
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
operator|&
name|c_hdl
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fd
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|ssl
condition|)
block|{
name|c_hdl
operator|->
name|ssl
operator|=
name|incoming_ssl_fd
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|new_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_hdl
operator|->
name|ssl
condition|)
block|{
name|c_hdl
operator|->
name|fd
operator|=
name|new_fd
expr_stmt|;
name|comm_point_close
argument_list|(
name|c_hdl
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_hdl
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_read
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|comm_point_tcp_win_bio_cb
argument_list|(
name|c_hdl
argument_list|,
name|c_hdl
operator|->
name|ssl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* grab the tcp handler buffers */
name|c
operator|->
name|tcp_free
operator|=
name|c_hdl
operator|->
name|tcp_free
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_free
condition|)
block|{
comment|/* stop accepting incoming queries for now. */
name|comm_point_stop_listening
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* addr is dropped. Not needed for tcp reply. */
name|setup_tcp_handler
argument_list|(
name|c_hdl
argument_list|,
name|new_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Make tcp handler free for next assignment */
end_comment

begin_function
specifier|static
name|void
name|reclaim_tcp_handler
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ssl
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|SSL_shutdown
argument_list|(
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|c
operator|->
name|ssl
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|comm_point_close
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_parent
condition|)
block|{
name|c
operator|->
name|tcp_free
operator|=
name|c
operator|->
name|tcp_parent
operator|->
name|tcp_free
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|->
name|tcp_free
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_free
condition|)
block|{
comment|/* re-enable listening on accept socket */
name|comm_point_start_listening
argument_list|(
name|c
operator|->
name|tcp_parent
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** do the callback when writing is done */
end_comment

begin_function
specifier|static
name|void
name|tcp_callback_writer
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
argument_list|)
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_do_toggle_rw
condition|)
name|c
operator|->
name|tcp_is_reading
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
comment|/* switch from listening(write) to listening(read) */
name|comm_point_stop_listening
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|comm_point_start_listening
argument_list|(
name|c
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** do the callback when reading is done */
end_comment

begin_function
specifier|static
name|void
name|tcp_callback_reader
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
operator|||
name|c
operator|->
name|type
operator|==
name|comm_local
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_do_toggle_rw
condition|)
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
condition|)
name|comm_point_stop_listening
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|c
operator|->
name|callback
call|)
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
operator|&
name|c
operator|->
name|repinfo
argument_list|)
condition|)
block|{
name|comm_point_start_listening
argument_list|(
name|c
argument_list|,
operator|-
literal|1
argument_list|,
name|TCP_QUERY_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** continue ssl handshake */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_function
specifier|static
name|int
name|ssl_handshake
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|==
name|comm_ssl_shake_hs_read
condition|)
block|{
comment|/* read condition satisfied back to writing */
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_none
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|==
name|comm_ssl_shake_hs_write
condition|)
block|{
comment|/* write condition satisfied, back to reading */
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_none
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
block|{
name|int
name|want
init|=
name|SSL_get_error
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|==
name|comm_ssl_shake_read
condition|)
return|return
literal|1
return|;
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_read
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|==
name|comm_ssl_shake_write
condition|)
return|return
literal|1
return|;
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_write
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
comment|/* closed */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_SYSCALL
condition|)
block|{
comment|/* SYSCALL and errno==0 means closed uncleanly */
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"SSL_handshake syscall: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|log_crypto_err
argument_list|(
literal|"ssl handshake failed"
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
literal|1
argument_list|,
literal|"ssl handshake failed"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* this is where peer verification could take place */
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"SSL DNS connection"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
comment|/* setup listen rw correctly */
if|if
condition|(
name|c
operator|->
name|tcp_is_reading
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|!=
name|comm_ssl_shake_read
condition|)
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_none
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_comment
comment|/** ssl read callback on TCP */
end_comment

begin_function
specifier|static
name|int
name|ssl_handle_read
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|int
name|r
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|!=
name|comm_ssl_shake_none
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_handshake
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|!=
name|comm_ssl_shake_none
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
block|{
comment|/* read length bytes */
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_read
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|c
operator|->
name|tcp_byte_count
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|-
name|c
operator|->
name|tcp_byte_count
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|int
name|want
init|=
name|SSL_get_error
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
return|return
literal|0
return|;
comment|/* shutdown, closed */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
return|return
literal|1
return|;
comment|/* read more later */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_hs_write
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_SYSCALL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"SSL_read syscall: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_crypto_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|tcp_byte_count
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
operator|>
name|sldns_buffer_capacity
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"ssl: dropped larger than buffer"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_set_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|<
name|LDNS_HEADER_SIZE
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"ssl: dropped bogus too short."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Reading ssl tcp query of length %d"
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log_assert
argument_list|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|r
operator|=
name|SSL_read
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_current
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
name|int
name|want
init|=
name|SSL_get_error
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
return|return
literal|0
return|;
comment|/* shutdown, closed */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
return|return
literal|1
return|;
comment|/* read more later */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_hs_write
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_SYSCALL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"SSL_read syscall: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_crypto_err
argument_list|(
literal|"could not SSL_read"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_skip
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
operator|(
name|ssize_t
operator|)
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tcp_callback_reader
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|c
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_SSL */
block|}
end_function

begin_comment
comment|/** ssl write callback on TCP */
end_comment

begin_function
specifier|static
name|int
name|ssl_handle_write
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|int
name|r
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|!=
name|comm_ssl_shake_none
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_handshake
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|ssl_shake_state
operator|!=
name|comm_ssl_shake_none
condition|)
return|return
literal|1
return|;
block|}
comment|/* ignore return, if fails we may simply block */
operator|(
name|void
operator|)
name|SSL_set_mode
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|SSL_MODE_ENABLE_PARTIAL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
block|{
name|uint16_t
name|len
init|=
name|htons
argument_list|(
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|r
operator|=
name|SSL_write
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|len
operator|)
operator|+
name|c
operator|->
name|tcp_byte_count
operator|)
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|-
name|c
operator|->
name|tcp_byte_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
name|int
name|want
init|=
name|SSL_get_error
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
return|return
literal|0
return|;
comment|/* closed */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_read
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* wait for read condition */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
return|return
literal|1
return|;
comment|/* write more later */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_SYSCALL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"SSL_write syscall: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_crypto_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|tcp_byte_count
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
literal|1
return|;
name|sldns_buffer_set_position
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|c
operator|->
name|tcp_byte_count
operator|-
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tcp_callback_writer
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|log_assert
argument_list|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|r
operator|=
name|SSL_write
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_current
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
name|int
name|want
init|=
name|SSL_get_error
argument_list|(
name|c
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
return|return
literal|0
return|;
comment|/* closed */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_read
expr_stmt|;
name|comm_point_listen_for_rw
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* wait for read condition */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
return|return
literal|1
return|;
comment|/* write more later */
block|}
elseif|else
if|if
condition|(
name|want
operator|==
name|SSL_ERROR_SYSCALL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"SSL_write syscall: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_crypto_err
argument_list|(
literal|"could not SSL_write"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_skip
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
operator|(
name|ssize_t
operator|)
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tcp_callback_writer
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|c
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_SSL */
block|}
end_function

begin_comment
comment|/** handle ssl tcp connection with dns contents */
end_comment

begin_function
specifier|static
name|int
name|ssl_handle_it
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|tcp_is_reading
condition|)
return|return
name|ssl_handle_read
argument_list|(
name|c
argument_list|)
return|;
return|return
name|ssl_handle_write
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Handle tcp reading callback.   * @param fd: file descriptor of socket.  * @param c: comm point to read from into buffer.  * @param short_ok: if true, very short packets are OK (for comm_local).  * @return: 0 on error   */
end_comment

begin_function
specifier|static
name|int
name|comm_point_tcp_handle_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|int
name|short_ok
parameter_list|)
block|{
name|ssize_t
name|r
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
operator|||
name|c
operator|->
name|type
operator|==
name|comm_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ssl
condition|)
return|return
name|ssl_handle_it
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_is_reading
condition|)
return|return
literal|0
return|;
name|log_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
block|{
comment|/* read length bytes */
name|r
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|c
operator|->
name|tcp_byte_count
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|-
name|c
operator|->
name|tcp_byte_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|ECONNRESET
if|if
condition|(
name|errno
operator|==
name|ECONNRESET
operator|&&
name|verbosity
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* silence reset by peer */
endif|#
directive|endif
name|log_err
argument_list|(
literal|"read (in tcp s): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAECONNRESET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
block|{
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"read (in tcp s): %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"remote address is"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|tcp_byte_count
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
operator|>
name|sldns_buffer_capacity
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"tcp: dropped larger than buffer"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_set_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|short_ok
operator|&&
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|<
name|LDNS_HEADER_SIZE
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"tcp: dropped bogus too short."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Reading tcp query of length %d"
argument_list|,
operator|(
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log_assert
argument_list|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_current
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"read (in tcp r): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAECONNRESET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
block|{
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"read (in tcp r): %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"remote address is"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_skip
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tcp_callback_reader
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**   * Handle tcp writing callback.   * @param fd: file descriptor of socket.  * @param c: comm point to write buffer out of.  * @return: 0 on error  */
end_comment

begin_function
specifier|static
name|int
name|comm_point_tcp_handle_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|ssize_t
name|r
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_is_reading
operator|&&
operator|!
name|c
operator|->
name|ssl
condition|)
return|return
literal|0
return|;
name|log_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|==
literal|0
operator|&&
name|c
operator|->
name|tcp_check_nb_connect
condition|)
block|{
comment|/* check for pending error from nonblocking connect */
comment|/* from Stevens, unix network programming, vol1, 3rd ed, p450*/
name|int
name|error
init|=
literal|0
decl_stmt|;
name|socklen_t
name|len
init|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|error
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|error
operator|=
name|errno
expr_stmt|;
comment|/* on solaris errno is error */
else|#
directive|else
comment|/* USE_WINSOCK */
name|error
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|#
directive|if
name|defined
argument_list|(
name|EINPROGRESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
return|return
literal|1
return|;
comment|/* try again later */
elseif|else
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|verbosity
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* silence lots of chatter in the logs */
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"tcp connect: %s"
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
comment|/* examine error */
if|if
condition|(
name|error
operator|==
name|WSAEINPROGRESS
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|error
operator|==
name|WSAEWOULDBLOCK
condition|)
block|{
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|verbosity
operator|<
literal|2
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"tcp connect: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WINSOCK */
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"remote address is"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|c
operator|->
name|ssl
condition|)
return|return
name|ssl_handle_it
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
block|{
name|uint16_t
name|len
init|=
name|htons
argument_list|(
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_WRITEV
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|len
operator|+
name|c
operator|->
name|tcp_byte_count
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|-
name|c
operator|->
name|tcp_byte_count
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|writev
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_WRITEV */
name|r
operator|=
name|send
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|len
operator|)
operator|+
name|c
operator|->
name|tcp_byte_count
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|-
name|c
operator|->
name|tcp_byte_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_WRITEV */
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
ifdef|#
directive|ifdef
name|EPIPE
if|if
condition|(
name|errno
operator|==
name|EPIPE
operator|&&
name|verbosity
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* silence 'broken pipe' */
endif|#
directive|endif
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"tcp writev: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAENOTCONN
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
block|{
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"tcp send s: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"remote address is"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|tcp_byte_count
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_byte_count
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
literal|1
return|;
name|sldns_buffer_set_position
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|c
operator|->
name|tcp_byte_count
operator|-
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tcp_callback_writer
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|log_assert
argument_list|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|send
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_current
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|1
return|;
name|log_err
argument_list|(
literal|"tcp send r: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEINPROGRESS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEWOULDBLOCK
condition|)
block|{
name|winsock_tcp_wouldblock
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"tcp send r: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"remote address is"
argument_list|,
operator|&
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
name|c
operator|->
name|repinfo
operator|.
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_skip
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_remaining
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tcp_callback_writer
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|void
name|comm_point_tcp_handle_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|arg
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
argument_list|)
expr_stmt|;
name|comm_base_now
argument_list|(
name|c
operator|->
name|ev
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_READ
condition|)
block|{
if|if
condition|(
operator|!
name|comm_point_tcp_handle_read
argument_list|(
name|fd
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|reclaim_tcp_handler
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_do_close
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|c
operator|->
name|callback
argument_list|)
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|event
operator|&
name|EV_WRITE
condition|)
block|{
if|if
condition|(
operator|!
name|comm_point_tcp_handle_write
argument_list|(
name|fd
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|reclaim_tcp_handler
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_do_close
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|c
operator|->
name|callback
argument_list|)
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|event
operator|&
name|EV_TIMEOUT
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"tcp took too long, dropped"
argument_list|)
expr_stmt|;
name|reclaim_tcp_handler
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_do_close
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|c
operator|->
name|callback
argument_list|)
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|log_err
argument_list|(
literal|"Ignored event %d for tcphdl."
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|void
name|comm_point_local_handle_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|arg
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_local
argument_list|)
expr_stmt|;
name|comm_base_now
argument_list|(
name|c
operator|->
name|ev
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_READ
condition|)
block|{
if|if
condition|(
operator|!
name|comm_point_tcp_handle_read
argument_list|(
name|fd
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point
argument_list|(
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|c
operator|->
name|callback
argument_list|)
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|log_err
argument_list|(
literal|"Ignored event %d for localhdl."
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|void
name|comm_point_raw_handle_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|err
init|=
name|NETEVENT_NOERROR
decl_stmt|;
name|log_assert
argument_list|(
name|c
operator|->
name|type
operator|==
name|comm_raw
argument_list|)
expr_stmt|;
name|comm_base_now
argument_list|(
name|c
operator|->
name|ev
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_TIMEOUT
condition|)
name|err
operator|=
name|NETEVENT_TIMEOUT
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_point_raw
argument_list|(
name|c
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|c
operator|->
name|callback
argument_list|)
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|struct
name|comm_point
modifier|*
name|comm_point_create_udp
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|c
operator|->
name|timeout
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_udp
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|evbits
operator|=
name|EV_READ
operator||
name|EV_PERSIST
expr_stmt|;
comment|/* libevent stuff */
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_udp_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not baseset udp event"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
operator|&&
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not add udp event"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
name|struct
name|comm_point
modifier|*
name|comm_point_create_udp_ancil
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|c
operator|->
name|timeout
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_udp
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|evbits
operator|=
name|EV_READ
operator||
name|EV_PERSIST
expr_stmt|;
comment|/* libevent stuff */
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_udp_ancil_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not baseset udp event"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
operator|&&
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not add udp event"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
specifier|static
name|struct
name|comm_point
modifier|*
name|comm_point_create_tcp_handler
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|struct
name|comm_point
modifier|*
name|parent
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|buffer
condition|)
block|{
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|timeout
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|timeout
condition|)
block|{
name|sldns_buffer_free
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|parent
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_tcp
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|repinfo
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
comment|/* add to parent free list */
name|c
operator|->
name|tcp_free
operator|=
name|parent
operator|->
name|tcp_free
expr_stmt|;
name|parent
operator|->
name|tcp_free
operator|=
name|c
expr_stmt|;
comment|/* libevent stuff */
name|evbits
operator|=
name|EV_PERSIST
operator||
name|EV_READ
operator||
name|EV_TIMEOUT
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_tcp_handle_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not basetset tcphdl event"
argument_list|)
expr_stmt|;
name|parent
operator|->
name|tcp_free
operator|=
name|c
operator|->
name|tcp_free
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
name|struct
name|comm_point
modifier|*
name|comm_point_create_tcp
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|num
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* first allocate the TCP accept listener */
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|timeout
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
name|num
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
operator|(
expr|struct
name|comm_point
operator|*
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_handlers
condition|)
block|{
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_tcp_accept
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|NULL
expr_stmt|;
name|evbits
operator|=
name|EV_READ
operator||
name|EV_PERSIST
expr_stmt|;
comment|/* libevent stuff */
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_tcp_accept_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
operator|||
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not add tcpacc event"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* now prealloc the tcp handlers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|->
name|tcp_handlers
index|[
name|i
index|]
operator|=
name|comm_point_create_tcp_handler
argument_list|(
name|base
argument_list|,
name|c
argument_list|,
name|bufsize
argument_list|,
name|callback
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|tcp_handlers
index|[
name|i
index|]
condition|)
block|{
name|comm_point_delete
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|c
return|;
block|}
name|struct
name|comm_point
modifier|*
name|comm_point_create_tcp_out
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|buffer
condition|)
block|{
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|timeout
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_tcp
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|repinfo
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|evbits
operator|=
name|EV_PERSIST
operator||
name|EV_WRITE
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_tcp_handle_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not basetset tcpout event"
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
name|struct
name|comm_point
modifier|*
name|comm_point_create_local
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|buffer
condition|)
block|{
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|timeout
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_local
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
comment|/* libevent stuff */
name|evbits
operator|=
name|EV_PERSIST
operator||
name|EV_READ
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_local_handle_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
operator|||
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not add localhdl event"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
name|struct
name|comm_point
modifier|*
name|comm_point_create_raw
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|writing
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|comm_point
modifier|*
name|c
init|=
operator|(
expr|struct
name|comm_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_point
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|evbits
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
name|c
operator|->
name|ev
operator|=
operator|(
expr|struct
name|internal_event
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ev
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|ev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|c
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|c
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|timeout
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_parent
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|max_tcp_count
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_handlers
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tcp_free
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|comm_raw
expr_stmt|;
name|c
operator|->
name|tcp_do_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|do_not_close
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|tcp_do_toggle_rw
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tcp_check_nb_connect
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
comment|/* libevent stuff */
if|if
condition|(
name|writing
condition|)
name|evbits
operator|=
name|EV_PERSIST
operator||
name|EV_WRITE
expr_stmt|;
else|else
name|evbits
operator|=
name|EV_PERSIST
operator||
name|EV_READ
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|evbits
argument_list|,
name|comm_point_raw_handle_callback
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
operator|||
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not add rawhdl event"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
name|void
name|comm_point_close
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|event_del
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not event_del on close"
argument_list|)
expr_stmt|;
block|}
comment|/* close fd after removing from event lists, or epoll.. is messed up */
if|if
condition|(
name|c
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|c
operator|->
name|do_not_close
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"close fd %d"
argument_list|,
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|c
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|void
name|comm_point_delete
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
operator|&&
name|c
operator|->
name|ssl
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|SSL_shutdown
argument_list|(
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|comm_point_close
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_handlers
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|max_tcp_count
condition|;
name|i
operator|++
control|)
name|comm_point_delete
argument_list|(
name|c
operator|->
name|tcp_handlers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|tcp_handlers
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
operator|||
name|c
operator|->
name|type
operator|==
name|comm_local
condition|)
name|sldns_buffer_free
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|void
name|comm_point_send_reply
parameter_list|(
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
name|log_assert
argument_list|(
name|repinfo
operator|&&
name|repinfo
operator|->
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|repinfo
operator|->
name|c
operator|->
name|type
operator|==
name|comm_udp
condition|)
block|{
if|if
condition|(
name|repinfo
operator|->
name|srctype
condition|)
name|comm_point_send_udp_msg_if
argument_list|(
name|repinfo
operator|->
name|c
argument_list|,
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|,
name|repinfo
argument_list|)
expr_stmt|;
else|else
name|comm_point_send_udp_msg
argument_list|(
name|repinfo
operator|->
name|c
argument_list|,
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|comm_point_start_listening
argument_list|(
name|repinfo
operator|->
name|c
argument_list|,
operator|-
literal|1
argument_list|,
name|TCP_QUERY_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|comm_point_drop_reply
parameter_list|(
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|repinfo
condition|)
return|return;
name|log_assert
argument_list|(
name|repinfo
operator|&&
name|repinfo
operator|->
name|c
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|repinfo
operator|->
name|c
operator|->
name|type
operator|!=
name|comm_tcp_accept
argument_list|)
expr_stmt|;
if|if
condition|(
name|repinfo
operator|->
name|c
operator|->
name|type
operator|==
name|comm_udp
condition|)
return|return;
name|reclaim_tcp_handler
argument_list|(
name|repinfo
operator|->
name|c
argument_list|)
expr_stmt|;
block|}
name|void
name|comm_point_stop_listening
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"comm point stop listening %d"
argument_list|,
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_del
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"event_del error to stoplisten"
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|comm_point_start_listening
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|int
name|newfd
parameter_list|,
name|int
name|sec
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"comm point start listening %d"
argument_list|,
name|c
operator|->
name|fd
operator|==
operator|-
literal|1
condition|?
name|newfd
else|:
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp_accept
operator|&&
operator|!
name|c
operator|->
name|tcp_free
condition|)
block|{
comment|/* no use to start listening no free slots. */
return|return;
block|}
if|if
condition|(
name|sec
operator|!=
operator|-
literal|1
operator|&&
name|sec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|timeout
condition|)
block|{
name|c
operator|->
name|timeout
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|timeout
condition|)
block|{
name|log_err
argument_list|(
literal|"cpsl: malloc failed. No net read."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator||=
name|EV_TIMEOUT
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
comment|/* splint fails on struct timeval. */
name|c
operator|->
name|timeout
operator|->
name|tv_sec
operator|=
name|sec
expr_stmt|;
name|c
operator|->
name|timeout
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* S_SPLINT_S */
block|}
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
condition|)
block|{
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator|&=
operator|~
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|tcp_is_reading
condition|)
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator||=
name|EV_READ
expr_stmt|;
else|else
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator||=
name|EV_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|newfd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|c
operator|->
name|fd
operator|=
name|newfd
expr_stmt|;
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_fd
operator|=
name|c
operator|->
name|fd
expr_stmt|;
block|}
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|sec
operator|==
literal|0
condition|?
name|NULL
else|:
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"event_add failed. in cpsl."
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|comm_point_listen_for_rw
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|int
name|rd
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"comm point listen_for_rw %d %d"
argument_list|,
name|c
operator|->
name|fd
argument_list|,
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_del
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"event_del error to cplf"
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator|&=
operator|~
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
expr_stmt|;
if|if
condition|(
name|rd
condition|)
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator||=
name|EV_READ
expr_stmt|;
if|if
condition|(
name|wr
condition|)
name|c
operator|->
name|ev
operator|->
name|ev
operator|.
name|ev_events
operator||=
name|EV_WRITE
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|c
operator|->
name|ev
operator|->
name|ev
argument_list|,
name|c
operator|->
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"event_add failed. in cplf."
argument_list|)
expr_stmt|;
block|}
block|}
name|size_t
name|comm_point_get_mem
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|c
operator|->
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|timeout
condition|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp
operator|||
name|c
operator|->
name|type
operator|==
name|comm_local
condition|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|c
operator|->
name|buffer
argument_list|)
operator|+
name|sldns_buffer_capacity
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_tcp_accept
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|max_tcp_count
condition|;
name|i
operator|++
control|)
name|s
operator|+=
name|comm_point_get_mem
argument_list|(
name|c
operator|->
name|tcp_handlers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
name|struct
name|comm_timer
modifier|*
name|comm_timer_create
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|comm_timer
modifier|*
name|tm
init|=
operator|(
expr|struct
name|comm_timer
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|comm_timer
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tm
condition|)
return|return
name|NULL
return|;
name|tm
operator|->
name|ev_timer
operator|=
operator|(
expr|struct
name|internal_timer
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_timer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tm
operator|->
name|ev_timer
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tm
operator|->
name|ev_timer
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|tm
operator|->
name|callback
operator|=
name|cb
expr_stmt|;
name|tm
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|tm
operator|->
name|ev_timer
operator|->
name|ev
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|comm_timer_callback
argument_list|,
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|tm
operator|->
name|ev_timer
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"timer_create: event_base_set failed."
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tm
operator|->
name|ev_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|tm
return|;
block|}
name|void
name|comm_timer_disable
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timer
condition|)
return|return;
name|evtimer_del
argument_list|(
operator|&
name|timer
operator|->
name|ev_timer
operator|->
name|ev
argument_list|)
expr_stmt|;
name|timer
operator|->
name|ev_timer
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|comm_timer_set
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|log_assert
argument_list|(
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|ev_timer
operator|->
name|enabled
condition|)
name|comm_timer_disable
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|timer
operator|->
name|ev_timer
operator|->
name|ev
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|comm_timer_callback
argument_list|,
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|timer
operator|->
name|ev_timer
operator|->
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|timer
operator|->
name|ev_timer
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"comm_timer_set: set_base failed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|evtimer_add
argument_list|(
operator|&
name|timer
operator|->
name|ev_timer
operator|->
name|ev
argument_list|,
name|tv
argument_list|)
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|"comm_timer_set: evtimer_add failed."
argument_list|)
expr_stmt|;
name|timer
operator|->
name|ev_timer
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|comm_timer_delete
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timer
condition|)
return|return;
name|comm_timer_disable
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|timer
operator|->
name|ev_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
name|void
name|comm_timer_callback
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_timer
modifier|*
name|tm
init|=
operator|(
expr|struct
name|comm_timer
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|EV_TIMEOUT
operator|)
condition|)
return|return;
name|comm_base_now
argument_list|(
name|tm
operator|->
name|ev_timer
operator|->
name|base
argument_list|)
expr_stmt|;
name|tm
operator|->
name|ev_timer
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_timer
argument_list|(
name|tm
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tm
operator|->
name|callback
call|)
argument_list|(
name|tm
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
block|}
name|int
name|comm_timer_is_set
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|timer
operator|->
name|ev_timer
operator|->
name|enabled
return|;
block|}
name|size_t
name|comm_timer_get_mem
parameter_list|(
name|struct
name|comm_timer
modifier|*
name|timer
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
operator|*
name|timer
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|internal_timer
argument_list|)
return|;
block|}
name|struct
name|comm_signal
modifier|*
name|comm_signal_create
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|comm_signal
modifier|*
name|com
init|=
operator|(
expr|struct
name|comm_signal
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|comm_signal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|com
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|com
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|com
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|com
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|com
operator|->
name|ev_signal
operator|=
name|NULL
expr_stmt|;
return|return
name|com
return|;
block|}
name|void
name|comm_signal_callback
parameter_list|(
name|int
name|sig
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|comm_signal
modifier|*
name|comsig
init|=
operator|(
expr|struct
name|comm_signal
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|EV_SIGNAL
operator|)
condition|)
return|return;
name|comm_base_now
argument_list|(
name|comsig
operator|->
name|base
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_comm_signal
argument_list|(
name|comsig
operator|->
name|callback
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|comsig
operator|->
name|callback
call|)
argument_list|(
name|sig
argument_list|,
name|comsig
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
block|}
name|int
name|comm_signal_bind
parameter_list|(
name|struct
name|comm_signal
modifier|*
name|comsig
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|internal_signal
modifier|*
name|entry
init|=
operator|(
expr|struct
name|internal_signal
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_signal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|comsig
argument_list|)
expr_stmt|;
comment|/* add signal event */
name|signal_set
argument_list|(
operator|&
name|entry
operator|->
name|ev
argument_list|,
name|sig
argument_list|,
name|comm_signal_callback
argument_list|,
name|comsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|comsig
operator|->
name|base
operator|->
name|eb
operator|->
name|base
argument_list|,
operator|&
name|entry
operator|->
name|ev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not set signal base"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|signal_add
argument_list|(
operator|&
name|entry
operator|->
name|ev
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not add signal handler"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* link into list */
name|entry
operator|->
name|next
operator|=
name|comsig
operator|->
name|ev_signal
expr_stmt|;
name|comsig
operator|->
name|ev_signal
operator|=
name|entry
expr_stmt|;
return|return
literal|1
return|;
block|}
name|void
name|comm_signal_delete
parameter_list|(
name|struct
name|comm_signal
modifier|*
name|comsig
parameter_list|)
block|{
name|struct
name|internal_signal
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|!
name|comsig
condition|)
return|return;
name|p
operator|=
name|comsig
operator|->
name|ev_signal
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|signal_del
argument_list|(
operator|&
name|p
operator|->
name|ev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|free
argument_list|(
name|comsig
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

