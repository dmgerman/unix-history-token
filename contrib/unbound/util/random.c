begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/random.c - thread safe random generator, which is reasonably secure.  *   * Copyright (c) 2007, NLnet Labs. All rights reserved.  *   * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  * Thread safe random functions. Similar to arc4random() with an explicit  * initialisation routine.  *  * The code in this file is based on arc4random from  * openssh-4.0p1/openbsd-compat/bsd-arc4random.c  * That code is also BSD licensed. Here is their statement:  *  * Copyright (c) 1996, David Mazieres<dm@uun.org>  * Copyright (c) 2008, Damien Miller<djm@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rc4.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
end_elif

begin_comment
comment|/* nspr4 */
end_comment

begin_include
include|#
directive|include
file|"prerror.h"
end_include

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"secport.h"
end_include

begin_include
include|#
directive|include
file|"pk11pub.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**   * Max random value.  Similar to RAND_MAX, but more portable  * (mingw uses only 15 bits random).  */
end_comment

begin_define
define|#
directive|define
name|MAX_VALUE
value|0x7fffffff
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_comment
comment|/**  * Struct with per-thread random state.  * Keeps SSL types away from the header file.  */
end_comment

begin_struct
struct|struct
name|ub_randstate
block|{
comment|/** key used for arc4random generation */
name|RC4_KEY
name|rc4
decl_stmt|;
comment|/** keeps track of key usage */
name|int
name|rc4_ready
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** Size of key to use (must be multiple of 8) */
end_comment

begin_define
define|#
directive|define
name|SEED_SIZE
value|24
end_define

begin_comment
comment|/** Number of bytes to reseed after */
end_comment

begin_define
define|#
directive|define
name|REKEY_BYTES
value|(1<< 24)
end_define

begin_comment
comment|/* (re)setup system seed */
end_comment

begin_function
name|void
name|ub_systemseed
parameter_list|(
name|unsigned
name|int
name|seed
parameter_list|)
block|{
comment|/* RAND_ is threadsafe, by the way */
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
block|{
comment|/* try to seed it */
name|unsigned
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|int
name|v
init|=
name|seed
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|/
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|memmove
argument_list|(
name|buf
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|v
operator|*
name|seed
operator|+
operator|(
name|unsigned
name|int
operator|)
name|i
expr_stmt|;
block|}
name|RAND_seed
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
block|{
name|log_err
argument_list|(
literal|"Random generator has no entropy "
literal|"(error %ld)"
argument_list|,
name|ERR_get_error
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_OPS
argument_list|,
literal|"openssl has no entropy, "
literal|"seeding with time and pid"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** reseed random generator */
end_comment

begin_function
specifier|static
name|void
name|ub_arc4random_stir
parameter_list|(
name|struct
name|ub_randstate
modifier|*
name|s
parameter_list|,
name|struct
name|ub_randstate
modifier|*
name|from
parameter_list|)
block|{
comment|/* not as unsigned char, but longerint so that it is 	   aligned properly on alignment sensitive platforms */
name|uint64_t
name|rand_buf
index|[
name|SEED_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|s
operator|->
name|rc4
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|rc4
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rand_buf
argument_list|,
literal|0xc
argument_list|,
sizeof|sizeof
argument_list|(
name|rand_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
condition|)
block|{
name|uint8_t
modifier|*
name|rbuf
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|rand_buf
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SEED_SIZE
condition|;
name|i
operator|++
control|)
name|rbuf
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|ub_random
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
name|ub_systemseed
argument_list|(
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
operator|^
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rand_buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|rand_buf
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* very unlikely that this happens, since we seeded 			 * above, if it does; complain and keep going */
name|log_err
argument_list|(
literal|"Couldn't obtain random bytes (error %ld)"
argument_list|,
name|ERR_get_error
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|->
name|rc4_ready
operator|=
literal|256
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_FIPS_MODE
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
block|{
comment|/* RC4 is not allowed, get some trustworthy randomness */
comment|/* double certainty here, this routine should not be 		 * called in FIPS_mode */
name|memset
argument_list|(
name|rand_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rand_buf
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|rc4_ready
operator|=
name|REKEY_BYTES
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* FIPS_MODE */
name|RC4_set_key
argument_list|(
operator|&
name|s
operator|->
name|rc4
argument_list|,
name|SEED_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rand_buf
argument_list|)
expr_stmt|;
comment|/* 	 * Discard early keystream, as per recommendations in: 	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|rand_buf
argument_list|)
control|)
name|RC4
argument_list|(
operator|&
name|s
operator|->
name|rc4
argument_list|,
sizeof|sizeof
argument_list|(
name|rand_buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rand_buf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rand_buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rand_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rand_buf
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|rc4_ready
operator|=
name|REKEY_BYTES
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ub_randstate
modifier|*
name|ub_initstate
parameter_list|(
name|unsigned
name|int
name|seed
parameter_list|,
name|struct
name|ub_randstate
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|ub_randstate
modifier|*
name|s
init|=
operator|(
expr|struct
name|ub_randstate
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in random init"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ub_systemseed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FIPS_MODE
if|if
condition|(
operator|!
name|FIPS_mode
argument_list|()
condition|)
endif|#
directive|endif
name|ub_arc4random_stir
argument_list|(
name|s
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|long
name|int
name|ub_random
parameter_list|(
name|struct
name|ub_randstate
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|int
name|r
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FIPS_MODE
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
block|{
comment|/* RC4 is not allowed, get some trustworthy randomness */
comment|/* we use pseudo bytes: it tries to return secure randomness 		 * but returns 'something' if that fails.  We need something 		 * else if it fails, because we cannot block here */
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|r
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"FIPSmode, no arc4random but RAND failed "
literal|"(error %ld)"
argument_list|,
name|ERR_get_error
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
call|(
name|long
name|int
call|)
argument_list|(
operator|(
name|r
operator|)
operator|%
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|MAX_VALUE
operator|+
literal|1
operator|)
operator|)
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* FIPS_MODE */
if|if
condition|(
name|s
operator|->
name|rc4_ready
operator|<=
literal|0
condition|)
block|{
name|ub_arc4random_stir
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|RC4
argument_list|(
operator|&
name|s
operator|->
name|rc4
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|r
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|r
argument_list|)
expr_stmt|;
name|s
operator|->
name|rc4_ready
operator|-=
sizeof|sizeof
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
call|(
name|long
name|int
call|)
argument_list|(
operator|(
name|r
operator|)
operator|%
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|MAX_VALUE
operator|+
literal|1
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
end_elif

begin_comment
comment|/* not much to remember for NSS since we use its pk11_random, placeholder */
end_comment

begin_struct
struct|struct
name|ub_randstate
block|{
name|int
name|ready
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|void
name|ub_systemseed
argument_list|(
name|unsigned
name|int
name|ATTR_UNUSED
argument_list|(
name|seed
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|struct
name|ub_randstate
modifier|*
name|ub_initstate
argument_list|(
name|unsigned
name|int
name|ATTR_UNUSED
argument_list|(
name|seed
argument_list|)
argument_list|,
expr|struct
name|ub_randstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|from
argument_list|)
argument_list|)
block|{
name|struct
name|ub_randstate
modifier|*
name|s
init|=
operator|(
expr|struct
name|ub_randstate
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in random init"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|ub_random
argument_list|(
expr|struct
name|ub_randstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|state
argument_list|)
argument_list|)
block|{
name|long
name|int
name|x
decl_stmt|;
comment|/* random 31 bit value. */
name|SECStatus
name|s
init|=
name|PK11_GenerateRandom
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|x
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
name|log_err
argument_list|(
literal|"PK11_GenerateRandom error: %s"
argument_list|,
name|PORT_ErrorToString
argument_list|(
name|PORT_GetError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
operator|&
name|MAX_VALUE
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL or HAVE_NSS */
end_comment

begin_function
name|long
name|int
name|ub_random_max
parameter_list|(
name|struct
name|ub_randstate
modifier|*
name|state
parameter_list|,
name|long
name|int
name|x
parameter_list|)
block|{
comment|/* make sure we fetch in a range that is divisible by x. ignore 	 * values from d .. MAX_VALUE, instead draw a new number */
name|long
name|int
name|d
init|=
name|MAX_VALUE
operator|-
operator|(
name|MAX_VALUE
operator|%
name|x
operator|)
decl_stmt|;
comment|/* d is divisible by x */
name|long
name|int
name|v
init|=
name|ub_random
argument_list|(
name|state
argument_list|)
decl_stmt|;
while|while
condition|(
name|d
operator|<=
name|v
condition|)
name|v
operator|=
name|ub_random
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|%
name|x
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ub_randfree
parameter_list|(
name|struct
name|ub_randstate
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
condition|)
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* user app must do RAND_cleanup(); */
block|}
end_function

end_unit

