begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infback9.c -- inflate deflate64 data using a call-back interface  * Copyright (C) 1995-2008 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"infback9.h"
end_include

begin_include
include|#
directive|include
file|"inftree9.h"
end_include

begin_include
include|#
directive|include
file|"inflate9.h"
end_include

begin_define
define|#
directive|define
name|WSIZE
value|65536UL
end_define

begin_comment
comment|/*    strm provides memory allocation functions in zalloc and zfree, or    Z_NULL to use the library memory allocation functions.     window is a user-supplied window and output buffer that is 64K bytes.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflateBack9Init_
parameter_list|(
name|strm
parameter_list|,
name|window
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_stream
name|FAR
modifier|*
name|strm
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|window
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|version
operator|==
name|Z_NULL
operator|||
name|version
index|[
literal|0
index|]
operator|!=
name|ZLIB_VERSION
index|[
literal|0
index|]
operator|||
name|stream_size
operator|!=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
condition|)
return|return
name|Z_VERSION_ERROR
return|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|window
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
comment|/* in case we return an error */
if|if
condition|(
name|strm
operator|->
name|zalloc
operator|==
operator|(
name|alloc_func
operator|)
literal|0
condition|)
block|{
name|strm
operator|->
name|zalloc
operator|=
name|zcalloc
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
name|strm
operator|->
name|zfree
operator|=
name|zcfree
expr_stmt|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: allocated\n"
operator|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
operator|(
name|voidpf
operator|)
name|state
expr_stmt|;
name|state
operator|->
name|window
operator|=
name|window
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*    Build and output length and distance decoding tables for fixed code    decoding.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAKEFIXED
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|void
name|makefixed9
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|sym
decl_stmt|,
name|bits
decl_stmt|,
name|low
decl_stmt|,
name|size
decl_stmt|;
name|code
modifier|*
name|next
decl_stmt|,
modifier|*
name|lenfix
decl_stmt|,
modifier|*
name|distfix
decl_stmt|;
name|struct
name|inflate_state
name|state
decl_stmt|;
name|code
name|fixed
index|[
literal|544
index|]
decl_stmt|;
comment|/* literal/length table */
name|sym
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|144
condition|)
name|state
operator|.
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|256
condition|)
name|state
operator|.
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|9
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|280
condition|)
name|state
operator|.
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|7
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|288
condition|)
name|state
operator|.
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|8
expr_stmt|;
name|next
operator|=
name|fixed
expr_stmt|;
name|lenfix
operator|=
name|next
expr_stmt|;
name|bits
operator|=
literal|9
expr_stmt|;
name|inflate_table9
argument_list|(
name|LENS
argument_list|,
name|state
operator|.
name|lens
argument_list|,
literal|288
argument_list|,
operator|&
operator|(
name|next
operator|)
argument_list|,
operator|&
operator|(
name|bits
operator|)
argument_list|,
name|state
operator|.
name|work
argument_list|)
expr_stmt|;
comment|/* distance table */
name|sym
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|32
condition|)
name|state
operator|.
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|5
expr_stmt|;
name|distfix
operator|=
name|next
expr_stmt|;
name|bits
operator|=
literal|5
expr_stmt|;
name|inflate_table9
argument_list|(
name|DISTS
argument_list|,
name|state
operator|.
name|lens
argument_list|,
literal|32
argument_list|,
operator|&
operator|(
name|next
operator|)
argument_list|,
operator|&
operator|(
name|bits
operator|)
argument_list|,
name|state
operator|.
name|work
argument_list|)
expr_stmt|;
comment|/* write tables */
name|puts
argument_list|(
literal|"    /* inffix9.h -- table for decoding deflate64 fixed codes"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     * Generated automatically by makefixed9()."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     */"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    /* WARNING: this file should *not* be used by applications."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"       It is part of the implementation of this library and is"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"       subject to change. Applications should only use zlib.h."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     */"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1U
operator|<<
literal|9
expr_stmt|;
name|printf
argument_list|(
literal|"    static const code lenfix[%u] = {"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|low
operator|%
literal|6
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n        "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{%u,%u,%d}"
argument_list|,
name|lenfix
index|[
name|low
index|]
operator|.
name|op
argument_list|,
name|lenfix
index|[
name|low
index|]
operator|.
name|bits
argument_list|,
name|lenfix
index|[
name|low
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|low
operator|==
name|size
condition|)
break|break;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\n    };"
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1U
operator|<<
literal|5
expr_stmt|;
name|printf
argument_list|(
literal|"\n    static const code distfix[%u] = {"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|low
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n        "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{%u,%u,%d}"
argument_list|,
name|distfix
index|[
name|low
index|]
operator|.
name|op
argument_list|,
name|distfix
index|[
name|low
index|]
operator|.
name|bits
argument_list|,
name|distfix
index|[
name|low
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|low
operator|==
name|size
condition|)
break|break;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\n    };"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKEFIXED */
end_comment

begin_comment
comment|/* Macros for inflateBack(): */
end_comment

begin_comment
comment|/* Clear the input bit accumulator */
end_comment

begin_define
define|#
directive|define
name|INITBITS
parameter_list|()
define|\
value|do { \         hold = 0; \         bits = 0; \     } while (0)
end_define

begin_comment
comment|/* Assure that some input is available.  If input is requested, but denied,    then return a Z_BUF_ERROR from inflateBack(). */
end_comment

begin_define
define|#
directive|define
name|PULL
parameter_list|()
define|\
value|do { \         if (have == 0) { \             have = in(in_desc,&next); \             if (have == 0) { \                 next = Z_NULL; \                 ret = Z_BUF_ERROR; \                 goto inf_leave; \             } \         } \     } while (0)
end_define

begin_comment
comment|/* Get a byte of input into the bit accumulator, or return from inflateBack()    with an error if there is no input available. */
end_comment

begin_define
define|#
directive|define
name|PULLBYTE
parameter_list|()
define|\
value|do { \         PULL(); \         have--; \         hold += (unsigned long)(*next++)<< bits; \         bits += 8; \     } while (0)
end_define

begin_comment
comment|/* Assure that there are at least n bits in the bit accumulator.  If there is    not enough available input to do that, then return from inflateBack() with    an error. */
end_comment

begin_define
define|#
directive|define
name|NEEDBITS
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \         while (bits< (unsigned)(n)) \             PULLBYTE(); \     } while (0)
end_define

begin_comment
comment|/* Return the low n bits of the bit accumulator (n<= 16) */
end_comment

begin_define
define|#
directive|define
name|BITS
parameter_list|(
name|n
parameter_list|)
define|\
value|((unsigned)hold& ((1U<< (n)) - 1))
end_define

begin_comment
comment|/* Remove n bits from the bit accumulator */
end_comment

begin_define
define|#
directive|define
name|DROPBITS
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \         hold>>= (n); \         bits -= (unsigned)(n); \     } while (0)
end_define

begin_comment
comment|/* Remove zero to seven bits as needed to go to a byte boundary */
end_comment

begin_define
define|#
directive|define
name|BYTEBITS
parameter_list|()
define|\
value|do { \         hold>>= bits& 7; \         bits -= bits& 7; \     } while (0)
end_define

begin_comment
comment|/* Assure that some output space is available, by writing out the window    if it's full.  If the write fails, return from inflateBack() with a    Z_BUF_ERROR. */
end_comment

begin_define
define|#
directive|define
name|ROOM
parameter_list|()
define|\
value|do { \         if (left == 0) { \             put = window; \             left = WSIZE; \             wrap = 1; \             if (out(out_desc, put, (unsigned)left)) { \                 ret = Z_BUF_ERROR; \                 goto inf_leave; \             } \         } \     } while (0)
end_define

begin_comment
comment|/*    strm provides the memory allocation functions and window buffer on input,    and provides information on the unused input on return.  For Z_DATA_ERROR    returns, strm will also provide an error message.     in() and out() are the call-back input and output functions.  When    inflateBack() needs more input, it calls in().  When inflateBack() has    filled the window with output, or when it completes with data in the    window, it calls out() to write out the data.  The application must not    change the provided input until in() is called again or inflateBack()    returns.  The application must not change the window/output buffer until    inflateBack() returns.     in() and out() are called with a descriptor parameter provided in the    inflateBack() call.  This parameter can be a structure that provides the    information required to do the read or write, as well as accumulated    information on the input and output such as totals and check values.     in() should return zero on failure.  out() should return non-zero on    failure.  If either in() or out() fails, than inflateBack() returns a    Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it    was in() or out() that caused in the error.  Otherwise,  inflateBack()    returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format    error, or Z_MEM_ERROR if it could not allocate memory for the state.    inflateBack() can also return Z_STREAM_ERROR if the input parameters    are not correct, i.e. strm is Z_NULL or the state was not initialized.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflateBack9
parameter_list|(
name|strm
parameter_list|,
name|in
parameter_list|,
name|in_desc
parameter_list|,
name|out
parameter_list|,
name|out_desc
parameter_list|)
name|z_stream
name|FAR
modifier|*
name|strm
decl_stmt|;
name|in_func
name|in
decl_stmt|;
name|void
name|FAR
modifier|*
name|in_desc
decl_stmt|;
name|out_func
name|out
decl_stmt|;
name|void
name|FAR
modifier|*
name|out_desc
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|z_const
name|unsigned
name|char
name|FAR
modifier|*
name|next
decl_stmt|;
comment|/* next input */
name|unsigned
name|char
name|FAR
modifier|*
name|put
decl_stmt|;
comment|/* next output */
name|unsigned
name|have
decl_stmt|;
comment|/* available input */
name|unsigned
name|long
name|left
decl_stmt|;
comment|/* available output */
name|inflate_mode
name|mode
decl_stmt|;
comment|/* current inflate mode */
name|int
name|lastblock
decl_stmt|;
comment|/* true if processing last block */
name|int
name|wrap
decl_stmt|;
comment|/* true if the window has wrapped */
name|unsigned
name|char
name|FAR
modifier|*
name|window
decl_stmt|;
comment|/* allocated sliding window, if needed */
name|unsigned
name|long
name|hold
decl_stmt|;
comment|/* bit buffer */
name|unsigned
name|bits
decl_stmt|;
comment|/* bits in bit buffer */
name|unsigned
name|extra
decl_stmt|;
comment|/* extra bits needed */
name|unsigned
name|long
name|length
decl_stmt|;
comment|/* literal or length of data to copy */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* distance back to copy string from */
name|unsigned
name|long
name|copy
decl_stmt|;
comment|/* number of stored or match bytes to copy */
name|unsigned
name|char
name|FAR
modifier|*
name|from
decl_stmt|;
comment|/* where to copy match bytes from */
name|code
specifier|const
name|FAR
modifier|*
name|lencode
decl_stmt|;
comment|/* starting table for length/literal codes */
name|code
specifier|const
name|FAR
modifier|*
name|distcode
decl_stmt|;
comment|/* starting table for distance codes */
name|unsigned
name|lenbits
decl_stmt|;
comment|/* index bits for lencode */
name|unsigned
name|distbits
decl_stmt|;
comment|/* index bits for distcode */
name|code
name|here
decl_stmt|;
comment|/* current decoding table entry */
name|code
name|last
decl_stmt|;
comment|/* parent table entry */
name|unsigned
name|len
decl_stmt|;
comment|/* length to copy for repeats, bits to drop */
name|int
name|ret
decl_stmt|;
comment|/* return code */
specifier|static
specifier|const
name|unsigned
name|short
name|order
index|[
literal|19
index|]
init|=
comment|/* permutation of code lengths */
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
include|#
directive|include
file|"inffix9.h"
comment|/* Check that the strm exists and that the state was initialized */
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
comment|/* Reset the state */
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
name|mode
operator|=
name|TYPE
expr_stmt|;
name|lastblock
operator|=
literal|0
expr_stmt|;
name|wrap
operator|=
literal|0
expr_stmt|;
name|window
operator|=
name|state
operator|->
name|window
expr_stmt|;
name|next
operator|=
name|strm
operator|->
name|next_in
expr_stmt|;
name|have
operator|=
name|next
operator|!=
name|Z_NULL
condition|?
name|strm
operator|->
name|avail_in
else|:
literal|0
expr_stmt|;
name|hold
operator|=
literal|0
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|put
operator|=
name|window
expr_stmt|;
name|left
operator|=
name|WSIZE
expr_stmt|;
name|lencode
operator|=
name|Z_NULL
expr_stmt|;
name|distcode
operator|=
name|Z_NULL
expr_stmt|;
comment|/* Inflate until end of block marked as last */
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TYPE
case|:
comment|/* determine and dispatch block type */
if|if
condition|(
name|lastblock
condition|)
block|{
name|BYTEBITS
argument_list|()
expr_stmt|;
name|mode
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|lastblock
operator|=
name|BITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|BITS
argument_list|(
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* stored block */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     stored block%s\n"
operator|,
name|lastblock
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|STORED
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* fixed block */
name|lencode
operator|=
name|lenfix
expr_stmt|;
name|lenbits
operator|=
literal|9
expr_stmt|;
name|distcode
operator|=
name|distfix
expr_stmt|;
name|distbits
operator|=
literal|5
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     fixed codes block%s\n"
operator|,
name|lastblock
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|LEN
expr_stmt|;
comment|/* decode codes */
break|break;
case|case
literal|2
case|:
comment|/* dynamic block */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     dynamic codes block%s\n"
operator|,
name|lastblock
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TABLE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid block type"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STORED
case|:
comment|/* get and verify stored block length */
name|BYTEBITS
argument_list|()
expr_stmt|;
comment|/* go to byte boundary */
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
operator|(
name|hold
operator|>>
literal|16
operator|)
operator|^
literal|0xffff
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid stored block lengths"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|length
operator|=
operator|(
name|unsigned
operator|)
name|hold
operator|&
literal|0xffff
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored length %lu\n"
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
comment|/* copy stored block from input to output */
while|while
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|copy
operator|=
name|length
expr_stmt|;
name|PULL
argument_list|()
expr_stmt|;
name|ROOM
argument_list|()
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|have
condition|)
name|copy
operator|=
name|have
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|left
condition|)
name|copy
operator|=
name|left
expr_stmt|;
name|zmemcpy
argument_list|(
name|put
argument_list|,
name|next
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|have
operator|-=
name|copy
expr_stmt|;
name|next
operator|+=
name|copy
expr_stmt|;
name|left
operator|-=
name|copy
expr_stmt|;
name|put
operator|+=
name|copy
expr_stmt|;
name|length
operator|-=
name|copy
expr_stmt|;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored end\n"
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
comment|/* get dynamic table entries descriptor */
name|NEEDBITS
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|state
operator|->
name|nlen
operator|=
name|BITS
argument_list|(
literal|5
argument_list|)
operator|+
literal|257
expr_stmt|;
name|DROPBITS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|state
operator|->
name|ndist
operator|=
name|BITS
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DROPBITS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|state
operator|->
name|ncode
operator|=
name|BITS
argument_list|(
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
name|DROPBITS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|nlen
operator|>
literal|286
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"too many length symbols"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       table sizes ok\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* get code length code lengths (not a typo) */
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|have
operator|<
name|state
operator|->
name|ncode
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|state
operator|->
name|lens
index|[
name|order
index|[
name|state
operator|->
name|have
operator|++
index|]
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|BITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|state
operator|->
name|have
operator|<
literal|19
condition|)
name|state
operator|->
name|lens
index|[
name|order
index|[
name|state
operator|->
name|have
operator|++
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|lencode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|lenbits
operator|=
literal|7
expr_stmt|;
name|ret
operator|=
name|inflate_table9
argument_list|(
name|CODES
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|19
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|lenbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid code lengths set"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       code lengths ok\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* get length and distance code code lengths */
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|have
operator|<
name|state
operator|->
name|nlen
operator|+
name|state
operator|->
name|ndist
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|here
operator|=
name|lencode
index|[
name|BITS
argument_list|(
name|lenbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|here
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|here
operator|.
name|val
operator|<
literal|16
condition|)
block|{
name|NEEDBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|++
index|]
operator|=
name|here
operator|.
name|val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|here
operator|.
name|val
operator|==
literal|16
condition|)
block|{
name|NEEDBITS
argument_list|(
name|here
operator|.
name|bits
operator|+
literal|2
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|have
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|len
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|3
operator|+
name|BITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|here
operator|.
name|val
operator|==
literal|17
condition|)
block|{
name|NEEDBITS
argument_list|(
name|here
operator|.
name|bits
operator|+
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
literal|3
operator|+
name|BITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NEEDBITS
argument_list|(
name|here
operator|.
name|bits
operator|+
literal|7
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
literal|11
operator|+
name|BITS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|have
operator|+
name|copy
operator|>
name|state
operator|->
name|nlen
operator|+
name|state
operator|->
name|ndist
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|copy
operator|--
condition|)
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|++
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|len
expr_stmt|;
block|}
block|}
comment|/* handle error breaks in while */
if|if
condition|(
name|mode
operator|==
name|BAD
condition|)
break|break;
comment|/* check for end-of-block code (better have one) */
if|if
condition|(
name|state
operator|->
name|lens
index|[
literal|256
index|]
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid code -- missing end-of-block"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
comment|/* build code tables -- note: do not change the lenbits or distbits                values here (9 and 6) without reading the comments in inftree9.h                concerning the ENOUGH constants, which depend on those values */
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|lencode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|lenbits
operator|=
literal|9
expr_stmt|;
name|ret
operator|=
name|inflate_table9
argument_list|(
name|LENS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
name|state
operator|->
name|nlen
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|lenbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/lengths set"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|distcode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|distbits
operator|=
literal|6
expr_stmt|;
name|ret
operator|=
name|inflate_table9
argument_list|(
name|DISTS
argument_list|,
name|state
operator|->
name|lens
operator|+
name|state
operator|->
name|nlen
argument_list|,
name|state
operator|->
name|ndist
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|distbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distances set"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes ok\n"
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|LEN
expr_stmt|;
case|case
name|LEN
case|:
comment|/* get a literal, length, or end-of-block code */
for|for
control|(
init|;
condition|;
control|)
block|{
name|here
operator|=
name|lencode
index|[
name|BITS
argument_list|(
name|lenbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|here
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|here
operator|.
name|op
operator|&&
operator|(
name|here
operator|.
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|here
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|here
operator|=
name|lencode
index|[
name|last
operator|.
name|val
operator|+
operator|(
name|BITS
argument_list|(
name|last
operator|.
name|bits
operator|+
name|last
operator|.
name|op
argument_list|)
operator|>>
name|last
operator|.
name|bits
operator|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|last
operator|.
name|bits
operator|+
name|here
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|last
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|unsigned
operator|)
name|here
operator|.
name|val
expr_stmt|;
comment|/* process literal */
if|if
condition|(
name|here
operator|.
name|op
operator|==
literal|0
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|here
operator|.
name|val
operator|>=
literal|0x20
operator|&&
name|here
operator|.
name|val
operator|<
literal|0x7f
condition|?
literal|"inflate:         literal '%c'\n"
else|:
literal|"inflate:         literal 0x%02x\n"
operator|,
name|here
operator|.
name|val
operator|)
argument_list|)
expr_stmt|;
name|ROOM
argument_list|()
expr_stmt|;
operator|*
name|put
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|left
operator|--
expr_stmt|;
name|mode
operator|=
name|LEN
expr_stmt|;
break|break;
block|}
comment|/* process end of block */
if|if
condition|(
name|here
operator|.
name|op
operator|&
literal|32
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
block|}
comment|/* invalid code */
if|if
condition|(
name|here
operator|.
name|op
operator|&
literal|64
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/length code"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
comment|/* length code -- get extra bits, if any */
name|extra
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|here
operator|.
name|op
argument_list|)
operator|&
literal|31
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|NEEDBITS
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|length
operator|+=
name|BITS
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         length %lu\n"
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* get distance code */
for|for
control|(
init|;
condition|;
control|)
block|{
name|here
operator|=
name|distcode
index|[
name|BITS
argument_list|(
name|distbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|here
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|here
operator|.
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|here
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|here
operator|=
name|distcode
index|[
name|last
operator|.
name|val
operator|+
operator|(
name|BITS
argument_list|(
name|last
operator|.
name|bits
operator|+
name|last
operator|.
name|op
argument_list|)
operator|>>
name|last
operator|.
name|bits
operator|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|last
operator|.
name|bits
operator|+
name|here
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|last
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|here
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|here
operator|.
name|op
operator|&
literal|64
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance code"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|offset
operator|=
operator|(
name|unsigned
operator|)
name|here
operator|.
name|val
expr_stmt|;
comment|/* get distance extra bits, if any */
name|extra
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|here
operator|.
name|op
argument_list|)
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|NEEDBITS
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|BITS
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|WSIZE
operator|-
operator|(
name|wrap
condition|?
literal|0
else|:
name|left
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance too far back"
expr_stmt|;
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         distance %lu\n"
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
comment|/* copy match from window to output */
do|do
block|{
name|ROOM
argument_list|()
expr_stmt|;
name|copy
operator|=
name|WSIZE
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|copy
operator|<
name|left
condition|)
block|{
name|from
operator|=
name|put
operator|+
name|copy
expr_stmt|;
name|copy
operator|=
name|left
operator|-
name|copy
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|put
operator|-
name|offset
expr_stmt|;
name|copy
operator|=
name|left
expr_stmt|;
block|}
if|if
condition|(
name|copy
operator|>
name|length
condition|)
name|copy
operator|=
name|length
expr_stmt|;
name|length
operator|-=
name|copy
expr_stmt|;
name|left
operator|-=
name|copy
expr_stmt|;
do|do
block|{
operator|*
name|put
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|copy
condition|)
do|;
block|}
do|while
condition|(
name|length
operator|!=
literal|0
condition|)
do|;
break|break;
case|case
name|DONE
case|:
comment|/* inflate stream terminated properly -- write leftover output */
name|ret
operator|=
name|Z_STREAM_END
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|WSIZE
condition|)
block|{
if|if
condition|(
name|out
argument_list|(
name|out_desc
argument_list|,
name|window
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|WSIZE
operator|-
name|left
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|Z_BUF_ERROR
expr_stmt|;
block|}
goto|goto
name|inf_leave
goto|;
case|case
name|BAD
case|:
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
goto|goto
name|inf_leave
goto|;
default|default:
comment|/* can't happen, but makes compilers happy */
name|ret
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
goto|goto
name|inf_leave
goto|;
block|}
comment|/* Return unused input */
name|inf_leave
label|:
name|strm
operator|->
name|next_in
operator|=
name|next
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|have
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateBack9End
parameter_list|(
name|strm
parameter_list|)
name|z_stream
name|FAR
modifier|*
name|strm
decl_stmt|;
block|{
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

end_unit

