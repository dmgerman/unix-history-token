begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|once
end_pragma

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|pzstd
block|{
comment|/**  * An unbounded pool of resources.  * A `ResourcePool<T>` requires a factory function that takes allocates `T*` and  * a free function that frees a `T*`.  * Calling `ResourcePool::get()` will give you a new `ResourcePool::UniquePtr`  * to a `T`, and when it goes out of scope the resource will be returned to the  * pool.  * The `ResourcePool<T>` *must* survive longer than any resources it hands out.  * Remember that `ResourcePool<T>` hands out mutable `T`s, so make sure to clean  * up the resource before or after every use.  */
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ResourcePool
block|{
name|public
operator|:
name|class
name|Deleter
block|;
name|using
name|Factory
operator|=
name|std
operator|::
name|function
operator|<
name|T
operator|*
operator|(
operator|)
operator|>
block|;
name|using
name|Free
operator|=
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|T
operator|*
argument_list|)
operator|>
block|;
name|using
name|UniquePtr
operator|=
name|std
operator|::
name|unique_ptr
operator|<
name|T
block|,
name|Deleter
operator|>
block|;
name|private
operator|:
name|std
operator|::
name|mutex
name|mutex_
block|;
name|Factory
name|factory_
block|;
name|Free
name|free_
block|;
name|std
operator|::
name|vector
operator|<
name|T
operator|*
operator|>
name|resources_
block|;
name|unsigned
name|inUse_
block|;
name|public
operator|:
comment|/**    * Creates a `ResourcePool`.    *    * @param factory  The function to use to create new resources.    * @param free     The function to use to free resources created by `factory`.    */
name|ResourcePool
argument_list|(
argument|Factory factory
argument_list|,
argument|Free free
argument_list|)
operator|:
name|factory_
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|factory
argument_list|)
argument_list|)
block|,
name|free_
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|free
argument_list|)
argument_list|)
block|,
name|inUse_
argument_list|(
literal|0
argument_list|)
block|{}
comment|/**    * @returns  A unique pointer to a resource.  The resource is null iff    *           there are no avaiable resources and `factory()` returns null.    */
name|UniquePtr
name|get
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|mutex_
argument_list|)
block|;
if|if
condition|(
operator|!
name|resources_
operator|.
name|empty
argument_list|()
condition|)
block|{
name|UniquePtr
name|resource
block|{
name|resources_
operator|.
name|back
argument_list|()
operator|,
name|Deleter
block|{
operator|*
name|this
block|}
block|}
decl_stmt|;
name|resources_
operator|.
name|pop_back
argument_list|()
expr_stmt|;
operator|++
name|inUse_
expr_stmt|;
return|return
name|resource
return|;
block|}
name|UniquePtr
name|resource
block|{
name|factory_
argument_list|()
operator|,
name|Deleter
block|{
operator|*
name|this
block|}
block|}
decl_stmt|;
operator|++
name|inUse_
block|;
return|return
name|resource
return|;
block|}
operator|~
name|ResourcePool
argument_list|()
name|noexcept
block|{
name|assert
argument_list|(
name|inUse_
operator|==
literal|0
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
name|resource
range|:
name|resources_
control|)
block|{
name|free_
argument_list|(
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
name|class
name|Deleter
block|{
name|ResourcePool
operator|*
name|pool_
block|;
name|public
operator|:
name|explicit
name|Deleter
argument_list|(
name|ResourcePool
operator|&
name|pool
argument_list|)
operator|:
name|pool_
argument_list|(
argument|&pool
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|T
operator|*
name|resource
operator|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|pool_
operator|->
name|mutex_
argument_list|)
block|;
comment|// Make sure we don't put null resources into the pool
if|if
condition|(
name|resource
condition|)
block|{
name|pool_
operator|->
name|resources_
operator|.
name|push_back
argument_list|(
name|resource
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|pool_
operator|->
name|inUse_
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|--
name|pool_
operator|->
name|inUse_
block|;     }
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

unit|};  }
end_unit

