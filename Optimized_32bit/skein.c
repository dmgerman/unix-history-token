begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************************** ** ** Implementation of the Skein hash function. ** ** Source code author: Doug Whiting, 2008. ** ** This algorithm and source code is released to the public domain. **  ************************************************************************/
end_comment

begin_define
define|#
directive|define
name|SKEIN_PORT_CODE
end_define

begin_comment
comment|/* instantiate any code in skein_port.h */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* get the memcpy/memset functions */
end_comment

begin_include
include|#
directive|include
file|"skein.h"
end_include

begin_comment
comment|/* get the Skein API definitions   */
end_comment

begin_include
include|#
directive|include
file|"skein_iv.h"
end_include

begin_comment
comment|/* get precomputed IVs */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/* External function to process blkCnt (nonzero) full block(s) of data. */
end_comment

begin_function_decl
name|void
name|Skein_256_Process_Block
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Skein_512_Process_Block
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Skein1024_Process_Block
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*     256-bit Skein                                             */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* init the context for a straight hashing operation  */
end_comment

begin_function
name|int
name|Skein_256_Init
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|hashBitLen
parameter_list|)
block|{
union|union
block|{
name|u08b_t
name|b
index|[
name|SKEIN_256_STATE_BYTES
index|]
decl_stmt|;
name|u64b_t
name|w
index|[
name|SKEIN_256_STATE_WORDS
index|]
decl_stmt|;
block|}
name|cfg
union|;
comment|/* config block */
name|Skein_Assert
argument_list|(
name|hashBitLen
operator|>
literal|0
argument_list|,
name|SKEIN_BAD_HASHLEN
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
name|hashBitLen
expr_stmt|;
comment|/* output hash bit count */
switch|switch
condition|(
name|hashBitLen
condition|)
block|{
comment|/* use pre-computed values, where available */
ifndef|#
directive|ifndef
name|SKEIN_NO_PRECOMP
case|case
literal|256
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_256_IV_256
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|224
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_256_IV_224
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|160
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_256_IV_160
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_256_IV_128
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* here if there is no precomputed IV value available */
comment|/* build/process the config block, type == CONFIG (could be precomputed) */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|CFG_FINAL
argument_list|)
expr_stmt|;
comment|/* set tweaks: T0=0; T1=CFG | FINAL */
name|cfg
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_SCHEMA_VER
argument_list|)
expr_stmt|;
comment|/* set the schema, version */
name|cfg
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|hashBitLen
argument_list|)
expr_stmt|;
comment|/* hash result length in bits */
name|cfg
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_CFG_TREE_INFO_SEQUENTIAL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
operator|.
name|w
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
argument_list|)
operator|-
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|w
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero pad config block */
comment|/* compute the initial chaining values from config block */
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the chaining variables */
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_CFG_STR_LEN
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The chaining vars ctx->X are now initialized for the given hashBitLen. */
comment|/* Set up to process the data message portion of the hash (default) */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|MSG
argument_list|)
expr_stmt|;
comment|/* T0=0, T1= MSG type */
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* init the context for a MAC and/or tree hash operation */
end_comment

begin_comment
comment|/* [identical to Skein_256_Init() when keyBytes == 0&& treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */
end_comment

begin_function
name|int
name|Skein_256_InitExt
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|hashBitLen
parameter_list|,
name|u64b_t
name|treeInfo
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keyBytes
parameter_list|)
block|{
union|union
block|{
name|u08b_t
name|b
index|[
name|SKEIN_256_STATE_BYTES
index|]
decl_stmt|;
name|u64b_t
name|w
index|[
name|SKEIN_256_STATE_WORDS
index|]
decl_stmt|;
block|}
name|cfg
union|;
comment|/* config block */
name|Skein_Assert
argument_list|(
name|hashBitLen
operator|>
literal|0
argument_list|,
name|SKEIN_BAD_HASHLEN
argument_list|)
expr_stmt|;
name|Skein_Assert
argument_list|(
name|keyBytes
operator|==
literal|0
operator|||
name|key
operator|!=
name|NULL
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* compute the initial chaining values ctx->X[], based on key */
if|if
condition|(
name|keyBytes
operator|==
literal|0
condition|)
comment|/* is there a key? */
block|{
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no key: use all zeroes as key for config block */
block|}
else|else
comment|/* here to pre-process a key */
block|{
name|Skein_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|b
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do a mini-Init right here */
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
expr_stmt|;
comment|/* set output hash bit count = state size */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|KEY
argument_list|)
expr_stmt|;
comment|/* set tweaks: T0 = 0; T1 = KEY type */
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the initial chaining variables */
name|Skein_256_Update
argument_list|(
name|ctx
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|/* hash the key */
name|Skein_256_Final_Pad
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|)
expr_stmt|;
comment|/* put result into cfg.b[] */
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy over into ctx->X[] */
if|#
directive|if
name|SKEIN_NEED_SWAP
block|{
name|uint_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SKEIN_256_STATE_WORDS
condition|;
name|i
operator|++
control|)
comment|/* convert key bytes to context words */
name|ctx
operator|->
name|X
index|[
name|i
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|ctx
operator|->
name|X
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* build/process the config block, type == CONFIG (could be precomputed for each key) */
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
name|hashBitLen
expr_stmt|;
comment|/* output hash bit count */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|CFG_FINAL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
operator|.
name|w
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|w
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pre-pad cfg.w[] with zeroes */
name|cfg
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_SCHEMA_VER
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|hashBitLen
argument_list|)
expr_stmt|;
comment|/* hash result length in bits */
name|cfg
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|treeInfo
argument_list|)
expr_stmt|;
comment|/* tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) */
name|Skein_Show_Key
argument_list|(
literal|256
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|/* compute the initial chaining values from config block */
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_CFG_STR_LEN
argument_list|)
expr_stmt|;
comment|/* The chaining vars ctx->X are now initialized */
comment|/* Set up to process the data message portion of the hash (default) */
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|=
literal|0
expr_stmt|;
comment|/* buffer b[] starts out empty */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|MSG
argument_list|)
expr_stmt|;
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* process the input bytes */
end_comment

begin_function
name|int
name|Skein_256_Update
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|msg
parameter_list|,
name|size_t
name|msgByteCnt
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_256_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
comment|/* process full blocks, if any */
if|if
condition|(
name|msgByteCnt
operator|+
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|>
name|SKEIN_256_BLOCK_BYTES
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
condition|)
comment|/* finish up any buffered message data */
block|{
name|n
operator|=
name|SKEIN_256_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
expr_stmt|;
comment|/* # bytes free in buffer b[] */
if|if
condition|(
name|n
condition|)
block|{
name|Skein_assert
argument_list|(
name|n
operator|<
name|msgByteCnt
argument_list|)
expr_stmt|;
comment|/* check on our logic here */
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
name|msg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|msgByteCnt
operator|-=
name|n
expr_stmt|;
name|msg
operator|+=
name|n
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|+=
name|n
expr_stmt|;
block|}
name|Skein_assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|==
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now process any remaining full blocks, directly from input message data */
if|if
condition|(
name|msgByteCnt
operator|>
name|SKEIN_256_BLOCK_BYTES
condition|)
block|{
name|n
operator|=
operator|(
name|msgByteCnt
operator|-
literal|1
operator|)
operator|/
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
comment|/* number of full blocks to process */
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|n
argument_list|,
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|msgByteCnt
operator|-=
name|n
operator|*
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
name|msg
operator|+=
name|n
operator|*
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
block|}
name|Skein_assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* copy any remaining source message data bytes into b[] */
if|if
condition|(
name|msgByteCnt
condition|)
block|{
name|Skein_assert
argument_list|(
name|msgByteCnt
operator|+
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
name|msg
argument_list|,
name|msgByteCnt
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|+=
name|msgByteCnt
expr_stmt|;
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize the hash computation and output the result */
end_comment

begin_function
name|int
name|Skein_256_Final
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|byteCnt
decl_stmt|;
name|u64b_t
name|X
index|[
name|SKEIN_256_STATE_WORDS
index|]
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_256_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator||=
name|SKEIN_T1_FLAG_FINAL
expr_stmt|;
comment|/* tag as the final block */
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<
name|SKEIN_256_BLOCK_BYTES
condition|)
comment|/* zero pad b[] if necessary */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
literal|0
argument_list|,
name|SKEIN_256_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
comment|/* process the final block */
comment|/* now output the result */
name|byteCnt
operator|=
operator|(
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* total number of output bytes */
comment|/* run Threefish in "counter mode" to generate output */
name|memset
argument_list|(
name|ctx
operator|->
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out b[], so it can hold the counter */
name|memcpy
argument_list|(
name|X
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep a local copy of counter mode "key" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
operator|<
name|byteCnt
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|u64b_t
operator|*
operator|)
name|ctx
operator|->
name|b
operator|)
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
operator|(
name|u64b_t
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* build the counter block */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|OUT_FINAL
argument_list|)
expr_stmt|;
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64b_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run "counter mode" */
name|n
operator|=
name|byteCnt
operator|-
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
comment|/* number of output bytes left to go */
if|if
condition|(
name|n
operator|>=
name|SKEIN_256_BLOCK_BYTES
condition|)
name|n
operator|=
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* "output" the ctr mode bytes */
name|Skein_Show_Final
argument_list|(
literal|256
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|n
argument_list|,
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the counter mode key for next time */
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_function
name|size_t
name|Skein_256_API_CodeSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_256_API_CodeSize
operator|)
operator|-
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_256_Init
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*     512-bit Skein                                             */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* init the context for a straight hashing operation  */
end_comment

begin_function
name|int
name|Skein_512_Init
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|hashBitLen
parameter_list|)
block|{
union|union
block|{
name|u08b_t
name|b
index|[
name|SKEIN_512_STATE_BYTES
index|]
decl_stmt|;
name|u64b_t
name|w
index|[
name|SKEIN_512_STATE_WORDS
index|]
decl_stmt|;
block|}
name|cfg
union|;
comment|/* config block */
name|Skein_Assert
argument_list|(
name|hashBitLen
operator|>
literal|0
argument_list|,
name|SKEIN_BAD_HASHLEN
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
name|hashBitLen
expr_stmt|;
comment|/* output hash bit count */
switch|switch
condition|(
name|hashBitLen
condition|)
block|{
comment|/* use pre-computed values, where available */
ifndef|#
directive|ifndef
name|SKEIN_NO_PRECOMP
case|case
literal|512
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_512_IV_512
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|384
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_512_IV_384
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_512_IV_256
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|224
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_512_IV_224
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* here if there is no precomputed IV value available */
comment|/* build/process the config block, type == CONFIG (could be precomputed) */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|CFG_FINAL
argument_list|)
expr_stmt|;
comment|/* set tweaks: T0=0; T1=CFG | FINAL */
name|cfg
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_SCHEMA_VER
argument_list|)
expr_stmt|;
comment|/* set the schema, version */
name|cfg
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|hashBitLen
argument_list|)
expr_stmt|;
comment|/* hash result length in bits */
name|cfg
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_CFG_TREE_INFO_SEQUENTIAL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
operator|.
name|w
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
argument_list|)
operator|-
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|w
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero pad config block */
comment|/* compute the initial chaining values from config block */
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the chaining variables */
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_CFG_STR_LEN
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The chaining vars ctx->X are now initialized for the given hashBitLen. */
comment|/* Set up to process the data message portion of the hash (default) */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|MSG
argument_list|)
expr_stmt|;
comment|/* T0=0, T1= MSG type */
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* init the context for a MAC and/or tree hash operation */
end_comment

begin_comment
comment|/* [identical to Skein_512_Init() when keyBytes == 0&& treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */
end_comment

begin_function
name|int
name|Skein_512_InitExt
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|hashBitLen
parameter_list|,
name|u64b_t
name|treeInfo
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keyBytes
parameter_list|)
block|{
union|union
block|{
name|u08b_t
name|b
index|[
name|SKEIN_512_STATE_BYTES
index|]
decl_stmt|;
name|u64b_t
name|w
index|[
name|SKEIN_512_STATE_WORDS
index|]
decl_stmt|;
block|}
name|cfg
union|;
comment|/* config block */
name|Skein_Assert
argument_list|(
name|hashBitLen
operator|>
literal|0
argument_list|,
name|SKEIN_BAD_HASHLEN
argument_list|)
expr_stmt|;
name|Skein_Assert
argument_list|(
name|keyBytes
operator|==
literal|0
operator|||
name|key
operator|!=
name|NULL
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* compute the initial chaining values ctx->X[], based on key */
if|if
condition|(
name|keyBytes
operator|==
literal|0
condition|)
comment|/* is there a key? */
block|{
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no key: use all zeroes as key for config block */
block|}
else|else
comment|/* here to pre-process a key */
block|{
name|Skein_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|b
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do a mini-Init right here */
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
expr_stmt|;
comment|/* set output hash bit count = state size */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|KEY
argument_list|)
expr_stmt|;
comment|/* set tweaks: T0 = 0; T1 = KEY type */
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the initial chaining variables */
name|Skein_512_Update
argument_list|(
name|ctx
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|/* hash the key */
name|Skein_512_Final_Pad
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|)
expr_stmt|;
comment|/* put result into cfg.b[] */
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy over into ctx->X[] */
if|#
directive|if
name|SKEIN_NEED_SWAP
block|{
name|uint_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SKEIN_512_STATE_WORDS
condition|;
name|i
operator|++
control|)
comment|/* convert key bytes to context words */
name|ctx
operator|->
name|X
index|[
name|i
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|ctx
operator|->
name|X
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* build/process the config block, type == CONFIG (could be precomputed for each key) */
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
name|hashBitLen
expr_stmt|;
comment|/* output hash bit count */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|CFG_FINAL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
operator|.
name|w
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|w
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pre-pad cfg.w[] with zeroes */
name|cfg
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_SCHEMA_VER
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|hashBitLen
argument_list|)
expr_stmt|;
comment|/* hash result length in bits */
name|cfg
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|treeInfo
argument_list|)
expr_stmt|;
comment|/* tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) */
name|Skein_Show_Key
argument_list|(
literal|512
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|/* compute the initial chaining values from config block */
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_CFG_STR_LEN
argument_list|)
expr_stmt|;
comment|/* The chaining vars ctx->X are now initialized */
comment|/* Set up to process the data message portion of the hash (default) */
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|=
literal|0
expr_stmt|;
comment|/* buffer b[] starts out empty */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|MSG
argument_list|)
expr_stmt|;
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* process the input bytes */
end_comment

begin_function
name|int
name|Skein_512_Update
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|msg
parameter_list|,
name|size_t
name|msgByteCnt
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_512_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
comment|/* process full blocks, if any */
if|if
condition|(
name|msgByteCnt
operator|+
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|>
name|SKEIN_512_BLOCK_BYTES
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
condition|)
comment|/* finish up any buffered message data */
block|{
name|n
operator|=
name|SKEIN_512_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
expr_stmt|;
comment|/* # bytes free in buffer b[] */
if|if
condition|(
name|n
condition|)
block|{
name|Skein_assert
argument_list|(
name|n
operator|<
name|msgByteCnt
argument_list|)
expr_stmt|;
comment|/* check on our logic here */
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
name|msg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|msgByteCnt
operator|-=
name|n
expr_stmt|;
name|msg
operator|+=
name|n
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|+=
name|n
expr_stmt|;
block|}
name|Skein_assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|==
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now process any remaining full blocks, directly from input message data */
if|if
condition|(
name|msgByteCnt
operator|>
name|SKEIN_512_BLOCK_BYTES
condition|)
block|{
name|n
operator|=
operator|(
name|msgByteCnt
operator|-
literal|1
operator|)
operator|/
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
comment|/* number of full blocks to process */
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|n
argument_list|,
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|msgByteCnt
operator|-=
name|n
operator|*
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
name|msg
operator|+=
name|n
operator|*
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
block|}
name|Skein_assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* copy any remaining source message data bytes into b[] */
if|if
condition|(
name|msgByteCnt
condition|)
block|{
name|Skein_assert
argument_list|(
name|msgByteCnt
operator|+
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
name|msg
argument_list|,
name|msgByteCnt
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|+=
name|msgByteCnt
expr_stmt|;
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize the hash computation and output the result */
end_comment

begin_function
name|int
name|Skein_512_Final
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|byteCnt
decl_stmt|;
name|u64b_t
name|X
index|[
name|SKEIN_512_STATE_WORDS
index|]
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_512_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator||=
name|SKEIN_T1_FLAG_FINAL
expr_stmt|;
comment|/* tag as the final block */
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<
name|SKEIN_512_BLOCK_BYTES
condition|)
comment|/* zero pad b[] if necessary */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
literal|0
argument_list|,
name|SKEIN_512_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
comment|/* process the final block */
comment|/* now output the result */
name|byteCnt
operator|=
operator|(
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* total number of output bytes */
comment|/* run Threefish in "counter mode" to generate output */
name|memset
argument_list|(
name|ctx
operator|->
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out b[], so it can hold the counter */
name|memcpy
argument_list|(
name|X
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep a local copy of counter mode "key" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
operator|<
name|byteCnt
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|u64b_t
operator|*
operator|)
name|ctx
operator|->
name|b
operator|)
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
operator|(
name|u64b_t
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* build the counter block */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|OUT_FINAL
argument_list|)
expr_stmt|;
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64b_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run "counter mode" */
name|n
operator|=
name|byteCnt
operator|-
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
comment|/* number of output bytes left to go */
if|if
condition|(
name|n
operator|>=
name|SKEIN_512_BLOCK_BYTES
condition|)
name|n
operator|=
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* "output" the ctr mode bytes */
name|Skein_Show_Final
argument_list|(
literal|512
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|n
argument_list|,
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the counter mode key for next time */
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_function
name|size_t
name|Skein_512_API_CodeSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_512_API_CodeSize
operator|)
operator|-
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein_512_Init
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*    1024-bit Skein                                             */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* init the context for a straight hashing operation  */
end_comment

begin_function
name|int
name|Skein1024_Init
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|hashBitLen
parameter_list|)
block|{
union|union
block|{
name|u08b_t
name|b
index|[
name|SKEIN1024_STATE_BYTES
index|]
decl_stmt|;
name|u64b_t
name|w
index|[
name|SKEIN1024_STATE_WORDS
index|]
decl_stmt|;
block|}
name|cfg
union|;
comment|/* config block */
name|Skein_Assert
argument_list|(
name|hashBitLen
operator|>
literal|0
argument_list|,
name|SKEIN_BAD_HASHLEN
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
name|hashBitLen
expr_stmt|;
comment|/* output hash bit count */
switch|switch
condition|(
name|hashBitLen
condition|)
block|{
comment|/* use pre-computed values, where available */
ifndef|#
directive|ifndef
name|SKEIN_NO_PRECOMP
case|case
literal|512
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN1024_IV_512
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|384
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN1024_IV_384
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN1024_IV_1024
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* here if there is no precomputed IV value available */
comment|/* build/process the config block, type == CONFIG (could be precomputed) */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|CFG_FINAL
argument_list|)
expr_stmt|;
comment|/* set tweaks: T0=0; T1=CFG | FINAL */
name|cfg
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_SCHEMA_VER
argument_list|)
expr_stmt|;
comment|/* set the schema, version */
name|cfg
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|hashBitLen
argument_list|)
expr_stmt|;
comment|/* hash result length in bits */
name|cfg
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_CFG_TREE_INFO_SEQUENTIAL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
operator|.
name|w
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
argument_list|)
operator|-
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|w
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero pad config block */
comment|/* compute the initial chaining values from config block */
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the chaining variables */
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_CFG_STR_LEN
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The chaining vars ctx->X are now initialized for the given hashBitLen. */
comment|/* Set up to process the data message portion of the hash (default) */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|MSG
argument_list|)
expr_stmt|;
comment|/* T0=0, T1= MSG type */
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* init the context for a MAC and/or tree hash operation */
end_comment

begin_comment
comment|/* [identical to Skein1024_Init() when keyBytes == 0&& treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */
end_comment

begin_function
name|int
name|Skein1024_InitExt
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|hashBitLen
parameter_list|,
name|u64b_t
name|treeInfo
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keyBytes
parameter_list|)
block|{
union|union
block|{
name|u08b_t
name|b
index|[
name|SKEIN1024_STATE_BYTES
index|]
decl_stmt|;
name|u64b_t
name|w
index|[
name|SKEIN1024_STATE_WORDS
index|]
decl_stmt|;
block|}
name|cfg
union|;
comment|/* config block */
name|Skein_Assert
argument_list|(
name|hashBitLen
operator|>
literal|0
argument_list|,
name|SKEIN_BAD_HASHLEN
argument_list|)
expr_stmt|;
name|Skein_Assert
argument_list|(
name|keyBytes
operator|==
literal|0
operator|||
name|key
operator|!=
name|NULL
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* compute the initial chaining values ctx->X[], based on key */
if|if
condition|(
name|keyBytes
operator|==
literal|0
condition|)
comment|/* is there a key? */
block|{
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no key: use all zeroes as key for config block */
block|}
else|else
comment|/* here to pre-process a key */
block|{
name|Skein_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|b
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do a mini-Init right here */
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
expr_stmt|;
comment|/* set output hash bit count = state size */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|KEY
argument_list|)
expr_stmt|;
comment|/* set tweaks: T0 = 0; T1 = KEY type */
name|memset
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the initial chaining variables */
name|Skein1024_Update
argument_list|(
name|ctx
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|/* hash the key */
name|Skein1024_Final_Pad
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|)
expr_stmt|;
comment|/* put result into cfg.b[] */
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy over into ctx->X[] */
if|#
directive|if
name|SKEIN_NEED_SWAP
block|{
name|uint_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SKEIN1024_STATE_WORDS
condition|;
name|i
operator|++
control|)
comment|/* convert key bytes to context words */
name|ctx
operator|->
name|X
index|[
name|i
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|ctx
operator|->
name|X
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* build/process the config block, type == CONFIG (could be precomputed for each key) */
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|=
name|hashBitLen
expr_stmt|;
comment|/* output hash bit count */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|CFG_FINAL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
operator|.
name|w
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|.
name|w
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pre-pad cfg.w[] with zeroes */
name|cfg
operator|.
name|w
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|SKEIN_SCHEMA_VER
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|w
index|[
literal|1
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|hashBitLen
argument_list|)
expr_stmt|;
comment|/* hash result length in bits */
name|cfg
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|Skein_Swap64
argument_list|(
name|treeInfo
argument_list|)
expr_stmt|;
comment|/* tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) */
name|Skein_Show_Key
argument_list|(
literal|1024
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|/* compute the initial chaining values from config block */
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|cfg
operator|.
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN_CFG_STR_LEN
argument_list|)
expr_stmt|;
comment|/* The chaining vars ctx->X are now initialized */
comment|/* Set up to process the data message portion of the hash (default) */
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|=
literal|0
expr_stmt|;
comment|/* buffer b[] starts out empty */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|MSG
argument_list|)
expr_stmt|;
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* process the input bytes */
end_comment

begin_function
name|int
name|Skein1024_Update
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|msg
parameter_list|,
name|size_t
name|msgByteCnt
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN1024_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
comment|/* process full blocks, if any */
if|if
condition|(
name|msgByteCnt
operator|+
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|>
name|SKEIN1024_BLOCK_BYTES
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
condition|)
comment|/* finish up any buffered message data */
block|{
name|n
operator|=
name|SKEIN1024_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
expr_stmt|;
comment|/* # bytes free in buffer b[] */
if|if
condition|(
name|n
condition|)
block|{
name|Skein_assert
argument_list|(
name|n
operator|<
name|msgByteCnt
argument_list|)
expr_stmt|;
comment|/* check on our logic here */
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
name|msg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|msgByteCnt
operator|-=
name|n
expr_stmt|;
name|msg
operator|+=
name|n
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|+=
name|n
expr_stmt|;
block|}
name|Skein_assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|==
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now process any remaining full blocks, directly from input message data */
if|if
condition|(
name|msgByteCnt
operator|>
name|SKEIN1024_BLOCK_BYTES
condition|)
block|{
name|n
operator|=
operator|(
name|msgByteCnt
operator|-
literal|1
operator|)
operator|/
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
comment|/* number of full blocks to process */
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|n
argument_list|,
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|msgByteCnt
operator|-=
name|n
operator|*
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
name|msg
operator|+=
name|n
operator|*
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
block|}
name|Skein_assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* copy any remaining source message data bytes into b[] */
if|if
condition|(
name|msgByteCnt
condition|)
block|{
name|Skein_assert
argument_list|(
name|msgByteCnt
operator|+
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
name|msg
argument_list|,
name|msgByteCnt
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|+=
name|msgByteCnt
expr_stmt|;
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize the hash computation and output the result */
end_comment

begin_function
name|int
name|Skein1024_Final
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|byteCnt
decl_stmt|;
name|u64b_t
name|X
index|[
name|SKEIN1024_STATE_WORDS
index|]
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN1024_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator||=
name|SKEIN_T1_FLAG_FINAL
expr_stmt|;
comment|/* tag as the final block */
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<
name|SKEIN1024_BLOCK_BYTES
condition|)
comment|/* zero pad b[] if necessary */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
literal|0
argument_list|,
name|SKEIN1024_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
comment|/* process the final block */
comment|/* now output the result */
name|byteCnt
operator|=
operator|(
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* total number of output bytes */
comment|/* run Threefish in "counter mode" to generate output */
name|memset
argument_list|(
name|ctx
operator|->
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out b[], so it can hold the counter */
name|memcpy
argument_list|(
name|X
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep a local copy of counter mode "key" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
operator|<
name|byteCnt
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|u64b_t
operator|*
operator|)
name|ctx
operator|->
name|b
operator|)
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
operator|(
name|u64b_t
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* build the counter block */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|OUT_FINAL
argument_list|)
expr_stmt|;
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64b_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run "counter mode" */
name|n
operator|=
name|byteCnt
operator|-
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
comment|/* number of output bytes left to go */
if|if
condition|(
name|n
operator|>=
name|SKEIN1024_BLOCK_BYTES
condition|)
name|n
operator|=
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
operator|+
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* "output" the ctr mode bytes */
name|Skein_Show_Final
argument_list|(
literal|1024
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|n
argument_list|,
name|hashVal
operator|+
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the counter mode key for next time */
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_function
name|size_t
name|Skein1024_API_CodeSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein1024_API_CodeSize
operator|)
operator|-
operator|(
operator|(
name|u08b_t
operator|*
operator|)
name|Skein1024_Init
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************** Functions to support MAC/tree hashing ***************/
end_comment

begin_comment
comment|/*   (this code is identical for Optimized and Reference versions)    */
end_comment

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize the hash computation and output the block, no OUTPUT stage */
end_comment

begin_function
name|int
name|Skein_256_Final_Pad
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_256_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator||=
name|SKEIN_T1_FLAG_FINAL
expr_stmt|;
comment|/* tag as the final block */
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<
name|SKEIN_256_BLOCK_BYTES
condition|)
comment|/* zero pad b[] if necessary */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
literal|0
argument_list|,
name|SKEIN_256_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
comment|/* process the final block */
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
comment|/* "output" the state bytes */
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize the hash computation and output the block, no OUTPUT stage */
end_comment

begin_function
name|int
name|Skein_512_Final_Pad
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_512_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator||=
name|SKEIN_T1_FLAG_FINAL
expr_stmt|;
comment|/* tag as the final block */
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<
name|SKEIN_512_BLOCK_BYTES
condition|)
comment|/* zero pad b[] if necessary */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
literal|0
argument_list|,
name|SKEIN_512_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
comment|/* process the final block */
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
comment|/* "output" the state bytes */
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize the hash computation and output the block, no OUTPUT stage */
end_comment

begin_function
name|int
name|Skein1024_Final_Pad
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN1024_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
name|ctx
operator|->
name|h
operator|.
name|T
index|[
literal|1
index|]
operator||=
name|SKEIN_T1_FLAG_FINAL
expr_stmt|;
comment|/* tag as the final block */
if|if
condition|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<
name|SKEIN1024_BLOCK_BYTES
condition|)
comment|/* zero pad b[] if necessary */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|b
index|[
name|ctx
operator|->
name|h
operator|.
name|bCnt
index|]
argument_list|,
literal|0
argument_list|,
name|SKEIN1024_BLOCK_BYTES
operator|-
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
name|ctx
operator|->
name|h
operator|.
name|bCnt
argument_list|)
expr_stmt|;
comment|/* process the final block */
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
comment|/* "output" the state bytes */
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SKEIN_TREE_HASH
end_if

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* just do the OUTPUT stage                                       */
end_comment

begin_function
name|int
name|Skein_256_Output
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|byteCnt
decl_stmt|;
name|u64b_t
name|X
index|[
name|SKEIN_256_STATE_WORDS
index|]
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_256_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
comment|/* now output the result */
name|byteCnt
operator|=
operator|(
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* total number of output bytes */
comment|/* run Threefish in "counter mode" to generate output */
name|memset
argument_list|(
name|ctx
operator|->
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out b[], so it can hold the counter */
name|memcpy
argument_list|(
name|X
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep a local copy of counter mode "key" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
operator|<
name|byteCnt
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|u64b_t
operator|*
operator|)
name|ctx
operator|->
name|b
operator|)
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
operator|(
name|u64b_t
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* build the counter block */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|OUT_FINAL
argument_list|)
expr_stmt|;
name|Skein_256_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64b_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run "counter mode" */
name|n
operator|=
name|byteCnt
operator|-
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
comment|/* number of output bytes left to go */
if|if
condition|(
name|n
operator|>=
name|SKEIN_256_BLOCK_BYTES
condition|)
name|n
operator|=
name|SKEIN_256_BLOCK_BYTES
expr_stmt|;
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* "output" the ctr mode bytes */
name|Skein_Show_Final
argument_list|(
literal|256
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|n
argument_list|,
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_256_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the counter mode key for next time */
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* just do the OUTPUT stage                                       */
end_comment

begin_function
name|int
name|Skein_512_Output
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|byteCnt
decl_stmt|;
name|u64b_t
name|X
index|[
name|SKEIN_512_STATE_WORDS
index|]
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN_512_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
comment|/* now output the result */
name|byteCnt
operator|=
operator|(
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* total number of output bytes */
comment|/* run Threefish in "counter mode" to generate output */
name|memset
argument_list|(
name|ctx
operator|->
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out b[], so it can hold the counter */
name|memcpy
argument_list|(
name|X
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep a local copy of counter mode "key" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
operator|<
name|byteCnt
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|u64b_t
operator|*
operator|)
name|ctx
operator|->
name|b
operator|)
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
operator|(
name|u64b_t
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* build the counter block */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|OUT_FINAL
argument_list|)
expr_stmt|;
name|Skein_512_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64b_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run "counter mode" */
name|n
operator|=
name|byteCnt
operator|-
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
comment|/* number of output bytes left to go */
if|if
condition|(
name|n
operator|>=
name|SKEIN_512_BLOCK_BYTES
condition|)
name|n
operator|=
name|SKEIN_512_BLOCK_BYTES
expr_stmt|;
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* "output" the ctr mode bytes */
name|Skein_Show_Final
argument_list|(
literal|256
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|n
argument_list|,
name|hashVal
operator|+
name|i
operator|*
name|SKEIN_512_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the counter mode key for next time */
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* just do the OUTPUT stage                                       */
end_comment

begin_function
name|int
name|Skein1024_Output
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
name|u08b_t
modifier|*
name|hashVal
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|byteCnt
decl_stmt|;
name|u64b_t
name|X
index|[
name|SKEIN1024_STATE_WORDS
index|]
decl_stmt|;
name|Skein_Assert
argument_list|(
name|ctx
operator|->
name|h
operator|.
name|bCnt
operator|<=
name|SKEIN1024_BLOCK_BYTES
argument_list|,
name|SKEIN_FAIL
argument_list|)
expr_stmt|;
comment|/* catch uninitialized context */
comment|/* now output the result */
name|byteCnt
operator|=
operator|(
name|ctx
operator|->
name|h
operator|.
name|hashBitLen
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* total number of output bytes */
comment|/* run Threefish in "counter mode" to generate output */
name|memset
argument_list|(
name|ctx
operator|->
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out b[], so it can hold the counter */
name|memcpy
argument_list|(
name|X
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep a local copy of counter mode "key" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
operator|<
name|byteCnt
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|u64b_t
operator|*
operator|)
name|ctx
operator|->
name|b
operator|)
index|[
literal|0
index|]
operator|=
name|Skein_Swap64
argument_list|(
operator|(
name|u64b_t
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* build the counter block */
name|Skein_Start_New_Type
argument_list|(
name|ctx
argument_list|,
name|OUT_FINAL
argument_list|)
expr_stmt|;
name|Skein1024_Process_Block
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|b
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64b_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run "counter mode" */
name|n
operator|=
name|byteCnt
operator|-
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
comment|/* number of output bytes left to go */
if|if
condition|(
name|n
operator|>=
name|SKEIN1024_BLOCK_BYTES
condition|)
name|n
operator|=
name|SKEIN1024_BLOCK_BYTES
expr_stmt|;
name|Skein_Put64_LSB_First
argument_list|(
name|hashVal
operator|+
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
argument_list|,
name|ctx
operator|->
name|X
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* "output" the ctr mode bytes */
name|Skein_Show_Final
argument_list|(
literal|256
argument_list|,
operator|&
name|ctx
operator|->
name|h
argument_list|,
name|n
argument_list|,
name|hashVal
operator|+
name|i
operator|*
name|SKEIN1024_BLOCK_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|X
argument_list|,
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|X
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the counter mode key for next time */
block|}
return|return
name|SKEIN_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

