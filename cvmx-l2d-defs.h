begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-l2d-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon l2d.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_L2D_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_L2D_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_BST0
value|CVMX_L2D_BST0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_BST0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_BST0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000780ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_BST0
value|(CVMX_ADD_IO_SEG(0x0001180080000780ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_BST1
value|CVMX_L2D_BST1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_BST1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_BST1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000788ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_BST1
value|(CVMX_ADD_IO_SEG(0x0001180080000788ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_BST2
value|CVMX_L2D_BST2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_BST2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_BST2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000790ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_BST2
value|(CVMX_ADD_IO_SEG(0x0001180080000790ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_BST3
value|CVMX_L2D_BST3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_BST3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_BST3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000798ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_BST3
value|(CVMX_ADD_IO_SEG(0x0001180080000798ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_ERR
value|CVMX_L2D_ERR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_ERR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_ERR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_ERR
value|(CVMX_ADD_IO_SEG(0x0001180080000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FADR
value|CVMX_L2D_FADR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FADR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FADR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FADR
value|(CVMX_ADD_IO_SEG(0x0001180080000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FSYN0
value|CVMX_L2D_FSYN0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FSYN0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FSYN0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FSYN0
value|(CVMX_ADD_IO_SEG(0x0001180080000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FSYN1
value|CVMX_L2D_FSYN1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FSYN1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FSYN1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FSYN1
value|(CVMX_ADD_IO_SEG(0x0001180080000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FUS0
value|CVMX_L2D_FUS0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FUS0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FUS0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FUS0
value|(CVMX_ADD_IO_SEG(0x00011800800007A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FUS1
value|CVMX_L2D_FUS1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FUS1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FUS1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FUS1
value|(CVMX_ADD_IO_SEG(0x00011800800007A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FUS2
value|CVMX_L2D_FUS2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FUS2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FUS2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FUS2
value|(CVMX_ADD_IO_SEG(0x00011800800007B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2D_FUS3
value|CVMX_L2D_FUS3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2D_FUS3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2D_FUS3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2D_FUS3
value|(CVMX_ADD_IO_SEG(0x00011800800007B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_l2d_bst0  *  * L2D_BST0 = L2C Data Store QUAD0 BIST Status Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_bst0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_bst0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|ftl
range|:
literal|1
decl_stmt|;
comment|/**< L2C Data Store Fatal Defect(across all QUADs)                                                          2 or more columns were detected bad across all                                                          QUADs[0-3]. Please refer to individual quad failures                                                          for bad column = 0x7e to determine which QUAD was in                                                          error. */
name|uint64_t
name|q0stat
range|:
literal|34
decl_stmt|;
comment|/**< Bist Results for QUAD0                                                          Failure \#1 Status                                                            [16:14] bad bank                                                            [13:7] bad high column                                                            [6:0] bad low column                                                          Failure \#2 Status                                                            [33:31] bad bank                                                            [30:24] bad high column                                                            [23:17] bad low column                                                          NOTES: For bad high/low column reporting:                                                             0x7f:   No failure                                                             0x7e:   Fatal Defect: 2 or more bad columns                                                             0-0x45: Bad column                                                          NOTE: If there are less than 2 failures then the                                                             bad bank will be 0x7. */
else|#
directive|else
name|uint64_t
name|q0stat
range|:
literal|34
decl_stmt|;
name|uint64_t
name|ftl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_bst0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_bst0
name|cvmx_l2d_bst0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_bst1  *  * L2D_BST1 = L2C Data Store QUAD1 BIST Status Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_bst1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_bst1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|q1stat
range|:
literal|34
decl_stmt|;
comment|/**< Bist Results for QUAD1                                                          Failure \#1 Status                                                             [16:14] bad bank                                                             [13:7] bad high column                                                             [6:0] bad low column                                                           Failure \#2 Status                                                             [33:31] bad bank                                                             [30:24] bad high column                                                             [23:17] bad low column                                                           NOTES: For bad high/low column reporting:                                                              0x7f:   No failure                                                              0x7e:   Fatal Defect: 2 or more bad columns                                                              0-0x45: Bad column                                                           NOTE: If there are less than 2 failures then the                                                              bad bank will be 0x7. */
else|#
directive|else
name|uint64_t
name|q1stat
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_bst1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_bst1
name|cvmx_l2d_bst1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_bst2  *  * L2D_BST2 = L2C Data Store QUAD2 BIST Status Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_bst2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_bst2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|q2stat
range|:
literal|34
decl_stmt|;
comment|/**< Bist Results for QUAD2                                                          Failure \#1 Status                                                             [16:14] bad bank                                                             [13:7] bad high column                                                             [6:0] bad low column                                                           Failure \#2 Status                                                             [33:31] bad bank                                                             [30:24] bad high column                                                             [23:17] bad low column                                                           NOTES: For bad high/low column reporting:                                                              0x7f:   No failure                                                              0x7e:   Fatal Defect: 2 or more bad columns                                                              0-0x45: Bad column                                                           NOTE: If there are less than 2 failures then the                                                              bad bank will be 0x7. */
else|#
directive|else
name|uint64_t
name|q2stat
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_bst2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_bst2
name|cvmx_l2d_bst2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_bst3  *  * L2D_BST3 = L2C Data Store QUAD3 BIST Status Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_bst3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_bst3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|q3stat
range|:
literal|34
decl_stmt|;
comment|/**< Bist Results for QUAD3                                                          Failure \#1 Status                                                             [16:14] bad bank                                                             [13:7] bad high column                                                             [6:0] bad low column                                                           Failure \#2 Status                                                             [33:31] bad bank                                                             [30:24] bad high column                                                             [23:17] bad low column                                                           NOTES: For bad high/low column reporting:                                                              0x7f:   No failure                                                              0x7e:   Fatal Defect: 2 or more bad columns                                                              0-0x45: Bad column                                                           NOTE: If there are less than 2 failures then the                                                              bad bank will be 0x7. */
else|#
directive|else
name|uint64_t
name|q3stat
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_bst3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_bst3_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_bst3
name|cvmx_l2d_bst3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_err  *  * L2D_ERR = L2 Data Errors  *  * Description: L2 Data ECC SEC/DED Errors and Interrupt Enable  */
end_comment

begin_union
union|union
name|cvmx_l2d_err
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_err_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|bmhclsel
range|:
literal|1
decl_stmt|;
comment|/**< L2 Bit Map Half CacheLine ECC Selector                                                            When L2C_DBG[L2T]=1/L2D_ERR[ECC_ENA]=0, the BMHCLSEL selects                                                           which half cacheline to conditionally latch into                                                           the L2D_FSYN0/L2D_FSYN1 registers when an LDD command                                                           is detected from the diagnostic PP (see L2C_DBG[PPNUM]).                                                          - 0: OW[0-3] ECC (from first 1/2 cacheline) is selected to                                                              be conditionally latched into the L2D_FSYN0/1 CSRs.                                                          - 1: OW[4-7] ECC (from last 1/2 cacheline) is selected to                                                              be conditionally latched into                                                              the L2D_FSYN0/1 CSRs. */
name|uint64_t
name|ded_err
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double Error detected (DED) */
name|uint64_t
name|sec_err
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single Error corrected (SEC) */
name|uint64_t
name|ded_intena
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data ECC Double Error Detect(DED) Interrupt Enable bit                                                          When set, allows interrupts to be reported on double bit                                                          (uncorrectable) errors from the L2 Data Arrays. */
name|uint64_t
name|sec_intena
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data ECC Single Error Correct(SEC) Interrupt Enable bit                                                          When set, allows interrupts to be reported on single bit                                                          (correctable) errors from the L2 Data Arrays. */
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data ECC Enable                                                          When set, enables 10-bit SEC/DED codeword for 128bit L2                                                          Data Arrays. */
else|#
directive|else
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sec_intena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ded_intena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sec_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ded_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bmhclsel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_err_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_err_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_err
name|cvmx_l2d_err_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fadr  *  * L2D_FADR = L2 Failing Address  *  * Description: L2 Data ECC SEC/DED Failing Address  *  * Notes:  * When L2D_SEC_ERR or L2D_DED_ERR are set, this field contains the failing L2 Data store index.  * (A DED Error will always overwrite a SEC Error SYNDROME and FADR).  */
end_comment

begin_union
union|union
name|cvmx_l2d_fadr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fadr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|fadru
range|:
literal|1
decl_stmt|;
comment|/**< Failing L2 Data Store Upper Index bit(MSB) */
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
comment|/**< Failing OW Mask (which one of 4 OWs contained SEC/DED                                                          error) */
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
comment|/**< Failing SET# */
name|uint64_t
name|fadr
range|:
literal|11
decl_stmt|;
comment|/**< Failing L2 Data Store Lower Index bits                                                          (NOTE: L2 Data Store Index is for each 1/2 cacheline)                                                             [FADRU, FADR[10:1]]: cacheline index[17:7]                                                             FADR[0]: 1/2 cacheline index                                                          NOTE: FADR[1] is used to select between upper/lower 1MB                                                          physical L2 Data Store banks. */
else|#
directive|else
name|uint64_t
name|fadr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fadru
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2d_fadr_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
comment|/**< Failing OW Mask (which one of 4 OWs contained SEC/DED                                                          error) */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|2
decl_stmt|;
comment|/**< Failing SET# */
name|uint64_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|9
decl_stmt|;
comment|/**< Failing L2 Data Store Index(1of512 = 1/2 CL address) */
else|#
directive|else
name|uint64_t
name|fadr
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2d_fadr_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
comment|/**< Failing OW Mask (which one of 4 OWs contained SEC/DED                                                          error) */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|2
decl_stmt|;
comment|/**< Failing SET# */
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|10
decl_stmt|;
comment|/**< Failing L2 Data Store Index                                                          (1 of 1024 = half cacheline indices) */
else|#
directive|else
name|uint64_t
name|fadr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2d_fadr_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
comment|/**< Failing OW Mask (which one of 4 OWs contained SEC/DED                                                          error) */
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
comment|/**< Failing SET# */
name|uint64_t
name|fadr
range|:
literal|11
decl_stmt|;
comment|/**< Failing L2 Data Store Index (1of2K = 1/2 CL address) */
else|#
directive|else
name|uint64_t
name|fadr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_l2d_fadr_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2d_fadr_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
comment|/**< Failing OW Mask (which one of 4 OWs contained SEC/DED                                                          error) */
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
comment|/**< Failing SET# */
name|uint64_t
name|reserved_8_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|8
decl_stmt|;
comment|/**< Failing L2 Data Store Lower Index bits                                                          (NOTE: L2 Data Store Index is for each 1/2 cacheline)                                                             FADR[7:1]: cacheline index[13:7]                                                             FADR[0]: 1/2 cacheline index */
else|#
directive|else
name|uint64_t
name|fadr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2d_fadr_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
comment|/**< Failing OW Mask (which one of 4 OWs contained SEC/DED                                                          error) */
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
comment|/**< Failing SET# */
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|10
decl_stmt|;
comment|/**< Failing L2 Data Store Lower Index bits                                                          (NOTE: L2 Data Store Index is for each 1/2 cacheline)                                                             FADR[9:1]: cacheline index[15:7]                                                             FADR[0]: 1/2 cacheline index */
else|#
directive|else
name|uint64_t
name|fadr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fset
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fowmsk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_l2d_fadr_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fadr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_fadr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fadr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_fadr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fadr
name|cvmx_l2d_fadr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fsyn0  *  * L2D_FSYN0 = L2 Failing Syndrome [OW0,4 / OW1,5]  *  * Description: L2 Data ECC SEC/DED Failing Syndrome for lower cache line  *  * Notes:  * When L2D_SEC_ERR or L2D_DED_ERR are set, this field contains the failing L2 Data ECC 10b syndrome.  * (A DED Error will always overwrite a SEC Error SYNDROME and FADR).  */
end_comment

begin_union
union|union
name|cvmx_l2d_fsyn0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fsyn0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|fsyn_ow1
range|:
literal|10
decl_stmt|;
comment|/**< Failing L2 Data Store SYNDROME OW[1,5]                                                          When L2D_ERR[ECC_ENA]=1 and either L2D_ERR[SEC_ERR]                                                          or L2D_ERR[DED_ERR] are set, this field represents                                                          the failing OWECC syndrome for the half cacheline                                                          indexed by L2D_FADR[FADR].                                                          NOTE: The L2D_FADR[FOWMSK] further qualifies which                                                          OW lane(1of4) detected the error.                                                          When L2C_DBG[L2T]=1 and L2D_ERR[ECC_ENA]=0, an LDD                                                          command from the diagnostic PP will conditionally latch                                                          the raw OWECC for the selected half cacheline.                                                          (see: L2D_ERR[BMHCLSEL] */
name|uint64_t
name|fsyn_ow0
range|:
literal|10
decl_stmt|;
comment|/**< Failing L2 Data Store SYNDROME OW[0,4]                                                          When L2D_ERR[ECC_ENA]=1 and either L2D_ERR[SEC_ERR]                                                          or L2D_ERR[DED_ERR] are set, this field represents                                                          the failing OWECC syndrome for the half cacheline                                                          indexed by L2D_FADR[FADR].                                                          NOTE: The L2D_FADR[FOWMSK] further qualifies which                                                          OW lane(1of4) detected the error.                                                          When L2C_DBG[L2T]=1 and L2D_ERR[ECC_ENA]=0, an LDD                                                          (L1 load-miss) from the diagnostic PP will conditionally                                                          latch the raw OWECC for the selected half cacheline.                                                          (see: L2D_ERR[BMHCLSEL] */
else|#
directive|else
name|uint64_t
name|fsyn_ow0
range|:
literal|10
decl_stmt|;
name|uint64_t
name|fsyn_ow1
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fsyn0
name|cvmx_l2d_fsyn0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fsyn1  *  * L2D_FSYN1 = L2 Failing Syndrome [OW2,6 / OW3,7]  *  * Description: L2 Data ECC SEC/DED Failing Syndrome for upper cache line  *  * Notes:  * When L2D_SEC_ERR or L2D_DED_ERR are set, this field contains the failing L2 Data ECC 10b syndrome.  * (A DED Error will always overwrite a SEC Error SYNDROME and FADR).  */
end_comment

begin_union
union|union
name|cvmx_l2d_fsyn1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fsyn1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|fsyn_ow3
range|:
literal|10
decl_stmt|;
comment|/**< Failing L2 Data Store SYNDROME OW[3,7] */
name|uint64_t
name|fsyn_ow2
range|:
literal|10
decl_stmt|;
comment|/**< Failing L2 Data Store SYNDROME OW[2,5] */
else|#
directive|else
name|uint64_t
name|fsyn_ow2
range|:
literal|10
decl_stmt|;
name|uint64_t
name|fsyn_ow3
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_fsyn1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fsyn1
name|cvmx_l2d_fsyn1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fus0  *  * L2D_FUS0 = L2C Data Store QUAD0 Fuse Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_fus0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fus0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|q0fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD0                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuse are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q0fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_fus0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fus0
name|cvmx_l2d_fus0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fus1  *  * L2D_FUS1 = L2C Data Store QUAD1 Fuse Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_fus1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fus1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|q1fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD1                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuse are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q1fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_fus1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fus1
name|cvmx_l2d_fus1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fus2  *  * L2D_FUS2 = L2C Data Store QUAD2 Fuse Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_fus2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fus2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|q2fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD2                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuse are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q2fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2d_fus2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2d_fus2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fus2
name|cvmx_l2d_fus2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2d_fus3  *  * L2D_FUS3 = L2C Data Store QUAD3 Fuse Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2d_fus3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2d_fus3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
comment|/**< L2 Data Store EMA Control                                                          These bits are used to 'observe' the EMA[1:0] inputs                                                          for the L2 Data Store RAMs which are controlled by                                                          either FUSES[141:140] or by MIO_FUSE_EMA[EMA] CSR.                                                          From poweron (dc_ok), the EMA_CTL are driven from                                                          FUSE[141:140]. However after the 1st CSR write to the                                                          MIO_FUSE_EMA[EMA] bits, the EMA_CTL will source                                                          from the MIO_FUSE_EMA[EMA] register permanently                                                          (until dc_ok). */
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2d_fus3_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|crip_64k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1. */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:15] UNUSED                                                              [14]    bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:32] UNUSED                                                              [31]    bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_64k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2d_fus3_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|crip_128k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1. */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:15] UNUSED                                                              [14]    bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:32] UNUSED                                                              [31]    bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_128k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2d_fus3_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|crip_256k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1.                                                          *** NOTE: Pass2 Addition */
name|uint64_t
name|crip_512k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1.                                                          *** NOTE: Pass2 Addition */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_512k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_256k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_l2d_fus3_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2d_fus3_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
comment|/**< L2 Data Store EMA Control                                                          These bits are used to 'observe' the EMA[2:0] inputs                                                          for the L2 Data Store RAMs which are controlled by                                                          either FUSES[142:140] or by MIO_FUSE_EMA[EMA] CSR.                                                          From poweron (dc_ok), the EMA_CTL are driven from                                                          FUSE[141:140]. However after the 1st CSR write to the                                                          MIO_FUSE_EMA[EMA] bits, the EMA_CTL will source                                                          from the MIO_FUSE_EMA[EMA] register permanently                                                          (until dc_ok). */
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_32k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1. */
name|uint64_t
name|crip_64k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1. */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] UNUSED (5020 uses single physical bank per quad)                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] UNUSED (5020 uses single physical bank per quad)                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_64k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_32k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2d_fus3_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
comment|/**< L2 Data Store EMA Control                                                          These bits are used to 'observe' the EMA[2:0] inputs                                                          for the L2 Data Store RAMs which are controlled by                                                          either FUSES[142:140] or by MIO_FUSE_EMA[EMA] CSR.                                                          From poweron (dc_ok), the EMA_CTL are driven from                                                          FUSE[141:140]. However after the 1st CSR write to the                                                          MIO_FUSE_EMA[EMA] bits, the EMA_CTL will source                                                          from the MIO_FUSE_EMA[EMA] register permanently                                                          (until dc_ok). */
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_128k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1. */
name|uint64_t
name|crip_256k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1. */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] UNUSED (5020 uses single physical bank per quad)                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] UNUSED (5020 uses single physical bank per quad)                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_256k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_128k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_l2d_fus3_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_l2d_fus3_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
comment|/**< L2 Data Store EMA Control                                                          These bits are used to 'observe' the EMA[2:0] inputs                                                          for the L2 Data Store RAMs which are controlled by                                                          either FUSES[142:140] or by MIO_FUSE_EMA[EMA] CSR.                                                          From poweron (dc_ok), the EMA_CTL are driven from                                                          FUSE[141:140]. However after the 1st CSR write to the                                                          MIO_FUSE_EMA[EMA] bits, the EMA_CTL will source                                                          from the MIO_FUSE_EMA[EMA] register permanently                                                          (until dc_ok). */
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_512k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1.                                                          *** NOTE: Pass2 Addition */
name|uint64_t
name|crip_1024k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1.                                                          *** NOTE: Pass2 Addition */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_1024k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_512k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_l2d_fus3_cn56xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_l2d_fus3_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|2
decl_stmt|;
comment|/**< L2 Data Store EMA Control                                                          These bits are used to 'observe' the EMA[1:0] inputs                                                          for the L2 Data Store RAMs which are controlled by                                                          either FUSES[141:140] or by MIO_FUSE_EMA[EMA] CSR.                                                          From poweron (dc_ok), the EMA_CTL are driven from                                                          FUSE[141:140]. However after the 1st CSR write to the                                                          MIO_FUSE_EMA[EMA] bits, the EMA_CTL will source                                                          from the MIO_FUSE_EMA[EMA] register permanently                                                          (until dc_ok). */
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_512k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1.                                                          *** NOTE: Pass2 Addition */
name|uint64_t
name|crip_1024k
range|:
literal|1
decl_stmt|;
comment|/**< This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          If the FUSE is not-blown, then this bit should read                                                          as 0. If the FUSE is blown, then this bit should read                                                          as 1.                                                          *** NOTE: Pass2 Addition */
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
comment|/**< Fuse Register for QUAD3                                                          This is purely for debug and not needed in the general                                                          manufacturing flow.                                                          Note that the fuses are complementary (Assigning a                                                          fuse to 1 will read as a zero). This means the case                                                          where no fuses are blown result in these csr's showing                                                          all ones.                                                           Failure \#1 Fuse Mapping                                                              [16:14] bad bank                                                              [13:7] bad high column                                                              [6:0] bad low column                                                            Failure \#2 Fuse Mapping                                                              [33:31] bad bank                                                              [30:24] bad high column                                                              [23:17] bad low column */
else|#
directive|else
name|uint64_t
name|q3fus
range|:
literal|34
decl_stmt|;
name|uint64_t
name|crip_1024k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_512k
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_36
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema_ctl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_l2d_fus3_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2d_fus3
name|cvmx_l2d_fus3_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

