begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  */
end_comment

begin_comment
comment|/* ************************************* *  Includes ***************************************/
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* Compiler options, UTIL_GetFileSize, UTIL_sleep */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen, ftello64 */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock_t, clock, CLOCKS_PER_SEC */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* toupper */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_include
include|#
directive|include
file|"datagen.h"
end_include

begin_comment
comment|/* RDG_genBuffer */
end_comment

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_include
include|#
directive|include
file|"zstd_zlibwrapper.h"
end_include

begin_comment
comment|/*-************************************ *  Tuning parameters **************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTDCLI_CLEVEL_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|ZSTDCLI_CLEVEL_DEFAULT
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************ *  Constants **************************************/
end_comment

begin_define
define|#
directive|define
name|COMPRESSOR_NAME
value|"Zstandard wrapper for zlib command line interface"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_VERSION
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_VERSION
value|"v" ZSTD_VERSION_STRING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AUTHOR
value|"Yann Collet"
end_define

begin_define
define|#
directive|define
name|WELCOME_MESSAGE
value|"*** %s %i-bits %s, by %s ***\n", COMPRESSOR_NAME, (int)(sizeof(size_t)*8), ZSTD_VERSION, AUTHOR
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_GIT_COMMIT
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_GIT_COMMIT_STRING
value|""
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZSTD_GIT_COMMIT_STRING
value|ZSTD_EXPAND_AND_QUOTE(ZSTD_GIT_COMMIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NBLOOPS
value|3
end_define

begin_define
define|#
directive|define
name|TIMELOOP_MICROSEC
value|1*1000000ULL
end_define

begin_comment
comment|/* 1 second */
end_comment

begin_define
define|#
directive|define
name|ACTIVEPERIOD_MICROSEC
value|70*1000000ULL
end_define

begin_comment
comment|/* 70 seconds */
end_comment

begin_define
define|#
directive|define
name|COOLPERIOD_SEC
value|10
end_define

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|maxMemory
init|=
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
operator|)
condition|?
operator|(
literal|2
name|GB
operator|-
literal|64
name|MB
operator|)
else|:
call|(
name|size_t
call|)
argument_list|(
literal|1ULL
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|31
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U32
name|g_compressibilityDefault
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************* *  console display ***************************************/
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DISPLAY_LEVEL
value|2
end_define

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(displayOut, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_decl_stmt
specifier|static
name|int
name|g_displayLevel
init|=
name|DEFAULT_DISPLAY_LEVEL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : no display;   1: errors;   2 : + result + interaction + warnings;   3 : + progression;   4 : + information */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|displayOut
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { \             if ((clock() - g_time> refreshRate) || (g_displayLevel>=4)) \             { g_time = clock(); DISPLAY(__VA_ARGS__); \             if (g_displayLevel>=4) fflush(displayOut); } }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|15
operator|/
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************* *  Exceptions ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGOUTPUT
parameter_list|(
modifier|...
parameter_list|)
value|{ if (DEBUG) DISPLAY(__VA_ARGS__); }
end_define

begin_define
define|#
directive|define
name|EXM_THROW
parameter_list|(
name|error
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{                                                                         \     DEBUGOUTPUT("Error defined at %s, line %i : \n", __FILE__, __LINE__); \     DISPLAYLEVEL(1, "Error %i : ", error);                                \     DISPLAYLEVEL(1, __VA_ARGS__);                                         \     DISPLAYLEVEL(1, "\n");                                                \     exit(error);                                                          \ }
end_define

begin_comment
comment|/* ************************************* *  Benchmark Parameters ***************************************/
end_comment

begin_decl_stmt
specifier|static
name|U32
name|g_nbIterations
init|=
name|NBLOOPS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|g_blockSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|g_additionalParam
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|BMK_setNotificationLevel
parameter_list|(
name|unsigned
name|level
parameter_list|)
block|{
name|g_displayLevel
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BMK_setAdditionalParam
parameter_list|(
name|int
name|additionalParam
parameter_list|)
block|{
name|g_additionalParam
operator|=
name|additionalParam
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BMK_SetNbIterations
parameter_list|(
name|unsigned
name|nbLoops
parameter_list|)
block|{
name|g_nbIterations
operator|=
name|nbLoops
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"- test>= %u seconds per compression / decompression -\n"
argument_list|,
name|g_nbIterations
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BMK_SetBlockSize
parameter_list|(
name|size_t
name|blockSize
parameter_list|)
block|{
name|g_blockSize
operator|=
name|blockSize
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"using blocks of size %u KB \n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|blockSize
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ******************************************************** *  Bench functions **********************************************************/
end_comment

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|z_const
name|char
modifier|*
name|srcPtr
decl_stmt|;
name|size_t
name|srcSize
decl_stmt|;
name|char
modifier|*
name|cPtr
decl_stmt|;
name|size_t
name|cRoom
decl_stmt|;
name|size_t
name|cSize
decl_stmt|;
name|char
modifier|*
name|resPtr
decl_stmt|;
name|size_t
name|resSize
decl_stmt|;
block|}
name|blockParam_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|BMK_ZSTD
block|,
name|BMK_ZSTD_STREAM
block|,
name|BMK_ZLIB
block|,
name|BMK_ZWRAP_ZLIB
block|,
name|BMK_ZWRAP_ZSTD
block|,
name|BMK_ZLIB_REUSE
block|,
name|BMK_ZWRAP_ZLIB_REUSE
block|,
name|BMK_ZWRAP_ZSTD_REUSE
block|}
name|BMK_compressor
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|BMK_benchMem
parameter_list|(
name|z_const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|char
modifier|*
name|displayName
parameter_list|,
name|int
name|cLevel
parameter_list|,
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|U32
name|nbFiles
parameter_list|,
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferSize
parameter_list|,
name|BMK_compressor
name|compressor
parameter_list|)
block|{
name|size_t
specifier|const
name|blockSize
init|=
operator|(
name|g_blockSize
operator|>=
literal|32
condition|?
name|g_blockSize
else|:
name|srcSize
operator|)
operator|+
operator|(
operator|!
name|srcSize
operator|)
comment|/* avoid div by 0 */
decl_stmt|;
name|size_t
specifier|const
name|avgSize
init|=
name|MIN
argument_list|(
name|g_blockSize
argument_list|,
operator|(
name|srcSize
operator|/
name|nbFiles
operator|)
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|maxNbBlocks
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|srcSize
operator|+
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|)
operator|/
name|blockSize
argument_list|)
operator|+
name|nbFiles
decl_stmt|;
name|blockParam_t
modifier|*
specifier|const
name|blockTable
init|=
operator|(
name|blockParam_t
operator|*
operator|)
name|malloc
argument_list|(
name|maxNbBlocks
operator|*
sizeof|sizeof
argument_list|(
name|blockParam_t
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|maxCompressedSize
init|=
name|ZSTD_compressBound
argument_list|(
name|srcSize
argument_list|)
operator|+
operator|(
name|maxNbBlocks
operator|*
literal|1024
operator|)
decl_stmt|;
comment|/* add some room for safety */
name|void
modifier|*
specifier|const
name|compressedBuffer
init|=
name|malloc
argument_list|(
name|maxCompressedSize
argument_list|)
decl_stmt|;
name|void
modifier|*
specifier|const
name|resultBuffer
init|=
name|malloc
argument_list|(
name|srcSize
argument_list|)
decl_stmt|;
name|ZSTD_CCtx
modifier|*
specifier|const
name|ctx
init|=
name|ZSTD_createCCtx
argument_list|()
decl_stmt|;
name|ZSTD_DCtx
modifier|*
specifier|const
name|dctx
init|=
name|ZSTD_createDCtx
argument_list|()
decl_stmt|;
name|U32
name|nbBlocks
decl_stmt|;
name|UTIL_freq_t
name|ticksPerSecond
decl_stmt|;
comment|/* checks */
if|if
condition|(
operator|!
name|compressedBuffer
operator|||
operator|!
name|resultBuffer
operator|||
operator|!
name|blockTable
operator|||
operator|!
name|ctx
operator|||
operator|!
name|dctx
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"allocation error : not enough memory"
argument_list|)
expr_stmt|;
comment|/* init */
if|if
condition|(
name|strlen
argument_list|(
name|displayName
argument_list|)
operator|>
literal|17
condition|)
name|displayName
operator|+=
name|strlen
argument_list|(
name|displayName
argument_list|)
operator|-
literal|17
expr_stmt|;
comment|/* can only display 17 characters */
name|UTIL_initTimer
argument_list|(
operator|&
name|ticksPerSecond
argument_list|)
expr_stmt|;
comment|/* Init blockTable data */
block|{
name|z_const
name|char
modifier|*
name|srcPtr
init|=
operator|(
name|z_const
name|char
operator|*
operator|)
name|srcBuffer
decl_stmt|;
name|char
modifier|*
name|cPtr
init|=
operator|(
name|char
operator|*
operator|)
name|compressedBuffer
decl_stmt|;
name|char
modifier|*
name|resPtr
init|=
operator|(
name|char
operator|*
operator|)
name|resultBuffer
decl_stmt|;
name|U32
name|fileNb
decl_stmt|;
for|for
control|(
name|nbBlocks
operator|=
literal|0
operator|,
name|fileNb
operator|=
literal|0
init|;
name|fileNb
operator|<
name|nbFiles
condition|;
name|fileNb
operator|++
control|)
block|{
name|size_t
name|remaining
init|=
name|fileSizes
index|[
name|fileNb
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBlocksforThisFile
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|remaining
operator|+
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|)
operator|/
name|blockSize
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|blockEnd
init|=
name|nbBlocks
operator|+
name|nbBlocksforThisFile
decl_stmt|;
for|for
control|(
init|;
name|nbBlocks
operator|<
name|blockEnd
condition|;
name|nbBlocks
operator|++
control|)
block|{
name|size_t
specifier|const
name|thisBlockSize
init|=
name|MIN
argument_list|(
name|remaining
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|srcPtr
operator|=
name|srcPtr
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cPtr
operator|=
name|cPtr
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|resPtr
operator|=
name|resPtr
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|srcSize
operator|=
name|thisBlockSize
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cRoom
operator|=
name|ZSTD_compressBound
argument_list|(
name|thisBlockSize
argument_list|)
expr_stmt|;
name|srcPtr
operator|+=
name|thisBlockSize
expr_stmt|;
name|cPtr
operator|+=
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cRoom
expr_stmt|;
name|resPtr
operator|+=
name|thisBlockSize
expr_stmt|;
name|remaining
operator|-=
name|thisBlockSize
expr_stmt|;
block|}
block|}
block|}
comment|/* warmimg up memory */
name|RDG_genBuffer
argument_list|(
name|compressedBuffer
argument_list|,
name|maxCompressedSize
argument_list|,
literal|0.10
argument_list|,
literal|0.50
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Bench */
block|{
name|U64
name|fastestC
init|=
call|(
name|U64
call|)
argument_list|(
operator|-
literal|1LL
argument_list|)
decl_stmt|,
name|fastestD
init|=
call|(
name|U64
call|)
argument_list|(
operator|-
literal|1LL
argument_list|)
decl_stmt|;
name|U64
specifier|const
name|crcOrig
init|=
name|XXH64
argument_list|(
name|srcBuffer
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|UTIL_time_t
name|coolTime
decl_stmt|;
name|U64
specifier|const
name|maxTime
init|=
operator|(
name|g_nbIterations
operator|*
name|TIMELOOP_MICROSEC
operator|)
operator|+
literal|100
decl_stmt|;
name|U64
name|totalCTime
init|=
literal|0
decl_stmt|,
name|totalDTime
init|=
literal|0
decl_stmt|;
name|U32
name|cCompleted
init|=
literal|0
decl_stmt|,
name|dCompleted
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|NB_MARKS
value|4
specifier|const
name|char
modifier|*
specifier|const
name|marks
index|[
name|NB_MARKS
index|]
init|=
block|{
literal|" |"
block|,
literal|" /"
block|,
literal|" ="
block|,
literal|"\\"
block|}
decl_stmt|;
name|U32
name|markNb
init|=
literal|0
decl_stmt|;
name|size_t
name|cSize
init|=
literal|0
decl_stmt|;
name|double
name|ratio
init|=
literal|0.
decl_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|coolTime
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cCompleted
operator||
operator|!
name|dCompleted
condition|)
block|{
name|UTIL_time_t
name|clockStart
decl_stmt|;
name|U64
name|clockLoop
init|=
name|g_nbIterations
condition|?
name|TIMELOOP_MICROSEC
else|:
literal|1
decl_stmt|;
comment|/* overheat protection */
if|if
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|coolTime
argument_list|,
name|ticksPerSecond
argument_list|)
operator|>
name|ACTIVEPERIOD_MICROSEC
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\rcooling down ...    \r"
argument_list|)
expr_stmt|;
name|UTIL_sleep
argument_list|(
name|COOLPERIOD_SEC
argument_list|)
expr_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|coolTime
argument_list|)
expr_stmt|;
block|}
comment|/* Compression */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2s-%-17.17s :%10u ->\r"
argument_list|,
name|marks
index|[
name|markNb
index|]
argument_list|,
name|displayName
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cCompleted
condition|)
name|memset
argument_list|(
name|compressedBuffer
argument_list|,
literal|0xE5
argument_list|,
name|maxCompressedSize
argument_list|)
expr_stmt|;
comment|/* warm up and erase result buffer */
name|UTIL_sleepMilli
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* give processor time to other processes */
name|UTIL_waitForNextTick
argument_list|(
name|ticksPerSecond
argument_list|)
expr_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|clockStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cCompleted
condition|)
block|{
comment|/* still some time to do compression tests */
name|U32
name|nbLoops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|compressor
operator|==
name|BMK_ZSTD
condition|)
block|{
name|ZSTD_parameters
specifier|const
name|zparams
init|=
name|ZSTD_getParams
argument_list|(
name|cLevel
argument_list|,
name|avgSize
argument_list|,
name|dictBufferSize
argument_list|)
decl_stmt|;
name|ZSTD_customMem
specifier|const
name|cmem
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|ZSTD_CDict
modifier|*
specifier|const
name|cdict
init|=
name|ZSTD_createCDict_advanced
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
literal|1
comment|/*byRef*/
argument_list|,
name|ZSTD_dm_auto
argument_list|,
name|zparams
operator|.
name|cParams
argument_list|,
name|cmem
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdict
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_createCDict_advanced() allocation failure"
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
name|size_t
name|rSize
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
if|if
condition|(
name|dictBufferSize
condition|)
block|{
name|rSize
operator|=
name|ZSTD_compress_usingCDict
argument_list|(
name|ctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|,
name|cdict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rSize
operator|=
name|ZSTD_compressCCtx
argument_list|(
name|ctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|,
name|cLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_compress_usingCDict() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
operator|=
name|rSize
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ZSTD_freeCDict
argument_list|(
name|cdict
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressor
operator|==
name|BMK_ZSTD_STREAM
condition|)
block|{
name|ZSTD_parameters
specifier|const
name|zparams
init|=
name|ZSTD_getParams
argument_list|(
name|cLevel
argument_list|,
name|avgSize
argument_list|,
name|dictBufferSize
argument_list|)
decl_stmt|;
name|ZSTD_inBuffer
name|inBuffer
decl_stmt|;
name|ZSTD_outBuffer
name|outBuffer
decl_stmt|;
name|ZSTD_CStream
modifier|*
name|zbc
init|=
name|ZSTD_createCStream
argument_list|()
decl_stmt|;
name|size_t
name|rSize
decl_stmt|;
if|if
condition|(
name|zbc
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_createCStream() allocation failure"
argument_list|)
expr_stmt|;
name|rSize
operator|=
name|ZSTD_initCStream_advanced
argument_list|(
name|zbc
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|zparams
argument_list|,
name|avgSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_initCStream_advanced() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
name|rSize
operator|=
name|ZSTD_resetCStream
argument_list|(
name|zbc
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_resetCStream() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|src
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
expr_stmt|;
name|inBuffer
operator|.
name|size
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
expr_stmt|;
name|inBuffer
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|outBuffer
operator|.
name|dst
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
expr_stmt|;
name|outBuffer
operator|.
name|size
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
expr_stmt|;
name|outBuffer
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|rSize
operator|=
name|ZSTD_compressStream
argument_list|(
name|zbc
argument_list|,
operator|&
name|outBuffer
argument_list|,
operator|&
name|inBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_compressStream() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|rSize
operator|=
name|ZSTD_endStream
argument_list|(
name|zbc
argument_list|,
operator|&
name|outBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_endStream() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
operator|=
name|outBuffer
operator|.
name|pos
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ZSTD_freeCStream
argument_list|(
name|zbc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressor
operator|==
name|BMK_ZWRAP_ZLIB_REUSE
operator|||
name|compressor
operator|==
name|BMK_ZWRAP_ZSTD_REUSE
operator|||
name|compressor
operator|==
name|BMK_ZLIB_REUSE
condition|)
block|{
name|z_stream
name|def
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|useSetDict
init|=
operator|(
name|dictBuffer
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|compressor
operator|==
name|BMK_ZLIB_REUSE
operator|||
name|compressor
operator|==
name|BMK_ZWRAP_ZLIB_REUSE
condition|)
name|ZWRAP_useZSTDcompression
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|ZWRAP_useZSTDcompression
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|def
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|def
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|def
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|deflateInit
argument_list|(
operator|&
name|def
argument_list|,
name|cLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateInit failure"
argument_list|)
expr_stmt|;
comment|/*   if (ZWRAP_isUsingZSTDcompression()) {                         ret = ZWRAP_setPledgedSrcSize(&def, avgSize);                         if (ret != Z_OK) EXM_THROW(1, "ZWRAP_setPledgedSrcSize failure");                     } */
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
if|if
condition|(
name|ZWRAP_isUsingZSTDcompression
argument_list|()
condition|)
name|ret
operator|=
name|ZWRAP_deflateReset_keepDict
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
comment|/* reuse dictionary to make compression faster */
else|else
name|ret
operator|=
name|deflateReset
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateReset failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|useSetDict
condition|)
block|{
name|ret
operator|=
name|deflateSetDictionary
argument_list|(
operator|&
name|def
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateSetDictionary failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZWRAP_isUsingZSTDcompression
argument_list|()
condition|)
name|useSetDict
operator|=
literal|0
expr_stmt|;
comment|/* zstd doesn't require deflateSetDictionary after ZWRAP_deflateReset_keepDict */
block|}
name|def
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
expr_stmt|;
name|def
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
expr_stmt|;
name|def
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|def
operator|.
name|next_out
operator|=
operator|(
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
expr_stmt|;
name|def
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
expr_stmt|;
name|def
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|def
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflate failure ret=%d srcSize=%d"
argument_list|,
name|ret
argument_list|,
operator|(
name|int
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
operator|=
name|def
operator|.
name|total_out
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateEnd failure"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|z_stream
name|def
decl_stmt|;
if|if
condition|(
name|compressor
operator|==
name|BMK_ZLIB
operator|||
name|compressor
operator|==
name|BMK_ZWRAP_ZLIB
condition|)
name|ZWRAP_useZSTDcompression
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|ZWRAP_useZSTDcompression
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
name|def
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|def
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|def
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|deflateInit
argument_list|(
operator|&
name|def
argument_list|,
name|cLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateInit failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dictBuffer
condition|)
block|{
name|ret
operator|=
name|deflateSetDictionary
argument_list|(
operator|&
name|def
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateSetDictionary failure"
argument_list|)
expr_stmt|;
block|}
name|def
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
expr_stmt|;
name|def
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
expr_stmt|;
name|def
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|def
operator|.
name|next_out
operator|=
operator|(
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
expr_stmt|;
name|def
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
expr_stmt|;
name|def
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|def
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflate failure"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"deflateEnd failure"
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
operator|=
name|def
operator|.
name|total_out
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
block|}
block|{
name|U64
specifier|const
name|clockSpan
init|=
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
decl_stmt|;
if|if
condition|(
name|clockSpan
operator|<
name|fastestC
operator|*
name|nbLoops
condition|)
name|fastestC
operator|=
name|clockSpan
operator|/
name|nbLoops
expr_stmt|;
name|totalCTime
operator|+=
name|clockSpan
expr_stmt|;
name|cCompleted
operator|=
name|totalCTime
operator|>
name|maxTime
expr_stmt|;
block|}
block|}
name|cSize
operator|=
literal|0
expr_stmt|;
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
name|cSize
operator|+=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
expr_stmt|;
block|}
name|ratio
operator|=
operator|(
name|double
operator|)
name|srcSize
operator|/
operator|(
name|double
operator|)
name|cSize
expr_stmt|;
name|markNb
operator|=
operator|(
name|markNb
operator|+
literal|1
operator|)
operator|%
name|NB_MARKS
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2s-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s\r"
argument_list|,
name|marks
index|[
name|markNb
index|]
argument_list|,
name|displayName
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|,
operator|(
name|U32
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fastestD
expr_stmt|;
operator|(
name|void
operator|)
name|crcOrig
expr_stmt|;
comment|/*  unused when decompression disabled */
if|#
directive|if
literal|1
comment|/* Decompression */
if|if
condition|(
operator|!
name|dCompleted
condition|)
name|memset
argument_list|(
name|resultBuffer
argument_list|,
literal|0xD6
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
comment|/* warm result buffer */
name|UTIL_sleepMilli
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* give processor time to other processes */
name|UTIL_waitForNextTick
argument_list|(
name|ticksPerSecond
argument_list|)
expr_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|clockStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dCompleted
condition|)
block|{
name|U32
name|nbLoops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|compressor
operator|==
name|BMK_ZSTD
condition|)
block|{
name|ZSTD_DDict
modifier|*
name|ddict
init|=
name|ZSTD_createDDict
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ddict
condition|)
name|EXM_THROW
argument_list|(
literal|2
argument_list|,
literal|"ZSTD_createDDict() allocation failure"
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
name|size_t
specifier|const
name|regenSize
init|=
name|ZSTD_decompress_usingDDict
argument_list|(
name|dctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
argument_list|,
name|ddict
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|regenSize
argument_list|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"ZSTD_decompress_usingDDict() failed on block %u : %s  \n"
argument_list|,
name|blockNb
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|regenSize
argument_list|)
argument_list|)
expr_stmt|;
name|clockLoop
operator|=
literal|0
expr_stmt|;
comment|/* force immediate test end */
break|break;
block|}
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resSize
operator|=
name|regenSize
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ZSTD_freeDDict
argument_list|(
name|ddict
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressor
operator|==
name|BMK_ZSTD_STREAM
condition|)
block|{
name|ZSTD_inBuffer
name|inBuffer
decl_stmt|;
name|ZSTD_outBuffer
name|outBuffer
decl_stmt|;
name|ZSTD_DStream
modifier|*
name|zbd
init|=
name|ZSTD_createDStream
argument_list|()
decl_stmt|;
name|size_t
name|rSize
decl_stmt|;
if|if
condition|(
name|zbd
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_createDStream() allocation failure"
argument_list|)
expr_stmt|;
name|rSize
operator|=
name|ZSTD_initDStream_usingDict
argument_list|(
name|zbd
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_initDStream() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
name|rSize
operator|=
name|ZSTD_resetDStream
argument_list|(
name|zbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_resetDStream() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|src
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
expr_stmt|;
name|inBuffer
operator|.
name|size
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
expr_stmt|;
name|inBuffer
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|outBuffer
operator|.
name|dst
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resPtr
expr_stmt|;
name|outBuffer
operator|.
name|size
operator|=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
expr_stmt|;
name|outBuffer
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|rSize
operator|=
name|ZSTD_decompressStream
argument_list|(
name|zbd
argument_list|,
operator|&
name|outBuffer
argument_list|,
operator|&
name|inBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_decompressStream() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resSize
operator|=
name|outBuffer
operator|.
name|pos
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ZSTD_freeDStream
argument_list|(
name|zbd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressor
operator|==
name|BMK_ZWRAP_ZLIB_REUSE
operator|||
name|compressor
operator|==
name|BMK_ZWRAP_ZSTD_REUSE
operator|||
name|compressor
operator|==
name|BMK_ZLIB_REUSE
condition|)
block|{
name|z_stream
name|inf
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|compressor
operator|==
name|BMK_ZLIB_REUSE
condition|)
name|ZWRAP_setDecompressionType
argument_list|(
name|ZWRAP_FORCE_ZLIB
argument_list|)
expr_stmt|;
else|else
name|ZWRAP_setDecompressionType
argument_list|(
name|ZWRAP_AUTO
argument_list|)
expr_stmt|;
name|inf
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateInit failure"
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
if|if
condition|(
name|ZWRAP_isUsingZSTDdecompression
argument_list|(
operator|&
name|inf
argument_list|)
condition|)
name|ret
operator|=
name|ZWRAP_inflateReset_keepDict
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
comment|/* reuse dictionary to make decompression faster; inflate will return Z_NEED_DICT only for the first time */
else|else
name|ret
operator|=
name|inflateReset
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateReset failure"
argument_list|)
expr_stmt|;
name|inf
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
expr_stmt|;
name|inf
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
expr_stmt|;
name|inf
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|next_out
operator|=
operator|(
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resPtr
expr_stmt|;
name|inf
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
expr_stmt|;
name|inf
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|inf
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_NEED_DICT
condition|)
block|{
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|inf
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateSetDictionary failure"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|inf
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflate failure"
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resSize
operator|=
name|inf
operator|.
name|total_out
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateEnd failure"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|z_stream
name|inf
decl_stmt|;
if|if
condition|(
name|compressor
operator|==
name|BMK_ZLIB
condition|)
name|ZWRAP_setDecompressionType
argument_list|(
name|ZWRAP_FORCE_ZLIB
argument_list|)
expr_stmt|;
else|else
name|ZWRAP_setDecompressionType
argument_list|(
name|ZWRAP_AUTO
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
name|inf
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateInit failure"
argument_list|)
expr_stmt|;
name|inf
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
expr_stmt|;
name|inf
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
expr_stmt|;
name|inf
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|next_out
operator|=
operator|(
name|void
operator|*
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resPtr
expr_stmt|;
name|inf
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
expr_stmt|;
name|inf
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|inf
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_NEED_DICT
condition|)
block|{
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|inf
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateSetDictionary failure"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|inf
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflate failure"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"inflateEnd failure"
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resSize
operator|=
name|inf
operator|.
name|total_out
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
block|}
block|{
name|U64
specifier|const
name|clockSpan
init|=
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
decl_stmt|;
if|if
condition|(
name|clockSpan
operator|<
name|fastestD
operator|*
name|nbLoops
condition|)
name|fastestD
operator|=
name|clockSpan
operator|/
name|nbLoops
expr_stmt|;
name|totalDTime
operator|+=
name|clockSpan
expr_stmt|;
name|dCompleted
operator|=
name|totalDTime
operator|>
name|maxTime
expr_stmt|;
block|}
block|}
name|markNb
operator|=
operator|(
name|markNb
operator|+
literal|1
operator|)
operator|%
name|NB_MARKS
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2s-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s ,%6.1f MB/s\r"
argument_list|,
name|marks
index|[
name|markNb
index|]
argument_list|,
name|displayName
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|,
operator|(
name|U32
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestC
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestD
argument_list|)
expr_stmt|;
comment|/* CRC Checking */
block|{
name|U64
specifier|const
name|crcCheck
init|=
name|XXH64
argument_list|(
name|resultBuffer
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|crcOrig
operator|!=
name|crcCheck
condition|)
block|{
name|size_t
name|u
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"!!! WARNING !!! %14s : Invalid Checksum : %x != %x   \n"
argument_list|,
name|displayName
argument_list|,
operator|(
name|unsigned
operator|)
name|crcOrig
argument_list|,
operator|(
name|unsigned
operator|)
name|crcCheck
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|srcSize
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|u
index|]
operator|!=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|resultBuffer
operator|)
index|[
name|u
index|]
condition|)
block|{
name|U32
name|segNb
decl_stmt|,
name|bNb
decl_stmt|,
name|pos
decl_stmt|;
name|size_t
name|bacc
init|=
literal|0
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"Decoding error at pos %u "
argument_list|,
operator|(
name|U32
operator|)
name|u
argument_list|)
expr_stmt|;
for|for
control|(
name|segNb
operator|=
literal|0
init|;
name|segNb
operator|<
name|nbBlocks
condition|;
name|segNb
operator|++
control|)
block|{
if|if
condition|(
name|bacc
operator|+
name|blockTable
index|[
name|segNb
index|]
operator|.
name|srcSize
operator|>
name|u
condition|)
break|break;
name|bacc
operator|+=
name|blockTable
index|[
name|segNb
index|]
operator|.
name|srcSize
expr_stmt|;
block|}
name|pos
operator|=
call|(
name|U32
call|)
argument_list|(
name|u
operator|-
name|bacc
argument_list|)
expr_stmt|;
name|bNb
operator|=
name|pos
operator|/
operator|(
literal|128
name|KB
operator|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"(block %u, sub %u, pos %u) \n"
argument_list|,
name|segNb
argument_list|,
name|bNb
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|u
operator|==
name|srcSize
operator|-
literal|1
condition|)
block|{
comment|/* should never happen */
name|DISPLAY
argument_list|(
literal|"no difference detected\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* CRC Checking */
endif|#
directive|endif
block|}
comment|/* for (testNb = 1; testNb<= (g_nbIterations + !g_nbIterations); testNb++) */
if|if
condition|(
name|g_displayLevel
operator|==
literal|1
condition|)
block|{
name|double
name|cSpeed
init|=
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestC
decl_stmt|;
name|double
name|dSpeed
init|=
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestD
decl_stmt|;
if|if
condition|(
name|g_additionalParam
condition|)
name|DISPLAY
argument_list|(
literal|"-%-3i%11i (%5.3f) %6.2f MB/s %6.1f MB/s  %s (param=%d)\n"
argument_list|,
name|cLevel
argument_list|,
operator|(
name|int
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
name|cSpeed
argument_list|,
name|dSpeed
argument_list|,
name|displayName
argument_list|,
name|g_additionalParam
argument_list|)
expr_stmt|;
else|else
name|DISPLAY
argument_list|(
literal|"-%-3i%11i (%5.3f) %6.2f MB/s %6.1f MB/s  %s\n"
argument_list|,
name|cLevel
argument_list|,
operator|(
name|int
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
name|cSpeed
argument_list|,
name|dSpeed
argument_list|,
name|displayName
argument_list|)
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2i#\n"
argument_list|,
name|cLevel
argument_list|)
expr_stmt|;
block|}
comment|/* Bench */
comment|/* clean up */
name|free
argument_list|(
name|blockTable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressedBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resultBuffer
argument_list|)
expr_stmt|;
name|ZSTD_freeCCtx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ZSTD_freeDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|BMK_findMaxMem
parameter_list|(
name|U64
name|requiredMem
parameter_list|)
block|{
name|size_t
specifier|const
name|step
init|=
literal|64
name|MB
decl_stmt|;
name|BYTE
modifier|*
name|testmem
init|=
name|NULL
decl_stmt|;
name|requiredMem
operator|=
operator|(
operator|(
operator|(
name|requiredMem
operator|>>
literal|26
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|26
operator|)
expr_stmt|;
name|requiredMem
operator|+=
name|step
expr_stmt|;
if|if
condition|(
name|requiredMem
operator|>
name|maxMemory
condition|)
name|requiredMem
operator|=
name|maxMemory
expr_stmt|;
do|do
block|{
name|testmem
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|requiredMem
argument_list|)
expr_stmt|;
name|requiredMem
operator|-=
name|step
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|testmem
condition|)
do|;
name|free
argument_list|(
name|testmem
argument_list|)
expr_stmt|;
return|return
call|(
name|size_t
call|)
argument_list|(
name|requiredMem
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|BMK_benchCLevel
parameter_list|(
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|benchedSize
parameter_list|,
specifier|const
name|char
modifier|*
name|displayName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|,
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferSize
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
init|=
name|strrchr
argument_list|(
name|displayName
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
comment|/* Windows */
if|if
condition|(
operator|!
name|pch
condition|)
name|pch
operator|=
name|strrchr
argument_list|(
name|displayName
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Linux */
if|if
condition|(
name|pch
condition|)
name|displayName
operator|=
name|pch
operator|+
literal|1
expr_stmt|;
name|SET_REALTIME_PRIORITY
expr_stmt|;
if|if
condition|(
name|g_displayLevel
operator|==
literal|1
operator|&&
operator|!
name|g_additionalParam
condition|)
name|DISPLAY
argument_list|(
literal|"bench %s %s: input %u bytes, %u seconds, %u KB blocks\n"
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|,
name|ZSTD_GIT_COMMIT_STRING
argument_list|,
operator|(
name|U32
operator|)
name|benchedSize
argument_list|,
name|g_nbIterations
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|g_blockSize
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cLevelLast
operator|<
name|cLevel
condition|)
name|cLevelLast
operator|=
name|cLevel
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"benchmarking zstd %s (using ZSTD_CStream)\n"
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZSTD_STREAM
argument_list|)
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"benchmarking zstd %s (using ZSTD_CCtx)\n"
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZSTD
argument_list|)
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"benchmarking zstd %s (using zlibWrapper)\n"
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZWRAP_ZSTD_REUSE
argument_list|)
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"benchmarking zstd %s (zlibWrapper not reusing a context)\n"
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZWRAP_ZSTD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cLevelLast
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|cLevelLast
operator|=
name|Z_BEST_COMPRESSION
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"benchmarking zlib %s\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZLIB_REUSE
argument_list|)
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"benchmarking zlib %s (zlib not reusing a context)\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZLIB
argument_list|)
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"benchmarking zlib %s (using zlibWrapper)\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZWRAP_ZLIB_REUSE
argument_list|)
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"benchmarking zlib %s (zlibWrapper not reusing a context)\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|BMK_ZWRAP_ZLIB
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*! BMK_loadFiles() :     Loads `buffer` with content of files listed within `fileNamesTable`.     At most, fills `buffer` entirely */
end_comment

begin_function
specifier|static
name|void
name|BMK_loadFiles
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
name|size_t
modifier|*
name|fileSizes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|,
name|totalSize
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbFiles
condition|;
name|n
operator|++
control|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|U64
name|fileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|UTIL_isDirectory
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Ignoring %s directory...       \n"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|fileSizes
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|10
argument_list|,
literal|"impossible to open file %s"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"Loading %s...       \r"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSize
operator|>
name|bufferSize
operator|-
name|pos
condition|)
name|fileSize
operator|=
name|bufferSize
operator|-
name|pos
operator|,
name|nbFiles
operator|=
name|n
expr_stmt|;
comment|/* buffer too small - stop after this file */
block|{
name|size_t
specifier|const
name|readSize
init|=
name|fread
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|)
operator|+
name|pos
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|fileSize
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|readSize
operator|!=
operator|(
name|size_t
operator|)
name|fileSize
condition|)
name|EXM_THROW
argument_list|(
literal|11
argument_list|,
literal|"could not read %s"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|readSize
expr_stmt|;
block|}
name|fileSizes
index|[
name|n
index|]
operator|=
operator|(
name|size_t
operator|)
name|fileSize
expr_stmt|;
name|totalSize
operator|+=
operator|(
name|size_t
operator|)
name|fileSize
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalSize
operator|==
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"no data to bench"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|BMK_benchFileTable
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|)
block|{
name|void
modifier|*
name|srcBuffer
decl_stmt|;
name|size_t
name|benchedSize
decl_stmt|;
name|void
modifier|*
name|dictBuffer
init|=
name|NULL
decl_stmt|;
name|size_t
name|dictBufferSize
init|=
literal|0
decl_stmt|;
name|size_t
modifier|*
name|fileSizes
init|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|nbFiles
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
decl_stmt|;
name|U64
specifier|const
name|totalSizeToLoad
init|=
name|UTIL_getTotalFileSize
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
decl_stmt|;
name|char
name|mfName
index|[
literal|20
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|fileSizes
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"not enough memory for fileSizes"
argument_list|)
expr_stmt|;
comment|/* Load dictionary */
if|if
condition|(
name|dictFileName
operator|!=
name|NULL
condition|)
block|{
name|U64
name|dictFileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|dictFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dictFileSize
operator|>
literal|64
name|MB
condition|)
name|EXM_THROW
argument_list|(
literal|10
argument_list|,
literal|"dictionary file %s too large"
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
name|dictBufferSize
operator|=
operator|(
name|size_t
operator|)
name|dictFileSize
expr_stmt|;
name|dictBuffer
operator|=
name|malloc
argument_list|(
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dictBuffer
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|11
argument_list|,
literal|"not enough memory for dictionary (%u bytes)"
argument_list|,
operator|(
name|U32
operator|)
name|dictBufferSize
argument_list|)
expr_stmt|;
name|BMK_loadFiles
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|fileSizes
argument_list|,
operator|&
name|dictFileName
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Memory allocation& restrictions */
name|benchedSize
operator|=
name|BMK_findMaxMem
argument_list|(
name|totalSizeToLoad
operator|*
literal|3
argument_list|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|U64
operator|)
name|benchedSize
operator|>
name|totalSizeToLoad
condition|)
name|benchedSize
operator|=
operator|(
name|size_t
operator|)
name|totalSizeToLoad
expr_stmt|;
if|if
condition|(
name|benchedSize
operator|<
name|totalSizeToLoad
condition|)
name|DISPLAY
argument_list|(
literal|"Not enough memory; testing %u MB only...\n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|benchedSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|srcBuffer
operator|=
name|malloc
argument_list|(
name|benchedSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srcBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
comment|/* Load input buffer */
name|BMK_loadFiles
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|fileSizes
argument_list|,
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
comment|/* Bench */
name|snprintf
argument_list|(
name|mfName
argument_list|,
sizeof|sizeof
argument_list|(
name|mfName
argument_list|)
argument_list|,
literal|" %u files"
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|displayName
init|=
operator|(
name|nbFiles
operator|>
literal|1
operator|)
condition|?
name|mfName
else|:
name|fileNamesTable
index|[
literal|0
index|]
decl_stmt|;
name|BMK_benchCLevel
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|free
argument_list|(
name|srcBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dictBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fileSizes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|BMK_syntheticTest
parameter_list|(
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|,
name|double
name|compressibility
parameter_list|)
block|{
name|char
name|name
index|[
literal|20
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|size_t
name|benchedSize
init|=
literal|10000000
decl_stmt|;
name|void
modifier|*
specifier|const
name|srcBuffer
init|=
name|malloc
argument_list|(
name|benchedSize
argument_list|)
decl_stmt|;
comment|/* Memory allocation */
if|if
condition|(
operator|!
name|srcBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|21
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
comment|/* Fill input buffer */
name|RDG_genBuffer
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|compressibility
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Bench */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Synthetic %2u%%"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|compressibility
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|BMK_benchCLevel
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|name
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
operator|&
name|benchedSize
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clean up */
name|free
argument_list|(
name|srcBuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|BMK_benchFiles
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|)
block|{
name|double
specifier|const
name|compressibility
init|=
operator|(
name|double
operator|)
name|g_compressibilityDefault
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|nbFiles
operator|==
literal|0
condition|)
name|BMK_syntheticTest
argument_list|(
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
name|compressibility
argument_list|)
expr_stmt|;
else|else
name|BMK_benchFileTable
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|,
name|dictFileName
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-************************************ *  Command Line **************************************/
end_comment

begin_function
specifier|static
name|int
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Usage :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"      %s [args] [FILE(s)] [-o file]\n"
argument_list|,
name|programName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"FILE    : a filename\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"          with no FILE, or when FILE is - , read standard input\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -D file: use `file` as Dictionary \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -h/-H  : display help/long help and exit\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -V     : display Version number and exit\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -v     : verbose mode; specify multiple times to increase log level (default:%d)\n"
argument_list|,
name|DEFAULT_DISPLAY_LEVEL
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -q     : suppress warnings; specify twice to suppress errors too\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
name|DISPLAY
argument_list|(
literal|" -r     : operate recursively on directories\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Benchmark arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -b#    : benchmark file(s), using # compression level (default : %d) \n"
argument_list|,
name|ZSTDCLI_CLEVEL_DEFAULT
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -e#    : test all compression levels from -bX to # (default: %d)\n"
argument_list|,
name|ZSTDCLI_CLEVEL_DEFAULT
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -i#    : minimum evaluation time in seconds (default : 3s)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -B#    : cut file into independent blocks of size # (default: no block)\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|badusage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Incorrect parameters\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_displayLevel
operator|>=
literal|1
condition|)
name|usage
argument_list|(
name|programName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|waitEnter
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|unused
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"Press enter to continue...\n"
argument_list|)
expr_stmt|;
name|unused
operator|=
name|getchar
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|unused
expr_stmt|;
block|}
end_function

begin_comment
comment|/*! readU32FromChar() :     @return : unsigned integer value reach from input in `char` format     Will also modify `*stringPtr`, advancing it to position where it stopped reading.     Note : this function can overflow if digit string> MAX_UINT */
end_comment

begin_function
specifier|static
name|unsigned
name|readU32FromChar
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stringPtr
parameter_list|)
block|{
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|*
operator|*
name|stringPtr
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|*
name|stringPtr
operator|<=
literal|'9'
operator|)
condition|)
name|result
operator|*=
literal|10
operator|,
name|result
operator|+=
operator|*
operator|*
name|stringPtr
operator|-
literal|'0'
operator|,
operator|(
operator|*
name|stringPtr
operator|)
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CLEAN_RETURN
parameter_list|(
name|i
parameter_list|)
value|{ operationResult = (i); goto _end; }
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argCount
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|argNb
decl_stmt|,
name|main_pause
init|=
literal|0
decl_stmt|,
name|nextEntryIsDictionary
init|=
literal|0
decl_stmt|,
name|operationResult
init|=
literal|0
decl_stmt|,
name|nextArgumentIsFile
init|=
literal|0
decl_stmt|;
name|int
name|cLevel
init|=
name|ZSTDCLI_CLEVEL_DEFAULT
decl_stmt|;
name|int
name|cLevelLast
init|=
literal|1
decl_stmt|;
name|unsigned
name|recursive
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filenameTable
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|argCount
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* argCount>= 1 */
name|unsigned
name|filenameIdx
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|programName
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|dictFileName
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|dynNameSpace
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fileNamesBuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|fileNamesNb
decl_stmt|;
endif|#
directive|endif
comment|/* init */
if|if
condition|(
name|filenameTable
operator|==
name|NULL
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"zstd: %s \n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|displayOut
operator|=
name|stderr
expr_stmt|;
comment|/* Pick out program name from path. Don't rely on stdlib because of conflicting behavior */
block|{
name|size_t
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|programName
argument_list|)
init|;
name|pos
operator|>
literal|0
condition|;
name|pos
operator|--
control|)
block|{
if|if
condition|(
name|programName
index|[
name|pos
index|]
operator|==
literal|'/'
condition|)
block|{
name|pos
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|programName
operator|+=
name|pos
expr_stmt|;
block|}
comment|/* command switches */
for|for
control|(
name|argNb
operator|=
literal|1
init|;
name|argNb
operator|<
name|argCount
condition|;
name|argNb
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|argument
init|=
name|argv
index|[
name|argNb
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argument
condition|)
continue|continue;
comment|/* Protection if argument empty */
if|if
condition|(
name|nextArgumentIsFile
operator|==
literal|0
condition|)
block|{
comment|/* long commands (--long-word) */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|nextArgumentIsFile
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--version"
argument_list|)
condition|)
block|{
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--help"
argument_list|)
condition|)
block|{
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
name|usage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|g_displayLevel
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--quiet"
argument_list|)
condition|)
block|{
name|g_displayLevel
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* Decode commands (note : aggregated commands are allowed) */
if|if
condition|(
name|argument
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argument
operator|++
expr_stmt|;
while|while
condition|(
name|argument
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|argument
index|[
literal|0
index|]
condition|)
block|{
comment|/* Display help */
case|case
literal|'V'
case|:
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Version Only */
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
name|usage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use file content as dictionary */
case|case
literal|'D'
case|:
name|nextEntryIsDictionary
operator|=
literal|1
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Verbose mode */
case|case
literal|'v'
case|:
name|g_displayLevel
operator|++
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Quiet mode */
case|case
literal|'q'
case|:
name|g_displayLevel
operator|--
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
comment|/* recursive */
case|case
literal|'r'
case|:
name|recursive
operator|=
literal|1
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* Benchmark */
case|case
literal|'b'
case|:
comment|/* first compression Level */
name|argument
operator|++
expr_stmt|;
name|cLevel
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
comment|/* range bench (benchmark only) */
case|case
literal|'e'
case|:
comment|/* last compression Level */
name|argument
operator|++
expr_stmt|;
name|cLevelLast
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
comment|/* Modify Nb Iterations (benchmark only) */
case|case
literal|'i'
case|:
name|argument
operator|++
expr_stmt|;
block|{
name|U32
specifier|const
name|iters
init|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
decl_stmt|;
name|BMK_setNotificationLevel
argument_list|(
name|g_displayLevel
argument_list|)
expr_stmt|;
name|BMK_SetNbIterations
argument_list|(
name|iters
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* cut input into blocks (benchmark only) */
case|case
literal|'B'
case|:
name|argument
operator|++
expr_stmt|;
block|{
name|size_t
name|bSize
init|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
decl_stmt|;
if|if
condition|(
name|toupper
argument_list|(
operator|*
name|argument
argument_list|)
operator|==
literal|'K'
condition|)
name|bSize
operator|<<=
literal|10
operator|,
name|argument
operator|++
expr_stmt|;
comment|/* allows using KB notation */
if|if
condition|(
name|toupper
argument_list|(
operator|*
name|argument
argument_list|)
operator|==
literal|'M'
condition|)
name|bSize
operator|<<=
literal|20
operator|,
name|argument
operator|++
expr_stmt|;
if|if
condition|(
name|toupper
argument_list|(
operator|*
name|argument
argument_list|)
operator|==
literal|'B'
condition|)
name|argument
operator|++
expr_stmt|;
name|BMK_setNotificationLevel
argument_list|(
name|g_displayLevel
argument_list|)
expr_stmt|;
name|BMK_SetBlockSize
argument_list|(
name|bSize
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Pause at the end (-p) or set an additional param (-p#) (hidden option) */
case|case
literal|'p'
case|:
name|argument
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|BMK_setAdditionalParam
argument_list|(
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|main_pause
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* unknown command */
default|default :
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* if (argument[0]=='-') */
block|}
comment|/* if (nextArgumentIsAFile==0) */
if|if
condition|(
name|nextEntryIsDictionary
condition|)
block|{
name|nextEntryIsDictionary
operator|=
literal|0
expr_stmt|;
name|dictFileName
operator|=
name|argument
expr_stmt|;
continue|continue;
block|}
comment|/* add filename to list */
name|filenameTable
index|[
name|filenameIdx
operator|++
index|]
operator|=
name|argument
expr_stmt|;
block|}
comment|/* Welcome message (if verbose) */
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
if|if
condition|(
name|recursive
condition|)
block|{
name|fileNamesTable
operator|=
name|UTIL_createFileList
argument_list|(
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
operator|&
name|fileNamesBuf
argument_list|,
operator|&
name|fileNamesNb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileNamesTable
condition|)
block|{
name|unsigned
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|fileNamesNb
condition|;
name|u
operator|++
control|)
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"%u %s\n"
argument_list|,
name|u
argument_list|,
name|fileNamesTable
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|filenameTable
argument_list|)
expr_stmt|;
name|filenameTable
operator|=
name|fileNamesTable
expr_stmt|;
name|filenameIdx
operator|=
name|fileNamesNb
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|BMK_setNotificationLevel
argument_list|(
name|g_displayLevel
argument_list|)
expr_stmt|;
name|BMK_benchFiles
argument_list|(
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
name|dictFileName
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|)
expr_stmt|;
name|_end
label|:
if|if
condition|(
name|main_pause
condition|)
name|waitEnter
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|dynNameSpace
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
if|if
condition|(
name|fileNamesTable
condition|)
name|UTIL_freeFileList
argument_list|(
name|fileNamesTable
argument_list|,
name|fileNamesBuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|filenameTable
argument_list|)
expr_stmt|;
return|return
name|operationResult
return|;
block|}
end_function

end_unit

