begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzread.c contains minimal changes required to be compiled with zlibWrapper:  * - gz_statep was converted to union to work with -Wstrict-aliasing=1      */
end_comment

begin_comment
comment|/* gzread.c -- zlib functions for reading gzip files  * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler  * For conditions of distribution and use, see http://www.zlib.net/zlib_license.html  */
end_comment

begin_include
include|#
directive|include
file|"gzguts.h"
end_include

begin_comment
comment|/* Local functions */
end_comment

begin_decl_stmt
name|local
name|int
name|gz_load
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_avail
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_look
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_decomp
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_fetch
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_skip
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|z_off64_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|z_size_t
name|gz_read
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|voidp
operator|,
name|z_size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from    state.state->fd, and update state.state->eof, state.state->err, and state.state->msg as appropriate.    This function needs to loop on read(), since read() is not guaranteed to    read the number of bytes requested, depending on the type of descriptor. */
end_comment

begin_function
name|local
name|int
name|gz_load
parameter_list|(
name|state
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|have
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
modifier|*
name|have
decl_stmt|;
block|{
name|ssize_t
name|ret
decl_stmt|;
name|unsigned
name|get
decl_stmt|,
name|max
init|=
operator|(
operator|(
name|unsigned
operator|)
operator|-
literal|1
operator|>>
literal|2
operator|)
operator|+
literal|1
decl_stmt|;
operator|*
name|have
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|get
operator|=
name|len
operator|-
operator|*
name|have
expr_stmt|;
if|if
condition|(
name|get
operator|>
name|max
condition|)
name|get
operator|=
name|max
expr_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|state
operator|.
name|state
operator|->
name|fd
argument_list|,
name|buf
operator|+
operator|*
name|have
argument_list|,
name|get
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
break|break;
operator|*
name|have
operator|+=
operator|(
name|unsigned
operator|)
name|ret
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|have
operator|<
name|len
condition|)
do|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_ERRNO
argument_list|,
name|zstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|state
operator|.
name|state
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Load up input buffer and set eof flag if last data loaded -- return -1 on    error, 0 otherwise.  Note that the eof flag is set when the end of the input    file is reached, even though there may be unused data in the buffer.  Once    that data has been used, no more attempts will be made to read the file.    If strm->avail_in != 0, then the current data is moved to the beginning of    the input buffer, and then the remainder of the buffer is loaded with the    available data from the input file. */
end_comment

begin_function
name|local
name|int
name|gz_avail
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|unsigned
name|got
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|strm
operator|)
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|eof
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_in
condition|)
block|{
comment|/* copy what's there to the start */
name|unsigned
name|char
modifier|*
name|p
init|=
name|state
operator|.
name|state
operator|->
name|in
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|q
init|=
name|strm
operator|->
name|next_in
decl_stmt|;
name|unsigned
name|n
init|=
name|strm
operator|->
name|avail_in
decl_stmt|;
do|do
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
if|if
condition|(
name|gz_load
argument_list|(
name|state
argument_list|,
name|state
operator|.
name|state
operator|->
name|in
operator|+
name|strm
operator|->
name|avail_in
argument_list|,
name|state
operator|.
name|state
operator|->
name|size
operator|-
name|strm
operator|->
name|avail_in
argument_list|,
operator|&
name|got
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|strm
operator|->
name|avail_in
operator|+=
name|got
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|state
operator|.
name|state
operator|->
name|in
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for gzip header, set up for inflate or copy.  state.state->x.have must be 0.    If this is the first time in, allocate required memory.  state.state->how will be    left unchanged if there is no more input data available, will be set to COPY    if there is no gzip header and direct copying will be performed, or it will    be set to GZIP for decompression.  If direct copying, then leftover input    data from the input buffer will be copied to the output buffer.  In that    case, all further file reads will be directly to either the output buffer or    a user buffer.  If decompressing, the inflate state will be initialized.    gz_look() will return 0 on success or -1 on failure. */
end_comment

begin_function
name|local
name|int
name|gz_look
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|strm
operator|)
decl_stmt|;
comment|/* allocate read buffers and inflate memory */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* allocate buffers */
name|state
operator|.
name|state
operator|->
name|in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|state
operator|.
name|state
operator|->
name|want
argument_list|)
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|state
operator|.
name|state
operator|->
name|want
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|in
operator|==
name|NULL
operator|||
name|state
operator|.
name|state
operator|->
name|out
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|.
name|state
operator|->
name|size
operator|=
name|state
operator|.
name|state
operator|->
name|want
expr_stmt|;
comment|/* allocate inflate memory */
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|inflateInit2
argument_list|(
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|strm
operator|)
argument_list|,
literal|15
operator|+
literal|16
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
comment|/* gunzip */
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* get at least the magic bytes in the input buffer */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|gz_avail
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* look for gzip magic bytes -- if there, do gzip decoding (note: there is        a logical dilemma here when considering the case of a partially written        gzip file, to wit, if a single 31 byte is written, then we cannot tell        whether this is a single-byte file, or just a partially written gzip        file -- for here we assume that if a gzip file is being written, then        the header will be written in a single operation, so that reading a        single byte is sufficient indication that it is not a gzip file) */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>
literal|1
operator|&&
operator|(
operator|(
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|==
literal|31
operator|&&
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|==
literal|139
operator|)
comment|/* gz header */
operator|||
operator|(
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|==
literal|40
operator|&&
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|==
literal|181
operator|)
operator|)
condition|)
block|{
comment|/* zstd header */
name|inflateReset
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|how
operator|=
name|GZIP
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|direct
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* no gzip header -- if we were decoding gzip before, then this is trailing        garbage.  Ignore the trailing garbage and finish. */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|direct
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* doing raw i/o, copy any leftover input to output -- this assumes that        the output buffer is larger than the input buffer, which also assures        space for gzungetc() */
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|state
operator|.
name|state
operator|->
name|out
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_in
condition|)
block|{
name|memcpy
argument_list|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|strm
operator|->
name|avail_in
argument_list|)
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
block|}
name|state
operator|.
name|state
operator|->
name|how
operator|=
name|COPY
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|direct
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decompress from input to the provided next_out and avail_out in the state.    On return, state.state->x.have and state.state->x.next point to the just decompressed    data.  If the gzip stream completes, state.state->how is reset to LOOK to look for    the next gzip stream or raw data, once state.state->x.have is depleted.  Returns 0    on success, -1 on failure. */
end_comment

begin_function
name|local
name|int
name|gz_decomp
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|int
name|ret
init|=
name|Z_OK
decl_stmt|;
name|unsigned
name|had
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|strm
operator|)
decl_stmt|;
comment|/* fill output buffer up to end of deflate stream */
name|had
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
do|do
block|{
comment|/* get more input for inflate() */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
operator|&&
name|gz_avail
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_BUF_ERROR
argument_list|,
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* decompress and handle errors */
name|ret
operator|=
name|inflate
argument_list|(
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_ERROR
operator|||
name|ret
operator|==
name|Z_NEED_DICT
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_STREAM_ERROR
argument_list|,
literal|"internal error: inflate stream corrupt"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_DATA_ERROR
condition|)
block|{
comment|/* deflate stream invalid */
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
name|strm
operator|->
name|msg
operator|==
name|NULL
condition|?
literal|"compressed data error"
else|:
name|strm
operator|->
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|strm
operator|->
name|avail_out
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
comment|/* update available output */
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|=
name|had
operator|-
name|strm
operator|->
name|avail_out
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|strm
operator|->
name|next_out
operator|-
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
expr_stmt|;
comment|/* if the gzip stream completed successfully, look for another */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
name|state
operator|.
name|state
operator|->
name|how
operator|=
name|LOOK
expr_stmt|;
comment|/* good decompression */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fetch data and put it in the output buffer.  Assumes state.state->x.have is 0.    Data is either copied from the input file or decompressed from the input    file depending on state.state->how.  If state.state->how is LOOK, then a gzip header is    looked for to determine whether to copy or decompress.  Returns -1 on error,    otherwise 0.  gz_fetch() will leave state.state->how as COPY or GZIP unless the    end of the input file has been reached and all data has been processed.  */
end_comment

begin_function
name|local
name|int
name|gz_fetch
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|strm
operator|)
decl_stmt|;
do|do
block|{
switch|switch
condition|(
name|state
operator|.
name|state
operator|->
name|how
condition|)
block|{
case|case
name|LOOK
case|:
comment|/* -> LOOK, COPY (only if never GZIP), or GZIP */
if|if
condition|(
name|gz_look
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|how
operator|==
name|LOOK
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|COPY
case|:
comment|/* -> COPY */
if|if
condition|(
name|gz_load
argument_list|(
name|state
argument_list|,
name|state
operator|.
name|state
operator|->
name|out
argument_list|,
name|state
operator|.
name|state
operator|->
name|size
operator|<<
literal|1
argument_list|,
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|state
operator|.
name|state
operator|->
name|out
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GZIP
case|:
comment|/* -> GZIP or LOOK (if end of gzip stream) */
name|strm
operator|->
name|avail_out
operator|=
name|state
operator|.
name|state
operator|->
name|size
operator|<<
literal|1
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|state
operator|.
name|state
operator|->
name|out
expr_stmt|;
if|if
condition|(
name|gz_decomp
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|==
literal|0
operator|&&
operator|(
operator|!
name|state
operator|.
name|state
operator|->
name|eof
operator|||
name|strm
operator|->
name|avail_in
operator|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
end_comment

begin_function
name|local
name|int
name|gz_skip
parameter_list|(
name|state
parameter_list|,
name|len
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|z_off64_t
name|len
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
comment|/* skip over len bytes or reach end-of-file, whichever comes first */
while|while
condition|(
name|len
condition|)
comment|/* skip over whatever is in output buffer */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
condition|)
block|{
name|n
operator|=
name|GT_OFF
argument_list|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
argument_list|)
operator|||
operator|(
name|z_off64_t
operator|)
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|>
name|len
condition|?
operator|(
name|unsigned
operator|)
name|len
else|:
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|-=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|+=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
comment|/* output buffer empty -- return if we're at the end of the input */
elseif|else
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|eof
operator|&&
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
break|break;
comment|/* need more data to skip -- load up output buffer */
else|else
block|{
comment|/* get more output, looking for header if required */
if|if
condition|(
name|gz_fetch
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read len bytes into buf from file, or less than len up to the end of the    input.  Return the number of bytes read.  If zero is returned, either the    end of file was reached, or there was an error.  state.state->err must be    consulted in that case to determine which. */
end_comment

begin_function
name|local
name|z_size_t
name|gz_read
parameter_list|(
name|state
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|voidp
name|buf
decl_stmt|;
name|z_size_t
name|len
decl_stmt|;
block|{
name|z_size_t
name|got
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
comment|/* if len is zero, avoid unnecessary operations */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* process a skip request */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|.
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_skip
argument_list|(
name|state
argument_list|,
name|state
operator|.
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
comment|/* get len bytes to buf, or less than len if at the end */
name|got
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* set n to the maximum amount of len that fits in an unsigned int */
name|n
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
comment|/* first just try copying data from the output buffer */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|<
name|n
condition|)
name|n
operator|=
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|+=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|-=
name|n
expr_stmt|;
block|}
comment|/* output buffer empty -- return if we're at the end of the input */
elseif|else
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|eof
operator|&&
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|state
operator|.
name|state
operator|->
name|past
operator|=
literal|1
expr_stmt|;
comment|/* tried to read past end */
break|break;
block|}
comment|/* need output data -- for small len or new stream load up our output            buffer */
elseif|else
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|how
operator|==
name|LOOK
operator|||
name|n
operator|<
operator|(
name|state
operator|.
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
condition|)
block|{
comment|/* get more output, looking for header if required */
if|if
condition|(
name|gz_fetch
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
continue|continue;
comment|/* no progress yet -- go back to copy above */
comment|/* the copy above assures that we will leave with space in the                output buffer, allowing at least one gzungetc() to succeed */
block|}
comment|/* large len -- read directly into user buffer */
elseif|else
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|how
operator|==
name|COPY
condition|)
block|{
comment|/* read directly */
if|if
condition|(
name|gz_load
argument_list|(
name|state
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|n
argument_list|,
operator|&
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
comment|/* large len -- decompress directly into user buffer */
else|else
block|{
comment|/* state.state->how == GZIP */
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|avail_out
operator|=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|strm
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|gz_decomp
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update progress */
name|len
operator|-=
name|n
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|n
expr_stmt|;
name|got
operator|+=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|len
condition|)
do|;
comment|/* return number of bytes read into user buffer */
return|return
name|got
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzread
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no (serious) error */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
operator|(
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* since an int is returned, make sure len fits in one, otherwise return        with an error (this avoids a flaw in the interface) */
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_STREAM_ERROR
argument_list|,
literal|"request does not fit in an int"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* read len or fewer bytes to buf */
name|len
operator|=
operator|(
name|unsigned
operator|)
name|gz_read
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* check for an error */
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
condition|)
return|return
operator|-
literal|1
return|;
comment|/* return the number of bytes read (this is assured to fit in an int) */
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|z_size_t
name|ZEXPORT
name|gzfread
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|nitems
parameter_list|,
name|file
parameter_list|)
name|voidp
name|buf
decl_stmt|;
name|z_size_t
name|size
decl_stmt|;
name|z_size_t
name|nitems
decl_stmt|;
name|gzFile
name|file
decl_stmt|;
block|{
name|z_size_t
name|len
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no (serious) error */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
operator|(
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
operator|)
condition|)
return|return
literal|0
return|;
comment|/* compute bytes to read -- error on overflow */
name|len
operator|=
name|nitems
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|len
operator|/
name|size
operator|!=
name|nitems
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_STREAM_ERROR
argument_list|,
literal|"request does not fit in a size_t"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* read len or fewer bytes to buf, return the number of full items read */
return|return
name|len
condition|?
name|gz_read
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|/
name|size
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_if
if|#
directive|if
name|ZLIB_VERNUM
operator|>=
literal|0x1261
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|Z_PREFIX_SET
end_ifdef

begin_undef
undef|#
directive|undef
name|z_gzgetc
end_undef

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|gzgetc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ZLIB_VERNUM
operator|==
literal|0x1260
end_if

begin_undef
undef|#
directive|undef
name|gzgetc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ZLIB_VERNUM
operator|<=
literal|0x1250
end_if

begin_decl_stmt
name|ZEXTERN
name|int
name|ZEXPORT
name|gzgetc
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ZEXTERN
name|int
name|ZEXPORT
name|gzgetc_
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ZEXPORT
name|gzgetc
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no (serious) error */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
operator|(
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* try output buffer (no need to check for skip request) */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
condition|)
block|{
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|--
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|pos
operator|++
expr_stmt|;
return|return
operator|*
operator|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|)
operator|++
return|;
block|}
comment|/* nothing there -- try gz_read() */
name|ret
operator|=
operator|(
name|unsigned
operator|)
name|gz_read
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
operator|<
literal|1
condition|?
operator|-
literal|1
else|:
name|buf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|gzgetc_
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
return|return
name|gzgetc
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzungetc
parameter_list|(
name|c
parameter_list|,
name|file
parameter_list|)
name|int
name|c
decl_stmt|;
name|gzFile
name|file
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no (serious) error */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
operator|(
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* process a skip request */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|.
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_skip
argument_list|(
name|state
argument_list|,
name|state
operator|.
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* can't push EOF */
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* if output buffer empty, put byte at end (allows more pushing) */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|==
literal|0
condition|)
block|{
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|state
operator|.
name|state
operator|->
name|out
operator|+
operator|(
name|state
operator|.
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|pos
operator|--
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|past
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/* if no room, give up (must have already done a gzungetc()) */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|==
operator|(
name|state
operator|.
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"out of room to push characters"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* slide output data if needed and insert byte before existing data */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|==
name|state
operator|.
name|state
operator|->
name|out
condition|)
block|{
name|unsigned
name|char
modifier|*
name|src
init|=
name|state
operator|.
name|state
operator|->
name|out
operator|+
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|state
operator|.
name|state
operator|->
name|out
operator|+
operator|(
name|state
operator|.
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|src
operator|>
name|state
operator|.
name|state
operator|->
name|out
condition|)
operator|*
operator|--
name|dest
operator|=
operator|*
operator|--
name|src
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|dest
expr_stmt|;
block|}
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|++
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|--
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|pos
operator|--
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|past
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|char
modifier|*
name|ZEXPORT
name|gzgets
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|left
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|char
modifier|*
name|eol
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* check parameters and get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|buf
operator|==
name|NULL
operator|||
name|len
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no (serious) error */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
operator|(
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_OK
operator|&&
name|state
operator|.
name|state
operator|->
name|err
operator|!=
name|Z_BUF_ERROR
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* process a skip request */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|.
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_skip
argument_list|(
name|state
argument_list|,
name|state
operator|.
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
comment|/* copy output bytes up to new line or len - 1, whichever comes first --        append a terminating zero to the string (we don't check for a zero in        the contents, let the user worry about that) */
name|str
operator|=
name|buf
expr_stmt|;
name|left
operator|=
operator|(
name|unsigned
operator|)
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|left
condition|)
do|do
block|{
comment|/* assure that something is in the output buffer */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|==
literal|0
operator|&&
name|gz_fetch
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* error */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|==
literal|0
condition|)
block|{
comment|/* end of file */
name|state
operator|.
name|state
operator|->
name|past
operator|=
literal|1
expr_stmt|;
comment|/* read past end */
break|break;
comment|/* return what we have */
block|}
comment|/* look for end-of-line in current output buffer */
name|n
operator|=
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|>
name|left
condition|?
name|left
else|:
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
expr_stmt|;
name|eol
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
argument_list|,
literal|'\n'
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
operator|!=
name|NULL
condition|)
name|n
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|eol
operator|-
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* copy through end-of-line, or remainder if not found */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|-=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|next
operator|+=
name|n
expr_stmt|;
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|n
expr_stmt|;
name|left
operator|-=
name|n
expr_stmt|;
name|buf
operator|+=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|left
operator|&&
name|eol
operator|==
name|NULL
condition|)
do|;
comment|/* return terminated string, or if nothing, end of file */
if|if
condition|(
name|buf
operator|==
name|str
condition|)
return|return
name|NULL
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzdirect
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* if the state is not known, but we can find out, then do so (this is        mainly for right after a gzopen() or gzdopen()) */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|==
name|GZ_READ
operator|&&
name|state
operator|.
name|state
operator|->
name|how
operator|==
name|LOOK
operator|&&
name|state
operator|.
name|state
operator|->
name|x
operator|.
name|have
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|gz_look
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* return 1 if transparent, 0 if processing a gzip stream */
return|return
name|state
operator|.
name|state
operator|->
name|direct
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzclose_r
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|err
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* free memory and close file */
if|if
condition|(
name|state
operator|.
name|state
operator|->
name|size
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
operator|(
name|state
operator|.
name|state
operator|->
name|strm
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|state
operator|.
name|state
operator|->
name|err
operator|==
name|Z_BUF_ERROR
condition|?
name|Z_BUF_ERROR
else|:
name|Z_OK
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
name|ret
operator|=
name|close
argument_list|(
name|state
operator|.
name|state
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|state
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
name|Z_ERRNO
else|:
name|err
return|;
block|}
end_function

end_unit

