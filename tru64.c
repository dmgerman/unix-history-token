begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysconfig.h>
end_include

begin_include
include|#
directive|include
file|<machine/machlimits.h>
end_include

begin_include
include|#
directive|include
file|<net/net_globals.h>
end_include

begin_include
include|#
directive|include
file|<io/common/iotypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/secdefines.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<io/common/pt.h>
end_include

begin_include
include|#
directive|include
file|<io/common/devdriver.h>
end_include

begin_include
include|#
directive|include
file|<io/common/devio.h>
end_include

begin_include
include|#
directive|include
file|<io/common/devgetinfo.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/firewall.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/ether_driver.h>
end_include

begin_include
include|#
directive|include
file|"ip_compat.h"
end_include

begin_include
include|#
directive|include
file|"ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"ip_state.h"
end_include

begin_include
include|#
directive|include
file|"ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"ip_auth.h"
end_include

begin_include
include|#
directive|include
file|"ip_compat.h"
end_include

begin_include
include|#
directive|include
file|"ip_fil.h"
end_include

begin_comment
comment|/* #undef	IPFDEBUG	*/
end_comment

begin_function_decl
specifier|static
name|int
name|ipfopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipfclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipfread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
name|int
name|ipfilter_attach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilter_detach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ipfilter_ifattach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ipfilter_ifdetach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilter_ifioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TRU64
operator|>=
literal|1885
end_if

begin_function_decl
name|int
name|ipfilter_ifoutput
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|ipfilter_ifoutput
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|ipfilter_in_control
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ipfilter_ip_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilter_ip_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|in_route
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|ipfilter_configure_callback
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ipfilter_timer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ipfilter_clock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilteropen
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilterread
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilterclose
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilterwrite
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipfilterioctl
parameter_list|(
name|dev_t
parameter_list|,
name|u_int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|nodev
argument_list|()
decl_stmt|,
name|nulldev
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|task_t
name|first_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ipfrwlock_t
name|ipf_tru64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ipf_timer_func
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dsent
name|ipfilter_devsw_entry
init|=
block|{
name|ipfilteropen
block|,
name|ipfilterclose
block|,
name|nodev
block|,
comment|/* d_strategy */
name|ipfilterread
block|,
name|ipfilterwrite
block|,
name|ipfilterioctl
block|,
name|nodev
block|,
comment|/* d_dump */
name|nodev
block|,
comment|/* d_psize */
name|nulldev
block|,
comment|/* d_stop */
name|nulldev
block|,
comment|/* d_reset */
name|nulldev
block|,
comment|/* d_select */
literal|0
block|,
comment|/* d_mmap */
literal|0
block|,
comment|/* d_segmap */
name|NULL
block|,
comment|/* d_ttys */
name|DEV_FUNNEL_NULL
block|,
comment|/* SMP-safe */
literal|0
block|,
comment|/* d_bflags */
literal|0
comment|/* d_cflags */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ipf_main_softc_t
name|ipfmain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|controller
modifier|*
name|ipfilter_info
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ipfilter_name
index|[]
init|=
literal|"ipfilter"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|ipfdriver
init|=
block|{
name|NULL
block|,
comment|/* probe  */
name|NULL
block|,
comment|/* slave */
name|NULL
block|,
comment|/* cattach */
name|NULL
block|,
comment|/* dattach */
literal|0
block|,
comment|/* go */
literal|0
block|,
comment|/* addr_list */
literal|0
block|,
comment|/* dev_name */
literal|0
block|,
comment|/* dev_list */
name|ipfilter_name
block|,
comment|/* ctlr_name */
name|ipfilter_info
block|,
comment|/* ctlr_list */
literal|0
block|,
comment|/* Want exclusive use of bdp's flag */
literal|0
block|,
comment|/* Size of first csr area */
literal|0
block|,
comment|/* Address space of first csr area */
literal|0
block|,
comment|/* Size of second csr area */
literal|0
block|,
comment|/* Address space of second csr area */
name|NULL
block|,
comment|/* controller unattach routine */
name|NULL
block|,
comment|/* dev_unattach */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_DEV
value|-1
end_define

begin_define
define|#
directive|define
name|MAJOR_INSTANCE
value|1
end_define

begin_define
define|#
directive|define
name|IPF_NAME
value|"ipf"
end_define

begin_decl_stmt
name|int
name|ipfilter_config
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipfilter_devno
init|=
name|NO_DEV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipfilter_num_units
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipfilter_dev_number
init|=
name|NO_DEV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|callback_return_status
init|=
name|ESUCCESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|driver_cfg_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipfilter_is_dynamic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables referenced by attributes. 'majnum' must  * be present to inform cfgmgr that this is a 5.0A  * driver. 'ipfilter_version' is used to keep track of the version  * numbers during development. It is printed out after  * configure to indicate which version is being loaded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|majnum
init|=
name|NO_DEV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipfilter_num_installed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ipfilter_desc
index|[
literal|100
index|]
init|=
literal|"IPFilter firewall"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ipfilter_unused
index|[
literal|300
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|thread_t
name|ipf_timeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protos for functions used in configuration */
end_comment

begin_decl_stmt
name|void
name|ipfilter_print_attr_error
name|__P
argument_list|(
operator|(
name|cfg_attr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ipfilter_preconfig_callback
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|ulong
operator|,
name|ulong
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ipfilter_postconfig_callback
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|ulong
operator|,
name|ulong
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|firewall_stat
block|{
name|u_long
name|in_control_called
decl_stmt|;
name|u_long
name|ip_input_mbufs
decl_stmt|;
name|u_long
name|ip_input_accept
decl_stmt|;
name|u_long
name|ip_input_reject
decl_stmt|;
name|u_long
name|ip_input_tooshort
decl_stmt|;
name|u_long
name|ip_input_toosmall
decl_stmt|;
name|u_long
name|ip_input_badlen
decl_stmt|;
name|u_long
name|ip_input_badhlen
decl_stmt|;
name|u_long
name|ip_input_badvers
decl_stmt|;
name|u_long
name|ip_input_badsum
decl_stmt|;
name|u_long
name|ip_output_mbufs
decl_stmt|;
name|u_long
name|ip_output_accept
decl_stmt|;
name|u_long
name|ip_output_reject
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|firewall_stat
name|ipfilter_stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipfilter_registered
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipftru64_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_subsys_attr_t
name|ipfilter_attributes
index|[]
init|=
block|{
block|{
literal|"Subsystem_Description"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_desc
block|,
literal|2
block|,
literal|300
block|,
literal|0
block|}
block|,
block|{
literal|"Module_Config_Name"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
literal|"ipfilter"
block|,
literal|2
block|,
name|CFG_ATTR_NAME_SZ
block|,
literal|0
block|}
block|,
block|{
literal|"majnum"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|majnum
block|,
literal|0
block|,
literal|512
block|,
literal|0
block|}
block|,
block|{
literal|"Num_Installed"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfilter_num_installed
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"Num_Units"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfilter_num_units
block|,
literal|1
block|,
name|IPL_LOGSIZE
block|,
literal|0
block|}
block|,
block|{
literal|"Module_Type"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_unused
block|,
literal|2
block|,
name|CFG_ATTR_NAME_SZ
block|,
literal|0
block|}
block|,
block|{
literal|"Device_Major_Req"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_unused
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|ipfilter_unused
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"Device_Char_Major"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_unused
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|ipfilter_unused
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"Device_Char_Files"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_unused
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|ipfilter_unused
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"Device_Char_Minor"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_unused
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|ipfilter_unused
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
name|CFG_ATTR_STRTYPE
block|,
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
name|ipfilter_version
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_chksrc"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_RECONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_chksrc
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_minttl"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_RECONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_minttl
block|,
literal|0
block|,
literal|255
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_pass"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_RECONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_minttl
block|,
literal|0
block|,
literal|0xffffffff
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_flags"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_RECONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_flags
block|,
literal|0
block|,
literal|0xffffffff
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_active"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_minttl
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_running"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_minttl
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_control_forwarding"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_RECONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_control_forwarding
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ipf_update_ipid"
block|,
name|CFG_ATTR_INTTYPE
block|,
name|CFG_OP_QUERY
operator||
name|CFG_OP_CONFIGURE
operator||
name|CFG_OP_RECONFIGURE
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipfmain
operator|.
name|ipf_update_ipid
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------  * Configure interface  * 1 - Handle attribute verification.  * 2 - Handle the differences between static and dynamic  *     configuration.  * Returns: EBUSY,EINVAL,ENOTSUP,ESRCH for fail,  *          ESUCCESS for success  *--------------------------------------------------------*/
end_comment

begin_function
name|cfg_status_t
name|ipfilter_configure
parameter_list|(
name|op
parameter_list|,
name|indata
parameter_list|,
name|indata_size
parameter_list|,
name|outdata
parameter_list|,
name|outdata_size
parameter_list|)
name|cfg_op_t
name|op
decl_stmt|;
name|caddr_t
name|indata
decl_stmt|;
name|ulong
name|indata_size
decl_stmt|;
name|caddr_t
name|outdata
decl_stmt|;
name|ulong
name|outdata_size
decl_stmt|;
block|{
name|int
name|ipfilter_cfg_state
decl_stmt|;
name|cfg_attr_t
modifier|*
name|attr_ptr
decl_stmt|;
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_configure(%x,%x,%d,%x,%d)\n"
argument_list|,
name|op
argument_list|,
name|indata
argument_list|,
name|indata_size
argument_list|,
name|outdata
argument_list|,
name|outdata_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|ESUCCESS
expr_stmt|;
if|if
condition|(
name|cfgmgr_get_state
argument_list|(
literal|"ipfilter"
argument_list|,
operator|&
name|ipfilter_cfg_state
argument_list|)
operator|!=
name|ESUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ipfilter cfgmgr_get_state failed\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|CFG_OP_CONFIGURE
case|:
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_config=%d\n"
argument_list|,
name|ipfilter_config
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"driver_cfg_state=%d\n"
argument_list|,
name|driver_cfg_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ipfilter_config
operator|==
name|TRUE
condition|)
block|{
comment|/* 			 * We have already been configured 			 */
return|return
name|EINVAL
return|;
block|}
comment|/* 		 * cfgmgr takes care of error checking, but we have to 		 * investigate what happened and report to user. 		 */
name|attr_ptr
operator|=
operator|(
name|cfg_attr_t
operator|*
operator|)
name|indata
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indata_size
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|attr_ptr
operator|->
name|type
condition|)
block|{
case|case
name|CFG_ATTR_STRTYPE
case|:
break|break;
default|default:
switch|switch
condition|(
name|attr_ptr
operator|->
name|status
condition|)
block|{
case|case
name|CFG_FRAME_SUCCESS
case|:
break|break;
default|default:
name|ipfilter_print_attr_error
argument_list|(
name|attr_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|attr_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cfgmgr_get_state
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ipfilter_name
argument_list|,
operator|&
name|driver_cfg_state
argument_list|)
operator|!=
name|ESUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ipfilter_conf:Error determining state of ipf subsystem\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Error determining state of the "ipf" subs.. 			 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|driver_cfg_state
operator|==
name|SUBSYSTEM_STATICALLY_CONFIGURED
condition|)
block|{
name|callback_return_status
operator|=
name|ESUCCESS
expr_stmt|;
name|ipfilter_is_dynamic
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|register_callback
argument_list|(
name|ipfilter_configure_callback
argument_list|,
name|CFG_PT_OLD_CONF_ALL
argument_list|,
name|CFG_ORD_DONTCARE
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
break|break;
name|status
operator|=
name|register_callback
argument_list|(
name|ipfilter_preconfig_callback
argument_list|,
name|CFG_PT_PRECONFIG
argument_list|,
name|CFG_ORD_NOMINAL
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
break|break;
name|status
operator|=
name|register_callback
argument_list|(
name|ipfilter_postconfig_callback
argument_list|,
name|CFG_PT_POSTCONFIG
argument_list|,
name|CFG_ORD_NOMINAL
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * ipf.mod is getting loaded dynamically. 			 */
name|ipfilter_is_dynamic
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|ipfilter_preconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ipfilter_conf:preconfig failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|ipfilter_postconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ipfilter_conf:postconfig failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|ipfilter_attach
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_attach=%d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|CFG_OP_QUERY
case|:
break|break;
case|case
name|CFG_OP_RECONFIGURE
case|:
break|break;
case|case
name|CFG_OP_UNCONFIGURE
case|:
if|if
condition|(
name|ipfilter_is_dynamic
condition|)
block|{
name|status
operator|=
name|devsw_del
argument_list|(
name|ipfilter_name
argument_list|,
name|MAJOR_INSTANCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|NO_DEV
condition|)
block|{
name|printf
argument_list|(
literal|"ipfilter_configure: call to devsw_del failed\n"
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
name|ipfilter_is_dynamic
operator|=
literal|0
expr_stmt|;
name|ipfilter_config
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"ipfilter_configure: dynamic module unconfigured\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* static configuration */
name|printf
argument_list|(
literal|"ipfilter_configure: Can't unconfigure a static mod\n"
argument_list|)
expr_stmt|;
return|return
name|ESUCCESS
return|;
block|}
if|if
condition|(
name|ipfilter_cfg_state
operator|&
name|SUBSYSTEM_STATICALLY_CONFIGURED
condition|)
block|{
name|status
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|ipfilter_detach
argument_list|()
expr_stmt|;
break|break;
default|default :
name|status
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_configure(%d)=%d\n"
argument_list|,
name|op
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|ipfilter_configure_callback
parameter_list|(
name|conf
parameter_list|,
name|order
parameter_list|,
name|arg
parameter_list|,
name|evarg
parameter_list|)
name|int
name|conf
decl_stmt|,
name|order
decl_stmt|,
name|arg
decl_stmt|,
name|evarg
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_configure_callback(%x,%x,%x,%x)\n"
argument_list|,
name|conf
argument_list|,
name|order
argument_list|,
name|arg
argument_list|,
name|evarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|ipfilter_attach
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
block|{
name|cfgmgr_set_status
argument_list|(
literal|"ipfilter"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This hook intercepts mbufs directly off the IP input  * queue(s) and gives them to the routine at (*ip_input_hook)(m).  * The hook must either free the mbuf, or enqueue it back to  * an IP input queue by calling ip_continue_input(m). It is  * assumed that the hook returns to the caller in a timely  * manner, enqueuing the mbuf on its own list for further  * processing at a later time (if necesary). */
end_comment

begin_function
name|void
name|ipfilter_ip_input
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_ip_input(%x)\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|READ_ENTER
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfilter_registered
operator|<
literal|1
operator|||
name|ipftru64_inited
operator|==
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
name|ip_continue_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|ipfilter_stat
operator|.
name|ip_input_mbufs
operator|++
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Because this gets packets directly off the IP input queue, we need 	 * to do all of the input packet checking.  This is IPv4 only. 	 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipfilter_stat
operator|.
name|ip_input_toosmall
operator|++
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|!=
name|IPVERSION
condition|)
block|{
name|ipfilter_stat
operator|.
name|ip_input_badvers
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hlen
operator|=
name|IP_HL
argument_list|(
name|ip
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
block|{
name|ipfilter_stat
operator|.
name|ip_input_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If header checksum verification fails, do no more. 	 */
if|if
condition|(
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ipfilter_stat
operator|.
name|ip_input_badsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Convert fields to host representation. 	 */
name|len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|hlen
condition|)
block|{
name|ipfilter_stat
operator|.
name|ip_input_badlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
block|{
name|ipfilter_stat
operator|.
name|ip_input_tooshort
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|len
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
name|len
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipf_check
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
literal|0
argument_list|,
operator|&
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PROTOCOL_SUM
operator||
name|M_NOCHECKSUM
operator||
name|M_CHECKSUM
expr_stmt|;
name|ipfilter_stat
operator|.
name|ip_input_accept
operator|++
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
name|ip_continue_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|bad
label|:
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This hook intercepts mbufs directly from the IP output  * routine and gives them to the routine at  * (*ip_output_hook)(ifp, m, in_ro, flags, imo).  The  * hook must either free the mbuf, or set an mbuf flag  * (m->m_flags |= M_OUTPUT_PROCESSING_DONE) and call  * ip_output() again to transmit it.  It is assumed that  * the hook returns to the caller in a timely manner, enqueuing  * the mbuf on its own list for further processing at a later  * time (if necesary).  */
end_comment

begin_function
name|int
name|ipfilter_ip_output
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|in_ro
parameter_list|,
name|flags
parameter_list|,
name|imo
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|in_route
modifier|*
name|in_ro
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|hlen
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_ip_output(%x,%x,%x,%x,%x)\n"
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
name|in_ro
argument_list|,
name|flags
argument_list|,
name|imo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|READ_ENTER
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfilter_registered
operator|<
literal|1
operator|||
name|ipftru64_inited
operator|==
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|in_ro
argument_list|,
name|flags
argument_list|,
name|imo
argument_list|)
operator|)
return|;
block|}
name|ipfilter_stat
operator|.
name|ip_output_mbufs
operator|++
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|IP_HL
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|ipf_check
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|,
name|ifp
argument_list|,
literal|1
argument_list|,
operator|&
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_OUTPUT_PROCESSING_DONE
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|in_ro
argument_list|,
name|flags
argument_list|,
name|imo
argument_list|)
operator|)
return|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is a passive routine.  It does not implement any ioctl's, just merely  * "snoops" ioctls being sent so that we can be aware of things like address  * changes on the interfaces.  */
end_comment

begin_function
name|void
name|ipfilter_in_control
parameter_list|(
name|so
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|u_int
name|cmd
decl_stmt|;
name|caddr_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_in_control(%x,%x,%x,%x)\n"
argument_list|,
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ipfilter_stat
operator|.
name|in_control_called
operator|++
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfilter_registered
operator|<
literal|1
operator|||
name|ipftru64_inited
operator|==
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCAIFADDR
condition|)
name|ipf_sync
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "protocol" ifnet structure for accessing ipf statistics */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|ifnet
name|ifnet
decl_stmt|;
name|char
name|pad
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ether_driver
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|ifnet
argument_list|)
index|]
decl_stmt|;
block|}
name|ipfilter_if
struct|;
end_struct

begin_comment
comment|/*  * Routine to attach ipf module  */
end_comment

begin_function
name|int
name|ipfilter_attach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|firewall
name|ipf
decl_stmt|;
name|int
name|status
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipfmain
argument_list|,
sizeof|sizeof
argument_list|(
name|ipfmain
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_attach(void)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|=
name|ipf_load_all
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipf_load_all() == %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|ipf_create_all
argument_list|(
operator|&
name|ipfmain
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipf_create_all() == %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EIO
return|;
block|}
name|status
operator|=
name|ipfattach
argument_list|(
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfattach() = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|ipfdetach
argument_list|(
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|ipfilter_registered
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Initialize the struct, else the kernel might interpret 	 * a field as being valid when it's not, which would probably 	 * be fatal. 	 */
name|bzero
argument_list|(
operator|&
name|ipf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|firewall
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Tell which version of the ipf structure we are passing-in. 	 * The only currently supported version is #1. 	 */
name|ipf
operator|.
name|version
operator|=
name|FIREWALL_VERSION1
expr_stmt|;
comment|/* 	 * Tell which protocol family we wish to register. 	 * The only currently supported family is PF_INET. 	 */
name|ipf
operator|.
name|pf
operator|=
name|PF_INET
expr_stmt|;
comment|/* 	 * Tell the kernel to disable the RPC/NFS "fastpath" code and 	 * send all NFS output packets through the "slow" IP output code. 	 */
name|ipf
operator|.
name|flags
operator|=
name|FW_DISABLE_RPC_FASTPATH
expr_stmt|;
comment|/* 	 * Fill-in the hooks we wish to register.  At a minumum there 	 * must be an input and output hook. 	 */
name|ipf
operator|.
name|in_control_hook
operator|=
name|ipfilter_in_control
expr_stmt|;
name|ipf
operator|.
name|fw_ip_input_hook
operator|=
name|ipfilter_ip_input
expr_stmt|;
name|ipf
operator|.
name|fw_ip_output_hook
operator|=
name|ipfilter_ip_output
expr_stmt|;
comment|/* make the call */
name|status
operator|=
name|register_firewall
argument_list|(
operator|&
name|ipf
argument_list|)
expr_stmt|;
comment|/* 	 * Additionally, if we wish to attach a protocol statistics structure, 	 * do it now.  We will only attach to counter ioctls on success. 	 */
if|if
condition|(
name|status
operator|==
name|ESUCCESS
condition|)
block|{
name|char
modifier|*
name|defpass
decl_stmt|;
name|ipfilter_registered
operator|=
literal|2
expr_stmt|;
name|ipfilter_ifattach
argument_list|()
expr_stmt|;
name|ipfmain
operator|.
name|ipf_running
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Start timeout thread 		 */
name|ipf_timeout
operator|=
name|kernel_thread_w_arg
argument_list|(
name|first_task
argument_list|,
name|ipfilter_timer
argument_list|,
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ipfilter_clock
argument_list|,
operator|&
name|ipfmain
argument_list|,
operator|(
name|hz
operator|/
name|IPF_HZ_DIVIDE
operator|)
operator|*
name|IPF_HZ_MULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|ipfmain
operator|.
name|ipf_pass
argument_list|)
condition|)
name|defpass
operator|=
literal|"pass"
expr_stmt|;
elseif|else
if|if
condition|(
name|FR_ISBLOCK
argument_list|(
name|ipfmain
operator|.
name|ipf_pass
argument_list|)
condition|)
name|defpass
operator|=
literal|"block"
expr_stmt|;
else|else
name|defpass
operator|=
literal|"no-match -> block"
expr_stmt|;
name|printf
argument_list|(
literal|"%s initialized.  Default = %s all, Logging = %s%s\n"
argument_list|,
name|ipfilter_version
argument_list|,
name|defpass
argument_list|,
ifdef|#
directive|ifdef
name|IPFILTER_LOG
literal|"enabled"
argument_list|,
else|#
directive|else
literal|"disabled"
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
literal|" (COMPILED)"
else|#
directive|else
literal|""
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine to detach ipf module  */
end_comment

begin_function
name|int
name|ipfilter_detach
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|firewall
name|ipf
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_detach(void)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the struct, else the kernel might interpret 	 * a field as being valid when it's not, which would probably 	 * be fatal. 	 */
name|bzero
argument_list|(
operator|&
name|ipf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|firewall
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we had attached a protocol statistics structure, detach it now. 	 * We do this before un-registering our hooks. 	 */
name|ipfilter_ifdetach
argument_list|()
expr_stmt|;
comment|/* 	 * Tell which version of the ipf structure we are passing-in. 	 * The only currently supported version is #1. 	 */
name|ipf
operator|.
name|version
operator|=
name|FIREWALL_VERSION1
expr_stmt|;
comment|/* 	 * Tell which protocol family we wish to register. 	 * The only currently supported family is PF_INET. 	 */
name|ipf
operator|.
name|pf
operator|=
name|PF_INET
expr_stmt|;
comment|/* 	 * Tell the kernel to re-enable the RPC/NFS "fastpath" code and stop 	 * sending all NFS output packets through the "slow" IP output code. 	 */
name|ipf
operator|.
name|flags
operator|=
name|FW_ENABLE_RPC_FASTPATH
expr_stmt|;
comment|/* 	 * We don't need to fill-in the hook pointers as they 	 * are not used in the unregister_ipf() routine. 	 */
comment|/* make the call */
name|status
operator|=
name|ESUCCESS
expr_stmt|;
if|if
condition|(
name|ipfilter_registered
operator|>
literal|1
condition|)
block|{
name|status
operator|=
name|unregister_firewall
argument_list|(
operator|&
name|ipf
argument_list|)
expr_stmt|;
name|ipfilter_registered
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|ESUCCESS
operator|)
operator|&&
operator|(
name|ipfilter_registered
operator|>
literal|0
operator|)
condition|)
block|{
name|status
operator|=
name|ipfdetach
argument_list|(
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfdetach() = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ipfilter_registered
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|ESUCCESS
condition|)
block|{
name|ipfmain
operator|.
name|ipf_running
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (ipf_timeout != 0) { 			thread_terminate(ipf_timeout); 			ipf_timeout = 0; 		}
else|#
directive|else
comment|/* 		 * Deschedule the timeout, kill the thread that is wiating on 		 * it and then wait one second for that thread to die. 		 */
name|untimeout
argument_list|(
name|ipfilter_clock
argument_list|,
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
name|thread_wakeup_one
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|ipf_timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|ipf_timeout
operator|!=
literal|0
condition|)
block|{
name|assert_wait_mesg
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|ipf_timeout
argument_list|,
name|TRUE
argument_list|,
literal|"ipftimeout"
argument_list|)
expr_stmt|;
name|thread_set_timeout
argument_list|(
name|hz
argument_list|)
expr_stmt|;
name|thread_block
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s unloaded\n"
argument_list|,
name|ipfilter_version
argument_list|)
expr_stmt|;
name|ipf_destroy_all
argument_list|(
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
name|ipf_unload_all
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine to attach protocol statistics structure  */
end_comment

begin_function
name|void
name|ipfilter_ifattach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
operator|(
name|ipfilter_if
operator|.
name|ifnet
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_ifattach(void)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_name
operator|=
literal|"ipf"
expr_stmt|;
name|ifp
operator|->
name|if_version
operator|=
literal|"Network Packet Filter"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|IP_MAXPACKET
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_UP
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ipfilter_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ipfilter_ifoutput
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_OTHER
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|8
expr_stmt|;
name|ifp
operator|->
name|if_affinity
operator|=
name|NETALLCPU
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|0
expr_stmt|;
name|if_proto_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to detach protocol statistics structure  */
end_comment

begin_function
name|void
name|ipfilter_ifdetach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
operator|(
name|ipfilter_if
operator|.
name|ifnet
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_ifdetach(void)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_proto_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to handle protocol ioctls  */
end_comment

begin_function
name|int
name|ipfilter_ifioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|unsigned
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stub output routine.  Should never be called, but just in case... */
end_comment

begin_if
if|#
directive|if
name|TRU64
operator|>=
literal|1885
end_if

begin_decl_stmt
name|int
name|ipfilter_ifoutput
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|dst
argument_list|,
name|rt
argument_list|,
name|cp
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|ipfilter_ifoutput
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* called from ipfilter_configure(CFG_OP_CONFIGURE,...) */
end_comment

begin_function
name|void
name|ipfilter_print_attr_error
parameter_list|(
name|cfg_attr_t
modifier|*
name|attr_ptr
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|attr_ptr
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attr_ptr
operator|->
name|status
condition|)
block|{
case|case
name|CFG_ATTR_EEXISTS
case|:
name|printf
argument_list|(
literal|"Attribute does not exist\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_EOP
case|:
name|printf
argument_list|(
literal|"Attribute does not support operation\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_ESUBSYS
case|:
name|printf
argument_list|(
literal|"Subsystem Failure\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_ESMALL
case|:
name|printf
argument_list|(
literal|"Attribute size/value too small\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_ELARGE
case|:
name|printf
argument_list|(
literal|"Attribute size/value too large\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_ETYPE
case|:
name|printf
argument_list|(
literal|"Attribute invalid type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_EINDEX
case|:
name|printf
argument_list|(
literal|"Attribute invalid index\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_ATTR_EMEM
case|:
name|printf
argument_list|(
literal|"Attribute memory allocation error\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"**Unknown attribute: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
name|attr_ptr
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- * pre-configuration * Returns: ENOMEM for fail. *          ESUCCESS for success. *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilter_preconfig
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
return|return
name|ESUCCESS
return|;
block|}
end_function

begin_function
name|void
name|ipfilter_preconfig_callback
parameter_list|(
name|int
name|point
parameter_list|,
name|int
name|order
parameter_list|,
name|ulong
name|argument
parameter_list|,
name|ulong
name|event_arg
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|hwconfig
modifier|*
name|hwc
decl_stmt|;
name|hwc
operator|=
name|create_hwconfig_struct
argument_list|()
expr_stmt|;
if|if
condition|(
name|hwc
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Add ourselves to the switch table. 	 */
name|majnum
operator|=
name|devsw_add
argument_list|(
name|ipfilter_name
argument_list|,
name|MAJOR_INSTANCE
argument_list|,
name|NO_DEV
argument_list|,
operator|&
name|ipfilter_devsw_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|majnum
operator|==
name|NO_DEV
condition|)
block|{
name|printf
argument_list|(
literal|"devsw_add_failed\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfgmgr_set_status
argument_list|(
name|ipfilter_name
argument_list|)
expr_stmt|;
name|callback_return_status
operator|=
name|ENODEV
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"devsw_add_majnum=%d\n"
argument_list|,
name|majnum
argument_list|)
expr_stmt|;
name|hwc
operator|->
name|type
operator|=
name|HWCONFIG_CONTROLLER_ALL
operator||
name|HWCONFIG_CONFIGURE_REQUEST
expr_stmt|;
name|hwc
operator|->
name|parent_bus
operator|=
name|HWCONFIG_ALL
expr_stmt|;
name|hwc
operator|->
name|parent_bus_instance
operator|=
name|DRIVER_WILDNUM
expr_stmt|;
name|hwc
operator|->
name|driver_name
operator|=
name|ipfilter_name
expr_stmt|;
name|hwc
operator|->
name|driver_struct
operator|=
operator|&
name|ipfdriver
expr_stmt|;
name|hwc
operator|->
name|instance_info
operator|=
operator|-
literal|1
expr_stmt|;
name|status
operator|=
name|driver_framework
argument_list|(
name|hwc
argument_list|)
expr_stmt|;
name|free_hwconfig_struct
argument_list|(
name|hwc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot configure driver %s-- status = %d\n"
argument_list|,
name|ipfilter_name
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- * post configure * Return: ENODEV on fail. *         ESUCCESS on success. *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilter_postconfig
parameter_list|()
block|{
name|majnum
operator|=
name|devsw_add
argument_list|(
name|ipfilter_name
argument_list|,
name|MAJOR_INSTANCE
argument_list|,
name|majnum
argument_list|,
operator|&
name|ipfilter_devsw_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|majnum
operator|==
name|ENODEV
condition|)
block|{
name|printf
argument_list|(
literal|"ipfilter_postconfig: call to devsw_add failed\n"
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|printf
argument_list|(
literal|"ipfilter_postconfig:major # = %d\n"
argument_list|,
name|majnum
argument_list|)
expr_stmt|;
name|ipfilter_devno
operator|=
name|majnum
expr_stmt|;
name|ipfilter_config
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s configured\n"
argument_list|,
name|ipfilter_version
argument_list|)
expr_stmt|;
return|return
name|ESUCCESS
return|;
block|}
end_function

begin_function
name|void
name|ipfilter_postconfig_callback
parameter_list|(
name|int
name|point
parameter_list|,
name|int
name|order
parameter_list|,
name|ulong
name|argument
parameter_list|,
name|ulong
name|event_arg
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|callback_return_status
operator|!=
name|ESUCCESS
condition|)
return|return;
name|status
operator|=
name|ipfilter_postconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ESUCCESS
condition|)
block|{
name|cfgmgr_set_status
argument_list|(
name|ipfilter_name
argument_list|)
expr_stmt|;
name|callback_return_status
operator|=
name|status
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------  * Open  * Return: ENXIO on fail.  *         ESUCCESS on success.  *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilteropen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IPL_LOGMAX
operator|<
name|unit
operator|)
operator|||
operator|(
name|unit
operator|<
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|IPL_LOGIPF
case|:
case|case
name|IPL_LOGNAT
case|:
case|case
name|IPL_LOGSTATE
case|:
case|case
name|IPL_LOGAUTH
case|:
case|case
name|IPL_LOGLOOKUP
case|:
case|case
name|IPL_LOGSYNC
case|:
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
case|case
name|IPL_LOGSCAN
case|:
endif|#
directive|endif
name|error
operator|=
name|ESUCCESS
expr_stmt|;
break|break;
default|default :
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- * Close * Return: ESUCCESS on success. *         ENXIO on fail. *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilterclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_close(%x,%x,%x)\n"
argument_list|,
name|dev
argument_list|,
name|flag
argument_list|,
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IPL_LOGMAX
operator|<
name|unit
operator|)
operator|||
operator|(
name|unit
operator|<
literal|0
operator|)
condition|)
name|unit
operator|=
name|ENXIO
expr_stmt|;
else|else
name|unit
operator|=
name|ESUCCESS
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- * Read - * return: ESUCCESS on success. *         fail: An error number from errno.h *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilterread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|int
name|unit
decl_stmt|,
name|status
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfread(%x,%lx,%x)\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|ipflog_read
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|unit
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
name|status
return|;
else|#
directive|else
return|return
name|ENXIO
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- * Write - * return: ESUCCESS on success. *         fail: An error number from errno.h *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilterwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_write(%x,%lx)\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getminor
argument_list|(
name|dev
argument_list|)
operator|!=
name|IPL_LOGSYNC
condition|)
return|return
name|ENXIO
return|;
return|return
name|ipfsync_write
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|uio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- * IOCTL * Return: ESUCCESS on success. *         fail: An error number from errno.h *--------------------------------------------------------*/
end_comment

begin_function
name|int
name|ipfilterioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilterioctl(%d(%d),%x,%lx,%x)\n"
argument_list|,
name|dev
argument_list|,
name|getminor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|READ_ENTER
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfilter_registered
operator|<
literal|1
operator|||
name|ipftru64_inited
operator|==
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"ipfilter_registered %d ipftru64_inited %d\n"
argument_list|,
name|ipfilter_registered
argument_list|,
name|ipftru64_inited
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EIO
return|;
block|}
name|err
operator|=
name|ipfioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tru64
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|ipfilter_clock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|thread_wakeup_one
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|ipf_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfmain
operator|.
name|ipf_running
operator|!=
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|ipfilter_clock
argument_list|,
operator|&
name|ipfmain
argument_list|,
operator|(
name|hz
operator|/
name|IPF_HZ_DIVIDE
operator|)
operator|*
name|IPF_HZ_MULT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ipfilter_timer
parameter_list|()
block|{
if|#
directive|if
literal|0
block|lock_data_t ipfdelaylock;  	lock_init(&ipfdelaylock, TRUE);
else|#
directive|else
name|simple_lock_data_t
name|ipfdelaylock
decl_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|ipfdelaylock
argument_list|)
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|ipfdelaylock
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
if|#
directive|if
literal|0
block|lock_write(&ipfdelaylock); 		assert_wait_mesg((vm_offset_t)&ipfdelaylock, TRUE, "ipftimer"); 		lock_done(&ipfdelaylock);  		thread_set_timeout((hz / IPF_HZ_DIVIDE) * IPF_HZ_MULT);  		thread_block();
else|#
directive|else
if|if
condition|(
name|ipfmain
operator|.
name|ipf_running
operator|==
literal|0
condition|)
break|break;
name|mpsleep
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|ipf_timeout
argument_list|,
name|PCATCH
argument_list|,
literal|"ipftimer"
argument_list|,
literal|0
argument_list|,
operator|&
name|ipfdelaylock
argument_list|,
name|MS_LOCK_SIMPLE
operator||
name|MS_LOCK_ON_ERROR
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ipfmain
operator|.
name|ipf_running
operator|==
literal|0
condition|)
break|break;
name|simple_unlock
argument_list|(
operator|&
name|ipfdelaylock
argument_list|)
expr_stmt|;
name|ipf_timer_func
argument_list|(
operator|&
name|ipfmain
argument_list|)
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|ipfdelaylock
argument_list|)
expr_stmt|;
block|}
name|simple_unlock
argument_list|(
operator|&
name|ipfdelaylock
argument_list|)
expr_stmt|;
name|simple_lock_terminate
argument_list|(
operator|&
name|ipfdelaylock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_timeout
operator|!=
literal|0
condition|)
block|{
name|thread_terminate
argument_list|(
name|ipf_timeout
argument_list|)
expr_stmt|;
name|ipf_timeout
operator|=
literal|0
expr_stmt|;
block|}
name|thread_halt_self
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * routines below for saving IP headers to buffer  */
end_comment

begin_function
specifier|static
name|int
name|ipfopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|u_int
name|min
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|IPL_LOGMAX
operator|<
name|min
condition|)
name|min
operator|=
name|ENXIO
expr_stmt|;
else|else
name|min
operator|=
literal|0
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipfclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|u_int
name|min
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|IPL_LOGMAX
operator|<
name|min
condition|)
name|min
operator|=
name|ENXIO
expr_stmt|;
else|else
name|min
operator|=
literal|0
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/*  * ipfread/ipllog  * both of these must operate with at least splnet() lest they be  * called during packet processing and cause an inconsistancy to appear in  * the filter lists.  */
end_comment

begin_function
specifier|static
name|int
name|ipfread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
if|if
condition|(
name|ipfmain
operator|.
name|ipf_running
operator|<
literal|1
condition|)
return|return
name|EIO
return|;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
return|return
name|ipflog_read
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|uio
argument_list|)
return|;
else|#
directive|else
return|return
name|ENXIO
return|;
endif|#
directive|endif
block|}
end_function

end_unit

