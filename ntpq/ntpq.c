begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpq - query an NTP server using mode 6 commands  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpq.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lineedit.h"
end_include

begin_include
include|#
directive|include
file|"ntp_debug.h"
end_include

begin_include
include|#
directive|include
file|"isc/net.h"
end_include

begin_include
include|#
directive|include
file|"isc/result.h"
end_include

begin_include
include|#
directive|include
file|<ssl_applink.c>
end_include

begin_include
include|#
directive|include
file|"ntp_libopts.h"
end_include

begin_include
include|#
directive|include
file|"ntpq-opts.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<Mswsock.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_comment
comment|/* vxWorks needs mode flag -casey*/
end_comment

begin_define
define|#
directive|define
name|open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
value|open(name, flags, 0777)
end_define

begin_define
define|#
directive|define
name|SERVER_PORT_NUM
value|123
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* we use COMMAND as an autogen keyword */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMMAND
end_ifdef

begin_undef
undef|#
directive|undef
name|COMMAND
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Because we potentially understand a lot of commands we will run  * interactive if connected to a terminal.  */
end_comment

begin_decl_stmt
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should prompt */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|prompt
init|=
literal|"ntpq> "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompt to ask him about */
end_comment

begin_comment
comment|/*  * use old readvars behavior?  --old-rv processing in ntpq resets  * this value based on the presence or absence of --old-rv.  It is  * initialized to 1 here to maintain backward compatibility with  * libntpq clients such as ntpsnmpd, which are free to reset it as  * desired.  */
end_comment

begin_decl_stmt
name|int
name|old_rv
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * for get_systime()  */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision (log2 s) */
end_comment

begin_comment
comment|/*  * Keyid used for authenticated requests.  Obtained on the fly.  */
end_comment

begin_decl_stmt
name|u_long
name|info_auth_keyid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_auth_keytype
init|=
name|NID_md5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5 */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|info_auth_hashlen
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5 */
end_comment

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed by authkeys; not used */
end_comment

begin_comment
comment|/*  * Flag which indicates we should always send authenticated requests  */
end_comment

begin_decl_stmt
name|int
name|always_auth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag which indicates raw mode output.  */
end_comment

begin_decl_stmt
name|int
name|rawmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Packet version number we use  */
end_comment

begin_decl_stmt
name|u_char
name|pktversion
init|=
name|NTP_OLDVERSION
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Don't jump if no set jmp.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|jump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Format values  */
end_comment

begin_define
define|#
directive|define
name|PADDING
value|0
end_define

begin_define
define|#
directive|define
name|TS
value|1
end_define

begin_comment
comment|/* time stamp */
end_comment

begin_define
define|#
directive|define
name|FL
value|2
end_define

begin_comment
comment|/* l_fp type value */
end_comment

begin_define
define|#
directive|define
name|FU
value|3
end_define

begin_comment
comment|/* u_fp type value */
end_comment

begin_define
define|#
directive|define
name|FS
value|4
end_define

begin_comment
comment|/* s_fp type value */
end_comment

begin_define
define|#
directive|define
name|UI
value|5
end_define

begin_comment
comment|/* unsigned integer value */
end_comment

begin_define
define|#
directive|define
name|SI
value|6
end_define

begin_comment
comment|/* signed integer value */
end_comment

begin_define
define|#
directive|define
name|HA
value|7
end_define

begin_comment
comment|/* host address */
end_comment

begin_define
define|#
directive|define
name|NA
value|8
end_define

begin_comment
comment|/* network address */
end_comment

begin_define
define|#
directive|define
name|ST
value|9
end_define

begin_comment
comment|/* string value */
end_comment

begin_define
define|#
directive|define
name|RF
value|10
end_define

begin_comment
comment|/* refid (sometimes string, sometimes not) */
end_comment

begin_define
define|#
directive|define
name|LP
value|11
end_define

begin_comment
comment|/* leap (print in binary) */
end_comment

begin_define
define|#
directive|define
name|OC
value|12
end_define

begin_comment
comment|/* integer, print in octal */
end_comment

begin_define
define|#
directive|define
name|MD
value|13
end_define

begin_comment
comment|/* mode */
end_comment

begin_define
define|#
directive|define
name|AR
value|14
end_define

begin_comment
comment|/* array of times */
end_comment

begin_define
define|#
directive|define
name|FX
value|15
end_define

begin_comment
comment|/* test flags */
end_comment

begin_define
define|#
directive|define
name|EOV
value|255
end_define

begin_comment
comment|/* end of table */
end_comment

begin_comment
comment|/*  * System variable values.  The array can be indexed by  * the variable index to find the textual name.  */
end_comment

begin_decl_stmt
name|struct
name|ctl_var
name|sys_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CS_LEAP
block|,
name|LP
block|,
literal|"leap"
block|}
block|,
comment|/* 1 */
block|{
name|CS_STRATUM
block|,
name|UI
block|,
literal|"stratum"
block|}
block|,
comment|/* 2 */
block|{
name|CS_PRECISION
block|,
name|SI
block|,
literal|"precision"
block|}
block|,
comment|/* 3 */
block|{
name|CS_ROOTDELAY
block|,
name|FS
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 4 */
block|{
name|CS_ROOTDISPERSION
block|,
name|FU
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 5 */
block|{
name|CS_REFID
block|,
name|RF
block|,
literal|"refid"
block|}
block|,
comment|/* 6 */
block|{
name|CS_REFTIME
block|,
name|TS
block|,
literal|"reftime"
block|}
block|,
comment|/* 7 */
block|{
name|CS_POLL
block|,
name|UI
block|,
literal|"poll"
block|}
block|,
comment|/* 8 */
block|{
name|CS_PEERID
block|,
name|UI
block|,
literal|"peer"
block|}
block|,
comment|/* 9 */
block|{
name|CS_OFFSET
block|,
name|FL
block|,
literal|"offset"
block|}
block|,
comment|/* 10 */
block|{
name|CS_DRIFT
block|,
name|FS
block|,
literal|"frequency"
block|}
block|,
comment|/* 11 */
block|{
name|CS_JITTER
block|,
name|FU
block|,
literal|"jitter"
block|}
block|,
comment|/* 12 */
block|{
name|CS_CLOCK
block|,
name|TS
block|,
literal|"clock"
block|}
block|,
comment|/* 13 */
block|{
name|CS_PROCESSOR
block|,
name|ST
block|,
literal|"processor"
block|}
block|,
comment|/* 14 */
block|{
name|CS_SYSTEM
block|,
name|ST
block|,
literal|"system"
block|}
block|,
comment|/* 15 */
block|{
name|CS_VERSION
block|,
name|ST
block|,
literal|"version"
block|}
block|,
comment|/* 16 */
block|{
name|CS_STABIL
block|,
name|FS
block|,
literal|"stability"
block|}
block|,
comment|/* 17 */
block|{
name|CS_VARLIST
block|,
name|ST
block|,
literal|"sys_var_list"
block|}
block|,
comment|/* 18 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variable list  */
end_comment

begin_decl_stmt
name|struct
name|ctl_var
name|peer_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CP_CONFIG
block|,
name|UI
block|,
literal|"config"
block|}
block|,
comment|/* 1 */
block|{
name|CP_AUTHENABLE
block|,
name|UI
block|,
literal|"authenable"
block|}
block|,
comment|/* 2 */
block|{
name|CP_AUTHENTIC
block|,
name|UI
block|,
literal|"authentic"
block|}
block|,
comment|/* 3 */
block|{
name|CP_SRCADR
block|,
name|HA
block|,
literal|"srcadr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|UI
block|,
literal|"srcport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_DSTADR
block|,
name|NA
block|,
literal|"dstadr"
block|}
block|,
comment|/* 6 */
block|{
name|CP_DSTPORT
block|,
name|UI
block|,
literal|"dstport"
block|}
block|,
comment|/* 7 */
block|{
name|CP_LEAP
block|,
name|LP
block|,
literal|"leap"
block|}
block|,
comment|/* 8 */
block|{
name|CP_HMODE
block|,
name|MD
block|,
literal|"hmode"
block|}
block|,
comment|/* 9 */
block|{
name|CP_STRATUM
block|,
name|UI
block|,
literal|"stratum"
block|}
block|,
comment|/* 10 */
block|{
name|CP_PPOLL
block|,
name|UI
block|,
literal|"ppoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|UI
block|,
literal|"hpoll"
block|}
block|,
comment|/* 12 */
block|{
name|CP_PRECISION
block|,
name|SI
block|,
literal|"precision"
block|}
block|,
comment|/* 13 */
block|{
name|CP_ROOTDELAY
block|,
name|FS
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 14 */
block|{
name|CP_ROOTDISPERSION
block|,
name|FU
block|,
literal|"rootdisp"
block|}
block|,
comment|/* 15 */
block|{
name|CP_REFID
block|,
name|RF
block|,
literal|"refid"
block|}
block|,
comment|/* 16 */
block|{
name|CP_REFTIME
block|,
name|TS
block|,
literal|"reftime"
block|}
block|,
comment|/* 17 */
block|{
name|CP_ORG
block|,
name|TS
block|,
literal|"org"
block|}
block|,
comment|/* 18 */
block|{
name|CP_REC
block|,
name|TS
block|,
literal|"rec"
block|}
block|,
comment|/* 19 */
block|{
name|CP_XMT
block|,
name|TS
block|,
literal|"xmt"
block|}
block|,
comment|/* 20 */
block|{
name|CP_REACH
block|,
name|OC
block|,
literal|"reach"
block|}
block|,
comment|/* 21 */
block|{
name|CP_UNREACH
block|,
name|UI
block|,
literal|"unreach"
block|}
block|,
comment|/* 22 */
block|{
name|CP_TIMER
block|,
name|UI
block|,
literal|"timer"
block|}
block|,
comment|/* 23 */
block|{
name|CP_DELAY
block|,
name|FS
block|,
literal|"delay"
block|}
block|,
comment|/* 24 */
block|{
name|CP_OFFSET
block|,
name|FL
block|,
literal|"offset"
block|}
block|,
comment|/* 25 */
block|{
name|CP_JITTER
block|,
name|FU
block|,
literal|"jitter"
block|}
block|,
comment|/* 26 */
block|{
name|CP_DISPERSION
block|,
name|FU
block|,
literal|"dispersion"
block|}
block|,
comment|/* 27 */
block|{
name|CP_KEYID
block|,
name|UI
block|,
literal|"keyid"
block|}
block|,
comment|/* 28 */
block|{
name|CP_FILTDELAY
block|,
name|AR
block|,
literal|"filtdelay"
block|}
block|,
comment|/* 29 */
block|{
name|CP_FILTOFFSET
block|,
name|AR
block|,
literal|"filtoffset"
block|}
block|,
comment|/* 30 */
block|{
name|CP_PMODE
block|,
name|ST
block|,
literal|"pmode"
block|}
block|,
comment|/* 31 */
block|{
name|CP_RECEIVED
block|,
name|UI
block|,
literal|"received"
block|}
block|,
comment|/* 32 */
block|{
name|CP_SENT
block|,
name|UI
block|,
literal|"sent"
block|}
block|,
comment|/* 33 */
block|{
name|CP_FILTERROR
block|,
name|AR
block|,
literal|"filtdisp"
block|}
block|,
comment|/* 34 */
block|{
name|CP_FLASH
block|,
name|FX
block|,
literal|"flash"
block|}
block|,
comment|/* 35 */
block|{
name|CP_TTL
block|,
name|UI
block|,
literal|"ttl"
block|}
block|,
comment|/* 36 */
comment|/* 	 * These are duplicate entries so that we can 	 * process deviant version of the ntp protocol. 	 */
block|{
name|CP_SRCADR
block|,
name|HA
block|,
literal|"peeraddr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|UI
block|,
literal|"peerport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_PPOLL
block|,
name|UI
block|,
literal|"peerpoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|UI
block|,
literal|"hostpoll"
block|}
block|,
comment|/* 12 */
block|{
name|CP_FILTERROR
block|,
name|AR
block|,
literal|"filterror"
block|}
block|,
comment|/* 34 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock variable list  */
end_comment

begin_decl_stmt
name|struct
name|ctl_var
name|clock_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CC_TYPE
block|,
name|UI
block|,
literal|"type"
block|}
block|,
comment|/* 1 */
block|{
name|CC_TIMECODE
block|,
name|ST
block|,
literal|"timecode"
block|}
block|,
comment|/* 2 */
block|{
name|CC_POLL
block|,
name|UI
block|,
literal|"poll"
block|}
block|,
comment|/* 3 */
block|{
name|CC_NOREPLY
block|,
name|UI
block|,
literal|"noreply"
block|}
block|,
comment|/* 4 */
block|{
name|CC_BADFORMAT
block|,
name|UI
block|,
literal|"badformat"
block|}
block|,
comment|/* 5 */
block|{
name|CC_BADDATA
block|,
name|UI
block|,
literal|"baddata"
block|}
block|,
comment|/* 6 */
block|{
name|CC_FUDGETIME1
block|,
name|FL
block|,
literal|"fudgetime1"
block|}
block|,
comment|/* 7 */
block|{
name|CC_FUDGETIME2
block|,
name|FL
block|,
literal|"fudgetime2"
block|}
block|,
comment|/* 8 */
block|{
name|CC_FUDGEVAL1
block|,
name|UI
block|,
literal|"stratum"
block|}
block|,
comment|/* 9 */
block|{
name|CC_FUDGEVAL2
block|,
name|RF
block|,
literal|"refid"
block|}
block|,
comment|/* 10 */
block|{
name|CC_FLAGS
block|,
name|UI
block|,
literal|"flags"
block|}
block|,
comment|/* 11 */
block|{
name|CC_DEVICE
block|,
name|ST
block|,
literal|"device"
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * flasher bits  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tstflagnames
index|[]
init|=
block|{
literal|"pkt_dup"
block|,
comment|/* TEST1 */
literal|"pkt_bogus"
block|,
comment|/* TEST2 */
literal|"pkt_unsync"
block|,
comment|/* TEST3 */
literal|"pkt_denied"
block|,
comment|/* TEST4 */
literal|"pkt_auth"
block|,
comment|/* TEST5 */
literal|"pkt_stratum"
block|,
comment|/* TEST6 */
literal|"pkt_header"
block|,
comment|/* TEST7 */
literal|"pkt_autokey"
block|,
comment|/* TEST8 */
literal|"pkt_crypto"
block|,
comment|/* TEST9 */
literal|"peer_stratum"
block|,
comment|/* TEST10 */
literal|"peer_dist"
block|,
comment|/* TEST11 */
literal|"peer_loop"
block|,
comment|/* TEST12 */
literal|"peer_unreach"
comment|/* TEST13 */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ntpqmain
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Built in command handler declarations  */
end_comment

begin_function_decl
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendpkt
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|u_short
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tstflags
parameter_list|(
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_function_decl
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_function_decl
specifier|static
name|RETSIGTYPE
name|abortcmd
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_function_decl
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getarg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|arg_v
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUILD_AS_LIB */
end_comment

begin_function_decl
specifier|static
name|int
name|findcmd
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtdatetolfp
parameter_list|(
name|char
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decodearr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|auth_delay
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntp_poll
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|raw
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cooked
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|authenticate
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntpversion
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atoascii
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cookedprint
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rawprint
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|startoutput
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|endoutput
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|outputarr
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|assoccmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ntpq_custom_opt_handler
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Built-in commands we understand  */
end_comment

begin_decl_stmt
name|struct
name|xcmd
name|builtins
index|[]
init|=
block|{
block|{
literal|"?"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"help"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"timeout"
block|,
name|timeout
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the primary receive time out"
block|}
block|,
block|{
literal|"delay"
block|,
name|auth_delay
block|,
block|{
name|OPT
operator||
name|NTP_INT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the delay added to encryption time stamps"
block|}
block|,
block|{
literal|"host"
block|,
name|host
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|"hostname"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify the host whose NTP server we talk to"
block|}
block|,
block|{
literal|"poll"
block|,
name|ntp_poll
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"n"
block|,
literal|"verbose"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"poll an NTP server in client mode `n' times"
block|}
block|,
block|{
literal|"passwd"
block|,
name|passwd
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify a password to use for authenticated requests"
block|}
block|,
block|{
literal|"hostnames"
block|,
name|hostnames
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify whether hostnames or net numbers are printed"
block|}
block|,
block|{
literal|"debug"
block|,
name|setdebug
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"no|more|less"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/change debugging level"
block|}
block|,
block|{
literal|"quit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpq"
block|}
block|,
block|{
literal|"exit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpq"
block|}
block|,
block|{
literal|"keyid"
block|,
name|keyid
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key#"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set keyid to use for authenticated requests"
block|}
block|,
block|{
literal|"version"
block|,
name|version
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print version number"
block|}
block|,
block|{
literal|"raw"
block|,
name|raw
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"do raw mode variable output"
block|}
block|,
block|{
literal|"cooked"
block|,
name|cooked
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"do cooked mode variable output"
block|}
block|,
block|{
literal|"authenticate"
block|,
name|authenticate
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"always authenticate requests to this server"
block|}
block|,
block|{
literal|"ntpversion"
block|,
name|ntpversion
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"version number"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the NTP version number to use for requests"
block|}
block|,
block|{
literal|"keytype"
block|,
name|keytype
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key type (md5|des)"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set key type to use for authenticated requests (des|md5)"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default values we use.  */
end_comment

begin_define
define|#
directive|define
name|DEFHOST
value|"localhost"
end_define

begin_comment
comment|/* default host name */
end_comment

begin_define
define|#
directive|define
name|DEFTIMEOUT
value|(5)
end_define

begin_comment
comment|/* 5 second time out */
end_comment

begin_define
define|#
directive|define
name|DEFSTIMEOUT
value|(2)
end_define

begin_comment
comment|/* 2 second time out after first */
end_comment

begin_define
define|#
directive|define
name|DEFDELAY
value|0x51EB852
end_define

begin_comment
comment|/* 20 milliseconds, l_fp fraction */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters long */
end_comment

begin_define
define|#
directive|define
name|MAXCMDS
value|100
end_define

begin_comment
comment|/* maximum commands on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|200
end_define

begin_comment
comment|/* maximum hosts on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum line length */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|(1+MAXARGS+2)
end_define

begin_comment
comment|/* maximum number of usable tokens */
end_comment

begin_define
define|#
directive|define
name|MAXVARLEN
value|256
end_define

begin_comment
comment|/* maximum length of a variable name */
end_comment

begin_define
define|#
directive|define
name|MAXVALLEN
value|400
end_define

begin_comment
comment|/* maximum length of a variable value */
end_comment

begin_define
define|#
directive|define
name|MAXOUTLINE
value|72
end_define

begin_comment
comment|/* maximum length of an output line */
end_comment

begin_define
define|#
directive|define
name|SCREENWIDTH
value|76
end_define

begin_comment
comment|/* nominal screen width in columns */
end_comment

begin_comment
comment|/*  * Some variables used and manipulated locally  */
end_comment

begin_decl_stmt
name|struct
name|sock_timeval
name|tvout
init|=
block|{
name|DEFTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time out for reads */
end_comment

begin_decl_stmt
name|struct
name|sock_timeval
name|tvsout
init|=
block|{
name|DEFSTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secondary time out */
end_comment

begin_decl_stmt
name|l_fp
name|delay_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay time */
end_comment

begin_decl_stmt
name|char
name|currenthost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current host name */
end_comment

begin_decl_stmt
name|int
name|currenthostisnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is prior text from IP? */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|hostaddr
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host address */
end_comment

begin_decl_stmt
name|int
name|showhostnames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show host names by default */
end_comment

begin_decl_stmt
name|int
name|ai_fam_templ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address family */
end_comment

begin_decl_stmt
name|int
name|ai_fam_default
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default address family */
end_comment

begin_decl_stmt
name|SOCKET
name|sockfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd socket is opened on */
end_comment

begin_decl_stmt
name|int
name|havehost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when host open */
end_comment

begin_decl_stmt
name|int
name|s_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|servent
modifier|*
name|server_entry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server entry for ntp */
end_comment

begin_comment
comment|/*  * Sequence number used for requests.  It is incremented before  * it is used.  */
end_comment

begin_decl_stmt
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Holds data returned from queries.  Declare buffer long to be sure of  * alignment.  */
end_comment

begin_define
define|#
directive|define
name|MAXFRAGS
value|24
end_define

begin_comment
comment|/* maximum number of fragments */
end_comment

begin_define
define|#
directive|define
name|DATASIZE
value|(MAXFRAGS*480)
end_define

begin_comment
comment|/* maximum amount of data */
end_comment

begin_decl_stmt
name|long
name|pktdata
index|[
name|DATASIZE
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Holds association data for use with the&n operator.  */
end_comment

begin_decl_stmt
name|struct
name|association
name|assoc_cache
index|[
name|MAXASSOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numassoc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached associations */
end_comment

begin_comment
comment|/*  * For commands typed on the command line (with the -c option)  */
end_comment

begin_decl_stmt
name|int
name|numcmds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ccmds
index|[
name|MAXCMDS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDCMD
parameter_list|(
name|cp
parameter_list|)
value|if (numcmds< MAXCMDS) ccmds[numcmds++] = (cp)
end_define

begin_comment
comment|/*  * When multiple hosts are specified.  */
end_comment

begin_decl_stmt
name|int
name|numhosts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|chosts
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDHOST
parameter_list|(
name|cp
parameter_list|)
value|if (numhosts< MAXHOSTS) chosts[numhosts++] = (cp)
end_define

begin_comment
comment|/*  * Error codes for internal use  */
end_comment

begin_define
define|#
directive|define
name|ERR_UNSPEC
value|256
end_define

begin_define
define|#
directive|define
name|ERR_INCOMPLETE
value|257
end_define

begin_define
define|#
directive|define
name|ERR_TIMEOUT
value|258
end_define

begin_define
define|#
directive|define
name|ERR_TOOMUCH
value|259
end_define

begin_comment
comment|/*  * Macro definitions we use  */
end_comment

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Jump buffer for longjumping back to the command level  */
end_comment

begin_decl_stmt
name|jmp_buf
name|interrupt_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Points at file being currently printed into  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|current_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command table imported from ntpdc_ops.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|xcmd
name|opcmds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_expr_stmt
name|CALL
argument_list|(
name|ntpq
argument_list|,
literal|"ntpq"
argument_list|,
name|ntpqmain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|clear_globals
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
name|showhostnames
operator|=
literal|0
expr_stmt|;
comment|/* don'tshow host names by default */
name|ntp_optind
operator|=
literal|0
expr_stmt|;
name|server_entry
operator|=
name|NULL
expr_stmt|;
comment|/* server entry for ntp */
name|havehost
operator|=
literal|0
expr_stmt|;
comment|/* set to 1 when host open */
name|numassoc
operator|=
literal|0
expr_stmt|;
comment|/* number of cached associations */
name|numcmds
operator|=
literal|0
expr_stmt|;
name|numhosts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MAIN_ALLOWED */
end_comment

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAIN_ALLOWED
end_ifndef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|ntpqmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_function
name|int
name|ntpqmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|clear_globals
argument_list|()
expr_stmt|;
name|taskPrioritySet
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delay_time
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|DEFDELAY
expr_stmt|;
name|init_lib
argument_list|()
expr_stmt|;
comment|/* sets up ipv4_works, ipv6_works */
name|ssl_applink
argument_list|()
expr_stmt|;
comment|/* Check to see if we have IPv6. Otherwise default to IPv4 */
if|if
condition|(
operator|!
name|ipv6_works
condition|)
name|ai_fam_default
operator|=
name|AF_INET
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|{
name|int
name|optct
init|=
name|ntpOptionProcess
argument_list|(
operator|&
name|ntpqOptions
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|argc
operator|-=
name|optct
expr_stmt|;
name|argv
operator|+=
name|optct
expr_stmt|;
block|}
comment|/* 	 * Process options other than -c and -p, which are specially 	 * handled by ntpq_custom_opt_handler(). 	 */
name|debug
operator|=
name|DESC
argument_list|(
name|DEBUG_LEVEL
argument_list|)
operator|.
name|optOccCt
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV4
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV6
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|ai_fam_templ
operator|=
name|ai_fam_default
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|INTERACTIVE
argument_list|)
condition|)
name|interactive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|NUMERIC
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
name|old_rv
operator|=
name|HAVE_OPT
argument_list|(
name|OLD_RV
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|while ((c = ntp_getopt(argc, argv, "46c:dinp")) != EOF) 	    switch (c) { 		case '4': 		    ai_fam_templ = AF_INET; 		    break; 		case '6': 		    ai_fam_templ = AF_INET6; 		    break; 		case 'c': 		    ADDCMD(ntp_optarg); 		    break; 		case 'd': 		    ++debug; 		    break; 		case 'i': 		    interactive = 1; 		    break; 		case 'n': 		    showhostnames = 0; 		    break; 		case 'p': 		    ADDCMD("peers"); 		    break; 		default: 		    errflg++; 		    break; 	    } 	if (errflg) { 		(void) fprintf(stderr, 			       "usage: %s [-46dinp] [-c cmd] host ...\n", 			       progname); 		exit(2); 	}
endif|#
directive|endif
name|NTP_INSIST
argument_list|(
name|ntp_optind
operator|<=
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntp_optind
operator|==
name|argc
condition|)
block|{
name|ADDHOST
argument_list|(
name|DEFHOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|ntp_optind
operator|<
name|argc
condition|;
name|ntp_optind
operator|++
control|)
name|ADDHOST
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numcmds
operator|==
literal|0
operator|&&
name|interactive
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* Under NT cannot handle SIGINT, WIN32 spawns a handler */
if|if
condition|(
name|interactive
condition|)
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGINT
argument_list|,
name|abortcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
name|numcmds
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|openhost
argument_list|(
name|chosts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getcmds
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|ihost
decl_stmt|;
name|int
name|icmd
decl_stmt|;
for|for
control|(
name|ihost
operator|=
literal|0
init|;
name|ihost
operator|<
name|numhosts
condition|;
name|ihost
operator|++
control|)
block|{
if|if
condition|(
name|openhost
argument_list|(
name|chosts
index|[
name|ihost
index|]
argument_list|)
condition|)
for|for
control|(
name|icmd
operator|=
literal|0
init|;
name|icmd
operator|<
name|numcmds
condition|;
name|icmd
operator|++
control|)
name|docmd
argument_list|(
name|ccmds
index|[
name|icmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_comment
comment|/*  * openhost - open a socket to a host  */
end_comment

begin_function
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|)
block|{
name|char
name|temphost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|int
name|a_info
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|name
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|char
name|service
index|[
literal|5
index|]
decl_stmt|;
comment|/* 	 * We need to get by the [] if they were entered 	 */
name|cp
operator|=
name|hname
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'['
condition|)
block|{
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|']'
condition|;
name|cp
operator|++
operator|,
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|']'
condition|)
block|{
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * First try to resolve it as an ip address and if that fails, 	 * do a fullblown (dns) lookup. That way we only use the dns 	 * when it is needed and work around some implementations that 	 * will return an "IPv4-mapped IPv6 address" address if you 	 * give it an IPv4 address to lookup. 	 */
name|strcpy
argument_list|(
name|service
argument_list|,
literal|"ntp"
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ai_fam_templ
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|Z_AI_NUMERICHOST
expr_stmt|;
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_info
operator|==
name|EAI_NONAME
ifdef|#
directive|ifdef
name|EAI_NODATA
operator|||
name|a_info
operator|==
name|EAI_NODATA
endif|#
directive|endif
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|hints
operator|.
name|ai_flags
operator||=
name|AI_ADDRCONFIG
expr_stmt|;
endif|#
directive|endif
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
comment|/* Some older implementations don't like AI_ADDRCONFIG. */
if|if
condition|(
name|a_info
operator|==
name|EAI_BADFLAGS
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|a_info
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gai_strerror
argument_list|(
name|a_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|showhostnames
operator|||
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|temphost
argument_list|,
name|stoa
argument_list|(
operator|(
name|sockaddr_u
operator|*
operator|)
name|ai
operator|->
name|ai_addr
argument_list|)
argument_list|,
name|LENHOSTNAME
argument_list|)
expr_stmt|;
name|currenthostisnum
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|temphost
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
name|LENHOSTNAME
argument_list|)
expr_stmt|;
name|currenthostisnum
operator|=
name|FALSE
expr_stmt|;
block|}
name|temphost
index|[
name|LENHOSTNAME
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Opening host %s\n"
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
if|if
condition|(
name|havehost
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Closing old host %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|currenthost
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
comment|/* port maps to the same location in both families */
name|s_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|hostaddr
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|SERVER_PORT_NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET
condition|)
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|hostaddr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
else|else
operator|*
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|hostaddr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_VXWORKS */
ifdef|#
directive|ifdef
name|SYS_WINNT
block|{
name|int
name|optionValue
init|=
name|SO_SYNCHRONOUS_NONALERT
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|setsockopt
argument_list|(
name|INVALID_SOCKET
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OPENTYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|optionValue
argument_list|,
sizeof|sizeof
argument_list|(
name|optionValue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setsockopt(SO_SYNCHRONOUS_NONALERT) "
literal|"error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|error
argument_list|(
literal|"socket"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NEED_RCVBUF_SLOP
ifdef|#
directive|ifdef
name|SO_RCVBUF
block|{
name|int
name|rbufsize
init|=
name|DATASIZE
operator|+
literal|2048
decl_stmt|;
comment|/* 2K for slop */
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"setsockopt"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_VXWORKS
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hostaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|hostaddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/* SYS_VXWORKS */
name|error
argument_list|(
literal|"connect"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_info
operator|==
literal|0
condition|)
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the remote host  */
end_comment

begin_function
specifier|static
name|int
name|sendpkt
parameter_list|(
name|void
modifier|*
name|xdata
parameter_list|,
name|size_t
name|xdatalen
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Sending %lu octets\n"
argument_list|,
operator|(
name|u_long
operator|)
name|xdatalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sockfd
argument_list|,
name|xdata
argument_list|,
operator|(
name|size_t
operator|)
name|xdatalen
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"write to %s failed"
argument_list|,
name|currenthost
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|int
name|first
init|=
literal|8
decl_stmt|;
name|char
modifier|*
name|cdata
init|=
name|xdata
decl_stmt|;
name|printf
argument_list|(
literal|"Packet data:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|xdatalen
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|first
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|7
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|cdata
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * getresponse - get a (series of) response packet(s) and return the data  */
end_comment

begin_function
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
name|opcode
parameter_list|,
name|int
name|associd
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|timeo
parameter_list|)
block|{
name|struct
name|ntp_control
name|rpkt
decl_stmt|;
name|struct
name|sock_timeval
name|tvo
decl_stmt|;
name|u_short
name|offsets
index|[
name|MAXFRAGS
operator|+
literal|1
index|]
decl_stmt|;
name|u_short
name|counts
index|[
name|MAXFRAGS
operator|+
literal|1
index|]
decl_stmt|;
name|u_short
name|offset
decl_stmt|;
name|u_short
name|count
decl_stmt|;
name|size_t
name|numfrags
decl_stmt|;
name|size_t
name|f
decl_stmt|;
name|size_t
name|ff
decl_stmt|;
name|int
name|seenlastfrag
decl_stmt|;
name|int
name|shouldbesize
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|first
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
comment|/* 	 * This is pretty tricky.  We may get between 1 and MAXFRAG packets 	 * back in response to the request.  We peel the data out of 	 * each packet and collect it in one long block.  When the last 	 * packet in the sequence is received we'll know how much data we 	 * should have had.  Note we use one long time out, should reconsider. 	 */
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rstatus
condition|)
operator|*
name|rstatus
operator|=
literal|0
expr_stmt|;
operator|*
name|rdata
operator|=
operator|(
name|char
operator|*
operator|)
name|pktdata
expr_stmt|;
name|numfrags
operator|=
literal|0
expr_stmt|;
name|seenlastfrag
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
comment|/* 	 * Loop until we have an error or a complete response.  Nearly all 	 * code paths to loop again use continue. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|numfrags
operator|==
literal|0
condition|)
name|tvo
operator|=
name|tvout
expr_stmt|;
else|else
name|tvo
operator|=
name|tvsout
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"select fails"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Timed out.  Return what we have 			 */
if|if
condition|(
name|numfrags
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeo
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out, nothing received\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
name|ERR_TIMEOUT
return|;
block|}
if|if
condition|(
name|timeo
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out with incomplete data\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERR_INCOMPLETE: Received fragments:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|numfrags
condition|;
name|f
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2u: %5d %5d\t%3d octets\n"
argument_list|,
name|f
argument_list|,
name|offsets
index|[
name|f
index|]
argument_list|,
name|offsets
index|[
name|f
index|]
operator|+
name|counts
index|[
name|f
index|]
argument_list|,
name|counts
index|[
name|f
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last fragment %sreceived\n"
argument_list|,
operator|(
name|seenlastfrag
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
block|}
return|return
name|ERR_INCOMPLETE
return|;
block|}
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"read"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|len
operator|=
name|n
expr_stmt|;
name|first
operator|=
literal|8
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
expr_stmt|;
name|printf
argument_list|(
literal|"Packet data:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|first
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|7
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|data
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check for format errors.  Bug proofing. 		 */
if|if
condition|(
name|n
operator|<
name|CTL_HEADER_LEN
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Short (%d byte) packet received\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with version %d\n"
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with mode %d\n"
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|CTL_ISRESPONSE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received request packet, wanted response\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check opcode and sequence number for a match. 		 * Could be old data getting to us. 		 */
if|if
condition|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|sequence
argument_list|)
operator|!=
name|sequence
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received sequnce number %d, wanted %d\n"
argument_list|,
name|ntohs
argument_list|(
name|rpkt
operator|.
name|sequence
argument_list|)
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|CTL_OP
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
operator|!=
name|opcode
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received opcode %d, wanted %d (sequence number okay)\n"
argument_list|,
name|CTL_OP
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check the error code.  If non-zero, return it. 		 */
if|if
condition|(
name|CTL_ISERROR
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|int
name|errcode
decl_stmt|;
name|errcode
operator|=
operator|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|status
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error code %d received on not-final packet\n"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|==
name|CERR_UNSPEC
condition|)
return|return
name|ERR_UNSPEC
return|;
return|return
name|errcode
return|;
block|}
comment|/* 		 * Check the association ID to make sure it matches what 		 * we sent. 		 */
if|if
condition|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|associd
argument_list|)
operator|!=
name|associd
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Association ID %d doesn't match expected %d\n"
argument_list|,
name|ntohs
argument_list|(
name|rpkt
operator|.
name|associd
argument_list|)
argument_list|,
name|associd
argument_list|)
expr_stmt|;
comment|/* 			 * Hack for silly fuzzballs which, at the time of writing, 			 * return an assID of sys.peer when queried for system variables. 			 */
ifdef|#
directive|ifdef
name|notdef
continue|continue;
endif|#
directive|endif
block|}
comment|/* 		 * Collect offset and count.  Make sure they make sense. 		 */
name|offset
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|count
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* 		 * validate received payload size is padded to next 32-bit 		 * boundary and no smaller than claimed by rpkt.count 		 */
if|if
condition|(
name|n
operator|&
literal|0x3
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Response packet not padded, "
literal|"size = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|shouldbesize
operator|=
operator|(
name|CTL_HEADER_LEN
operator|+
name|count
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|shouldbesize
condition|)
block|{
name|printf
argument_list|(
literal|"Response packet claims %u octets "
literal|"payload, above %d received\n"
argument_list|,
name|count
argument_list|,
name|n
operator|-
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
return|return
name|ERR_INCOMPLETE
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|3
operator|&&
name|shouldbesize
operator|>
name|n
condition|)
block|{
name|u_int32
name|key
decl_stmt|;
name|u_int32
modifier|*
name|lpkt
decl_stmt|;
name|int
name|maclen
decl_stmt|;
comment|/* 			 * Usually we ignore authentication, but for debugging purposes 			 * we watch it here. 			 */
comment|/* round to 8 octet boundary */
name|shouldbesize
operator|=
operator|(
name|shouldbesize
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|maclen
operator|=
name|n
operator|-
name|shouldbesize
expr_stmt|;
if|if
condition|(
name|maclen
operator|>=
name|MIN_MAC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"Packet shows signs of authentication (total %d, data %d, mac %d)\n"
argument_list|,
name|n
argument_list|,
name|shouldbesize
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
name|lpkt
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
expr_stmt|;
name|printf
argument_list|(
literal|"%08lx %08lx %08lx %08lx %08lx %08lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|3
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|2
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|+
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Authenticated with keyid %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
literal|0
operator|&&
name|key
operator|!=
name|info_auth_keyid
condition|)
block|{
name|printf
argument_list|(
literal|"We don't know that key\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|authdecrypt
argument_list|(
name|key
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|n
operator|-
name|maclen
argument_list|,
name|maclen
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Auth okay!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Auth failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Got packet, size = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|count
operator|>
operator|(
name|n
operator|-
name|CTL_HEADER_LEN
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received count of %d octets, "
literal|"data in packet is %d\n"
argument_list|,
name|count
argument_list|,
name|n
operator|-
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received count of 0 in non-final fragment\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|offset
operator|+
name|count
operator|>
sizeof|sizeof
argument_list|(
name|pktdata
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Offset %d, count %d, too big for buffer\n"
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|ERR_TOOMUCH
return|;
block|}
if|if
condition|(
name|seenlastfrag
operator|&&
operator|!
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received second last fragment packet\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * So far, so good.  Record this fragment, making sure it doesn't 		 * overlap anything. 		 */
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Packet okay\n"
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|numfrags
operator|>
operator|(
name|MAXFRAGS
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Number of fragments exceeds maximum %d\n"
argument_list|,
name|MAXFRAGS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ERR_TOOMUCH
return|;
block|}
comment|/* 		 * Find the position for the fragment relative to any 		 * previously received. 		 */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|numfrags
operator|&&
name|offsets
index|[
name|f
index|]
operator|<
name|offset
condition|;
name|f
operator|++
control|)
block|{
comment|/* empty body */
empty_stmt|;
block|}
if|if
condition|(
name|f
operator|<
name|numfrags
operator|&&
name|offset
operator|==
name|offsets
index|[
name|f
index|]
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"duplicate %u octets at %u ignored, prior %u at %u\n"
argument_list|,
name|count
argument_list|,
name|offset
argument_list|,
name|counts
index|[
name|f
index|]
argument_list|,
name|offsets
index|[
name|f
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|f
operator|>
literal|0
operator|&&
operator|(
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|f
operator|-
literal|1
index|]
operator|)
operator|>
name|offset
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"received frag at %u overlaps with %u octet frag at %u\n"
argument_list|,
name|offset
argument_list|,
name|counts
index|[
name|f
operator|-
literal|1
index|]
argument_list|,
name|offsets
index|[
name|f
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|f
operator|<
name|numfrags
operator|&&
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|offsets
index|[
name|f
index|]
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"received %u octet frag at %u overlaps with frag at %u\n"
argument_list|,
name|count
argument_list|,
name|offset
argument_list|,
name|offsets
index|[
name|f
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|ff
operator|=
name|numfrags
init|;
name|ff
operator|>
name|f
condition|;
name|ff
operator|--
control|)
block|{
name|offsets
index|[
name|ff
index|]
operator|=
name|offsets
index|[
name|ff
operator|-
literal|1
index|]
expr_stmt|;
name|counts
index|[
name|ff
index|]
operator|=
name|counts
index|[
name|ff
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|offsets
index|[
name|f
index|]
operator|=
name|offset
expr_stmt|;
name|counts
index|[
name|f
index|]
operator|=
name|count
expr_stmt|;
name|numfrags
operator|++
expr_stmt|;
comment|/* 		 * Got that stuffed in right.  Figure out if this was the last. 		 * Record status info out of the last packet. 		 */
if|if
condition|(
operator|!
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|seenlastfrag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rstatus
operator|!=
literal|0
condition|)
operator|*
name|rstatus
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Copy the data into the data buffer. 		 */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pktdata
operator|+
name|offset
argument_list|,
name|rpkt
operator|.
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 		 * If we've seen the last fragment, look for holes in the sequence. 		 * If there aren't any, we're done. 		 */
if|if
condition|(
name|seenlastfrag
operator|&&
name|offsets
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|f
operator|=
literal|1
init|;
name|f
operator|<
name|numfrags
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|f
operator|-
literal|1
index|]
operator|!=
name|offsets
index|[
name|f
index|]
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|numfrags
condition|)
block|{
operator|*
name|rsize
operator|=
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|f
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u packets reassembled into response\n"
argument_list|,
name|numfrags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* giant for (;;) collecting response packets */
block|}
end_function

begin_comment
comment|/* getresponse() */
end_comment

begin_comment
comment|/*  * sendrequest - format and send a request packet  */
end_comment

begin_function
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
name|opcode
parameter_list|,
name|int
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|)
block|{
name|struct
name|ntp_control
name|qpkt
decl_stmt|;
name|int
name|pktsize
decl_stmt|;
name|u_long
name|key_id
decl_stmt|;
name|char
modifier|*
name|pass
decl_stmt|;
name|int
name|maclen
decl_stmt|;
comment|/* 	 * Check to make sure the data will fit in one packet 	 */
if|if
condition|(
name|qsize
operator|>
name|CTL_MAX_DATA_LEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Internal error!  qsize (%d) too large\n"
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Fill in the packet 	 */
name|qpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
literal|0
argument_list|,
name|pktversion
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|r_m_e_op
operator|=
call|(
name|u_char
call|)
argument_list|(
name|opcode
operator|&
name|CTL_OP_MASK
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|sequence
operator|=
name|htons
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|qpkt
operator|.
name|associd
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|associd
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|qpkt
operator|.
name|count
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|qsize
argument_list|)
expr_stmt|;
name|pktsize
operator|=
name|CTL_HEADER_LEN
expr_stmt|;
comment|/* 	 * If we have data, copy and pad it out to a 32-bit boundary. 	 */
if|if
condition|(
name|qsize
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|qpkt
operator|.
name|data
argument_list|,
name|qdata
argument_list|,
operator|(
name|size_t
operator|)
name|qsize
argument_list|)
expr_stmt|;
name|pktsize
operator|+=
name|qsize
expr_stmt|;
while|while
condition|(
name|pktsize
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|qpkt
operator|.
name|data
index|[
name|qsize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pktsize
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If it isn't authenticated we can just send it.  Otherwise 	 * we're going to have to think about it a little. 	 */
if|if
condition|(
operator|!
name|auth
operator|&&
operator|!
name|always_auth
condition|)
block|{
return|return
name|sendpkt
argument_list|(
operator|&
name|qpkt
argument_list|,
name|pktsize
argument_list|)
return|;
block|}
comment|/* 	 * Pad out packet to a multiple of 8 octets to be sure 	 * receiver can handle it. 	 */
while|while
condition|(
name|pktsize
operator|&
literal|7
condition|)
block|{
name|qpkt
operator|.
name|data
index|[
name|qsize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pktsize
operator|++
expr_stmt|;
block|}
comment|/* 	 * Get the keyid and the password if we don't have one. 	 */
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|key_id
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_id
operator|==
literal|0
operator|||
name|key_id
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|info_auth_keyid
operator|=
name|key_id
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
name|pass
operator|=
name|getpass_keytype
argument_list|(
name|info_auth_keytype
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|pass
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid password\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do the encryption. 	 */
name|maclen
operator|=
name|authencrypt
argument_list|(
name|info_auth_keyid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maclen
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key not found\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|maclen
operator|!=
operator|(
name|info_auth_hashlen
operator|+
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d octet MAC, %lu expected with %lu octet digest\n"
argument_list|,
name|maclen
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|info_auth_hashlen
operator|+
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_hashlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|sendpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
operator|+
name|maclen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * show_error_msg - display the error text for a mode 6 error response.  */
end_comment

begin_function
name|void
name|show_error_msg
parameter_list|(
name|int
name|m6resp
parameter_list|,
name|associd_t
name|associd
parameter_list|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m6resp
condition|)
block|{
case|case
name|CERR_BADFMT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a bad format request packet\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_PERMISSION
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server disallowed request (authentication?)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADOP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a bad opcode in request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADASSOC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association ID %d unknown to server\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_UNKNOWNVAR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***A request variable unknown to the server\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADVALUE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server indicates a request variable was bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_UNSPEC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returned an unspecified error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TIMEOUT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Request timed out\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_INCOMPLETE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Response from server was incomplete\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TOOMUCH
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Buffer size exceeded for returned data\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returns unknown error code %d\n"
argument_list|,
name|m6resp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * doquery - send a request and process the response, displaying  *	     error messages for any error responses.  */
end_comment

begin_function
name|int
name|doquery
parameter_list|(
name|int
name|opcode
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
return|return
name|doqueryex
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|,
name|rstatus
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * doqueryex - send a request and process the response, optionally  *	       displaying error messages for any error responses.  */
end_comment

begin_function
name|int
name|doqueryex
parameter_list|(
name|int
name|opcode
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* 	 * Check to make sure host is open 	 */
if|if
condition|(
operator|!
name|havehost
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No host open, use `host' command\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|done
operator|=
literal|0
expr_stmt|;
name|sequence
operator|++
expr_stmt|;
name|again
label|:
comment|/* 	 * send a request 	 */
name|res
operator|=
name|sendrequest
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
comment|/* 	 * Get the response.  If we got a standard error, print a message 	 */
name|res
operator|=
name|getresponse
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|rstatus
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|res
operator|==
name|ERR_TIMEOUT
operator|||
name|res
operator|==
name|ERR_INCOMPLETE
operator|)
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|ERR_INCOMPLETE
condition|)
block|{
comment|/* 				 * better bump the sequence so we don't 				 * get confused about differing fragments. 				 */
name|sequence
operator|++
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|show_error_msg
argument_list|(
name|res
argument_list|,
name|associd
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_comment
comment|/*  * getcmds - read commands from the standard input and execute them  */
end_comment

begin_function
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ntp_readline_init
argument_list|(
name|interactive
condition|?
name|prompt
else|:
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
operator|=
name|ntp_readline
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|line
condition|)
break|break;
name|docmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|ntp_readline_uninit
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BUILD_AS_LIB
argument_list|)
end_if

begin_comment
comment|/*  * abortcmd - catch interrupts and abort the current command  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|abortcmd
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|current_output
operator|==
name|stdout
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|longjmp
argument_list|(
name|interrupt_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SYS_WINNT&& !BUILD_AS_LIB */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_comment
comment|/*  * docmd - decode the command line and execute a command  */
end_comment

begin_function
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
name|cmdline
parameter_list|)
block|{
name|char
modifier|*
name|tokens
index|[
literal|1
operator|+
name|MAXARGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|parse
name|pcmd
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|static
name|int
name|i
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcmd
decl_stmt|;
comment|/* 	 * Tokenize the command line.  If nothing on it, return. 	 */
name|tokenize
argument_list|(
name|cmdline
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Find the appropriate command description. 	 */
name|i
operator|=
name|findcmd
argument_list|(
name|tokens
index|[
literal|0
index|]
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' unknown\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' ambiguous\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Save the keyword, then walk through the arguments, interpreting 	 * as we go. 	 */
name|pcmd
operator|.
name|keyword
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pcmd
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|>=
name|ntok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
condition|)
block|{
name|printusage
argument_list|(
name|xcmd
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
operator|&&
operator|(
operator|*
name|tokens
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|getarg
argument_list|(
name|tokens
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
operator|&
name|pcmd
operator|.
name|argval
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
name|pcmd
operator|.
name|nargs
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ntok
operator|&&
operator|*
name|tokens
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|tokens
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|ntok
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No file for redirect\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_output
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_output
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Error opening %s: "
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
comment|/* flag we need a close */
block|}
else|else
block|{
name|current_output
operator|=
name|stdout
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* flag no close */
block|}
if|if
condition|(
name|interactive
operator|&&
name|setjmp
argument_list|(
name|interrupt_buf
argument_list|)
condition|)
block|{
name|jump
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|jump
operator|++
expr_stmt|;
call|(
name|xcmd
operator|->
name|handler
call|)
argument_list|(
operator|&
name|pcmd
argument_list|,
name|current_output
argument_list|)
expr_stmt|;
name|jump
operator|=
literal|0
expr_stmt|;
comment|/* HMS: 961106: was after fclose() */
if|if
condition|(
name|i
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|current_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * tokenize - turn a command line into tokens  *  * SK: Modified to allow a quoted string   *  * HMS: If the first character of the first token is a ':' then (after  * eating inter-token whitespace) the 2nd token is the rest of the line.  */
end_comment

begin_function
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokens
parameter_list|,
name|int
modifier|*
name|ntok
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
name|char
name|tspace
index|[
name|MAXLINE
index|]
decl_stmt|;
name|sp
operator|=
name|tspace
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
for|for
control|(
operator|*
name|ntok
operator|=
literal|0
init|;
operator|*
name|ntok
operator|<
name|MAXTOKENS
condition|;
operator|(
operator|*
name|ntok
operator|)
operator|++
control|)
block|{
name|tokens
index|[
operator|*
name|ntok
index|]
operator|=
name|sp
expr_stmt|;
comment|/* Skip inter-token whitespace */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* If we're at EOL we're done */
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
comment|/* If this is the 2nd token and the first token begins 		 * with a ':', then just grab to EOL. 		 */
if|if
condition|(
operator|*
name|ntok
operator|==
literal|1
operator|&&
name|tokens
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
block|}
comment|/* Check if this token begins with a double quote. 		 * If yes, continue reading till the next double quote 		 */
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\"'
condition|)
block|{
operator|++
name|cp
expr_stmt|;
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\"'
operator|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
comment|/* HMS: a missing closing " should be an error */
block|}
else|else
block|{
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\"'
operator|)
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
comment|/* HMS: Why check for a " in the previous line? */
block|}
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * getarg - interpret an argument token  */
end_comment

begin_function
specifier|static
name|int
name|getarg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|code
parameter_list|,
name|arg_v
modifier|*
name|argp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|digits
init|=
literal|"0123456789"
decl_stmt|;
switch|switch
condition|(
name|code
operator|&
operator|~
name|OPT
condition|)
block|{
case|case
name|NTP_STR
case|:
name|argp
operator|->
name|string
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|NTP_ADD
case|:
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|str
argument_list|,
operator|&
operator|(
name|argp
operator|->
name|netnum
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
name|NTP_INT
case|:
case|case
name|NTP_UINT
case|:
name|isneg
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'&'
condition|)
block|{
name|np
operator|++
expr_stmt|;
name|isneg
operator|=
name|atoi
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association value `%s' invalid/undecodable\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isneg
operator|>
name|numassoc
condition|)
block|{
if|if
condition|(
name|numassoc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association for `%s' unknown (max&%d)\n"
argument_list|,
name|str
argument_list|,
name|numassoc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|isneg
operator|=
name|numassoc
expr_stmt|;
block|}
block|}
name|argp
operator|->
name|uval
operator|=
name|assoc_cache
index|[
name|isneg
operator|-
literal|1
index|]
operator|.
name|assid
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|np
operator|==
literal|'-'
condition|)
block|{
name|np
operator|++
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
name|argp
operator|->
name|uval
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|digits
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Illegal integer value %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|uval
operator|*=
literal|10
expr_stmt|;
name|argp
operator|->
name|uval
operator|+=
operator|(
name|cp
operator|-
name|digits
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
operator|++
name|np
operator|)
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|isneg
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
operator|~
name|OPT
operator|)
operator|==
name|NTP_UINT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Value %s should be unsigned\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|ival
operator|=
operator|-
name|argp
operator|->
name|ival
expr_stmt|;
block|}
break|break;
case|case
name|IP_VERSION
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|str
argument_list|)
condition|)
name|argp
operator|->
name|ival
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|str
argument_list|)
condition|)
name|argp
operator|->
name|ival
operator|=
literal|4
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Version must be either 4 or 6\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_comment
comment|/*  * findcmd - find a command in a command description table  */
end_comment

begin_function
specifier|static
name|int
name|findcmd
parameter_list|(
specifier|register
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist1
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist2
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
name|cmd
parameter_list|)
block|{
specifier|register
name|struct
name|xcmd
modifier|*
name|cl
decl_stmt|;
specifier|register
name|int
name|clen
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|nearmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clist1
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist1
expr_stmt|;
elseif|else
if|if
condition|(
name|clist2
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist2
expr_stmt|;
else|else
return|return
literal|0
return|;
name|again
label|:
for|for
control|(
name|cl
operator|=
name|clist
init|;
name|cl
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|cl
operator|++
control|)
block|{
comment|/* do a first character check, for efficiency */
if|if
condition|(
operator|*
name|str
operator|!=
operator|*
operator|(
name|cl
operator|->
name|keyword
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|cl
operator|->
name|keyword
argument_list|,
operator|(
name|unsigned
operator|)
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Could be extact match, could be approximate. 			 * Is exact if the length of the keyword is the 			 * same as the str. 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|cl
operator|->
name|keyword
operator|)
operator|+
name|clen
operator|)
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cmd
operator|=
name|cl
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|nearmatch
operator|=
name|cl
expr_stmt|;
block|}
block|}
comment|/* 	 * See if there is more to do.  If so, go again.  Sorry about the 	 * goto, too much looking at BSD sources... 	 */
if|if
condition|(
name|clist
operator|==
name|clist1
operator|&&
name|clist2
operator|!=
literal|0
condition|)
block|{
name|clist
operator|=
name|clist2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If we got extactly 1 near match, use it, else return number 	 * of matches. 	 */
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
operator|*
name|cmd
operator|=
name|nearmatch
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|nmatch
return|;
block|}
end_function

begin_comment
comment|/*  * getnetnum - given a host name, return its net number  *	       and (optional) full name  */
end_comment

begin_function
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|,
name|sockaddr_u
modifier|*
name|num
parameter_list|,
name|char
modifier|*
name|fullhost
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|hints
operator|.
name|ai_flags
operator||=
name|AI_ADDRCONFIG
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * decodenetnum only works with addresses, but handles syntax 	 * that getaddrinfo doesn't:  [2001::1]:1234 	 */
if|if
condition|(
name|decodenetnum
argument_list|(
name|hname
argument_list|,
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|fullhost
operator|!=
name|NULL
condition|)
name|getnameinfo
argument_list|(
operator|&
name|num
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|num
argument_list|)
argument_list|,
name|fullhost
argument_list|,
name|LENHOSTNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NTP_INSIST
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|num
argument_list|)
operator|>=
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|num
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullhost
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|fullhost
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
name|LENHOSTNAME
argument_list|)
expr_stmt|;
name|fullhost
index|[
name|LENHOSTNAME
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|getnameinfo
argument_list|(
operator|&
name|num
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|num
argument_list|)
argument_list|,
name|fullhost
argument_list|,
name|LENHOSTNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Can't find host %s\n"
argument_list|,
name|hname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * nntohost - convert network number to host name.  This routine enforces  *	       the showhostnames setting.  */
end_comment

begin_function
name|char
modifier|*
name|nntohost
parameter_list|(
name|sockaddr_u
modifier|*
name|netnum
parameter_list|)
block|{
return|return
name|nntohost_col
argument_list|(
name|netnum
argument_list|,
name|LIB_BUFLENGTH
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * nntohost_col - convert network number to host name in fixed width.  *		  This routine enforces the showhostnames setting.  *		  When displaying hostnames longer than the width,  *		  the first part of the hostname is displayed.  When  *		  displaying numeric addresses longer than the width,  *		  Such as IPv6 addresses, the caller decides whether  *		  the first or last of the numeric address is used.  */
end_comment

begin_function
name|char
modifier|*
name|nntohost_col
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|size_t
name|width
parameter_list|,
name|int
name|preserve_lowaddrbits
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|showhostnames
condition|)
block|{
if|if
condition|(
name|preserve_lowaddrbits
condition|)
name|out
operator|=
name|trunc_left
argument_list|(
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
else|else
name|out
operator|=
name|trunc_right
argument_list|(
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|out
operator|=
name|refnumtoa
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|trunc_right
argument_list|(
name|socktohost
argument_list|(
name|addr
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/*  * rtdatetolfp - decode an RT-11 date into an l_fp  */
end_comment

begin_function
specifier|static
name|int
name|rtdatetolfp
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|calendar
name|cal
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|months
index|[
literal|12
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
name|cal
operator|.
name|yearday
operator|=
literal|0
expr_stmt|;
comment|/* 	 * An RT-11 date looks like: 	 * 	 * d[d]-Mth-y[y] hh:mm:ss 	 * 	 * (No docs, but assume 4-digit years are also legal...) 	 * 	 * d[d]-Mth-y[y[y[y]]] hh:mm:ss 	 */
name|cp
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * Catch special case 			 */
name|L_CLR
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
name|cal
operator|.
name|monthday
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
comment|/* ascii dependent */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|monthday
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|monthday
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|monthday
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|monthday
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|monthday
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|buf
argument_list|,
name|months
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|12
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|month
operator|=
call|(
name|u_char
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
name|cal
operator|.
name|year
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
name|cal
operator|.
name|year
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Catch special case.  If cal.year == 0 this is a zero timestamp. 	 */
if|if
condition|(
name|cal
operator|.
name|year
operator|==
literal|0
condition|)
block|{
name|L_CLR
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|' '
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|hour
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|hour
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|hour
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|hour
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|hour
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|hour
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|minute
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|minute
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|minute
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|minute
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|minute
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|minute
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|second
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|second
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|second
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|second
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|second
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|second
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For RT-11, 1972 seems to be the pivot year 	 */
if|if
condition|(
name|cal
operator|.
name|year
operator|<
literal|72
condition|)
name|cal
operator|.
name|year
operator|+=
literal|2000
expr_stmt|;
if|if
condition|(
name|cal
operator|.
name|year
operator|<
literal|100
condition|)
name|cal
operator|.
name|year
operator|+=
literal|1900
expr_stmt|;
name|lfp
operator|->
name|l_ui
operator|=
name|caltontp
argument_list|(
operator|&
name|cal
argument_list|)
expr_stmt|;
name|lfp
operator|->
name|l_uf
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * decodets - decode a timestamp into an l_fp format number, with  *	      consideration of fuzzball formats.  */
end_comment

begin_function
name|int
name|decodets
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|size_t
name|b
decl_stmt|;
comment|/* 	 * If it starts with a 0x, decode as hex. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
return|return
name|hextolfp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|lfp
argument_list|)
return|;
comment|/* 	 * If it starts with a '"', try it as an RT-11 date. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'"'
condition|)
block|{
name|cp
operator|=
name|str
operator|+
literal|1
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'"'
operator|!=
operator|*
name|cp
operator|&&
literal|'\0'
operator|!=
operator|*
name|cp
operator|&&
name|b
operator|<
name|COUNTOF
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
name|buf
index|[
name|b
operator|++
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|buf
index|[
name|b
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rtdatetolfp
argument_list|(
name|buf
argument_list|,
name|lfp
argument_list|)
return|;
block|}
comment|/* 	 * Might still be hex.  Check out the first character.  Talk 	 * about heuristics! 	 */
if|if
condition|(
operator|(
operator|*
name|str
operator|>=
literal|'A'
operator|&&
operator|*
name|str
operator|<=
literal|'F'
operator|)
operator|||
operator|(
operator|*
name|str
operator|>=
literal|'a'
operator|&&
operator|*
name|str
operator|<=
literal|'f'
operator|)
condition|)
return|return
name|hextolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
comment|/* 	 * Try it as a decimal.  If this fails, try as an unquoted 	 * RT-11 date.  This code should go away eventually. 	 */
if|if
condition|(
name|atolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|rtdatetolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodetime - decode a time value.  It should be in milliseconds  */
end_comment

begin_function
name|int
name|decodetime
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
return|return
name|mstolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodeint - decode an integer  */
end_comment

begin_function
name|int
name|decodeint
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|long
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|val
argument_list|)
return|;
return|return
name|octtoint
argument_list|(
name|str
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|val
argument_list|)
return|;
block|}
return|return
name|atoint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodeuint - decode an unsigned integer  */
end_comment

begin_function
name|int
name|decodeuint
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|u_long
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
operator|(
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|val
argument_list|)
operator|)
return|;
return|return
operator|(
name|octtoint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|atouint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodearr - decode an array of time values  */
end_comment

begin_function
specifier|static
name|int
name|decodearr
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|narr
parameter_list|,
name|l_fp
modifier|*
name|lfparr
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|l_fp
modifier|*
name|lfp
decl_stmt|;
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|lfp
operator|=
name|lfparr
expr_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
operator|*
name|narr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|narr
operator|<
literal|8
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|decodetime
argument_list|(
name|buf
argument_list|,
name|lfp
argument_list|)
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|narr
operator|)
operator|++
expr_stmt|;
name|lfp
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Finally, the built in command handlers  */
end_comment

begin_comment
comment|/*  * help - tell about commands, or details of a particular command  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|xcmd
modifier|*
name|xcp
init|=
name|NULL
decl_stmt|;
comment|/* quiet warning */
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|list
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|word
decl_stmt|,
name|words
decl_stmt|;
name|size_t
name|row
decl_stmt|,
name|rows
decl_stmt|;
name|size_t
name|col
decl_stmt|,
name|cols
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|xcp
operator|=
name|builtins
init|;
name|xcp
operator|->
name|keyword
operator|!=
name|NULL
condition|;
name|xcp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|xcp
operator|->
name|keyword
operator|)
operator|!=
literal|'?'
condition|)
name|list
index|[
name|words
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
block|}
for|for
control|(
name|xcp
operator|=
name|opcmds
init|;
name|xcp
operator|->
name|keyword
operator|!=
name|NULL
condition|;
name|xcp
operator|++
control|)
name|list
index|[
name|words
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|list
argument_list|,
operator|(
name|size_t
operator|)
name|words
argument_list|,
sizeof|sizeof
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|list
index|[
name|word
index|]
argument_list|)
expr_stmt|;
name|col
operator|=
name|max
argument_list|(
name|col
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|cols
operator|=
name|SCREENWIDTH
operator|/
operator|++
name|col
expr_stmt|;
name|rows
operator|=
operator|(
name|words
operator|+
name|cols
operator|-
literal|1
operator|)
operator|/
name|cols
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ntpq commands:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|word
operator|=
name|row
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|+=
name|rows
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s"
argument_list|,
name|col
argument_list|,
name|col
operator|-
literal|1
argument_list|,
name|list
index|[
name|word
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|words
operator|=
name|findcmd
argument_list|(
name|cmd
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is unknown\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|words
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is ambiguous\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"function: %s\n"
argument_list|,
name|xcp
operator|->
name|comment
argument_list|)
expr_stmt|;
name|printusage
argument_list|(
name|xcp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * helpsort - do hostname qsort comparisons  */
end_comment

begin_function
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
name|t1
parameter_list|,
specifier|const
name|void
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|name1
init|=
name|t1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|name2
init|=
name|t2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|name1
argument_list|,
operator|*
name|name2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * printusage - print usage information for a command  */
end_comment

begin_function
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
name|xcp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage: %s"
argument_list|,
name|xcp
operator|->
name|keyword
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" [ %s ]"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timeout - set time out time  */
end_comment

begin_function
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
operator|(
name|int
operator|)
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tvout
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"primary timeout %d ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tvout
operator|.
name|tv_sec
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|/
literal|1000
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|-
operator|(
operator|(
name|long
operator|)
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * auth_delay - set delay for auth requests  */
end_comment

begin_function
specifier|static
name|void
name|auth_delay
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|u_long
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|delay_time
operator|.
name|l_ui
operator|*
literal|1000
operator|+
name|delay_time
operator|.
name|l_uf
operator|/
literal|4294967
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %lu ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|-
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|u_long
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
expr_stmt|;
block|}
name|delay_time
operator|.
name|l_ui
operator|=
name|val
operator|/
literal|1000
expr_stmt|;
name|val
operator|%=
literal|1000
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|val
operator|*
literal|4294967
expr_stmt|;
comment|/* 2**32/1000 */
if|if
condition|(
name|isneg
condition|)
name|L_NEG
argument_list|(
operator|&
name|delay_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * host - set the host we are dealing with.  */
end_comment

begin_function
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host is %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no current host\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|ai_fam_templ
operator|=
name|ai_fam_default
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
else|else
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|openhost
argument_list|(
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host set to %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|numassoc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * poll - do one (or more) polls of the host via NTP  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|ntp_poll
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"poll not implemented yet\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * keyid - get a keyid to use for authenticating requests  */
end_comment

begin_function
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no keyid defined\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keyid is %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_keyid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* allow zero so that keyid can be cleared. */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|>
name|NTP_MAXKEY
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
name|info_auth_keyid
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * keytype - get type of key to use for authenticating requests  */
end_comment

begin_function
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_name
decl_stmt|;
name|size_t
name|digest_len
decl_stmt|;
name|int
name|key_type
decl_stmt|;
if|if
condition|(
operator|!
name|pcmd
operator|->
name|nargs
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype is %s with %lu octet digests\n"
argument_list|,
name|keytype_name
argument_list|(
name|info_auth_keytype
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_hashlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|digest_name
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|digest_len
operator|=
literal|0
expr_stmt|;
name|key_type
operator|=
name|keytype_from_text
argument_list|(
name|digest_name
argument_list|,
operator|&
name|digest_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_type
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype must be 'md5'%s\n"
argument_list|,
ifdef|#
directive|ifdef
name|OPENSSL
literal|" or a digest type provided by OpenSSL"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|""
block|)
empty_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_expr_stmt
name|info_auth_keytype
operator|=
name|key_type
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|info_auth_hashlen
operator|=
name|digest_len
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * passwd - get an authentication key  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
unit|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|pass
decl_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|int
name|u_keyid
init|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
decl_stmt|;
if|if
condition|(
name|u_keyid
operator|==
literal|0
operator|||
name|u_keyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|info_auth_keyid
operator|=
name|u_keyid
expr_stmt|;
block|}
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|1
condition|)
name|pass
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
else|else
block|{
name|pass
operator|=
name|getpass_keytype
argument_list|(
name|info_auth_keytype
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|pass
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Password unchanged\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * hostnames - set the showhostnames flag  */
end_comment

begin_function
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|showhostnames
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames being shown\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames not being shown\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * setdebug - set/change debugging level  */
end_comment

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level is %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"more"
argument_list|)
condition|)
block|{
name|debug
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"less"
argument_list|)
condition|)
block|{
name|debug
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level set to %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * quit - stop this nonsense  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|havehost
condition|)
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
comment|/* cleanliness next to godliness */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * version - print the current version number  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * raw - set raw mode output  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|raw
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|rawmode
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Output set to raw\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cooked - set cooked mode output  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|cooked
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|rawmode
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Output set to cooked\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * authenticate - always authenticate requests to this host  */
end_comment

begin_function
specifier|static
name|void
name|authenticate
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|always_auth
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"authenticated requests being sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"unauthenticated requests being sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
block|{
name|always_auth
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|always_auth
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ntpversion - choose the NTP version to use  */
end_comment

begin_function
specifier|static
name|void
name|ntpversion
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NTP version being claimed is %d\n"
argument_list|,
name|pktversion
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|<
name|NTP_OLDVERSION
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|>
name|NTP_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"versions %d to %d, please\n"
argument_list|,
name|NTP_OLDVERSION
argument_list|,
name|NTP_VERSION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pktversion
operator|=
operator|(
name|u_char
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * warning - print a warning message  */
end_comment

begin_function
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|st1
parameter_list|,
specifier|const
name|char
modifier|*
name|st2
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|st1
argument_list|,
name|st2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error - print a message and exit  */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|st1
parameter_list|,
specifier|const
name|char
modifier|*
name|st2
parameter_list|)
block|{
name|warning
argument_list|(
name|fmt
argument_list|,
name|st1
argument_list|,
name|st2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getkeyid - prompt the user for a keyid to use  */
end_comment

begin_function
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
name|keyprompt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|fi
decl_stmt|;
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|ilim
decl_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
operator|(
name|fi
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|fi
operator|=
name|_fdopen
argument_list|(
name|open
argument_list|(
literal|"CONIN$"
argument_list|,
name|_O_TEXT
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|fi
operator|=
name|stdin
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|fi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|keyprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ilim
operator|=
name|COUNTOF
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
init|;
name|i
operator|<
name|ilim
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
name|pbuf
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|pbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_long
operator|)
name|atoi
argument_list|(
name|pbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * atoascii - printable-ize possibly ascii data using the character  *	      transformations cat -v uses.  */
end_comment

begin_function
specifier|static
name|void
name|atoascii
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|in_octets
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|out_octets
parameter_list|)
block|{
specifier|register
specifier|const
name|u_char
modifier|*
name|pchIn
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|pchInLimit
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pchOut
decl_stmt|;
specifier|register
name|u_char
name|c
decl_stmt|;
name|pchIn
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|in
expr_stmt|;
name|pchInLimit
operator|=
name|pchIn
operator|+
name|in_octets
expr_stmt|;
name|pchOut
operator|=
operator|(
name|u_char
operator|*
operator|)
name|out
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pchIn
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|out_octets
condition|)
operator|*
name|pchOut
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|ONEOUT
parameter_list|(
name|c
parameter_list|)
define|\
value|do {							\ 	if (0 == --out_octets) {			\ 		*pchOut = '\0';				\ 		return;					\ 	}						\ 	*pchOut++ = (c);				\ } while (0)
for|for
control|(
init|;
name|pchIn
operator|<
name|pchInLimit
condition|;
name|pchIn
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|pchIn
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|ONEOUT
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|ONEOUT
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|ONEOUT
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|ONEOUT
argument_list|(
call|(
name|u_char
call|)
argument_list|(
name|c
operator|+
literal|'@'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0x7f
operator|==
name|c
condition|)
block|{
name|ONEOUT
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|ONEOUT
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
name|ONEOUT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|ONEOUT
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ONEOUT
block|}
end_function

begin_comment
comment|/*  * makeascii - print possibly ascii data using the character  *	       transformations that cat -v uses.  */
end_comment

begin_function
name|void
name|makeascii
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|data_u_char
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|data_u_char
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|data_u_char
init|;
name|cp
operator|<
name|data_u_char
operator|+
name|length
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|int
operator|)
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|putc
argument_list|(
literal|'M'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
operator|+
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0x7f
operator|==
name|c
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'?'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * asciize - same thing as makeascii except add a newline  */
end_comment

begin_function
name|void
name|asciize
parameter_list|(
name|int
name|length
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|makeascii
argument_list|(
name|length
argument_list|,
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * truncate string to fit clipping excess at end.  *	"too long"	->	"too l"  * Used for hostnames.  */
end_comment

begin_function
name|char
modifier|*
name|trunc_right
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|width
parameter_list|)
block|{
name|size_t
name|sl
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|sl
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl
operator|>
name|width
operator|&&
name|LIB_BUFLENGTH
operator|-
literal|1
operator|>
name|width
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|LIB_GETBUF
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|src
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|out
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|out
return|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/*  * truncate string to fit by preserving right side and using '_' to hint  *	"too long"	->	"_long"  * Used for local IPv6 addresses, where low bits differentiate.  */
end_comment

begin_function
name|char
modifier|*
name|trunc_left
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|width
parameter_list|)
block|{
name|size_t
name|sl
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|sl
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl
operator|>
name|width
operator|&&
name|LIB_BUFLENGTH
operator|-
literal|1
operator|>
name|width
operator|&&
name|width
operator|>
literal|1
condition|)
block|{
name|LIB_GETBUF
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|out
index|[
literal|1
index|]
argument_list|,
operator|&
name|src
index|[
name|sl
operator|+
literal|1
operator|-
name|width
index|]
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/*  * Some circular buffer space  */
end_comment

begin_define
define|#
directive|define
name|CBLEN
value|80
end_define

begin_define
define|#
directive|define
name|NUMCB
value|6
end_define

begin_decl_stmt
name|char
name|circ_buf
index|[
name|NUMCB
index|]
index|[
name|CBLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nextcb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nextvar - find the next variable in the buffer  */
end_comment

begin_function
name|int
name|nextvar
parameter_list|(
name|int
modifier|*
name|datalen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|datap
parameter_list|,
name|char
modifier|*
modifier|*
name|vname
parameter_list|,
name|char
modifier|*
modifier|*
name|vvalue
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|cpend
decl_stmt|;
name|char
modifier|*
name|npend
decl_stmt|;
comment|/* character after last */
name|int
name|quoted
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|name
index|[
name|MAXVARLEN
index|]
decl_stmt|;
specifier|static
name|char
name|value
index|[
name|MAXVALLEN
index|]
decl_stmt|;
name|cp
operator|=
operator|*
name|datap
expr_stmt|;
name|cpend
operator|=
name|cp
operator|+
operator|*
name|datalen
expr_stmt|;
comment|/* 	 * Space past commas and white space 	 */
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|cpend
condition|)
return|return
literal|0
return|;
comment|/* 	 * Copy name until we hit a ',', an '=', a '\r' or a '\n'.  Backspace 	 * over any white space and terminate it. 	 */
name|np
operator|=
name|name
expr_stmt|;
name|npend
operator|=
operator|&
name|name
index|[
name|MAXVARLEN
index|]
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
name|np
operator|<
name|npend
operator|&&
operator|*
name|cp
operator|!=
literal|','
operator|&&
operator|*
name|cp
operator|!=
literal|'='
operator|&&
operator|*
name|cp
operator|!=
literal|'\r'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Check if we ran out of name space, without reaching the end or a 	 * terminating character 	 */
if|if
condition|(
name|np
operator|==
name|npend
operator|&&
operator|!
operator|(
name|cp
operator|==
name|cpend
operator|||
operator|*
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|'='
operator|||
operator|*
name|cp
operator|==
literal|'\r'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|isspace
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|np
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
name|np
operator|--
expr_stmt|;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|vname
operator|=
name|name
expr_stmt|;
comment|/* 	 * Check if we hit the end of the buffer or a ','.  If so we are done. 	 */
if|if
condition|(
name|cp
operator|==
name|cpend
operator|||
operator|*
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|'\r'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|cpend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|datap
operator|=
name|cp
expr_stmt|;
operator|*
name|datalen
operator|=
name|cpend
operator|-
name|cp
expr_stmt|;
operator|*
name|vvalue
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * So far, so good.  Copy out the value 	 */
name|cp
operator|++
expr_stmt|;
comment|/* past '=' */
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\r'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
name|np
operator|=
name|value
expr_stmt|;
name|npend
operator|=
operator|&
name|value
index|[
name|MAXVALLEN
index|]
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
name|np
operator|<
name|npend
operator|&&
operator|(
operator|(
operator|*
name|cp
operator|!=
literal|','
operator|)
operator|||
name|quoted
operator|)
condition|)
block|{
name|quoted
operator|^=
operator|(
operator|(
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|'"'
operator|)
expr_stmt|;
block|}
comment|/* 	 * Check if we overran the value buffer while still in a quoted string 	 * or without finding a comma 	 */
if|if
condition|(
name|np
operator|==
name|npend
operator|&&
operator|(
name|quoted
operator|||
operator|*
name|cp
operator|!=
literal|','
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Trim off any trailing whitespace 	 */
while|while
condition|(
name|np
operator|>
name|value
operator|&&
name|isspace
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|np
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
name|np
operator|--
expr_stmt|;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Return this.  All done. 	 */
if|if
condition|(
name|cp
operator|!=
name|cpend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|datap
operator|=
name|cp
expr_stmt|;
operator|*
name|datalen
operator|=
name|cpend
operator|-
name|cp
expr_stmt|;
operator|*
name|vvalue
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * findvar - see if this variable is known to us.  * If "code" is 1, return ctl_var->code.  * Otherwise return the ordinal position of the found variable.  */
end_comment

begin_function
name|int
name|findvar
parameter_list|(
name|char
modifier|*
name|varname
parameter_list|,
name|struct
name|ctl_var
modifier|*
name|varlist
parameter_list|,
name|int
name|code
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|vl
decl_stmt|;
name|vl
operator|=
name|varlist
expr_stmt|;
name|np
operator|=
name|varname
expr_stmt|;
while|while
condition|(
name|vl
operator|->
name|fmt
operator|!=
name|EOV
condition|)
block|{
if|if
condition|(
name|vl
operator|->
name|fmt
operator|!=
name|PADDING
operator|&&
name|STREQ
argument_list|(
name|np
argument_list|,
name|vl
operator|->
name|text
argument_list|)
condition|)
return|return
operator|(
name|code
operator|)
condition|?
name|vl
operator|->
name|code
else|:
operator|(
name|vl
operator|-
name|varlist
operator|)
return|;
name|vl
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * printvars - print variables returned in response packet  */
end_comment

begin_function
name|void
name|printvars
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|sttype
parameter_list|,
name|int
name|quiet
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|rawmode
condition|)
name|rawprint
argument_list|(
name|sttype
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|status
argument_list|,
name|quiet
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|cookedprint
argument_list|(
name|sttype
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|status
argument_list|,
name|quiet
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rawprint - do a printout of the data in raw mode  */
end_comment

begin_function
specifier|static
name|void
name|rawprint
parameter_list|(
name|int
name|datatype
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|quiet
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cpend
decl_stmt|;
comment|/* 	 * Essentially print the data as is.  We reformat unprintables, though. 	 */
name|cp
operator|=
name|data
expr_stmt|;
name|cpend
operator|=
name|data
operator|+
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"status=0x%04x,\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
comment|/* 			 * If this is a \r and the next character is a 			 * \n, supress this, else pretty print it.  Otherwise 			 * just output the character. 			 */
if|if
condition|(
name|cp
operator|==
operator|(
name|cpend
operator|-
literal|1
operator|)
operator|||
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
name|makeascii
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|makeascii
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Global data used by the cooked output routines  */
end_comment

begin_decl_stmt
name|int
name|out_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters output */
end_comment

begin_decl_stmt
name|int
name|out_linecount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters output on this line */
end_comment

begin_comment
comment|/*  * startoutput - get ready to do cooked output  */
end_comment

begin_function
specifier|static
name|void
name|startoutput
parameter_list|(
name|void
parameter_list|)
block|{
name|out_chars
operator|=
literal|0
expr_stmt|;
name|out_linecount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * output - output a variable=value combination  */
end_comment

begin_function
specifier|static
name|void
name|output
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* strlen of "name=value" */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_chars
operator|!=
literal|0
condition|)
block|{
name|out_chars
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|out_linecount
operator|+
name|len
operator|+
literal|2
operator|)
operator|>
name|MAXOUTLINE
condition|)
block|{
name|fputs
argument_list|(
literal|",\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_linecount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|", "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_linecount
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'='
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|value
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_chars
operator|+=
name|len
expr_stmt|;
name|out_linecount
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * endoutput - terminate a block of cooked output  */
end_comment

begin_function
specifier|static
name|void
name|endoutput
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|out_chars
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * outputarr - output an array of values  */
end_comment

begin_function
specifier|static
name|void
name|outputarr
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|narr
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Hack to align delay and offset values 	 */
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
name|narr
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|narr
condition|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cp
operator|=
name|lfptoms
argument_list|(
name|lfp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|7
condition|)
block|{
name|cp
index|[
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
literal|7
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|7
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|lfp
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tstflags
parameter_list|(
name|u_long
name|val
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|cb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|cp
operator|=
name|circ_buf
index|[
name|nextcb
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|nextcb
operator|>=
name|NUMCB
condition|)
name|nextcb
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|circ_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
name|cb
argument_list|,
literal|"%02lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cb
operator|-=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|strncat
argument_list|(
name|cp
argument_list|,
literal|" ok"
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cb
operator|-=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cb
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cb
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|tstflagnames
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|&
literal|0x1
condition|)
block|{
name|snprintf
argument_list|(
name|cp
argument_list|,
name|cb
argument_list|,
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|tstflagnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cb
operator|-=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cb
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * cookedprint - output variables in cooked mode  */
end_comment

begin_function
specifier|static
name|void
name|cookedprint
parameter_list|(
name|int
name|datatype
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|quiet
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|varid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
name|output_raw
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|varlist
decl_stmt|;
name|l_fp
name|lfp
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|sockaddr_u
name|hval
decl_stmt|;
name|u_long
name|uval
decl_stmt|;
name|l_fp
name|lfparr
index|[
literal|8
index|]
decl_stmt|;
name|int
name|narr
decl_stmt|;
switch|switch
condition|(
name|datatype
condition|)
block|{
case|case
name|TYPE_PEER
case|:
name|varlist
operator|=
name|peer_var
expr_stmt|;
break|break;
case|case
name|TYPE_SYS
case|:
name|varlist
operator|=
name|sys_var
expr_stmt|;
break|break;
case|case
name|TYPE_CLOCK
case|:
name|varlist
operator|=
name|clock_var
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown datatype(0x%x) in cookedprint\n"
argument_list|,
name|datatype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"status=%04x %s,\n"
argument_list|,
name|status
argument_list|,
name|statustoa
argument_list|(
name|datatype
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|startoutput
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|length
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|varid
operator|=
name|findvar
argument_list|(
name|name
argument_list|,
name|varlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|varid
operator|==
literal|0
condition|)
block|{
name|output_raw
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
block|{
name|output_raw
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|varlist
index|[
name|varid
index|]
operator|.
name|fmt
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|TS
case|:
if|if
condition|(
operator|!
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|lfp
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|prettydate
argument_list|(
operator|&
name|lfp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FL
case|:
case|case
name|FU
case|:
case|case
name|FS
case|:
if|if
condition|(
operator|!
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|lfp
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|FL
case|:
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|lfp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FU
case|:
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|ulfptoms
argument_list|(
operator|&
name|lfp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FS
case|:
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|lfp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|UI
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|uinttoa
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI
case|:
if|if
condition|(
operator|!
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|ival
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|inttoa
argument_list|(
name|ival
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HA
case|:
case|case
name|NA
case|:
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|hval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
operator|==
name|HA
condition|)
block|{
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|nntohost
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|stoa
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST
case|:
name|output_raw
operator|=
literal|'*'
expr_stmt|;
break|break;
case|case
name|RF
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|hval
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|hval
argument_list|)
condition|)
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|stoa
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|value
argument_list|)
operator|<=
literal|4
condition|)
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|output_raw
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
name|LP
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
operator|||
name|uval
operator|>
literal|3
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
name|char
name|b
index|[
literal|3
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|uval
operator|&
literal|0x2
condition|)
name|b
index|[
literal|0
index|]
operator|=
literal|'1'
expr_stmt|;
if|if
condition|(
name|uval
operator|&
literal|0x1
condition|)
name|b
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OC
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
name|char
name|b
index|[
literal|12
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
name|b
argument_list|,
literal|"%03lo"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MD
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|uinttoa
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AR
case|:
if|if
condition|(
operator|!
name|decodearr
argument_list|(
name|value
argument_list|,
operator|&
name|narr
argument_list|,
name|lfparr
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|outputarr
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|narr
argument_list|,
name|lfparr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FX
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|tstflags
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error in cookedprint, %s=%s, fmt %d\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|output_raw
operator|!=
literal|0
condition|)
block|{
name|char
name|bn
index|[
literal|401
index|]
decl_stmt|;
name|char
name|bv
index|[
literal|401
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|atoascii
argument_list|(
name|name
argument_list|,
name|MAXVARLEN
argument_list|,
name|bn
argument_list|,
sizeof|sizeof
argument_list|(
name|bn
argument_list|)
argument_list|)
expr_stmt|;
name|atoascii
argument_list|(
name|value
argument_list|,
name|MAXVARLEN
argument_list|,
name|bv
argument_list|,
sizeof|sizeof
argument_list|(
name|bv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_raw
operator|!=
literal|'*'
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|bv
argument_list|)
expr_stmt|;
name|bv
index|[
name|len
index|]
operator|=
name|output_raw
expr_stmt|;
name|bv
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|output
argument_list|(
name|fp
argument_list|,
name|bn
argument_list|,
name|bv
argument_list|)
expr_stmt|;
block|}
block|}
name|endoutput
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sortassoc - sort associations in the cache into ascending order  */
end_comment

begin_function
name|void
name|sortassoc
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|numassoc
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|assoc_cache
argument_list|,
operator|(
name|size_t
operator|)
name|numassoc
argument_list|,
sizeof|sizeof
argument_list|(
name|assoc_cache
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|assoccmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * assoccmp - compare two associations  */
end_comment

begin_function
specifier|static
name|int
name|assoccmp
parameter_list|(
specifier|const
name|void
modifier|*
name|t1
parameter_list|,
specifier|const
name|void
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|struct
name|association
modifier|*
name|ass1
init|=
name|t1
decl_stmt|;
specifier|const
name|struct
name|association
modifier|*
name|ass2
init|=
name|t2
decl_stmt|;
if|if
condition|(
name|ass1
operator|->
name|assid
operator|<
name|ass2
operator|->
name|assid
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ass1
operator|->
name|assid
operator|>
name|ass2
operator|->
name|assid
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ntpq_custom_opt_handler - autoopts handler for -c and -p  *  * By default, autoopts loses the relative order of -c and -p options  * on the command line.  This routine replaces the default handler for  * those routines and builds a list of commands to execute preserving  * the order.  */
end_comment

begin_function
name|void
name|ntpq_custom_opt_handler
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
block|{
switch|switch
condition|(
name|pOptDesc
operator|->
name|optValue
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ntpq_custom_opt_handler unexpected option '%c' (%d)\n"
argument_list|,
name|pOptDesc
operator|->
name|optValue
argument_list|,
name|pOptDesc
operator|->
name|optValue
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
name|ADDCMD
argument_list|(
name|pOptDesc
operator|->
name|pzLastArg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ADDCMD
argument_list|(
literal|"peers"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

