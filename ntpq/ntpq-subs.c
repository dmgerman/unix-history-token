begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpq-subs.c - subroutines which are called to perform ntpq commands.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpq.h"
end_include

begin_include
include|#
directive|include
file|"ntpq-opts.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|currenthost
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|currenthostisnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|maxhostlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declarations for command handlers in here  */
end_comment

begin_function_decl
specifier|static
name|associd_t
name|checkassocid
parameter_list|(
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|varlist
modifier|*
name|findlistvar
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doaddvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dormvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doclearvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|makequerydata
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doquerylist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|associd_t
parameter_list|,
name|int
parameter_list|,
name|u_short
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doprintvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clearvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|showvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dolist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|associd_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readlist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writelist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readvar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writevar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clocklist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clockvar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findassidrange
parameter_list|(
name|u_int32
parameter_list|,
name|u_int32
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mreadlist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mreadvar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printassoc
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|associations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lassociations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passociations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpassociations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_function_decl
specifier|static
name|void
name|radiostatus
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_function_decl
specifier|static
name|void
name|authinfo
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pstats
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|when
parameter_list|(
name|l_fp
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|prettyinterval
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doprintpeers
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dogetpeers
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|associd_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopeers
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpeers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doopeers
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opeers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lopeers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|saveconfig
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_from_file
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mrulist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ifstats
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reslist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sysstats
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sysinfo
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kerninfo
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monstats
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iostats
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timerstats
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Commands we understand.	Ntpdc imports this.  */
end_comment

begin_decl_stmt
name|struct
name|xcmd
name|opcmds
index|[]
init|=
block|{
block|{
literal|"saveconfig"
block|,
name|saveconfig
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"filename"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"save ntpd configuration to file, . for current config file"
block|}
block|,
block|{
literal|"associations"
block|,
name|associations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of association ID's and statuses for the server's peers"
block|}
block|,
block|{
literal|"passociations"
block|,
name|passociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of associations returned by last associations command"
block|}
block|,
block|{
literal|"lassociations"
block|,
name|lassociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of associations including all client information"
block|}
block|,
block|{
literal|"lpassociations"
block|,
name|lpassociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print last obtained list of associations, including client information"
block|}
block|,
block|{
literal|"addvars"
block|,
name|addvars
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"name[=value][,...]"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"add variables to the variable list or change their values"
block|}
block|,
block|{
literal|"rmvars"
block|,
name|rmvars
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"name[,...]"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"remove variables from the variable list"
block|}
block|,
block|{
literal|"clearvars"
block|,
name|clearvars
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"remove all variables from the variable list"
block|}
block|,
block|{
literal|"showvars"
block|,
name|showvars
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print variables on the variable list"
block|}
block|,
block|{
literal|"readlist"
block|,
name|readlist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"rl"
block|,
name|readlist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"writelist"
block|,
name|writelist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"write the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"readvar"
block|,
name|readvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|, }
block|,
block|{
literal|"assocID"
block|,
literal|"varname1"
block|,
literal|"varname2"
block|,
literal|"varname3"
block|}
block|,
literal|"read system or peer variables"
block|}
block|,
block|{
literal|"rv"
block|,
name|readvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|, }
block|,
block|{
literal|"assocID"
block|,
literal|"varname1"
block|,
literal|"varname2"
block|,
literal|"varname3"
block|}
block|,
literal|"read system or peer variables"
block|}
block|,
block|{
literal|"writevar"
block|,
name|writevar
block|,
block|{
name|NTP_UINT
block|,
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value,[...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"write system or peer variables"
block|}
block|,
block|{
literal|"mreadlist"
block|,
name|mreadlist
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocIDlow"
block|,
literal|"assocIDhigh"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the peer variables in the variable list for multiple peers"
block|}
block|,
block|{
literal|"mrl"
block|,
name|mreadlist
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocIDlow"
block|,
literal|"assocIDhigh"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the peer variables in the variable list for multiple peers"
block|}
block|,
block|{
literal|"mreadvar"
block|,
name|mreadvar
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|}
block|,
block|{
literal|"assocIDlow"
block|,
literal|"assocIDhigh"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|}
block|,
literal|"read peer variables from multiple peers"
block|}
block|,
block|{
literal|"mrv"
block|,
name|mreadvar
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|}
block|,
block|{
literal|"assocIDlow"
block|,
literal|"assocIDhigh"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|}
block|,
literal|"read peer variables from multiple peers"
block|}
block|,
block|{
literal|"clocklist"
block|,
name|clocklist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the clock variables included in the variable list"
block|}
block|,
block|{
literal|"cl"
block|,
name|clocklist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the clock variables included in the variable list"
block|}
block|,
block|{
literal|"clockvar"
block|,
name|clockvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read clock variables"
block|}
block|,
block|{
literal|"cv"
block|,
name|clockvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read clock variables"
block|}
block|,
block|{
literal|"pstats"
block|,
name|pstats
block|,
block|{
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"show statistics for a peer"
block|}
block|,
block|{
literal|"peers"
block|,
name|peers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of the server's peers [IP version]"
block|}
block|,
block|{
literal|"lpeers"
block|,
name|lpeers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of all peers and clients [IP version]"
block|}
block|,
block|{
literal|"opeers"
block|,
name|opeers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print peer list the old way, with dstadr shown rather than refid [IP version]"
block|}
block|,
block|{
literal|"lopeers"
block|,
name|lopeers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of all peers and clients showing dstadr [IP version]"
block|}
block|,
block|{
literal|":config"
block|,
name|config
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"<configuration command line>"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"send a remote configuration command to ntpd"
block|}
block|,
block|{
literal|"config-from-file"
block|,
name|config_from_file
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"<configuration filename>"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"configure ntpd using the configuration filename"
block|}
block|,
block|{
literal|"mrulist"
block|,
name|mrulist
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|}
block|,
block|{
literal|"tag=value"
block|,
literal|"tag=value"
block|,
literal|"tag=value"
block|,
literal|"tag=value"
block|}
block|,
literal|"display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x..."
block|}
block|,
block|{
literal|"ifstats"
block|,
name|ifstats
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"show statistics for each local address ntpd is using"
block|}
block|,
block|{
literal|"reslist"
block|,
name|reslist
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"show ntpd access control list"
block|}
block|,
block|{
literal|"sysinfo"
block|,
name|sysinfo
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display system summary"
block|}
block|,
block|{
literal|"kerninfo"
block|,
name|kerninfo
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display kernel loop and PPS statistics"
block|}
block|,
block|{
literal|"sysstats"
block|,
name|sysstats
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display system uptime and packet counts"
block|}
block|,
block|{
literal|"monstats"
block|,
name|monstats
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display monitor (mrulist) counters and limits"
block|}
block|,
block|{
literal|"authinfo"
block|,
name|authinfo
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display symmetric authentication counters"
block|}
block|,
block|{
literal|"iostats"
block|,
name|iostats
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display network input and output counters"
block|}
block|,
block|{
literal|"timerstats"
block|,
name|timerstats
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display interval timer counters"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable list data space  */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum length of a line */
end_comment

begin_define
define|#
directive|define
name|MAXLIST
value|128
end_define

begin_comment
comment|/* maximum variables in list */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name limit */
end_comment

begin_define
define|#
directive|define
name|MRU_GOT_COUNT
value|0x1
end_define

begin_define
define|#
directive|define
name|MRU_GOT_LAST
value|0x2
end_define

begin_define
define|#
directive|define
name|MRU_GOT_FIRST
value|0x4
end_define

begin_define
define|#
directive|define
name|MRU_GOT_MV
value|0x8
end_define

begin_define
define|#
directive|define
name|MRU_GOT_RS
value|0x10
end_define

begin_define
define|#
directive|define
name|MRU_GOT_ADDR
value|0x20
end_define

begin_define
define|#
directive|define
name|MRU_GOT_ALL
value|(MRU_GOT_COUNT | MRU_GOT_LAST | MRU_GOT_FIRST \ 			 | MRU_GOT_MV | MRU_GOT_RS | MRU_GOT_ADDR)
end_define

begin_comment
comment|/*  * mrulist() depends on MRUSORT_DEF and MRUSORT_RDEF being the first two  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|mru_sort_order_tag
block|{
name|MRUSORT_DEF
init|=
literal|0
block|,
comment|/* lstint ascending */
name|MRUSORT_R_DEF
block|,
comment|/* lstint descending */
name|MRUSORT_AVGINT
block|,
comment|/* avgint ascending */
name|MRUSORT_R_AVGINT
block|,
comment|/* avgint descending */
name|MRUSORT_ADDR
block|,
comment|/* IPv4 asc. then IPv6 asc. */
name|MRUSORT_R_ADDR
block|,
comment|/* IPv6 desc. then IPv4 desc. */
name|MRUSORT_COUNT
block|,
comment|/* hit count ascending */
name|MRUSORT_R_COUNT
block|,
comment|/* hit count descending */
name|MRUSORT_MAX
block|,
comment|/* special: count of this enum */
block|}
name|mru_sort_order
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|mru_sort_keywords
index|[
name|MRUSORT_MAX
index|]
init|=
block|{
literal|"lstint"
block|,
comment|/* MRUSORT_DEF */
literal|"-lstint"
block|,
comment|/* MRUSORT_R_DEF */
literal|"avgint"
block|,
comment|/* MRUSORT_AVGINT */
literal|"-avgint"
block|,
comment|/* MRUSORT_R_AVGINT */
literal|"addr"
block|,
comment|/* MRUSORT_ADDR */
literal|"-addr"
block|,
comment|/* MRUSORT_R_ADDR */
literal|"count"
block|,
comment|/* MRUSORT_COUNT */
literal|"-count"
block|,
comment|/* MRUSORT_R_COUNT */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|qsort_cmp
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Old CTL_PST defines for version 2.  */
end_comment

begin_define
define|#
directive|define
name|OLD_CTL_PST_CONFIG
value|0x80
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_AUTHENABLE
value|0x40
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_AUTHENTIC
value|0x20
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_REACH
value|0x10
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SANE
value|0x08
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_DISP
value|0x04
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_REJECT
value|0
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SELCAND
value|1
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SYNCCAND
value|2
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SYSPEER
value|3
end_define

begin_decl_stmt
name|char
name|flash2
index|[]
init|=
literal|" .+*    "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash decode for version 2 */
end_comment

begin_decl_stmt
name|char
name|flash3
index|[]
init|=
literal|" x.-+#*o"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash decode for peer status version 3 */
end_comment

begin_struct
struct|struct
name|varlist
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|g_varlist
index|[
name|MAXLIST
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Imported from ntpq.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|showhostnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|wideremote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rawmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|servent
modifier|*
name|server_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|association
modifier|*
name|assoc_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|pktversion
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|mru_tag
name|mru
typedef|;
end_typedef

begin_struct
struct|struct
name|mru_tag
block|{
name|mru
modifier|*
name|hlink
decl_stmt|;
comment|/* next in hash table bucket */
name|DECL_DLIST_LINK
argument_list|(
name|mru
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|int
name|count
decl_stmt|;
name|l_fp
name|last
decl_stmt|;
name|l_fp
name|first
decl_stmt|;
name|u_char
name|mode
decl_stmt|;
name|u_char
name|ver
decl_stmt|;
name|u_short
name|rs
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|ifstats_row_tag
block|{
name|u_int
name|ifnum
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|sockaddr_u
name|bcast
decl_stmt|;
name|int
name|enabled
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|mcast_count
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|int
name|peer_count
decl_stmt|;
name|int
name|received
decl_stmt|;
name|int
name|sent
decl_stmt|;
name|int
name|send_errors
decl_stmt|;
name|u_int
name|ttl
decl_stmt|;
name|u_int
name|uptime
decl_stmt|;
block|}
name|ifstats_row
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|reslist_row_tag
block|{
name|u_int
name|idx
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|sockaddr_u
name|mask
decl_stmt|;
name|u_long
name|hits
decl_stmt|;
name|char
name|flagstr
index|[
literal|128
index|]
decl_stmt|;
block|}
name|reslist_row
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|var_display_collection_tag
block|{
specifier|const
name|char
modifier|*
specifier|const
name|tag
decl_stmt|;
comment|/* system variable */
specifier|const
name|char
modifier|*
specifier|const
name|display
decl_stmt|;
comment|/* descriptive text */
name|u_char
name|type
decl_stmt|;
comment|/* NTP_STR, etc */
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|sockaddr_u
name|sau
decl_stmt|;
comment|/* NTP_ADD */
name|l_fp
name|lfp
decl_stmt|;
comment|/* NTP_LFP */
block|}
name|v
union|;
comment|/* retrieved value */
block|}
name|vdc
typedef|;
end_typedef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MISSING_C99_STYLE_INIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|VDC_INIT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|{ .tag = a, .display = b, .type = c }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VDC_INIT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|{ a, b, c }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * other local function prototypes  */
end_comment

begin_function_decl
name|void
name|mrulist_ctrl_c_hook
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mru
modifier|*
name|add_mru
parameter_list|(
name|mru
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_mru_list
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fetch_nonce
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qcmp_mru_avgint
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qcmp_mru_r_avgint
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qcmp_mru_addr
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qcmp_mru_r_addr
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qcmp_mru_count
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qcmp_mru_r_count
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_ifnum
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifstats_row
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|another_ifstats_field
parameter_list|(
name|int
modifier|*
parameter_list|,
name|ifstats_row
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|collect_display_vdc
parameter_list|(
name|associd_t
name|as
parameter_list|,
name|vdc
modifier|*
name|table
parameter_list|,
name|int
name|decodestatus
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * static globals  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|mru_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|mru_dupes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|mrulist_interrupted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mru
name|mru_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* listhead */
end_comment

begin_decl_stmt
specifier|static
name|mru
modifier|*
modifier|*
name|hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * qsort comparison function table for mrulist().  The first two  * entries are NULL because they are handled without qsort().  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|qsort_cmp
name|mru_qcmp_table
index|[
name|MRUSORT_MAX
index|]
init|=
block|{
name|NULL
block|,
comment|/* MRUSORT_DEF unused */
name|NULL
block|,
comment|/* MRUSORT_R_DEF unused */
operator|&
name|qcmp_mru_avgint
block|,
comment|/* MRUSORT_AVGINT */
operator|&
name|qcmp_mru_r_avgint
block|,
comment|/* MRUSORT_R_AVGINT */
operator|&
name|qcmp_mru_addr
block|,
comment|/* MRUSORT_ADDR */
operator|&
name|qcmp_mru_r_addr
block|,
comment|/* MRUSORT_R_ADDR */
operator|&
name|qcmp_mru_count
block|,
comment|/* MRUSORT_COUNT */
operator|&
name|qcmp_mru_r_count
block|,
comment|/* MRUSORT_R_COUNT */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * checkassocid - return the association ID, checking to see if it is valid  */
end_comment

begin_function
specifier|static
name|associd_t
name|checkassocid
parameter_list|(
name|u_int32
name|value
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|u_long
name|ulvalue
decl_stmt|;
name|associd
operator|=
operator|(
name|associd_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|associd
operator|||
name|value
operator|!=
name|associd
condition|)
block|{
name|ulvalue
operator|=
name|value
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Invalid association ID %lu specified\n"
argument_list|,
name|ulvalue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|associd
return|;
block|}
end_function

begin_comment
comment|/*  * findlistvar - Look for the named variable in a varlist.  If found,  *		 return a pointer to it.  Otherwise, if the list has  *		 slots available, return the pointer to the first free  *		 slot, or NULL if it's full.  */
end_comment

begin_function
specifier|static
name|struct
name|varlist
modifier|*
name|findlistvar
parameter_list|(
name|struct
name|varlist
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
for|for
control|(
name|vl
operator|=
name|list
init|;
name|vl
operator|<
name|list
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
name|NULL
condition|;
name|vl
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|vl
operator|->
name|name
argument_list|)
condition|)
return|return
name|vl
return|;
if|if
condition|(
name|vl
operator|<
name|list
operator|+
name|MAXLIST
condition|)
return|return
name|vl
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * doaddvlist - add variable(s) to the variable list  */
end_comment

begin_function
specifier|static
name|void
name|doaddvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
specifier|const
name|char
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|vars
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|vl
operator|=
name|findlistvar
argument_list|(
name|vlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|vl
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable list full\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|NULL
operator|==
name|vl
operator|->
name|name
condition|)
block|{
name|vl
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|vl
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|vl
operator|->
name|value
operator|=
name|estrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * dormvlist - remove variable(s) from the variable list  */
end_comment

begin_function
specifier|static
name|void
name|dormvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
specifier|const
name|char
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|vars
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|vl
operator|=
name|findlistvar
argument_list|(
name|vlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|==
literal|0
operator|||
name|vl
operator|->
name|name
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable `%s' not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|vl
operator|+
literal|1
operator|)
operator|<
operator|(
name|g_varlist
operator|+
name|MAXLIST
operator|)
operator|&&
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|vl
operator|->
name|name
operator|=
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|name
expr_stmt|;
name|vl
operator|->
name|value
operator|=
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|value
expr_stmt|;
block|}
name|vl
operator|->
name|name
operator|=
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * doclearvlist - clear a variable list  */
end_comment

begin_function
specifier|static
name|void
name|doclearvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
name|vl
operator|->
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * makequerydata - form a data buffer to be included with a query  */
end_comment

begin_function
specifier|static
name|void
name|makequerydata
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
modifier|*
name|datalen
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpend
decl_stmt|;
specifier|register
name|int
name|namelen
decl_stmt|,
name|valuelen
decl_stmt|;
specifier|register
name|int
name|totallen
decl_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|cpend
operator|=
name|data
operator|+
operator|*
name|datalen
expr_stmt|;
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|namelen
operator|=
name|strlen
argument_list|(
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|==
literal|0
condition|)
name|valuelen
operator|=
literal|0
expr_stmt|;
else|else
name|valuelen
operator|=
name|strlen
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|namelen
operator|+
name|valuelen
operator|+
operator|(
name|valuelen
operator|!=
literal|0
operator|)
operator|+
operator|(
name|cp
operator|!=
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|totallen
operator|>
name|cpend
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Ignoring variables starting with `%s'\n"
argument_list|,
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|!=
name|data
condition|)
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|vl
operator|->
name|name
argument_list|,
operator|(
name|size_t
operator|)
name|namelen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|namelen
expr_stmt|;
if|if
condition|(
name|valuelen
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|vl
operator|->
name|value
argument_list|,
operator|(
name|size_t
operator|)
name|valuelen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|valuelen
expr_stmt|;
block|}
block|}
operator|*
name|datalen
operator|=
name|cp
operator|-
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * doquerylist - send a message including variables in a list  */
end_comment

begin_function
specifier|static
name|int
name|doquerylist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
name|op
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|int
modifier|*
name|dsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
name|char
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|datalen
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|makequerydata
argument_list|(
name|vlist
argument_list|,
operator|&
name|datalen
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|doquery
argument_list|(
name|op
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|datalen
argument_list|,
name|data
argument_list|,
name|rstatus
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * doprintvlist - print the variables on a list  */
end_comment

begin_function
specifier|static
name|void
name|doprintvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|vlist
operator|->
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No variables on list\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAXLIST
operator|&&
name|vlist
index|[
name|n
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|vlist
index|[
name|n
index|]
operator|.
name|value
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|vlist
index|[
name|n
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s=%s\n"
argument_list|,
name|vlist
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|vlist
index|[
name|n
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * addvars - add variables to the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|addvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doaddvlist
argument_list|(
name|g_varlist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rmvars - remove variables from the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|rmvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|dormvlist
argument_list|(
name|g_varlist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clearvars - clear the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|clearvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doclearvlist
argument_list|(
name|g_varlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * showvars - show variables on the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|showvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doprintvlist
argument_list|(
name|g_varlist
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dolist - send a request with the given list of variables  */
end_comment

begin_function
specifier|static
name|int
name|dolist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|type
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|quiet
decl_stmt|;
comment|/* 	 * if we're asking for specific variables don't include the 	 * status header line in the output. 	 */
if|if
condition|(
name|old_rv
condition|)
name|quiet
operator|=
literal|0
expr_stmt|;
else|else
name|quiet
operator|=
operator|(
name|vlist
operator|->
name|name
operator|!=
name|NULL
operator|)
expr_stmt|;
name|res
operator|=
name|doquerylist
argument_list|(
name|vlist
argument_list|,
name|op
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|associd
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No system%s variables returned\n"
argument_list|,
operator|(
name|type
operator|==
name|TYPE_CLOCK
operator|)
condition|?
literal|" clock"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No information returned for%s association %u\n"
argument_list|,
operator|(
name|type
operator|==
name|TYPE_CLOCK
operator|)
condition|?
literal|" clock"
else|:
literal|""
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%u "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|type
argument_list|,
name|quiet
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * readlist - send a read variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|readlist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HMS: I think we want the u_int32 target here, not the u_long */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|type
operator|=
operator|(
literal|0
operator|==
name|associd
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|dolist
argument_list|(
name|g_varlist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|type
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writelist - send a write variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|writelist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HMS: Do we really want uval here? */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|res
operator|=
name|doquerylist
argument_list|(
name|g_varlist
argument_list|,
name|CTL_OP_WRITEVAR
argument_list|,
name|associd
argument_list|,
literal|1
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"done! (no data returned)\n"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%u "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
operator|(
name|associd
operator|!=
literal|0
operator|)
condition|?
name|TYPE_PEER
else|:
name|TYPE_SYS
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * readvar - send a read variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|readvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|u_int
name|tmpcount
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ZERO
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>
literal|1
condition|)
block|{
name|tmpcount
operator|=
name|pcmd
operator|->
name|nargs
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|tmpcount
condition|;
name|u
operator|++
control|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
operator|+
name|u
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
operator|(
literal|0
operator|==
name|associd
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|dolist
argument_list|(
name|tmplist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|type
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writevar - send a write variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|writevar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ZERO
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|res
operator|=
name|doquerylist
argument_list|(
name|tmplist
argument_list|,
name|CTL_OP_WRITEVAR
argument_list|,
name|associd
argument_list|,
literal|1
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"done! (no data returned)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%u "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
literal|0
operator|==
name|associd
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * clocklist - send a clock variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|clocklist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|dolist
argument_list|(
name|g_varlist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|TYPE_CLOCK
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clockvar - send a clock variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|clockvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ZERO
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|2
condition|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|dolist
argument_list|(
name|tmplist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|TYPE_CLOCK
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * findassidrange - verify a range of association ID's  */
end_comment

begin_function
specifier|static
name|int
name|findassidrange
parameter_list|(
name|u_int32
name|assid1
parameter_list|,
name|u_int32
name|assid2
parameter_list|,
name|int
modifier|*
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|assids
index|[
literal|2
index|]
decl_stmt|;
name|int
name|ind
index|[
name|COUNTOF
argument_list|(
name|assids
argument_list|)
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|size_t
name|a
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|numassoc
condition|)
name|dogetassoc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assids
index|[
literal|0
index|]
operator|=
name|checkassocid
argument_list|(
name|assid1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|assids
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
name|assids
index|[
literal|1
index|]
operator|=
name|checkassocid
argument_list|(
name|assid2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|assids
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|COUNTOF
argument_list|(
name|assids
argument_list|)
condition|;
name|a
operator|++
control|)
block|{
name|ind
index|[
name|a
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
operator|==
name|assids
index|[
name|a
index|]
condition|)
name|ind
index|[
name|a
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|COUNTOF
argument_list|(
name|assids
argument_list|)
condition|;
name|a
operator|++
control|)
if|if
condition|(
operator|-
literal|1
operator|==
name|ind
index|[
name|a
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association ID %u not found in list\n"
argument_list|,
name|assids
index|[
name|a
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ind
index|[
literal|0
index|]
operator|<
name|ind
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|from
operator|=
name|ind
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|to
operator|=
name|ind
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|to
operator|=
name|ind
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|from
operator|=
name|ind
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * mreadlist - send a read variables request for multiple associations  */
end_comment

begin_function
specifier|static
name|void
name|mreadlist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
if|if
condition|(
operator|!
name|findassidrange
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|uval
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|fp
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|from
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolist
argument_list|(
name|g_varlist
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
condition|)
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * mreadvar - send a read variables request for multiple associations  */
end_comment

begin_function
specifier|static
name|void
name|mreadvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
name|struct
name|varlist
modifier|*
name|pvars
decl_stmt|;
if|if
condition|(
operator|!
name|findassidrange
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|uval
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|fp
argument_list|)
condition|)
return|return;
name|ZERO
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|3
condition|)
block|{
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|pvars
operator|=
name|tmplist
expr_stmt|;
block|}
else|else
block|{
name|pvars
operator|=
name|g_varlist
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dolist
argument_list|(
name|pvars
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|pvars
operator|==
name|tmplist
condition|)
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * dogetassoc - query the host for its list of associations  */
end_comment

begin_function
name|int
name|dogetassoc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
specifier|const
name|u_short
modifier|*
name|pus
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READSTAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No association ID's returned\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dsize
operator|&
literal|0x3
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returned %d octets, should be multiple of 4\n"
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|numassoc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|numassoc
operator|>=
name|assoc_cache_slots
condition|)
block|{
name|grow_assoc_cache
argument_list|()
expr_stmt|;
block|}
name|pus
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|datap
expr_stmt|;
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|assid
operator|=
name|ntohs
argument_list|(
operator|*
name|pus
argument_list|)
expr_stmt|;
name|datap
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|pus
argument_list|)
expr_stmt|;
name|pus
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|datap
expr_stmt|;
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|status
operator|=
name|ntohs
argument_list|(
operator|*
name|pus
argument_list|)
expr_stmt|;
name|datap
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|pus
argument_list|)
expr_stmt|;
name|dsize
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pus
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u] "
argument_list|,
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|assid
argument_list|)
expr_stmt|;
block|}
name|numassoc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%d associations total\n"
argument_list|,
name|numassoc
argument_list|)
expr_stmt|;
block|}
name|sortassoc
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * printassoc - print the current list of associations  */
end_comment

begin_function
specifier|static
name|void
name|printassoc
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_char
name|statval
decl_stmt|;
name|int
name|event
decl_stmt|;
name|u_long
name|event_count
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
specifier|const
name|char
modifier|*
name|reach
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth
decl_stmt|;
specifier|const
name|char
modifier|*
name|condition
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_event
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|numassoc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No association ID's in list\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Output a header 	 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nind assid status  conf reach auth condition  last_event cnt\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"===========================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
name|statval
operator|=
operator|(
name|u_char
operator|)
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|statval
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
name|event
operator|=
name|CTL_PEER_EVENT
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
name|event_count
operator|=
name|CTL_PEER_NEVNT
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_CONFIG
condition|)
name|conf
operator|=
literal|"yes"
expr_stmt|;
else|else
name|conf
operator|=
literal|"no"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_BCAST
condition|)
block|{
name|reach
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENABLE
condition|)
name|auth
operator|=
literal|"yes"
expr_stmt|;
else|else
name|auth
operator|=
literal|"none"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|statval
operator|&
name|CTL_PST_REACH
condition|)
name|reach
operator|=
literal|"yes"
expr_stmt|;
else|else
name|reach
operator|=
literal|"no"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENABLE
condition|)
block|{
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENTIC
condition|)
name|auth
operator|=
literal|"ok "
expr_stmt|;
else|else
name|auth
operator|=
literal|"bad"
expr_stmt|;
block|}
else|else
block|{
name|auth
operator|=
literal|"none"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pktversion
operator|>
name|NTP_OLDVERSION
condition|)
block|{
switch|switch
condition|(
name|statval
operator|&
literal|0x7
condition|)
block|{
case|case
name|CTL_PST_SEL_REJECT
case|:
name|condition
operator|=
literal|"reject"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SANE
case|:
name|condition
operator|=
literal|"falsetick"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_CORRECT
case|:
name|condition
operator|=
literal|"excess"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SELCAND
case|:
name|condition
operator|=
literal|"outlyer"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SYNCCAND
case|:
name|condition
operator|=
literal|"candidate"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_EXCESS
case|:
name|condition
operator|=
literal|"backup"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SYSPEER
case|:
name|condition
operator|=
literal|"sys.peer"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_PPS
case|:
name|condition
operator|=
literal|"pps.peer"
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|statval
operator|&
literal|0x3
condition|)
block|{
case|case
name|OLD_CTL_PST_SEL_REJECT
case|:
if|if
condition|(
operator|!
operator|(
name|statval
operator|&
name|OLD_CTL_PST_SANE
operator|)
condition|)
name|condition
operator|=
literal|"insane"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|statval
operator|&
name|OLD_CTL_PST_DISP
operator|)
condition|)
name|condition
operator|=
literal|"hi_disp"
expr_stmt|;
else|else
name|condition
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SELCAND
case|:
name|condition
operator|=
literal|"sel_cand"
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SYNCCAND
case|:
name|condition
operator|=
literal|"sync_cand"
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SYSPEER
case|:
name|condition
operator|=
literal|"sys_peer"
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|PEER_EVENT
operator||
name|event
condition|)
block|{
case|case
name|PEVNT_MOBIL
case|:
name|last_event
operator|=
literal|"mobilize"
expr_stmt|;
break|break;
case|case
name|PEVNT_DEMOBIL
case|:
name|last_event
operator|=
literal|"demobilize"
expr_stmt|;
break|break;
case|case
name|PEVNT_REACH
case|:
name|last_event
operator|=
literal|"reachable"
expr_stmt|;
break|break;
case|case
name|PEVNT_UNREACH
case|:
name|last_event
operator|=
literal|"unreachable"
expr_stmt|;
break|break;
case|case
name|PEVNT_RESTART
case|:
name|last_event
operator|=
literal|"restart"
expr_stmt|;
break|break;
case|case
name|PEVNT_REPLY
case|:
name|last_event
operator|=
literal|"no_reply"
expr_stmt|;
break|break;
case|case
name|PEVNT_RATE
case|:
name|last_event
operator|=
literal|"rate_exceeded"
expr_stmt|;
break|break;
case|case
name|PEVNT_DENY
case|:
name|last_event
operator|=
literal|"access_denied"
expr_stmt|;
break|break;
case|case
name|PEVNT_ARMED
case|:
name|last_event
operator|=
literal|"leap_armed"
expr_stmt|;
break|break;
case|case
name|PEVNT_NEWPEER
case|:
name|last_event
operator|=
literal|"sys_peer"
expr_stmt|;
break|break;
case|case
name|PEVNT_CLOCK
case|:
name|last_event
operator|=
literal|"clock_alarm"
expr_stmt|;
break|break;
default|default:
name|last_event
operator|=
literal|""
expr_stmt|;
break|break;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%3d %5u  %04x   %3.3s  %4s  %4.4s %9.9s %11s %2lu"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|,
name|conf
argument_list|,
name|reach
argument_list|,
name|auth
argument_list|,
name|condition
argument_list|,
name|last_event
argument_list|,
name|event_count
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|>
name|buf
operator|&&
literal|' '
operator|==
name|bp
index|[
operator|-
literal|1
index|]
condition|)
operator|--
name|bp
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * associations - get, record and print a list of associations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|associations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
name|printassoc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lassociations - get, record and print a long list of associations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lassociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
name|printassoc
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * passociations - print the association list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|passociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|printassoc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lpassociations - print the long association list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lpassociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|printassoc
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  saveconfig - dump ntp server configuration to server file  */
end_comment

begin_function
specifier|static
name|void
name|saveconfig
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|pcmd
operator|->
name|nargs
condition|)
return|return;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_SAVECONFIG
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|dsize
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(no response message, curiously)"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.*s"
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_comment
comment|/*  * radiostatus - print the radio status returned by the server  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|radiostatus
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READCLOCK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No radio status string returned\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|asciize
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/*  * when - print how long its been since his last packet arrived  */
end_comment

begin_function
specifier|static
name|long
name|when
parameter_list|(
name|l_fp
modifier|*
name|ts
parameter_list|,
name|l_fp
modifier|*
name|rec
parameter_list|,
name|l_fp
modifier|*
name|reftime
parameter_list|)
block|{
name|l_fp
modifier|*
name|lasttime
decl_stmt|;
if|if
condition|(
name|rec
operator|->
name|l_ui
operator|!=
literal|0
condition|)
name|lasttime
operator|=
name|rec
expr_stmt|;
elseif|else
if|if
condition|(
name|reftime
operator|->
name|l_ui
operator|!=
literal|0
condition|)
name|lasttime
operator|=
name|reftime
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
operator|(
name|ts
operator|->
name|l_ui
operator|-
name|lasttime
operator|->
name|l_ui
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pretty-print an interval into the given buffer, in a human-friendly format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|prettyinterval
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|cb
parameter_list|,
name|long
name|diff
parameter_list|)
block|{
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|diff
operator|<=
literal|2048
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ld"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|29
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|300
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ldm"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|29
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|96
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ldh"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|11
operator|)
operator|/
literal|24
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ldd"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|decodeaddrtype
parameter_list|(
name|sockaddr_u
modifier|*
name|sock
parameter_list|)
block|{
name|char
name|ch
init|=
literal|'-'
decl_stmt|;
name|u_int32
name|dummy
decl_stmt|;
switch|switch
condition|(
name|AF
argument_list|(
name|sock
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|dummy
operator|=
name|SRCADR
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|ch
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|dummy
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0xe0000000
operator|)
condition|?
literal|'m'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0x000000ff
operator|)
operator|==
literal|0x000000ff
operator|)
condition|?
literal|'b'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0x7f000001
operator|)
condition|?
literal|'l'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0xffffffe0
operator|)
operator|==
literal|0x00000000
operator|)
condition|?
literal|'-'
else|:
literal|'u'
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|PSOCK_ADDR6
argument_list|(
name|sock
argument_list|)
argument_list|)
condition|)
name|ch
operator|=
literal|'m'
expr_stmt|;
else|else
name|ch
operator|=
literal|'u'
expr_stmt|;
break|break;
default|default:
name|ch
operator|=
literal|'-'
expr_stmt|;
break|break;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * A list of variables required by the peers command  */
end_comment

begin_decl_stmt
name|struct
name|varlist
name|opeervarlist
index|[]
init|=
block|{
block|{
literal|"srcadr"
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|"dstadr"
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|"stratum"
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|"hpoll"
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|"ppoll"
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
literal|"reach"
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
literal|"delay"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"offset"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|"jitter"
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
literal|"dispersion"
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
literal|"rec"
block|,
literal|0
block|}
block|,
comment|/* 10 */
block|{
literal|"reftime"
block|,
literal|0
block|}
block|,
comment|/* 11 */
block|{
literal|"srcport"
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
literal|"hmode"
block|,
literal|0
block|}
block|,
comment|/* 13 */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|varlist
name|peervarlist
index|[]
init|=
block|{
block|{
literal|"srcadr"
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|"refid"
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|"stratum"
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|"hpoll"
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|"ppoll"
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
literal|"reach"
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
literal|"delay"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"offset"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|"jitter"
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
literal|"dispersion"
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
literal|"rec"
block|,
literal|0
block|}
block|,
comment|/* 10 */
block|{
literal|"reftime"
block|,
literal|0
block|}
block|,
comment|/* 11 */
block|{
literal|"srcport"
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
literal|"hmode"
block|,
literal|0
block|}
block|,
comment|/* 13 */
block|{
literal|"srchost"
block|,
literal|0
block|}
block|,
comment|/* 14 */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Decode an incoming data buffer and print a line in the peer list  */
end_comment

begin_function
specifier|static
name|int
name|doprintpeers
parameter_list|(
name|struct
name|varlist
modifier|*
name|pvl
parameter_list|,
name|int
name|associd
parameter_list|,
name|int
name|rstatus
parameter_list|,
name|int
name|datalen
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|have_srchost
decl_stmt|;
name|int
name|have_dstadr
decl_stmt|;
name|int
name|have_da_rid
decl_stmt|;
name|int
name|have_jitter
decl_stmt|;
name|sockaddr_u
name|srcadr
decl_stmt|;
name|sockaddr_u
name|dstadr
decl_stmt|;
name|sockaddr_u
name|dum_store
decl_stmt|;
name|sockaddr_u
name|refidadr
decl_stmt|;
name|long
name|hmode
init|=
literal|0
decl_stmt|;
name|u_long
name|srcport
init|=
literal|0
decl_stmt|;
name|u_int32
name|u32
decl_stmt|;
specifier|const
name|char
modifier|*
name|dstadr_refid
init|=
literal|"0.0.0.0"
decl_stmt|;
specifier|const
name|char
modifier|*
name|serverlocal
decl_stmt|;
name|size_t
name|drlen
decl_stmt|;
name|u_long
name|stratum
init|=
literal|0
decl_stmt|;
name|long
name|ppoll
init|=
literal|0
decl_stmt|;
name|long
name|hpoll
init|=
literal|0
decl_stmt|;
name|u_long
name|reach
init|=
literal|0
decl_stmt|;
name|l_fp
name|estoffset
decl_stmt|;
name|l_fp
name|estdelay
decl_stmt|;
name|l_fp
name|estjitter
decl_stmt|;
name|l_fp
name|estdisp
decl_stmt|;
name|l_fp
name|reftime
decl_stmt|;
name|l_fp
name|rec
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|u_long
name|poll_sec
decl_stmt|;
name|char
name|type
init|=
literal|'?'
decl_stmt|;
name|char
name|whenbuf
index|[
literal|8
index|]
decl_stmt|,
name|pollbuf
index|[
literal|8
index|]
decl_stmt|;
name|char
name|clock_name
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|have_srchost
operator|=
name|FALSE
expr_stmt|;
name|have_dstadr
operator|=
name|FALSE
expr_stmt|;
name|have_da_rid
operator|=
name|FALSE
expr_stmt|;
name|have_jitter
operator|=
name|FALSE
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|srcadr
argument_list|)
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|dstadr
argument_list|)
expr_stmt|;
name|clock_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ZERO
argument_list|(
name|estoffset
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|estdelay
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|estjitter
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|estdisp
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|datalen
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"srcadr"
argument_list|,
name|name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"peeradr"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|srcadr
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malformed %s=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"srchost"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|pvl
operator|==
name|peervarlist
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
literal|2
operator|<
name|len
operator|&&
operator|(
name|size_t
operator|)
name|len
operator|<
sizeof|sizeof
argument_list|(
name|clock_name
argument_list|)
condition|)
block|{
comment|/* strip quotes */
name|value
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|clock_name
argument_list|,
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|clock_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|have_srchost
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"dstadr"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|dum_store
argument_list|)
condition|)
block|{
name|type
operator|=
name|decodeaddrtype
argument_list|(
operator|&
name|dum_store
argument_list|)
expr_stmt|;
name|have_dstadr
operator|=
name|TRUE
expr_stmt|;
name|dstadr
operator|=
name|dum_store
expr_stmt|;
if|if
condition|(
name|pvl
operator|==
name|opeervarlist
condition|)
block|{
name|have_da_rid
operator|=
name|TRUE
expr_stmt|;
name|dstadr_refid
operator|=
name|trunc_left
argument_list|(
name|stoa
argument_list|(
operator|&
name|dstadr
argument_list|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"hmode"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|hmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"refid"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|pvl
operator|==
name|peervarlist
condition|)
block|{
name|have_da_rid
operator|=
name|TRUE
expr_stmt|;
name|drlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|drlen
condition|)
block|{
name|dstadr_refid
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drlen
operator|<=
literal|4
condition|)
block|{
name|ZERO
argument_list|(
name|u32
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|u32
argument_list|,
name|value
argument_list|,
name|drlen
argument_list|)
expr_stmt|;
name|dstadr_refid
operator|=
name|refid_str
argument_list|(
name|u32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|refidadr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SOCK_UNSPEC
argument_list|(
operator|&
name|refidadr
argument_list|)
condition|)
name|dstadr_refid
operator|=
literal|"0.0.0.0"
expr_stmt|;
elseif|else
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|refidadr
argument_list|)
condition|)
name|dstadr_refid
operator|=
name|refnumtoa
argument_list|(
operator|&
name|refidadr
argument_list|)
expr_stmt|;
else|else
name|dstadr_refid
operator|=
name|stoa
argument_list|(
operator|&
name|refidadr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|have_da_rid
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"stratum"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|stratum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"hpoll"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|hpoll
argument_list|)
operator|&&
name|hpoll
operator|<
literal|0
condition|)
name|hpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ppoll"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|ppoll
argument_list|)
operator|&&
name|ppoll
operator|<
literal|0
condition|)
name|ppoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"reach"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|reach
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"delay"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estdelay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"offset"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estoffset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"jitter"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|pvl
operator|==
name|peervarlist
operator|&&
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estjitter
argument_list|)
condition|)
name|have_jitter
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"rootdisp"
argument_list|,
name|name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"dispersion"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estdisp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"rec"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|rec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"srcport"
argument_list|,
name|name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"peerport"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|srcport
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"reftime"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|reftime
argument_list|)
condition|)
name|L_CLR
argument_list|(
operator|&
name|reftime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * hmode gives the best guidance for the t column.  If the response 	 * did not include hmode we'll use the old decodeaddrtype() result. 	 */
switch|switch
condition|(
name|hmode
condition|)
block|{
case|case
name|MODE_BCLIENT
case|:
comment|/* broadcastclient or multicastclient */
name|type
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|MODE_BROADCAST
case|:
comment|/* broadcast or multicast server */
if|if
condition|(
name|IS_MCAST
argument_list|(
operator|&
name|srcadr
argument_list|)
condition|)
name|type
operator|=
literal|'M'
expr_stmt|;
else|else
name|type
operator|=
literal|'B'
expr_stmt|;
break|break;
case|case
name|MODE_CLIENT
case|:
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|srcadr
argument_list|)
condition|)
name|type
operator|=
literal|'l'
expr_stmt|;
comment|/* local refclock*/
elseif|else
if|if
condition|(
name|SOCK_UNSPEC
argument_list|(
operator|&
name|srcadr
argument_list|)
condition|)
name|type
operator|=
literal|'p'
expr_stmt|;
comment|/* pool */
elseif|else
if|if
condition|(
name|IS_MCAST
argument_list|(
operator|&
name|srcadr
argument_list|)
condition|)
name|type
operator|=
literal|'a'
expr_stmt|;
comment|/* manycastclient */
else|else
name|type
operator|=
literal|'u'
expr_stmt|;
comment|/* unicast */
break|break;
case|case
name|MODE_ACTIVE
case|:
name|type
operator|=
literal|'s'
expr_stmt|;
comment|/* symmetric active */
break|break;
comment|/* configured */
case|case
name|MODE_PASSIVE
case|:
name|type
operator|=
literal|'S'
expr_stmt|;
comment|/* symmetric passive */
break|break;
comment|/* ephemeral */
block|}
comment|/* 	 * Got everything, format the line 	 */
name|poll_sec
operator|=
literal|1
operator|<<
name|min
argument_list|(
name|ppoll
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktversion
operator|>
name|NTP_OLDVERSION
condition|)
name|c
operator|=
name|flash3
index|[
name|CTL_PEER_STATVAL
argument_list|(
name|rstatus
argument_list|)
operator|&
literal|0x7
index|]
expr_stmt|;
else|else
name|c
operator|=
name|flash2
index|[
name|CTL_PEER_STATVAL
argument_list|(
name|rstatus
argument_list|)
operator|&
literal|0x3
index|]
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|peervarlist
operator|==
name|pvl
operator|&&
name|have_dstadr
condition|)
block|{
name|serverlocal
operator|=
name|nntohost_col
argument_list|(
operator|&
name|dstadr
argument_list|,
operator|(
name|size_t
operator|)
name|min
argument_list|(
name|LIB_BUFLENGTH
operator|-
literal|1
argument_list|,
name|maxhostlen
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currenthostisnum
condition|)
name|serverlocal
operator|=
name|trunc_left
argument_list|(
name|currenthost
argument_list|,
name|maxhostlen
argument_list|)
expr_stmt|;
else|else
name|serverlocal
operator|=
name|currenthost
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*s "
argument_list|,
operator|(
name|int
operator|)
name|maxhostlen
argument_list|,
name|serverlocal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AF_UNSPEC
operator|==
name|af
operator|||
name|AF
argument_list|(
operator|&
name|srcadr
argument_list|)
operator|==
name|af
condition|)
block|{
if|if
condition|(
operator|!
name|have_srchost
condition|)
name|strlcpy
argument_list|(
name|clock_name
argument_list|,
name|nntohost
argument_list|(
operator|&
name|srcadr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|clock_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wideremote
operator|&&
literal|15
operator|<
name|strlen
argument_list|(
name|clock_name
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c%s\n                 "
argument_list|,
name|c
argument_list|,
name|clock_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c%-15.15s "
argument_list|,
name|c
argument_list|,
name|clock_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_da_rid
condition|)
block|{
name|drlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|drlen
operator|=
name|strlen
argument_list|(
name|dstadr_refid
argument_list|)
expr_stmt|;
name|makeascii
argument_list|(
name|drlen
argument_list|,
name|dstadr_refid
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|drlen
operator|++
operator|<
literal|15
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %2ld %c %4.4s %4.4s  %3lo  %7.7s %8.7s %7.7s\n"
argument_list|,
name|stratum
argument_list|,
name|type
argument_list|,
name|prettyinterval
argument_list|(
name|whenbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|whenbuf
argument_list|)
argument_list|,
name|when
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|rec
argument_list|,
operator|&
name|reftime
argument_list|)
argument_list|)
argument_list|,
name|prettyinterval
argument_list|(
name|pollbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pollbuf
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|poll_sec
argument_list|)
argument_list|,
name|reach
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|estdelay
argument_list|,
literal|3
argument_list|)
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|estoffset
argument_list|,
literal|3
argument_list|)
argument_list|,
operator|(
name|have_jitter
operator|)
condition|?
name|lfptoms
argument_list|(
operator|&
name|estjitter
argument_list|,
literal|3
argument_list|)
else|:
name|lfptoms
argument_list|(
operator|&
name|estdisp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dogetpeers - given an association ID, read and print the spreadsheet  *		peer variables.  */
end_comment

begin_function
specifier|static
name|int
name|dogetpeers
parameter_list|(
name|struct
name|varlist
modifier|*
name|pvl
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|res
operator|=
name|doquerylist
argument_list|(
name|pvl
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Damn fuzzballs 	 */
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No information returned for association %u\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|doprintpeers
argument_list|(
name|pvl
argument_list|,
name|associd
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * peers - print a peer spreadsheet  */
end_comment

begin_function
specifier|static
name|void
name|dopeers
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|u_int
name|u
decl_stmt|;
name|char
name|fullname
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|sockaddr_u
name|netnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_or_num
decl_stmt|;
name|size_t
name|sl
decl_stmt|;
if|if
condition|(
operator|!
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|numhosts
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|getnetnum
argument_list|(
name|chosts
index|[
name|u
index|]
operator|.
name|name
argument_list|,
operator|&
name|netnum
argument_list|,
name|fullname
argument_list|,
name|af
argument_list|)
condition|)
block|{
name|name_or_num
operator|=
name|nntohost
argument_list|(
operator|&
name|netnum
argument_list|)
expr_stmt|;
name|sl
operator|=
name|strlen
argument_list|(
name|name_or_num
argument_list|)
expr_stmt|;
name|maxhostlen
operator|=
name|max
argument_list|(
name|maxhostlen
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s "
argument_list|,
operator|(
name|int
operator|)
name|maxhostlen
argument_list|,
operator|(
name|int
operator|)
name|maxhostlen
argument_list|,
literal|"server (local)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"     remote           refid      st t when poll reach   delay   offset  jitter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|maxhostlen
condition|;
name|u
operator|++
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|numassoc
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|u
index|]
operator|.
name|status
argument_list|)
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"eliding [%d]\n"
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|u
index|]
operator|.
name|assid
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|dogetpeers
argument_list|(
name|peervarlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|u
index|]
operator|.
name|assid
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
condition|)
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * peers - print a peer spreadsheet  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|peers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|dopeers
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lpeers - print a peer spreadsheet including all fuzzball peers  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lpeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|dopeers
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * opeers - print a peer spreadsheet  */
end_comment

begin_function
specifier|static
name|void
name|doopeers
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|char
name|fullname
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|sockaddr_u
name|netnum
decl_stmt|;
if|if
condition|(
operator|!
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numhosts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|getnetnum
argument_list|(
name|chosts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|netnum
argument_list|,
name|fullname
argument_list|,
name|af
argument_list|)
condition|)
if|if
condition|(
name|strlen
argument_list|(
name|fullname
argument_list|)
operator|>
name|maxhostlen
condition|)
name|maxhostlen
operator|=
name|strlen
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s "
argument_list|,
operator|(
name|int
operator|)
name|maxhostlen
argument_list|,
operator|(
name|int
operator|)
name|maxhostlen
argument_list|,
literal|"server"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"     remote           local      st t when poll reach   delay   offset    disp\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxhostlen
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dogetpeers
argument_list|(
name|opeervarlist
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
condition|)
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * opeers - print a peer spreadsheet the old way  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|opeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|doopeers
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lopeers - print a peer spreadsheet including all fuzzball peers  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lopeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|doopeers
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * config - send a configuration command to a remote host  */
end_comment

begin_function
specifier|static
name|void
name|config
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cfgcmd
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|char
modifier|*
name|resp
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cfgcmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In Config\n"
literal|"Keyword = %s\n"
literal|"Command = %s\n"
argument_list|,
name|pcmd
operator|->
name|keyword
argument_list|,
name|cfgcmd
argument_list|)
expr_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_CONFIGURE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|cfgcmd
argument_list|)
argument_list|,
name|cfgcmd
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|rsize
operator|>
literal|0
operator|&&
literal|'\n'
operator|==
name|rdata
index|[
name|rsize
operator|-
literal|1
index|]
condition|)
name|rsize
operator|--
expr_stmt|;
name|resp
operator|=
name|emalloc
argument_list|(
name|rsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|resp
argument_list|,
name|rdata
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|resp
index|[
name|rsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|col
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|resp
argument_list|,
literal|"column %d syntax error"
argument_list|,
operator|&
name|col
argument_list|)
operator|&&
name|col
operator|>=
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|col
operator|<=
name|strlen
argument_list|(
name|cfgcmd
argument_list|)
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
block|{
name|printf
argument_list|(
literal|"______"
argument_list|)
expr_stmt|;
comment|/* "ntpq> " */
name|printf
argument_list|(
literal|"________"
argument_list|)
expr_stmt|;
comment|/* ":config " */
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cfgcmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|col
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"^\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * config_from_file - remotely configure an ntpd daemon using the  * specified configuration file  * SK: This function is a kludge at best and is full of bad design  * bugs:  * 1. ntpq uses UDP, which means that there is no guarantee of in-order,  *    error-free delivery.   * 2. The maximum length of a packet is constrained, and as a result, the  *    maximum length of a line in a configuration file is constrained.   *    Longer lines will lead to unpredictable results.  * 3. Since this function is sending a line at a time, we can't update  *    the control key through the configuration file (YUCK!!)  */
end_comment

begin_function
specifier|static
name|void
name|config_from_file
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|int
name|res
decl_stmt|;
name|FILE
modifier|*
name|config_fd
decl_stmt|;
name|char
name|config_cmd
index|[
name|MAXLINE
index|]
decl_stmt|;
name|size_t
name|config_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retry_limit
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In Config\n"
literal|"Keyword = %s\n"
literal|"Filename = %s\n"
argument_list|,
name|pcmd
operator|->
name|keyword
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|config_fd
operator|=
name|fopen
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|config_fd
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR!! Couldn't open file: %s\n"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Sending configuration file, one line at a time.\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|config_cmd
argument_list|,
name|MAXLINE
argument_list|,
name|config_fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|config_len
operator|=
name|strlen
argument_list|(
name|config_cmd
argument_list|)
expr_stmt|;
comment|/* ensure even the last line has newline, if possible */
if|if
condition|(
name|config_len
operator|>
literal|0
operator|&&
name|config_len
operator|+
literal|2
operator|<
sizeof|sizeof
argument_list|(
name|config_cmd
argument_list|)
operator|&&
literal|'\n'
operator|!=
name|config_cmd
index|[
name|config_len
operator|-
literal|1
index|]
condition|)
name|config_cmd
index|[
name|config_len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|retry_limit
operator|=
literal|2
expr_stmt|;
do|do
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_CONFIGURE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|config_cmd
argument_list|)
argument_list|,
name|config_cmd
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
do|while
condition|(
name|res
operator|!=
literal|0
operator|&&
name|retry_limit
operator|--
condition|)
do|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Line No: %d query failed: %s"
argument_list|,
name|i
argument_list|,
name|config_cmd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Subsequent lines not sent.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|config_fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rsize
operator|>
literal|0
operator|&&
literal|'\n'
operator|==
name|rdata
index|[
name|rsize
operator|-
literal|1
index|]
condition|)
name|rsize
operator|--
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
literal|0
operator|&&
literal|'\r'
operator|==
name|rdata
index|[
name|rsize
operator|-
literal|1
index|]
condition|)
name|rsize
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"Line No: %d %.*s: %s"
argument_list|,
name|i
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|config_cmd
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Done sending file\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|config_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fetch_nonce
parameter_list|(
name|char
modifier|*
name|nonce
parameter_list|,
name|size_t
name|cb_nonce
parameter_list|)
block|{
specifier|const
name|char
name|nonce_eq
index|[]
init|=
literal|"nonce="
decl_stmt|;
name|int
name|qres
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|int
name|chars
decl_stmt|;
comment|/* 	 * Retrieve a nonce specific to this client to demonstrate to 	 * ntpd that we're capable of receiving responses to our source 	 * IP address, and thereby unlikely to be forging the source. 	 */
name|qres
operator|=
name|doquery
argument_list|(
name|CTL_OP_REQ_NONCE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|qres
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nonce request failed\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|rsize
operator|<=
sizeof|sizeof
argument_list|(
name|nonce_eq
argument_list|)
operator|-
literal|1
operator|||
name|strncmp
argument_list|(
name|rdata
argument_list|,
name|nonce_eq
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce_eq
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected nonce response format: %.*s\n"
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|chars
operator|=
name|rsize
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|nonce_eq
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|chars
operator|>=
operator|(
name|int
operator|)
name|cb_nonce
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|nonce
argument_list|,
name|rdata
operator|+
sizeof|sizeof
argument_list|(
name|nonce_eq
argument_list|)
operator|-
literal|1
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|nonce
index|[
name|chars
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|chars
operator|>
literal|0
operator|&&
operator|(
literal|'\r'
operator|==
name|nonce
index|[
name|chars
operator|-
literal|1
index|]
operator|||
literal|'\n'
operator|==
name|nonce
index|[
name|chars
operator|-
literal|1
index|]
operator|)
condition|)
block|{
name|chars
operator|--
expr_stmt|;
name|nonce
index|[
name|chars
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * add_mru	Add and entry to mru list, hash table, and allocate  *		and return a replacement.  *		This is a helper for collect_mru_list().  */
end_comment

begin_function
specifier|static
name|mru
modifier|*
name|add_mru
parameter_list|(
name|mru
modifier|*
name|add
parameter_list|)
block|{
name|u_short
name|hash
decl_stmt|;
name|mru
modifier|*
name|mon
decl_stmt|;
name|mru
modifier|*
name|unlinked
decl_stmt|;
name|hash
operator|=
name|NTP_HASH_ADDR
argument_list|(
operator|&
name|add
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* see if we have it among previously received entries */
for|for
control|(
name|mon
operator|=
name|hash_table
index|[
name|hash
index|]
init|;
name|mon
operator|!=
name|NULL
condition|;
name|mon
operator|=
name|mon
operator|->
name|hlink
control|)
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|mon
operator|->
name|addr
argument_list|,
operator|&
name|add
operator|->
name|addr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|mon
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISGEQ
argument_list|(
operator|&
name|add
operator|->
name|first
argument_list|,
operator|&
name|mon
operator|->
name|first
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add_mru duplicate %s new first ts %08x.%08x precedes prior %08x.%08x\n"
argument_list|,
name|sptoa
argument_list|(
operator|&
name|add
operator|->
name|addr
argument_list|)
argument_list|,
name|add
operator|->
name|last
operator|.
name|l_ui
argument_list|,
name|add
operator|->
name|last
operator|.
name|l_uf
argument_list|,
name|mon
operator|->
name|last
operator|.
name|l_ui
argument_list|,
name|mon
operator|->
name|last
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|UNLINK_DLIST
argument_list|(
name|mon
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
name|hash_table
index|[
name|hash
index|]
argument_list|,
name|mon
argument_list|,
name|hlink
argument_list|,
name|mru
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|unlinked
operator|==
name|mon
argument_list|)
expr_stmt|;
name|mru_dupes
operator|++
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"(updated from %08x.%08x) "
operator|,
name|mon
operator|->
name|last
operator|.
name|l_ui
operator|,
name|mon
operator|->
name|last
operator|.
name|l_uf
operator|)
argument_list|)
expr_stmt|;
block|}
name|LINK_DLIST
argument_list|(
name|mru_list
argument_list|,
name|add
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|hash_table
index|[
name|hash
index|]
argument_list|,
name|add
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"add_mru %08x.%08x c %d m %d v %d rest %x first %08x.%08x %s\n"
operator|,
name|add
operator|->
name|last
operator|.
name|l_ui
operator|,
name|add
operator|->
name|last
operator|.
name|l_uf
operator|,
name|add
operator|->
name|count
operator|,
operator|(
name|int
operator|)
name|add
operator|->
name|mode
operator|,
operator|(
name|int
operator|)
name|add
operator|->
name|ver
operator|,
operator|(
name|u_int
operator|)
name|add
operator|->
name|rs
operator|,
name|add
operator|->
name|first
operator|.
name|l_ui
operator|,
name|add
operator|->
name|first
operator|.
name|l_uf
operator|,
name|sptoa
argument_list|(
operator|&
name|add
operator|->
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* if we didn't update an existing entry, alloc replacement */
if|if
condition|(
name|NULL
operator|==
name|mon
condition|)
block|{
name|mon
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mon
argument_list|)
argument_list|)
expr_stmt|;
name|mru_count
operator|++
expr_stmt|;
block|}
name|ZERO
argument_list|(
operator|*
name|mon
argument_list|)
expr_stmt|;
return|return
name|mon
return|;
block|}
end_function

begin_comment
comment|/* MGOT macro is specific to collect_mru_list() */
end_comment

begin_define
define|#
directive|define
name|MGOT
parameter_list|(
name|bit
parameter_list|)
define|\
value|do {					\ 		got |= (bit);			\ 		if (MRU_GOT_ALL == got) {	\ 			got = 0;		\ 			mon = add_mru(mon);	\ 			ci++;			\ 		}				\ 	} while (0)
end_define

begin_function
name|void
name|mrulist_ctrl_c_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|mrulist_interrupted
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_mru_list
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|,
name|l_fp
modifier|*
name|pnow
parameter_list|)
block|{
specifier|const
name|u_int
name|sleep_msecs
init|=
literal|5
decl_stmt|;
specifier|static
name|int
name|ntpd_row_limit
init|=
name|MRU_ROW_LIMIT
decl_stmt|;
name|int
name|c_mru_l_rc
decl_stmt|;
comment|/* this function's return code */
name|u_char
name|got
decl_stmt|;
comment|/* MRU_GOT_* bits */
name|time_t
name|next_report
decl_stmt|;
name|size_t
name|cb
decl_stmt|;
name|mru
modifier|*
name|mon
decl_stmt|;
name|mru
modifier|*
name|head
decl_stmt|;
name|mru
modifier|*
name|recent
decl_stmt|;
name|int
name|list_complete
decl_stmt|;
name|char
name|nonce
index|[
literal|128
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
name|req_buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|req
decl_stmt|;
name|char
modifier|*
name|req_end
decl_stmt|;
name|int
name|chars
decl_stmt|;
name|int
name|qres
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|cap_frags
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|si
decl_stmt|;
comment|/* server index in response */
name|int
name|ci
decl_stmt|;
comment|/* client (our) index for validation */
name|int
name|ri
decl_stmt|;
comment|/* request index (.# suffix) */
name|int
name|mv
decl_stmt|;
name|l_fp
name|newest
decl_stmt|;
name|l_fp
name|last_older
decl_stmt|;
name|sockaddr_u
name|addr_older
decl_stmt|;
name|int
name|have_now
decl_stmt|;
name|int
name|have_addr_older
decl_stmt|;
name|int
name|have_last_older
decl_stmt|;
name|u_int
name|restarted_count
decl_stmt|;
name|u_int
name|nonce_uses
decl_stmt|;
name|u_short
name|hash
decl_stmt|;
name|mru
modifier|*
name|unlinked
decl_stmt|;
if|if
condition|(
operator|!
name|fetch_nonce
argument_list|(
name|nonce
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|nonce_uses
operator|=
literal|0
expr_stmt|;
name|restarted_count
operator|=
literal|0
expr_stmt|;
name|mru_count
operator|=
literal|0
expr_stmt|;
name|INIT_DLIST
argument_list|(
name|mru_list
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|cb
operator|=
name|NTP_HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hash_table
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|NULL
operator|==
name|hash_table
argument_list|)
expr_stmt|;
name|hash_table
operator|=
name|emalloc_zero
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|c_mru_l_rc
operator|=
name|FALSE
expr_stmt|;
name|list_complete
operator|=
name|FALSE
expr_stmt|;
name|have_now
operator|=
name|FALSE
expr_stmt|;
name|cap_frags
operator|=
name|TRUE
expr_stmt|;
name|got
operator|=
literal|0
expr_stmt|;
name|ri
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mon
argument_list|)
expr_stmt|;
name|mon
operator|=
name|emalloc_zero
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|pnow
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|last_older
argument_list|)
expr_stmt|;
name|mrulist_interrupted
operator|=
name|FALSE
expr_stmt|;
name|set_ctrl_c_hook
argument_list|(
operator|&
name|mrulist_ctrl_c_hook
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ctrl-C will stop MRU retrieval and display partial results.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|next_report
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|MRU_REPORT_SECS
expr_stmt|;
name|limit
operator|=
name|min
argument_list|(
literal|3
operator|*
name|MAXFRAGS
argument_list|,
name|ntpd_row_limit
argument_list|)
expr_stmt|;
name|frags
operator|=
name|MAXFRAGS
expr_stmt|;
name|snprintf
argument_list|(
name|req_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|req_buf
argument_list|)
argument_list|,
literal|"nonce=%s, frags=%d%s"
argument_list|,
name|nonce
argument_list|,
name|frags
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|nonce_uses
operator|++
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"READ_MRU parms: %s\n"
argument_list|,
name|req_buf
argument_list|)
expr_stmt|;
name|qres
operator|=
name|doqueryex
argument_list|(
name|CTL_OP_READ_MRU
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|req_buf
argument_list|)
argument_list|,
name|req_buf
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CERR_UNKNOWNVAR
operator|==
name|qres
operator|&&
name|ri
operator|>
literal|0
condition|)
block|{
comment|/* 			 * None of the supplied prior entries match, so 			 * toss them from our list and try again. 			 */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no overlap between %d prior entries and server MRU list\n"
argument_list|,
name|ri
argument_list|)
expr_stmt|;
while|while
condition|(
name|ri
operator|--
condition|)
block|{
name|recent
operator|=
name|HEAD_DLIST
argument_list|(
name|mru_list
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|recent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tossing prior entry %s to resync\n"
argument_list|,
name|sptoa
argument_list|(
operator|&
name|recent
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|UNLINK_DLIST
argument_list|(
name|recent
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|hash
operator|=
name|NTP_HASH_ADDR
argument_list|(
operator|&
name|recent
operator|->
name|addr
argument_list|)
expr_stmt|;
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
name|hash_table
index|[
name|hash
index|]
argument_list|,
name|recent
argument_list|,
name|hlink
argument_list|,
name|mru
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|unlinked
operator|==
name|recent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|recent
argument_list|)
expr_stmt|;
name|mru_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|HEAD_DLIST
argument_list|(
name|mru_list
argument_list|,
name|mlink
argument_list|)
condition|)
block|{
name|restarted_count
operator|++
expr_stmt|;
if|if
condition|(
name|restarted_count
operator|>
literal|8
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Giving up after 8 restarts from the beginning.\n"
literal|"With high-traffic NTP servers, this can occur if the\n"
literal|"MRU list is limited to less than about 16 seconds' of\n"
literal|"entries.  See the 'mru' ntp.conf directive to adjust.\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--->   Restarting from the beginning, retry #%u\n"
argument_list|,
name|restarted_count
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CERR_UNKNOWNVAR
operator|==
name|qres
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CERR_UNKNOWNVAR from ntpd but no priors given.\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
elseif|else
if|if
condition|(
name|CERR_BADVALUE
operator|==
name|qres
condition|)
block|{
if|if
condition|(
name|cap_frags
condition|)
block|{
name|cap_frags
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reverted to row limit from fragments limit.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ntpd has lower cap on row limit */
name|ntpd_row_limit
operator|--
expr_stmt|;
name|limit
operator|=
name|min
argument_list|(
name|limit
argument_list|,
name|ntpd_row_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Row limit reduced to %d following CERR_BADVALUE.\n"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ERR_INCOMPLETE
operator|==
name|qres
operator|||
name|ERR_TIMEOUT
operator|==
name|qres
condition|)
block|{
comment|/* 			 * Reduce the number of rows/frags requested by 			 * half to recover from lost response fragments. 			 */
if|if
condition|(
name|cap_frags
condition|)
block|{
name|frags
operator|=
name|max
argument_list|(
literal|2
argument_list|,
name|frags
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Frag limit reduced to %d following incomplete response.\n"
argument_list|,
name|frags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|limit
operator|=
name|max
argument_list|(
literal|2
argument_list|,
name|limit
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Row limit reduced to %d following incomplete response.\n"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qres
condition|)
block|{
name|show_error_msg
argument_list|(
name|qres
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
comment|/* 		 * This is a cheap cop-out implementation of rawmode 		 * output for mrulist.  A better approach would be to 		 * dump similar output after the list is collected by 		 * ntpq with a continuous sequence of indexes.  This 		 * cheap approach has indexes resetting to zero for 		 * each query/response, and duplicates are not  		 * coalesced. 		 */
if|if
condition|(
operator|!
name|qres
operator|&&
name|rawmode
condition|)
name|printvars
argument_list|(
name|rsize
argument_list|,
name|rdata
argument_list|,
name|rstatus
argument_list|,
name|TYPE_SYS
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ci
operator|=
literal|0
expr_stmt|;
name|have_addr_older
operator|=
name|FALSE
expr_stmt|;
name|have_last_older
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|qres
operator|&&
name|nextvar
argument_list|(
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextvar gave: %s = %s\n"
argument_list|,
name|tag
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"addr.older"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|have_last_older
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"addr.older %s before last.older\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|addr_older
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"addr.older %s garbled\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
name|hash
operator|=
name|NTP_HASH_ADDR
argument_list|(
operator|&
name|addr_older
argument_list|)
expr_stmt|;
for|for
control|(
name|recent
operator|=
name|hash_table
index|[
name|hash
index|]
init|;
name|recent
operator|!=
name|NULL
condition|;
name|recent
operator|=
name|recent
operator|->
name|hlink
control|)
if|if
condition|(
name|ADDR_PORT_EQ
argument_list|(
operator|&
name|addr_older
argument_list|,
operator|&
name|recent
operator|->
name|addr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|recent
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"addr.older %s not in hash table\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|last_older
argument_list|,
operator|&
name|recent
operator|->
name|last
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last.older %08x.%08x mismatches %08x.%08x expected.\n"
argument_list|,
name|last_older
operator|.
name|l_ui
argument_list|,
name|last_older
operator|.
name|l_uf
argument_list|,
name|recent
operator|->
name|last
operator|.
name|l_ui
argument_list|,
name|recent
operator|->
name|last
operator|.
name|l_uf
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
name|have_addr_older
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|tag
argument_list|,
literal|"addr.%d"
argument_list|,
operator|&
name|si
argument_list|)
operator|||
name|si
operator|!=
name|ci
condition|)
goto|goto
name|nomatch
goto|;
elseif|else
if|if
condition|(
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|mon
operator|->
name|addr
argument_list|)
condition|)
name|MGOT
argument_list|(
name|MRU_GOT_ADDR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"last.older"
argument_list|)
condition|)
block|{
if|if
condition|(
literal|'0'
operator|!=
name|val
index|[
literal|0
index|]
operator|||
literal|'x'
operator|!=
name|val
index|[
literal|1
index|]
operator|||
operator|!
name|hextolfp
argument_list|(
name|val
operator|+
literal|2
argument_list|,
operator|&
name|last_older
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last.older %s garbled\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
name|have_last_older
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"last.newest"
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|got
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last.newest %s before complete row, got = 0x%x\n"
argument_list|,
name|val
argument_list|,
operator|(
name|u_int
operator|)
name|got
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
if|if
condition|(
operator|!
name|have_now
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last.newest %s before now=\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
name|head
operator|=
name|HEAD_DLIST
argument_list|(
name|mru_list
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|head
condition|)
block|{
if|if
condition|(
literal|'0'
operator|!=
name|val
index|[
literal|0
index|]
operator|||
literal|'x'
operator|!=
name|val
index|[
literal|1
index|]
operator|||
operator|!
name|hextolfp
argument_list|(
name|val
operator|+
literal|2
argument_list|,
operator|&
name|newest
argument_list|)
operator|||
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|newest
argument_list|,
operator|&
name|head
operator|->
name|last
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last.newest %s mismatches %08x.%08x"
argument_list|,
name|val
argument_list|,
name|head
operator|->
name|last
operator|.
name|l_ui
argument_list|,
name|head
operator|->
name|last
operator|.
name|l_uf
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
block|}
name|list_complete
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|tag
argument_list|,
literal|"last.%d"
argument_list|,
operator|&
name|si
argument_list|)
operator|||
name|si
operator|!=
name|ci
operator|||
literal|'0'
operator|!=
name|val
index|[
literal|0
index|]
operator|||
literal|'x'
operator|!=
name|val
index|[
literal|1
index|]
operator|||
operator|!
name|hextolfp
argument_list|(
name|val
operator|+
literal|2
argument_list|,
operator|&
name|mon
operator|->
name|last
argument_list|)
condition|)
block|{
goto|goto
name|nomatch
goto|;
block|}
else|else
block|{
name|MGOT
argument_list|(
name|MRU_GOT_LAST
argument_list|)
expr_stmt|;
comment|/* 					 * allow interrupted retrieval, 					 * using most recent retrieved 					 * entry's last seen timestamp 					 * as the end of operation. 					 */
operator|*
name|pnow
operator|=
name|mon
operator|->
name|last
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|tag
argument_list|,
literal|"first.%d"
argument_list|,
operator|&
name|si
argument_list|)
operator|||
name|si
operator|!=
name|ci
operator|||
literal|'0'
operator|!=
name|val
index|[
literal|0
index|]
operator|||
literal|'x'
operator|!=
name|val
index|[
literal|1
index|]
operator|||
operator|!
name|hextolfp
argument_list|(
name|val
operator|+
literal|2
argument_list|,
operator|&
name|mon
operator|->
name|first
argument_list|)
condition|)
goto|goto
name|nomatch
goto|;
name|MGOT
argument_list|(
name|MRU_GOT_FIRST
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"nonce"
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|nonce
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce
argument_list|)
argument_list|)
expr_stmt|;
name|nonce_uses
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* case */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"now"
argument_list|)
operator|||
literal|'0'
operator|!=
name|val
index|[
literal|0
index|]
operator|||
literal|'x'
operator|!=
name|val
index|[
literal|1
index|]
operator|||
operator|!
name|hextolfp
argument_list|(
name|val
operator|+
literal|2
argument_list|,
name|pnow
argument_list|)
condition|)
goto|goto
name|nomatch
goto|;
name|have_now
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|tag
argument_list|,
literal|"ct.%d"
argument_list|,
operator|&
name|si
argument_list|)
operator|||
name|si
operator|!=
name|ci
operator|||
literal|1
operator|!=
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mon
operator|->
name|count
argument_list|)
operator|||
name|mon
operator|->
name|count
operator|<
literal|1
condition|)
goto|goto
name|nomatch
goto|;
name|MGOT
argument_list|(
name|MRU_GOT_COUNT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|tag
argument_list|,
literal|"mv.%d"
argument_list|,
operator|&
name|si
argument_list|)
operator|||
name|si
operator|!=
name|ci
operator|||
literal|1
operator|!=
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mv
argument_list|)
condition|)
goto|goto
name|nomatch
goto|;
name|mon
operator|->
name|mode
operator|=
name|PKT_MODE
argument_list|(
name|mv
argument_list|)
expr_stmt|;
name|mon
operator|->
name|ver
operator|=
name|PKT_VERSION
argument_list|(
name|mv
argument_list|)
expr_stmt|;
name|MGOT
argument_list|(
name|MRU_GOT_MV
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|tag
argument_list|,
literal|"rs.%d"
argument_list|,
operator|&
name|si
argument_list|)
operator|||
name|si
operator|!=
name|ci
operator|||
literal|1
operator|!=
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"0x%hx"
argument_list|,
operator|&
name|mon
operator|->
name|rs
argument_list|)
condition|)
goto|goto
name|nomatch
goto|;
name|MGOT
argument_list|(
name|MRU_GOT_RS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nomatch
label|:
comment|/* empty stmt */
empty_stmt|;
comment|/* ignore unknown tags */
block|}
block|}
if|if
condition|(
name|have_now
condition|)
name|list_complete
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|list_complete
condition|)
block|{
name|NTP_INSIST
argument_list|(
literal|0
operator|==
name|ri
operator|||
name|have_addr_older
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mrulist_interrupted
condition|)
block|{
name|printf
argument_list|(
literal|"mrulist retrieval interrupted by operator.\n"
literal|"Displaying partial client list.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list_complete
operator|||
name|mrulist_interrupted
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\rRetrieved %u unique MRU entries and %u updates.\n"
argument_list|,
name|mru_count
argument_list|,
name|mru_dupes
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|>=
name|next_report
condition|)
block|{
name|next_report
operator|+=
name|MRU_REPORT_SECS
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r%u (%u updates) "
argument_list|,
name|mru_count
argument_list|,
name|mru_dupes
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Snooze for a bit between queries to let ntpd catch 		 * up with other duties. 		 */
ifdef|#
directive|ifdef
name|SYS_WINNT
name|Sleep
argument_list|(
name|sleep_msecs
argument_list|)
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|HAVE_NANOSLEEP
argument_list|)
name|sleep
argument_list|(
operator|(
name|sleep_msecs
operator|/
literal|1000
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|timespec
name|interv
init|=
block|{
literal|0
block|,
literal|1000
operator|*
name|sleep_msecs
block|}
decl_stmt|;
name|nanosleep
argument_list|(
operator|&
name|interv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If there were no errors, increase the number of rows 		 * to a maximum of 3 * MAXFRAGS (the most packets ntpq 		 * can handle in one response), on the assumption that 		 * no less than 3 rows fit in each packet, capped at  		 * our best guess at the server's row limit. 		 */
if|if
condition|(
operator|!
name|qres
condition|)
block|{
if|if
condition|(
name|cap_frags
condition|)
block|{
name|frags
operator|=
name|min
argument_list|(
name|MAXFRAGS
argument_list|,
name|frags
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|limit
operator|=
name|min3
argument_list|(
literal|3
operator|*
name|MAXFRAGS
argument_list|,
name|ntpd_row_limit
argument_list|,
name|max
argument_list|(
name|limit
operator|+
literal|1
argument_list|,
name|limit
operator|*
literal|33
operator|/
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * prepare next query with as many address and last-seen 		 * timestamps as will fit in a single packet. 		 */
name|req
operator|=
name|req_buf
expr_stmt|;
name|req_end
operator|=
name|req_buf
operator|+
sizeof|sizeof
argument_list|(
name|req_buf
argument_list|)
expr_stmt|;
define|#
directive|define
name|REQ_ROOM
value|(req_end - req)
name|snprintf
argument_list|(
name|req
argument_list|,
name|REQ_ROOM
argument_list|,
literal|"nonce=%s, %s=%d%s"
argument_list|,
name|nonce
argument_list|,
operator|(
name|cap_frags
operator|)
condition|?
literal|"frags"
else|:
literal|"limit"
argument_list|,
operator|(
name|cap_frags
operator|)
condition|?
name|frags
else|:
name|limit
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|req
operator|+=
name|strlen
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|nonce_uses
operator|++
expr_stmt|;
if|if
condition|(
name|nonce_uses
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|fetch_nonce
argument_list|(
name|nonce
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce
argument_list|)
argument_list|)
condition|)
goto|goto
name|cleanup_return
goto|;
name|nonce_uses
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|ri
operator|=
literal|0
operator|,
name|recent
operator|=
name|HEAD_DLIST
argument_list|(
name|mru_list
argument_list|,
name|mlink
argument_list|)
init|;
name|recent
operator|!=
name|NULL
condition|;
name|ri
operator|++
operator|,
name|recent
operator|=
name|NEXT_DLIST
argument_list|(
name|mru_list
argument_list|,
name|recent
argument_list|,
name|mlink
argument_list|)
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", addr.%d=%s, last.%d=0x%08x.%08x"
argument_list|,
name|ri
argument_list|,
name|sptoa
argument_list|(
operator|&
name|recent
operator|->
name|addr
argument_list|)
argument_list|,
name|ri
argument_list|,
name|recent
operator|->
name|last
operator|.
name|l_ui
argument_list|,
name|recent
operator|->
name|last
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|chars
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|REQ_ROOM
operator|-
name|chars
operator|<
literal|1
condition|)
break|break;
name|memcpy
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|chars
operator|+
literal|1
argument_list|)
expr_stmt|;
name|req
operator|+=
name|chars
expr_stmt|;
block|}
block|}
name|set_ctrl_c_hook
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|c_mru_l_rc
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retain_hash_table
goto|;
name|cleanup_return
label|:
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
name|hash_table
operator|=
name|NULL
expr_stmt|;
name|retain_hash_table
label|:
if|if
condition|(
name|mon
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mon
argument_list|)
expr_stmt|;
return|return
name|c_mru_l_rc
return|;
block|}
end_function

begin_comment
comment|/*  * qcmp_mru_addr - sort MRU entries by remote address.  *  * All IPv4 addresses sort before any IPv6, addresses are sorted by  * value within address family.  */
end_comment

begin_function
specifier|static
name|int
name|qcmp_mru_addr
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|mru
modifier|*
specifier|const
modifier|*
name|ppm1
init|=
name|v1
decl_stmt|;
specifier|const
name|mru
modifier|*
specifier|const
modifier|*
name|ppm2
init|=
name|v2
decl_stmt|;
specifier|const
name|mru
modifier|*
name|pm1
decl_stmt|;
specifier|const
name|mru
modifier|*
name|pm2
decl_stmt|;
name|u_short
name|af1
decl_stmt|;
name|u_short
name|af2
decl_stmt|;
name|size_t
name|cmplen
decl_stmt|;
name|size_t
name|addr_off
decl_stmt|;
name|pm1
operator|=
operator|*
name|ppm1
expr_stmt|;
name|pm2
operator|=
operator|*
name|ppm2
expr_stmt|;
name|af1
operator|=
name|AF
argument_list|(
operator|&
name|pm1
operator|->
name|addr
argument_list|)
expr_stmt|;
name|af2
operator|=
name|AF
argument_list|(
operator|&
name|pm2
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|af1
operator|!=
name|af2
condition|)
return|return
operator|(
name|AF_INET
operator|==
name|af1
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
name|cmplen
operator|=
name|SIZEOF_INADDR
argument_list|(
name|af1
argument_list|)
expr_stmt|;
name|addr_off
operator|=
operator|(
name|AF_INET
operator|==
name|af1
operator|)
condition|?
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
else|:
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
expr_stmt|;
return|return
name|memcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|pm1
operator|->
name|addr
operator|+
name|addr_off
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|pm2
operator|->
name|addr
operator|+
name|addr_off
argument_list|,
name|cmplen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qcmp_mru_r_addr
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
return|return
operator|-
name|qcmp_mru_addr
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * qcmp_mru_count - sort MRU entries by times seen (hit count).  */
end_comment

begin_function
specifier|static
name|int
name|qcmp_mru_count
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|mru
modifier|*
specifier|const
modifier|*
name|ppm1
init|=
name|v1
decl_stmt|;
specifier|const
name|mru
modifier|*
specifier|const
modifier|*
name|ppm2
init|=
name|v2
decl_stmt|;
specifier|const
name|mru
modifier|*
name|pm1
decl_stmt|;
specifier|const
name|mru
modifier|*
name|pm2
decl_stmt|;
name|pm1
operator|=
operator|*
name|ppm1
expr_stmt|;
name|pm2
operator|=
operator|*
name|ppm2
expr_stmt|;
return|return
operator|(
name|pm1
operator|->
name|count
operator|<
name|pm2
operator|->
name|count
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|pm1
operator|->
name|count
operator|==
name|pm2
operator|->
name|count
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qcmp_mru_r_count
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
return|return
operator|-
name|qcmp_mru_count
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * qcmp_mru_avgint - sort MRU entries by average interval.  */
end_comment

begin_function
specifier|static
name|int
name|qcmp_mru_avgint
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|mru
modifier|*
specifier|const
modifier|*
name|ppm1
init|=
name|v1
decl_stmt|;
specifier|const
name|mru
modifier|*
specifier|const
modifier|*
name|ppm2
init|=
name|v2
decl_stmt|;
specifier|const
name|mru
modifier|*
name|pm1
decl_stmt|;
specifier|const
name|mru
modifier|*
name|pm2
decl_stmt|;
name|l_fp
name|interval
decl_stmt|;
name|double
name|avg1
decl_stmt|;
name|double
name|avg2
decl_stmt|;
name|pm1
operator|=
operator|*
name|ppm1
expr_stmt|;
name|pm2
operator|=
operator|*
name|ppm2
expr_stmt|;
name|interval
operator|=
name|pm1
operator|->
name|last
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|interval
argument_list|,
operator|&
name|pm1
operator|->
name|first
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|interval
argument_list|,
name|avg1
argument_list|)
expr_stmt|;
name|avg1
operator|/=
name|pm1
operator|->
name|count
expr_stmt|;
name|interval
operator|=
name|pm2
operator|->
name|last
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|interval
argument_list|,
operator|&
name|pm2
operator|->
name|first
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|interval
argument_list|,
name|avg2
argument_list|)
expr_stmt|;
name|avg2
operator|/=
name|pm2
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|avg1
operator|<
name|avg2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|avg1
operator|>
name|avg2
condition|)
return|return
literal|1
return|;
comment|/* secondary sort on lstint - rarely tested */
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|pm1
operator|->
name|last
argument_list|,
operator|&
name|pm2
operator|->
name|last
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|pm1
operator|->
name|last
argument_list|,
operator|&
name|pm2
operator|->
name|last
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qcmp_mru_r_avgint
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
return|return
operator|-
name|qcmp_mru_avgint
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * mrulist - ntpq's mrulist command to fetch an arbitrarily large Most  *	     Recently Used (seen) remote address list from ntpd.  *  * Similar to ntpdc's monlist command, but not limited to a single  * request/response, and thereby not limited to a few hundred remote  * addresses.  *  * See ntpd/ntp_control.c read_mru_list() for comments on the way  * CTL_OP_READ_MRU is designed to be used.  *  * mrulist intentionally differs from monlist in the way the avgint  * column is calculated.  monlist includes the time after the last  * packet from the client until the monlist query time in the average,  * while mrulist excludes it.  That is, monlist's average interval grows  * over time for remote addresses not heard from in some time, while it  * remains unchanged in mrulist.  This also affects the avgint value for  * entries representing a single packet, with identical first and last  * timestamps.  mrulist shows 0 avgint, monlist shows a value identical  * to lstint.  */
end_comment

begin_function
specifier|static
name|void
name|mrulist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
name|mincount_eq
index|[]
init|=
literal|"mincount="
decl_stmt|;
specifier|const
name|char
name|resall_eq
index|[]
init|=
literal|"resall="
decl_stmt|;
specifier|const
name|char
name|resany_eq
index|[]
init|=
literal|"resany="
decl_stmt|;
specifier|const
name|char
name|maxlstint_eq
index|[]
init|=
literal|"maxlstint="
decl_stmt|;
specifier|const
name|char
name|laddr_eq
index|[]
init|=
literal|"laddr="
decl_stmt|;
specifier|const
name|char
name|sort_eq
index|[]
init|=
literal|"sort="
decl_stmt|;
name|mru_sort_order
name|order
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|char
name|parms_buf
index|[
literal|128
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|parms
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|size_t
name|cb
decl_stmt|;
name|mru
modifier|*
modifier|*
name|sorted
decl_stmt|;
name|mru
modifier|*
modifier|*
name|ppentry
decl_stmt|;
name|mru
modifier|*
name|recent
decl_stmt|;
name|l_fp
name|now
decl_stmt|;
name|l_fp
name|interval
decl_stmt|;
name|double
name|favgint
decl_stmt|;
name|double
name|flstint
decl_stmt|;
name|int
name|avgint
decl_stmt|;
name|int
name|lstint
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|order
operator|=
name|MRUSORT_DEF
expr_stmt|;
name|parms_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|parms
operator|=
name|parms_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcmd
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
name|cb
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|strncmp
argument_list|(
name|resall_eq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|resall_eq
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|resany_eq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|resany_eq
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|mincount_eq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|mincount_eq
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|laddr_eq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|laddr_eq
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|maxlstint_eq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|laddr_eq
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|&&
name|parms
operator|+
name|cb
operator|+
literal|2
operator|<=
name|parms_buf
operator|+
sizeof|sizeof
argument_list|(
name|parms_buf
argument_list|)
condition|)
block|{
comment|/* these are passed intact to ntpd */
name|memcpy
argument_list|(
name|parms
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|parms
operator|+=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|parms
argument_list|,
name|arg
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|parms
operator|+=
name|cb
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sort_eq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|sort_eq
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|arg
operator|+=
sizeof|sizeof
argument_list|(
name|sort_eq
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNTOF
argument_list|(
name|mru_sort_keywords
argument_list|)
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mru_sort_keywords
index|[
name|n
index|]
argument_list|,
name|arg
argument_list|)
condition|)
break|break;
if|if
condition|(
name|n
operator|<
name|COUNTOF
argument_list|(
name|mru_sort_keywords
argument_list|)
condition|)
name|order
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"limited"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"kod"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
comment|/* transform to resany=... */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", resany=0x%x"
argument_list|,
operator|(
literal|'k'
operator|==
name|arg
index|[
literal|0
index|]
operator|)
condition|?
name|RES_KOD
else|:
name|RES_LIMITED
argument_list|)
expr_stmt|;
name|cb
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|+
name|cb
operator|<
name|parms_buf
operator|+
sizeof|sizeof
argument_list|(
name|parms_buf
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|parms
argument_list|,
name|buf
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|parms
operator|+=
name|cb
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ignoring unrecognized mrulist parameter: %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
name|parms
operator|=
name|parms_buf
expr_stmt|;
if|if
condition|(
operator|!
name|collect_mru_list
argument_list|(
name|parms
argument_list|,
operator|&
name|now
argument_list|)
condition|)
return|return;
comment|/* display the results */
if|if
condition|(
name|rawmode
condition|)
goto|goto
name|cleanup_return
goto|;
comment|/* construct an array of entry pointers in default order */
name|sorted
operator|=
name|emalloc
argument_list|(
name|mru_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sorted
argument_list|)
argument_list|)
expr_stmt|;
name|ppentry
operator|=
name|sorted
expr_stmt|;
if|if
condition|(
name|MRUSORT_R_DEF
operator|!=
name|order
condition|)
block|{
name|ITER_DLIST_BEGIN
argument_list|(
argument|mru_list
argument_list|,
argument|recent
argument_list|,
argument|mlink
argument_list|,
argument|mru
argument_list|)
name|NTP_INSIST
argument_list|(
name|ppentry
operator|<
name|sorted
operator|+
name|mru_count
argument_list|)
expr_stmt|;
operator|*
name|ppentry
operator|=
name|recent
expr_stmt|;
name|ppentry
operator|++
expr_stmt|;
name|ITER_DLIST_END
argument_list|()
block|}
else|else
block|{
name|REV_ITER_DLIST_BEGIN
argument_list|(
argument|mru_list
argument_list|,
argument|recent
argument_list|,
argument|mlink
argument_list|,
argument|mru
argument_list|)
name|NTP_INSIST
argument_list|(
name|ppentry
operator|<
name|sorted
operator|+
name|mru_count
argument_list|)
expr_stmt|;
operator|*
name|ppentry
operator|=
name|recent
expr_stmt|;
name|ppentry
operator|++
expr_stmt|;
name|REV_ITER_DLIST_END
argument_list|()
block|}
if|if
condition|(
name|ppentry
operator|-
name|sorted
operator|!=
operator|(
name|int
operator|)
name|mru_count
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mru_count %u should match MRU list depth %ld.\n"
argument_list|,
name|mru_count
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ppentry
operator|-
name|sorted
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_return
goto|;
block|}
comment|/* re-sort sorted[] if not default or reverse default */
if|if
condition|(
name|MRUSORT_R_DEF
operator|<
name|order
condition|)
name|qsort
argument_list|(
name|sorted
argument_list|,
name|mru_count
argument_list|,
sizeof|sizeof
argument_list|(
name|sorted
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mru_qcmp_table
index|[
name|order
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lstint avgint rstr r m v  count rport remote address\n"
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
comment|/* '=' x 78 */
for|for
control|(
name|ppentry
operator|=
name|sorted
init|;
name|ppentry
operator|<
name|sorted
operator|+
name|mru_count
condition|;
name|ppentry
operator|++
control|)
block|{
name|recent
operator|=
operator|*
name|ppentry
expr_stmt|;
name|interval
operator|=
name|now
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|interval
argument_list|,
operator|&
name|recent
operator|->
name|last
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|interval
argument_list|,
name|flstint
argument_list|)
expr_stmt|;
name|lstint
operator|=
call|(
name|int
call|)
argument_list|(
name|flstint
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|interval
operator|=
name|recent
operator|->
name|last
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|interval
argument_list|,
operator|&
name|recent
operator|->
name|first
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|interval
argument_list|,
name|favgint
argument_list|)
expr_stmt|;
name|favgint
operator|/=
name|recent
operator|->
name|count
expr_stmt|;
name|avgint
operator|=
call|(
name|int
call|)
argument_list|(
name|favgint
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%6d %6d %4hx %c %d %d %6d %5u %s\n"
argument_list|,
name|lstint
argument_list|,
name|avgint
argument_list|,
name|recent
operator|->
name|rs
argument_list|,
operator|(
name|RES_KOD
operator|&
name|recent
operator|->
name|rs
operator|)
condition|?
literal|'K'
else|:
operator|(
name|RES_LIMITED
operator|&
name|recent
operator|->
name|rs
operator|)
condition|?
literal|'L'
else|:
literal|'.'
argument_list|,
operator|(
name|int
operator|)
name|recent
operator|->
name|mode
argument_list|,
operator|(
name|int
operator|)
name|recent
operator|->
name|ver
argument_list|,
name|recent
operator|->
name|count
argument_list|,
name|SRCPORT
argument_list|(
operator|&
name|recent
operator|->
name|addr
argument_list|)
argument_list|,
name|nntohost
argument_list|(
operator|&
name|recent
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|showhostnames
condition|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--- completed, freeing sorted[] pointers\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
name|cleanup_return
label|:
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"... freeing MRU entries\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|ITER_DLIST_BEGIN
argument_list|(
argument|mru_list
argument_list|,
argument|recent
argument_list|,
argument|mlink
argument_list|,
argument|mru
argument_list|)
name|free
argument_list|(
name|recent
argument_list|)
expr_stmt|;
name|ITER_DLIST_END
argument_list|()
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"... freeing hash_table[]\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
name|hash_table
operator|=
name|NULL
expr_stmt|;
name|INIT_DLIST
argument_list|(
name|mru_list
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * validate_ifnum - helper for ifstats()  *  * Ensures rows are received in order and complete.  */
end_comment

begin_function
specifier|static
name|void
name|validate_ifnum
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_int
name|ifnum
parameter_list|,
name|int
modifier|*
name|pfields
parameter_list|,
name|ifstats_row
modifier|*
name|prow
parameter_list|)
block|{
if|if
condition|(
name|prow
operator|->
name|ifnum
operator|==
name|ifnum
condition|)
return|return;
if|if
condition|(
name|prow
operator|->
name|ifnum
operator|+
literal|1
operator|==
name|ifnum
condition|)
block|{
if|if
condition|(
operator|*
name|pfields
operator|<
name|IFSTATS_FIELDS
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Warning: incomplete row with %d (of %d) fields"
argument_list|,
operator|*
name|pfields
argument_list|,
name|IFSTATS_FIELDS
argument_list|)
expr_stmt|;
operator|*
name|pfields
operator|=
literal|0
expr_stmt|;
name|prow
operator|->
name|ifnum
operator|=
name|ifnum
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"received if index %u, have %d of %d fields for index %u, aborting.\n"
argument_list|,
name|ifnum
argument_list|,
operator|*
name|pfields
argument_list|,
name|IFSTATS_FIELDS
argument_list|,
name|prow
operator|->
name|ifnum
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * another_ifstats_field - helper for ifstats()  *  * If all fields for the row have been received, print it.  */
end_comment

begin_function
specifier|static
name|void
name|another_ifstats_field
parameter_list|(
name|int
modifier|*
name|pfields
parameter_list|,
name|ifstats_row
modifier|*
name|prow
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|u_int
name|ifnum
decl_stmt|;
operator|(
operator|*
name|pfields
operator|)
operator|++
expr_stmt|;
comment|/* we understand 12 tags */
if|if
condition|(
name|IFSTATS_FIELDS
operator|>
operator|*
name|pfields
condition|)
return|return;
comment|/* 	"    interface name                                        send\n" 	" #  address/broadcast     drop flag ttl mc received sent failed peers   uptime\n" 	"==============================================================================\n"); 	 */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%3u %-24.24s %c %4x %3d %2d %6d %6d %6d %5d %8d\n"
literal|"    %s\n"
argument_list|,
name|prow
operator|->
name|ifnum
argument_list|,
name|prow
operator|->
name|name
argument_list|,
operator|(
name|prow
operator|->
name|enabled
operator|)
condition|?
literal|'.'
else|:
literal|'D'
argument_list|,
name|prow
operator|->
name|flags
argument_list|,
name|prow
operator|->
name|ttl
argument_list|,
name|prow
operator|->
name|mcast_count
argument_list|,
name|prow
operator|->
name|received
argument_list|,
name|prow
operator|->
name|sent
argument_list|,
name|prow
operator|->
name|send_errors
argument_list|,
name|prow
operator|->
name|peer_count
argument_list|,
name|prow
operator|->
name|uptime
argument_list|,
name|sptoa
argument_list|(
operator|&
name|prow
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOCK_UNSPEC
argument_list|(
operator|&
name|prow
operator|->
name|bcast
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    %s\n"
argument_list|,
name|sptoa
argument_list|(
operator|&
name|prow
operator|->
name|bcast
argument_list|)
argument_list|)
expr_stmt|;
name|ifnum
operator|=
name|prow
operator|->
name|ifnum
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|prow
argument_list|)
expr_stmt|;
name|prow
operator|->
name|ifnum
operator|=
name|ifnum
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ifstats - ntpq -c ifstats modeled on ntpdc -c ifstats.  */
end_comment

begin_function
specifier|static
name|void
name|ifstats
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
name|addr_fmt
index|[]
init|=
literal|"addr.%u"
decl_stmt|;
specifier|const
name|char
name|bcast_fmt
index|[]
init|=
literal|"bcast.%u"
decl_stmt|;
specifier|const
name|char
name|en_fmt
index|[]
init|=
literal|"en.%u"
decl_stmt|;
comment|/* enabled */
specifier|const
name|char
name|flags_fmt
index|[]
init|=
literal|"flags.%u"
decl_stmt|;
specifier|const
name|char
name|mc_fmt
index|[]
init|=
literal|"mc.%u"
decl_stmt|;
comment|/* mcast count */
specifier|const
name|char
name|name_fmt
index|[]
init|=
literal|"name.%u"
decl_stmt|;
specifier|const
name|char
name|pc_fmt
index|[]
init|=
literal|"pc.%u"
decl_stmt|;
comment|/* peer count */
specifier|const
name|char
name|rx_fmt
index|[]
init|=
literal|"rx.%u"
decl_stmt|;
specifier|const
name|char
name|tl_fmt
index|[]
init|=
literal|"tl.%u"
decl_stmt|;
comment|/* ttl */
specifier|const
name|char
name|tx_fmt
index|[]
init|=
literal|"tx.%u"
decl_stmt|;
specifier|const
name|char
name|txerr_fmt
index|[]
init|=
literal|"txerr.%u"
decl_stmt|;
specifier|const
name|char
name|up_fmt
index|[]
init|=
literal|"up.%u"
decl_stmt|;
comment|/* uptime */
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|qres
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|fields
decl_stmt|;
name|u_int
name|ui
decl_stmt|;
name|ifstats_row
name|row
decl_stmt|;
name|int
name|comprende
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|qres
operator|=
name|doquery
argument_list|(
name|CTL_OP_READ_ORDLIST_A
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|qres
condition|)
comment|/* message already displayed */
return|return;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    interface name                                        send\n"
literal|" #  address/broadcast     drop flag ttl mc received sent failed peers   uptime\n"
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
comment|/* '=' x 78 */
name|ZERO
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|fields
operator|=
literal|0
expr_stmt|;
name|ui
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextvar gave: %s = %s\n"
argument_list|,
name|tag
argument_list|,
operator|(
name|NULL
operator|==
name|val
operator|)
condition|?
literal|""
else|:
name|val
argument_list|)
expr_stmt|;
name|comprende
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|tag
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|addr_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|row
operator|.
name|addr
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|bcast_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
operator|(
name|NULL
operator|==
name|val
operator|||
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|row
operator|.
name|bcast
argument_list|)
operator|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|en_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|enabled
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|flags_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"0x%x"
argument_list|,
operator|&
name|row
operator|.
name|flags
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|mc_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|mcast_count
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|name_fmt
argument_list|,
operator|&
name|ui
argument_list|)
condition|)
block|{
comment|/* strip quotes */
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|len
operator|-
literal|2
operator|<
sizeof|sizeof
argument_list|(
name|row
operator|.
name|name
argument_list|)
condition|)
block|{
name|len
operator|-=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|row
operator|.
name|name
argument_list|,
name|val
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|row
operator|.
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|comprende
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|pc_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|peer_count
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|rx_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|received
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|tl_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|ttl
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|tx_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|sent
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|txerr_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|send_errors
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|up_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|row
operator|.
name|uptime
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|comprende
condition|)
block|{
comment|/* error out if rows out of order */
name|validate_ifnum
argument_list|(
name|fp
argument_list|,
name|ui
argument_list|,
operator|&
name|fields
argument_list|,
operator|&
name|row
argument_list|)
expr_stmt|;
comment|/* if the row is complete, print it */
name|another_ifstats_field
argument_list|(
operator|&
name|fields
argument_list|,
operator|&
name|row
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fields
operator|!=
name|IFSTATS_FIELDS
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Warning: incomplete row with %d (of %d) fields"
argument_list|,
name|fields
argument_list|,
name|IFSTATS_FIELDS
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * validate_reslist_idx - helper for reslist()  *  * Ensures rows are received in order and complete.  */
end_comment

begin_function
specifier|static
name|void
name|validate_reslist_idx
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|int
modifier|*
name|pfields
parameter_list|,
name|reslist_row
modifier|*
name|prow
parameter_list|)
block|{
if|if
condition|(
name|prow
operator|->
name|idx
operator|==
name|idx
condition|)
return|return;
if|if
condition|(
name|prow
operator|->
name|idx
operator|+
literal|1
operator|==
name|idx
condition|)
block|{
if|if
condition|(
operator|*
name|pfields
operator|<
name|RESLIST_FIELDS
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Warning: incomplete row with %d (of %d) fields"
argument_list|,
operator|*
name|pfields
argument_list|,
name|RESLIST_FIELDS
argument_list|)
expr_stmt|;
operator|*
name|pfields
operator|=
literal|0
expr_stmt|;
name|prow
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"received reslist index %u, have %d of %d fields for index %u, aborting.\n"
argument_list|,
name|idx
argument_list|,
operator|*
name|pfields
argument_list|,
name|RESLIST_FIELDS
argument_list|,
name|prow
operator|->
name|idx
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * another_reslist_field - helper for reslist()  *  * If all fields for the row have been received, print it.  */
end_comment

begin_function
specifier|static
name|void
name|another_reslist_field
parameter_list|(
name|int
modifier|*
name|pfields
parameter_list|,
name|reslist_row
modifier|*
name|prow
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|addrmaskstr
index|[
literal|128
index|]
decl_stmt|;
name|int
name|prefix
decl_stmt|;
comment|/* subnet mask as prefix bits count */
name|u_int
name|idx
decl_stmt|;
operator|(
operator|*
name|pfields
operator|)
operator|++
expr_stmt|;
comment|/* we understand 4 tags */
if|if
condition|(
name|RESLIST_FIELDS
operator|>
operator|*
name|pfields
condition|)
return|return;
name|prefix
operator|=
name|sockaddr_masktoprefixlen
argument_list|(
operator|&
name|prow
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|addrmaskstr
argument_list|,
sizeof|sizeof
argument_list|(
name|addrmaskstr
argument_list|)
argument_list|,
literal|"%s/%d"
argument_list|,
name|stoa
argument_list|(
operator|&
name|prow
operator|->
name|addr
argument_list|)
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|addrmaskstr
argument_list|,
sizeof|sizeof
argument_list|(
name|addrmaskstr
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|prow
operator|->
name|addr
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|prow
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	"   hits    addr/prefix or addr mask\n" 	"           restrictions\n" 	"==============================================================================\n"); 	 */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%10lu %s\n"
literal|"           %s\n"
argument_list|,
name|prow
operator|->
name|hits
argument_list|,
name|addrmaskstr
argument_list|,
name|prow
operator|->
name|flagstr
argument_list|)
expr_stmt|;
name|idx
operator|=
name|prow
operator|->
name|idx
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|prow
argument_list|)
expr_stmt|;
name|prow
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * reslist - ntpq -c reslist modeled on ntpdc -c reslist.  */
end_comment

begin_function
specifier|static
name|void
name|reslist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
name|addr_fmtu
index|[]
init|=
literal|"addr.%u"
decl_stmt|;
specifier|const
name|char
name|mask_fmtu
index|[]
init|=
literal|"mask.%u"
decl_stmt|;
specifier|const
name|char
name|hits_fmt
index|[]
init|=
literal|"hits.%u"
decl_stmt|;
specifier|const
name|char
name|flags_fmt
index|[]
init|=
literal|"flags.%u"
decl_stmt|;
specifier|const
name|char
name|qdata
index|[]
init|=
literal|"addr_restrictions"
decl_stmt|;
specifier|const
name|int
name|qdata_chars
init|=
name|COUNTOF
argument_list|(
name|qdata
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|qres
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|fields
decl_stmt|;
name|u_int
name|ui
decl_stmt|;
name|reslist_row
name|row
decl_stmt|;
name|int
name|comprende
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|qres
operator|=
name|doquery
argument_list|(
name|CTL_OP_READ_ORDLIST_A
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|qdata_chars
argument_list|,
name|qdata
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|qres
condition|)
comment|/* message already displayed */
return|return;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"   hits    addr/prefix or addr mask\n"
literal|"           restrictions\n"
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
comment|/* '=' x 78 */
name|ZERO
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|fields
operator|=
literal|0
expr_stmt|;
name|ui
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextvar gave: %s = %s\n"
argument_list|,
name|tag
argument_list|,
operator|(
name|NULL
operator|==
name|val
operator|)
condition|?
literal|""
else|:
name|val
argument_list|)
expr_stmt|;
name|comprende
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|tag
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|addr_fmtu
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|row
operator|.
name|addr
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|flags_fmt
argument_list|,
operator|&
name|ui
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|val
condition|)
block|{
name|row
operator|.
name|flagstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|comprende
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|row
operator|.
name|flagstr
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|row
operator|.
name|flagstr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|comprende
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|hits_fmt
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|row
operator|.
name|hits
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|tag
argument_list|,
name|mask_fmtu
argument_list|,
operator|&
name|ui
argument_list|)
operator|&&
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|row
operator|.
name|mask
argument_list|)
condition|)
name|comprende
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|comprende
condition|)
block|{
comment|/* error out if rows out of order */
name|validate_reslist_idx
argument_list|(
name|fp
argument_list|,
name|ui
argument_list|,
operator|&
name|fields
argument_list|,
operator|&
name|row
argument_list|)
expr_stmt|;
comment|/* if the row is complete, print it */
name|another_reslist_field
argument_list|(
operator|&
name|fields
argument_list|,
operator|&
name|row
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fields
operator|!=
name|RESLIST_FIELDS
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Warning: incomplete row with %d (of %d) fields"
argument_list|,
name|fields
argument_list|,
name|RESLIST_FIELDS
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * collect_display_vdc  */
end_comment

begin_function
specifier|static
name|void
name|collect_display_vdc
parameter_list|(
name|associd_t
name|as
parameter_list|,
name|vdc
modifier|*
name|table
parameter_list|,
name|int
name|decodestatus
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suf
index|[
literal|2
index|]
init|=
block|{
literal|"adr"
block|,
literal|"port"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|leapbits
index|[
literal|4
index|]
init|=
block|{
literal|"00"
block|,
literal|"01"
block|,
literal|"10"
block|,
literal|"11"
block|}
decl_stmt|;
name|struct
name|varlist
name|vl
index|[
name|MAXLIST
index|]
decl_stmt|;
name|char
name|tagbuf
index|[
literal|32
index|]
decl_stmt|;
name|vdc
modifier|*
name|pvdc
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|int
name|qres
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|match
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|int
name|vtype
decl_stmt|;
name|ZERO
argument_list|(
name|vl
argument_list|)
expr_stmt|;
for|for
control|(
name|pvdc
operator|=
name|table
init|;
name|pvdc
operator|->
name|tag
operator|!=
name|NULL
condition|;
name|pvdc
operator|++
control|)
block|{
name|ZERO
argument_list|(
name|pvdc
operator|->
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|NTP_ADD
operator|!=
name|pvdc
operator|->
name|type
condition|)
block|{
name|doaddvlist
argument_list|(
name|vl
argument_list|,
name|pvdc
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNTOF
argument_list|(
name|suf
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|tagbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tagbuf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|pvdc
operator|->
name|tag
argument_list|,
name|suf
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|doaddvlist
argument_list|(
name|vl
argument_list|,
name|tagbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|qres
operator|=
name|doquerylist
argument_list|(
name|vl
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|as
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|vl
argument_list|)
expr_stmt|;
if|if
condition|(
name|qres
condition|)
return|return;
comment|/* error msg already displayed */
comment|/* 	 * iterate over the response variables filling vdc_table with 	 * the retrieved values. 	 */
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|val
condition|)
continue|continue;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pvdc
operator|=
name|table
init|;
name|pvdc
operator|->
name|tag
operator|!=
name|NULL
condition|;
name|pvdc
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|pvdc
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tag
argument_list|,
name|pvdc
operator|->
name|tag
argument_list|,
name|len
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|NTP_ADD
operator|!=
name|pvdc
operator|->
name|type
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|!=
name|tag
index|[
name|len
index|]
condition|)
continue|continue;
break|break;
block|}
name|match
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNTOF
argument_list|(
name|suf
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tag
operator|+
name|len
argument_list|,
name|suf
index|[
name|n
index|]
argument_list|)
condition|)
continue|continue;
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
condition|)
break|break;
block|}
if|if
condition|(
name|NULL
operator|==
name|pvdc
operator|->
name|tag
condition|)
continue|continue;
switch|switch
condition|(
name|pvdc
operator|->
name|type
condition|)
block|{
case|case
name|NTP_STR
case|:
comment|/* strip surrounding double quotes */
if|if
condition|(
literal|'"'
operator|==
name|val
index|[
literal|0
index|]
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
literal|'"'
operator|==
name|val
index|[
name|len
operator|-
literal|1
index|]
condition|)
block|{
name|val
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
block|}
comment|/* fallthru */
case|case
name|NTP_MODE
case|:
comment|/* fallthru */
case|case
name|NTP_2BIT
case|:
name|pvdc
operator|->
name|v
operator|.
name|str
operator|=
name|estrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTP_LFP
case|:
name|decodets
argument_list|(
name|val
argument_list|,
operator|&
name|pvdc
operator|->
name|v
operator|.
name|lfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTP_ADP
case|:
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|pvdc
operator|->
name|v
operator|.
name|sau
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malformed %s=%s\n"
argument_list|,
name|pvdc
operator|->
name|tag
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTP_ADD
case|:
if|if
condition|(
literal|0
operator|==
name|n
condition|)
block|{
comment|/* adr */
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|pvdc
operator|->
name|v
operator|.
name|sau
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malformed %s=%s\n"
argument_list|,
name|pvdc
operator|->
name|tag
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* port */
if|if
condition|(
name|atouint
argument_list|(
name|val
argument_list|,
operator|&
name|ul
argument_list|)
condition|)
name|SET_PORT
argument_list|(
operator|&
name|pvdc
operator|->
name|v
operator|.
name|sau
argument_list|,
operator|(
name|u_short
operator|)
name|ul
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* and display */
if|if
condition|(
name|decodestatus
condition|)
block|{
name|vtype
operator|=
operator|(
literal|0
operator|==
name|as
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%u status=%04x %s,\n"
argument_list|,
name|as
argument_list|,
name|rstatus
argument_list|,
name|statustoa
argument_list|(
name|vtype
argument_list|,
name|rstatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pvdc
operator|=
name|table
init|;
name|pvdc
operator|->
name|tag
operator|!=
name|NULL
condition|;
name|pvdc
operator|++
control|)
block|{
switch|switch
condition|(
name|pvdc
operator|->
name|type
condition|)
block|{
case|case
name|NTP_STR
case|:
if|if
condition|(
name|pvdc
operator|->
name|v
operator|.
name|str
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s  %s\n"
argument_list|,
name|pvdc
operator|->
name|display
argument_list|,
name|pvdc
operator|->
name|v
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pvdc
operator|->
name|v
operator|.
name|str
argument_list|)
expr_stmt|;
name|pvdc
operator|->
name|v
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|NTP_ADD
case|:
comment|/* fallthru */
case|case
name|NTP_ADP
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s  %s\n"
argument_list|,
name|pvdc
operator|->
name|display
argument_list|,
name|nntohostp
argument_list|(
operator|&
name|pvdc
operator|->
name|v
operator|.
name|sau
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTP_LFP
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s  %s\n"
argument_list|,
name|pvdc
operator|->
name|display
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pvdc
operator|->
name|v
operator|.
name|lfp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTP_MODE
case|:
name|atouint
argument_list|(
name|pvdc
operator|->
name|v
operator|.
name|str
argument_list|,
operator|&
name|ul
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s  %s\n"
argument_list|,
name|pvdc
operator|->
name|display
argument_list|,
name|modetoa
argument_list|(
operator|(
name|int
operator|)
name|ul
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTP_2BIT
case|:
name|atouint
argument_list|(
name|pvdc
operator|->
name|v
operator|.
name|str
argument_list|,
operator|&
name|ul
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s  %s\n"
argument_list|,
name|pvdc
operator|->
name|display
argument_list|,
name|leapbits
index|[
name|ul
operator|&
literal|0x3
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected vdc type %d for %s\n"
argument_list|,
name|pvdc
operator|->
name|type
argument_list|,
name|pvdc
operator|->
name|tag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * sysstats - implements ntpq -c sysstats modeled on ntpdc -c sysstats  */
end_comment

begin_function
specifier|static
name|void
name|sysstats
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|sysstats_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"ss_uptime"
argument_list|,
literal|"uptime:               "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_reset"
argument_list|,
literal|"sysstats reset:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_received"
argument_list|,
literal|"packets received:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_thisver"
argument_list|,
literal|"current version:      "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_oldver"
argument_list|,
literal|"older version:        "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_badformat"
argument_list|,
literal|"bad length or format: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_badauth"
argument_list|,
literal|"authentication failed:"
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_declined"
argument_list|,
literal|"declined:             "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_restricted"
argument_list|,
literal|"restricted:           "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_limited"
argument_list|,
literal|"rate limited:         "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_kodsent"
argument_list|,
literal|"KoD responses:        "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ss_processed"
argument_list|,
literal|"processed for time:   "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|sysstats_vdc
argument_list|,
name|FALSE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sysinfo - modeled on ntpdc's sysinfo  */
end_comment

begin_function
specifier|static
name|void
name|sysinfo
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|sysinfo_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"peeradr"
argument_list|,
literal|"system peer:      "
argument_list|,
name|NTP_ADP
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"peermode"
argument_list|,
literal|"system peer mode: "
argument_list|,
name|NTP_MODE
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"leap"
argument_list|,
literal|"leap indicator:   "
argument_list|,
name|NTP_2BIT
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"stratum"
argument_list|,
literal|"stratum:          "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"precision"
argument_list|,
literal|"log2 precision:   "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"rootdelay"
argument_list|,
literal|"root delay:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"rootdisp"
argument_list|,
literal|"root dispersion:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"refid"
argument_list|,
literal|"reference ID:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"reftime"
argument_list|,
literal|"reference time:   "
argument_list|,
name|NTP_LFP
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"sys_jitter"
argument_list|,
literal|"system jitter:    "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"clk_jitter"
argument_list|,
literal|"clock jitter:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"clk_wander"
argument_list|,
literal|"clock wander:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"bcastdelay"
argument_list|,
literal|"broadcast delay:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authdelay"
argument_list|,
literal|"symm. auth. delay:"
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|sysinfo_vdc
argument_list|,
name|TRUE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * kerninfo - modeled on ntpdc's kerninfo  */
end_comment

begin_function
specifier|static
name|void
name|kerninfo
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|kerninfo_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"koffset"
argument_list|,
literal|"pll offset:          "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kfreq"
argument_list|,
literal|"pll frequency:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kmaxerr"
argument_list|,
literal|"maximum error:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kesterr"
argument_list|,
literal|"estimated error:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kstflags"
argument_list|,
literal|"kernel status:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"ktimeconst"
argument_list|,
literal|"pll time constant:   "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kprecis"
argument_list|,
literal|"precision:           "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kfreqtol"
argument_list|,
literal|"frequency tolerance: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppsfreq"
argument_list|,
literal|"pps frequency:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppsstab"
argument_list|,
literal|"pps stability:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppsjitter"
argument_list|,
literal|"pps jitter:          "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppscalibdur"
argument_list|,
literal|"calibration interval "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppscalibs"
argument_list|,
literal|"calibration cycles:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppsjitexc"
argument_list|,
literal|"jitter exceeded:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppsstbexc"
argument_list|,
literal|"stability exceeded:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"kppscaliberrs"
argument_list|,
literal|"calibration errors:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|kerninfo_vdc
argument_list|,
name|TRUE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * monstats - implements ntpq -c monstats  */
end_comment

begin_function
specifier|static
name|void
name|monstats
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|monstats_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"mru_enabled"
argument_list|,
literal|"enabled:            "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_depth"
argument_list|,
literal|"addresses:          "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_deepest"
argument_list|,
literal|"peak addresses:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_maxdepth"
argument_list|,
literal|"maximum addresses:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_mindepth"
argument_list|,
literal|"reclaim above count:"
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_maxage"
argument_list|,
literal|"reclaim older than: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_mem"
argument_list|,
literal|"kilobytes:          "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"mru_maxmem"
argument_list|,
literal|"maximum kilobytes:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|monstats_vdc
argument_list|,
name|FALSE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * iostats - ntpq -c iostats - network input and output counters  */
end_comment

begin_function
specifier|static
name|void
name|iostats
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|iostats_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"iostats_reset"
argument_list|,
literal|"time since reset:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"total_rbuf"
argument_list|,
literal|"receive buffers:      "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"free_rbuf"
argument_list|,
literal|"free receive buffers: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"used_rbuf"
argument_list|,
literal|"used receive buffers: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"rbuf_lowater"
argument_list|,
literal|"low water refills:    "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_dropped"
argument_list|,
literal|"dropped packets:      "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_ignored"
argument_list|,
literal|"ignored packets:      "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_received"
argument_list|,
literal|"received packets:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_sent"
argument_list|,
literal|"packets sent:         "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_sendfailed"
argument_list|,
literal|"packet send failures: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_wakeups"
argument_list|,
literal|"input wakeups:        "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"io_goodwakeups"
argument_list|,
literal|"useful input wakeups: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|iostats_vdc
argument_list|,
name|FALSE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timerstats - ntpq -c timerstats - interval timer counters  */
end_comment

begin_function
specifier|static
name|void
name|timerstats
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|timerstats_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"timerstats_reset"
argument_list|,
literal|"time since reset:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"timer_overruns"
argument_list|,
literal|"timer overruns:    "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"timer_xmts"
argument_list|,
literal|"calls to transmit: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|timerstats_vdc
argument_list|,
name|FALSE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * authinfo - implements ntpq -c authinfo  */
end_comment

begin_function
specifier|static
name|void
name|authinfo
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|authinfo_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"authreset"
argument_list|,
literal|"time since reset:"
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authkeys"
argument_list|,
literal|"stored keys:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authfreek"
argument_list|,
literal|"free keys:       "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authklookups"
argument_list|,
literal|"key lookups:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authknotfound"
argument_list|,
literal|"keys not found:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authkuncached"
argument_list|,
literal|"uncached keys:   "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authkexpired"
argument_list|,
literal|"expired keys:    "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authencrypts"
argument_list|,
literal|"encryptions:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"authdecrypts"
argument_list|,
literal|"decryptions:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|collect_display_vdc
argument_list|(
literal|0
argument_list|,
name|authinfo_vdc
argument_list|,
name|FALSE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pstats - show statistics for a peer  */
end_comment

begin_function
specifier|static
name|void
name|pstats
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|vdc
name|pstats_vdc
index|[]
init|=
block|{
name|VDC_INIT
argument_list|(
literal|"src"
argument_list|,
literal|"remote host:         "
argument_list|,
name|NTP_ADD
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"dst"
argument_list|,
literal|"local address:       "
argument_list|,
name|NTP_ADD
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"timerec"
argument_list|,
literal|"time last received:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"timer"
argument_list|,
literal|"time until next send:"
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"timereach"
argument_list|,
literal|"reachability change: "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"sent"
argument_list|,
literal|"packets sent:        "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"received"
argument_list|,
literal|"packets received:    "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"badauth"
argument_list|,
literal|"bad authentication:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"bogusorg"
argument_list|,
literal|"bogus origin:        "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"oldpkt"
argument_list|,
literal|"duplicate:           "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"seldisp"
argument_list|,
literal|"bad dispersion:      "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"selbroken"
argument_list|,
literal|"bad reference time:  "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
literal|"candidate"
argument_list|,
literal|"candidate order:     "
argument_list|,
name|NTP_STR
argument_list|)
block|,
name|VDC_INIT
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|associd
condition|)
return|return;
name|collect_display_vdc
argument_list|(
name|associd
argument_list|,
name|pstats_vdc
argument_list|,
name|TRUE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

