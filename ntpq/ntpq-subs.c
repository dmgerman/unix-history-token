begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpq_ops.c - subroutines which are called to perform operations by ntpq  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntpq.h"
end_include

begin_include
include|#
directive|include
file|"ntpq-opts.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|chosts
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|currenthost
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|currenthostisnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|numhosts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxhostlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declarations for command handlers in here  */
end_comment

begin_function_decl
specifier|static
name|associd_t
name|checkassocid
parameter_list|(
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|varlist
modifier|*
name|findlistvar
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doaddvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dormvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doclearvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|makequerydata
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doquerylist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|associd_t
parameter_list|,
name|int
parameter_list|,
name|u_short
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doprintvlist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clearvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|showvars
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dolist
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|associd_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readlist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writelist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readvar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writevar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clocklist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clockvar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findassidrange
parameter_list|(
name|u_int32
parameter_list|,
name|u_int32
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mreadlist
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mreadvar
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dogetassoc
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printassoc
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|associations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lassociations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passociations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpassociations
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_function_decl
specifier|static
name|void
name|radiostatus
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_function_decl
specifier|static
name|void
name|pstatus
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|when
parameter_list|(
name|l_fp
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|prettyinterval
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doprintpeers
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dogetpeers
parameter_list|(
name|struct
name|varlist
modifier|*
parameter_list|,
name|associd_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopeers
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpeers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doopeers
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opeers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lopeers
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|saveconfig
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_from_file
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Commands we understand.	Ntpdc imports this.  */
end_comment

begin_decl_stmt
name|struct
name|xcmd
name|opcmds
index|[]
init|=
block|{
block|{
literal|"saveconfig"
block|,
name|saveconfig
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"filename"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"save ntpd configuration to file, . for current config file"
block|}
block|,
block|{
literal|"associations"
block|,
name|associations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of association ID's and statuses for the server's peers"
block|}
block|,
block|{
literal|"passociations"
block|,
name|passociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of associations returned by last associations command"
block|}
block|,
block|{
literal|"lassociations"
block|,
name|lassociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of associations including all client information"
block|}
block|,
block|{
literal|"lpassociations"
block|,
name|lpassociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print last obtained list of associations, including client information"
block|}
block|,
block|{
literal|"addvars"
block|,
name|addvars
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"name[=value][,...]"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"add variables to the variable list or change their values"
block|}
block|,
block|{
literal|"rmvars"
block|,
name|rmvars
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"name[,...]"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"remove variables from the variable list"
block|}
block|,
block|{
literal|"clearvars"
block|,
name|clearvars
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"remove all variables from the variable list"
block|}
block|,
block|{
literal|"showvars"
block|,
name|showvars
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print variables on the variable list"
block|}
block|,
block|{
literal|"readlist"
block|,
name|readlist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"rl"
block|,
name|readlist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"writelist"
block|,
name|writelist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"write the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"readvar"
block|,
name|readvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read system or peer variables"
block|}
block|,
block|{
literal|"rv"
block|,
name|readvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read system or peer variables"
block|}
block|,
block|{
literal|"writevar"
block|,
name|writevar
block|,
block|{
name|NTP_UINT
block|,
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value,[...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"write system or peer variables"
block|}
block|,
block|{
literal|"mreadlist"
block|,
name|mreadlist
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the peer variables in the variable list for multiple peers"
block|}
block|,
block|{
literal|"mrl"
block|,
name|mreadlist
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the peer variables in the variable list for multiple peers"
block|}
block|,
block|{
literal|"mreadvar"
block|,
name|mreadvar
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|}
block|,
literal|"read peer variables from multiple peers"
block|}
block|,
block|{
literal|"mrv"
block|,
name|mreadvar
block|,
block|{
name|NTP_UINT
block|,
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|}
block|,
literal|"read peer variables from multiple peers"
block|}
block|,
block|{
literal|"clocklist"
block|,
name|clocklist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the clock variables included in the variable list"
block|}
block|,
block|{
literal|"cl"
block|,
name|clocklist
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the clock variables included in the variable list"
block|}
block|,
block|{
literal|"clockvar"
block|,
name|clockvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read clock variables"
block|}
block|,
block|{
literal|"cv"
block|,
name|clockvar
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read clock variables"
block|}
block|,
block|{
literal|"pstatus"
block|,
name|pstatus
block|,
block|{
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print status information returned for a peer"
block|}
block|,
block|{
literal|"peers"
block|,
name|peers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of the server's peers [IP version]"
block|}
block|,
block|{
literal|"lpeers"
block|,
name|lpeers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of all peers and clients [IP version]"
block|}
block|,
block|{
literal|"opeers"
block|,
name|opeers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print peer list the old way, with dstadr shown rather than refid [IP version]"
block|}
block|,
block|{
literal|"lopeers"
block|,
name|lopeers
block|,
block|{
name|OPT
operator||
name|IP_VERSION
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of all peers and clients showing dstadr [IP version]"
block|}
block|,
block|{
literal|":config"
block|,
name|config
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"<configuration command line>"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"send a remote configuration command to ntpd"
block|}
block|,
block|{
literal|"config-from-file"
block|,
name|config_from_file
block|,
block|{
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"<configuration filename>"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"configure ntpd using the configuration filename"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable list data space  */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum length of a line */
end_comment

begin_define
define|#
directive|define
name|MAXLIST
value|64
end_define

begin_comment
comment|/* maximum number of variables in list */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters long */
end_comment

begin_comment
comment|/*  * Old CTL_PST defines for version 2.  */
end_comment

begin_define
define|#
directive|define
name|OLD_CTL_PST_CONFIG
value|0x80
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_AUTHENABLE
value|0x40
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_AUTHENTIC
value|0x20
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_REACH
value|0x10
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SANE
value|0x08
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_DISP
value|0x04
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_REJECT
value|0
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SELCAND
value|1
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SYNCCAND
value|2
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SYSPEER
value|3
end_define

begin_decl_stmt
name|char
name|flash2
index|[]
init|=
literal|" .+*    "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash decode for version 2 */
end_comment

begin_decl_stmt
name|char
name|flash3
index|[]
init|=
literal|" x.-+#*o"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash decode for peer status version 3 */
end_comment

begin_struct
struct|struct
name|varlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|g_varlist
index|[
name|MAXLIST
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Imported from ntpq.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|showhostnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rawmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|servent
modifier|*
name|server_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|association
name|assoc_cache
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|numassoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|pktversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ctl_var
name|peer_var
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For quick string comparisons  */
end_comment

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * checkassocid - return the association ID, checking to see if it is valid  */
end_comment

begin_function
specifier|static
name|associd_t
name|checkassocid
parameter_list|(
name|u_int32
name|value
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|u_long
name|ulvalue
decl_stmt|;
name|associd
operator|=
operator|(
name|associd_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|associd
operator|||
name|value
operator|!=
name|associd
condition|)
block|{
name|ulvalue
operator|=
name|value
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Invalid association ID %lu specified\n"
argument_list|,
name|ulvalue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|associd
return|;
block|}
end_function

begin_comment
comment|/*  * findlistvar - look for the named variable in a list and return if found  */
end_comment

begin_function
specifier|static
name|struct
name|varlist
modifier|*
name|findlistvar
parameter_list|(
name|struct
name|varlist
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
for|for
control|(
name|vl
operator|=
name|list
init|;
name|vl
operator|<
name|list
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|vl
operator|->
name|name
argument_list|)
condition|)
return|return
name|vl
return|;
if|if
condition|(
name|vl
operator|<
name|list
operator|+
name|MAXLIST
condition|)
return|return
name|vl
return|;
return|return
operator|(
expr|struct
name|varlist
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * doaddvlist - add variable(s) to the variable list  */
end_comment

begin_function
specifier|static
name|void
name|doaddvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
specifier|const
name|char
modifier|*
name|vars
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|vars
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|vl
operator|=
name|findlistvar
argument_list|(
name|vlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable list full\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vl
operator|->
name|name
operator|==
literal|0
condition|)
block|{
name|vl
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|vl
operator|->
name|value
operator|=
name|estrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * dormvlist - remove variable(s) from the variable list  */
end_comment

begin_function
specifier|static
name|void
name|dormvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
specifier|const
name|char
modifier|*
name|vars
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|vars
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|vl
operator|=
name|findlistvar
argument_list|(
name|vlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|==
literal|0
operator|||
name|vl
operator|->
name|name
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable `%s' not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|vl
operator|+
literal|1
operator|)
operator|<
operator|(
name|g_varlist
operator|+
name|MAXLIST
operator|)
operator|&&
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|vl
operator|->
name|name
operator|=
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|name
expr_stmt|;
name|vl
operator|->
name|value
operator|=
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|value
expr_stmt|;
block|}
name|vl
operator|->
name|name
operator|=
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * doclearvlist - clear a variable list  */
end_comment

begin_function
specifier|static
name|void
name|doclearvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
name|vl
operator|->
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * makequerydata - form a data buffer to be included with a query  */
end_comment

begin_function
specifier|static
name|void
name|makequerydata
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
modifier|*
name|datalen
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpend
decl_stmt|;
specifier|register
name|int
name|namelen
decl_stmt|,
name|valuelen
decl_stmt|;
specifier|register
name|int
name|totallen
decl_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|cpend
operator|=
name|data
operator|+
operator|*
name|datalen
expr_stmt|;
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|namelen
operator|=
name|strlen
argument_list|(
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|==
literal|0
condition|)
name|valuelen
operator|=
literal|0
expr_stmt|;
else|else
name|valuelen
operator|=
name|strlen
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|namelen
operator|+
name|valuelen
operator|+
operator|(
name|valuelen
operator|!=
literal|0
operator|)
operator|+
operator|(
name|cp
operator|!=
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|totallen
operator|>
name|cpend
condition|)
break|break;
if|if
condition|(
name|cp
operator|!=
name|data
condition|)
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|vl
operator|->
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|namelen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|namelen
expr_stmt|;
if|if
condition|(
name|valuelen
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|vl
operator|->
name|value
argument_list|,
operator|(
name|unsigned
operator|)
name|valuelen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|valuelen
expr_stmt|;
block|}
block|}
operator|*
name|datalen
operator|=
name|cp
operator|-
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * doquerylist - send a message including variables in a list  */
end_comment

begin_function
specifier|static
name|int
name|doquerylist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
name|op
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|int
modifier|*
name|dsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
name|char
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|datalen
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|makequerydata
argument_list|(
name|vlist
argument_list|,
operator|&
name|datalen
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|doquery
argument_list|(
name|op
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|datalen
argument_list|,
name|data
argument_list|,
name|rstatus
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * doprintvlist - print the variables on a list  */
end_comment

begin_function
specifier|static
name|void
name|doprintvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
if|if
condition|(
name|vlist
operator|->
name|name
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No variables on list\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
if|if
condition|(
name|vl
operator|->
name|value
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s=%s\n"
argument_list|,
name|vl
operator|->
name|name
argument_list|,
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * addvars - add variables to the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|addvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doaddvlist
argument_list|(
name|g_varlist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rmvars - remove variables from the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|rmvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|dormvlist
argument_list|(
name|g_varlist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clearvars - clear the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|clearvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doclearvlist
argument_list|(
name|g_varlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * showvars - show variables on the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|showvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doprintvlist
argument_list|(
name|g_varlist
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dolist - send a request with the given list of variables  */
end_comment

begin_function
specifier|static
name|int
name|dolist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|type
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|quiet
decl_stmt|;
comment|/* 	 * if we're asking for specific variables don't include the 	 * status header line in the output. 	 */
if|if
condition|(
name|old_rv
condition|)
name|quiet
operator|=
literal|0
expr_stmt|;
else|else
name|quiet
operator|=
operator|(
name|vlist
operator|->
name|name
operator|!=
name|NULL
operator|)
expr_stmt|;
name|res
operator|=
name|doquerylist
argument_list|(
name|vlist
argument_list|,
name|op
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|associd
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No system%s variables returned\n"
argument_list|,
operator|(
name|type
operator|==
name|TYPE_CLOCK
operator|)
condition|?
literal|" clock"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No information returned for%s association %u\n"
argument_list|,
operator|(
name|type
operator|==
name|TYPE_CLOCK
operator|)
condition|?
literal|" clock"
else|:
literal|""
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%d "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|type
argument_list|,
name|quiet
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * readlist - send a read variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|readlist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HMS: I think we want the u_int32 target here, not the u_long */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|type
operator|=
operator|(
literal|0
operator|==
name|associd
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|dolist
argument_list|(
name|g_varlist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|type
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writelist - send a write variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|writelist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HMS: Do we really want uval here? */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|res
operator|=
name|doquerylist
argument_list|(
name|g_varlist
argument_list|,
name|CTL_OP_WRITEVAR
argument_list|,
name|associd
argument_list|,
literal|1
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"done! (no data returned)\n"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%d "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
operator|(
name|associd
operator|!=
literal|0
operator|)
condition|?
name|TYPE_PEER
else|:
name|TYPE_SYS
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * readvar - send a read variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|readvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|2
condition|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
literal|0
operator|==
name|associd
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|dolist
argument_list|(
name|tmplist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|type
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writevar - send a write variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|writevar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|res
operator|=
name|doquerylist
argument_list|(
name|tmplist
argument_list|,
name|CTL_OP_WRITEVAR
argument_list|,
name|associd
argument_list|,
literal|1
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"done! (no data returned)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%d "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
literal|0
operator|==
name|associd
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * clocklist - send a clock variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|clocklist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|dolist
argument_list|(
name|g_varlist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|TYPE_CLOCK
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clockvar - send a clock variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|clockvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|2
condition|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|dolist
argument_list|(
name|tmplist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|TYPE_CLOCK
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * findassidrange - verify a range of association ID's  */
end_comment

begin_function
specifier|static
name|int
name|findassidrange
parameter_list|(
name|u_int32
name|assid1
parameter_list|,
name|u_int32
name|assid2
parameter_list|,
name|int
modifier|*
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|)
block|{
name|associd_t
name|assids
index|[
literal|2
index|]
decl_stmt|;
name|int
name|ind
index|[
name|COUNTOF
argument_list|(
name|assids
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|a
decl_stmt|;
name|assids
index|[
literal|0
index|]
operator|=
name|checkassocid
argument_list|(
name|assid1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|assids
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
name|assids
index|[
literal|1
index|]
operator|=
name|checkassocid
argument_list|(
name|assid2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|assids
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|COUNTOF
argument_list|(
name|assids
argument_list|)
condition|;
name|a
operator|++
control|)
block|{
name|ind
index|[
name|a
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
operator|==
name|assids
index|[
name|a
index|]
condition|)
name|ind
index|[
name|a
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|COUNTOF
argument_list|(
name|assids
argument_list|)
condition|;
name|a
operator|++
control|)
if|if
condition|(
operator|-
literal|1
operator|==
name|ind
index|[
name|a
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association ID %u not found in list\n"
argument_list|,
name|assids
index|[
name|a
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ind
index|[
literal|0
index|]
operator|<
name|ind
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|from
operator|=
name|ind
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|to
operator|=
name|ind
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|to
operator|=
name|ind
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|from
operator|=
name|ind
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * mreadlist - send a read variables request for multiple associations  */
end_comment

begin_function
specifier|static
name|void
name|mreadlist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
operator|!
name|findassidrange
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|uval
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|from
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolist
argument_list|(
name|g_varlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
condition|)
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * mreadvar - send a read variables request for multiple associations  */
end_comment

begin_function
specifier|static
name|void
name|mreadvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
name|struct
name|varlist
modifier|*
name|pvars
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
operator|!
name|findassidrange
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|uval
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|3
condition|)
block|{
name|memset
argument_list|(
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|pvars
operator|=
name|tmplist
expr_stmt|;
block|}
else|else
block|{
name|pvars
operator|=
name|g_varlist
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|from
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolist
argument_list|(
name|pvars
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
condition|)
break|break;
block|}
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * dogetassoc - query the host for its list of associations  */
end_comment

begin_function
specifier|static
name|int
name|dogetassoc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READSTAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No association ID's returned\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dsize
operator|&
literal|0x3
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returned %d octets, should be multiple of 4\n"
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|numassoc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|assid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
operator|(
specifier|const
name|u_short
operator|*
operator|)
name|datap
operator|)
argument_list|)
expr_stmt|;
name|datap
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|status
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
operator|(
specifier|const
name|u_short
operator|*
operator|)
name|datap
operator|)
argument_list|)
expr_stmt|;
name|datap
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|numassoc
operator|>=
name|MAXASSOC
condition|)
break|break;
name|dsize
operator|-=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|sortassoc
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * printassoc - print the current list of associations  */
end_comment

begin_function
specifier|static
name|void
name|printassoc
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|statval
decl_stmt|;
name|int
name|event
decl_stmt|;
name|u_long
name|event_count
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
specifier|const
name|char
modifier|*
name|reach
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth
decl_stmt|;
specifier|const
name|char
modifier|*
name|condition
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_event
decl_stmt|;
specifier|const
name|char
modifier|*
name|cnt
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|numassoc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No association ID's in list\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Output a header 	 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nind assid status  conf reach auth condition  last_event cnt\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"===========================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
name|statval
operator|=
operator|(
name|u_char
operator|)
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|statval
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
name|event
operator|=
name|CTL_PEER_EVENT
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
name|event_count
operator|=
name|CTL_PEER_NEVNT
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_CONFIG
condition|)
name|conf
operator|=
literal|"yes"
expr_stmt|;
else|else
name|conf
operator|=
literal|"no"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_BCAST
condition|)
block|{
name|reach
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENABLE
condition|)
name|auth
operator|=
literal|"yes"
expr_stmt|;
else|else
name|auth
operator|=
literal|"none"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|statval
operator|&
name|CTL_PST_REACH
condition|)
name|reach
operator|=
literal|"yes"
expr_stmt|;
else|else
name|reach
operator|=
literal|"no"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENABLE
condition|)
block|{
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENTIC
condition|)
name|auth
operator|=
literal|"ok "
expr_stmt|;
else|else
name|auth
operator|=
literal|"bad"
expr_stmt|;
block|}
else|else
block|{
name|auth
operator|=
literal|"none"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pktversion
operator|>
name|NTP_OLDVERSION
condition|)
block|{
switch|switch
condition|(
name|statval
operator|&
literal|0x7
condition|)
block|{
case|case
name|CTL_PST_SEL_REJECT
case|:
name|condition
operator|=
literal|"reject"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SANE
case|:
name|condition
operator|=
literal|"falsetick"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_CORRECT
case|:
name|condition
operator|=
literal|"excess"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SELCAND
case|:
name|condition
operator|=
literal|"outlyer"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SYNCCAND
case|:
name|condition
operator|=
literal|"candidate"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_EXCESS
case|:
name|condition
operator|=
literal|"backup"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SYSPEER
case|:
name|condition
operator|=
literal|"sys.peer"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_PPS
case|:
name|condition
operator|=
literal|"pps.peer"
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|statval
operator|&
literal|0x3
condition|)
block|{
case|case
name|OLD_CTL_PST_SEL_REJECT
case|:
if|if
condition|(
operator|!
operator|(
name|statval
operator|&
name|OLD_CTL_PST_SANE
operator|)
condition|)
name|condition
operator|=
literal|"insane"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|statval
operator|&
name|OLD_CTL_PST_DISP
operator|)
condition|)
name|condition
operator|=
literal|"hi_disp"
expr_stmt|;
else|else
name|condition
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SELCAND
case|:
name|condition
operator|=
literal|"sel_cand"
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SYNCCAND
case|:
name|condition
operator|=
literal|"sync_cand"
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SYSPEER
case|:
name|condition
operator|=
literal|"sys_peer"
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|PEER_EVENT
operator||
name|event
condition|)
block|{
case|case
name|PEVNT_MOBIL
case|:
name|last_event
operator|=
literal|"mobilize"
expr_stmt|;
break|break;
case|case
name|PEVNT_DEMOBIL
case|:
name|last_event
operator|=
literal|"demobilize"
expr_stmt|;
break|break;
case|case
name|PEVNT_REACH
case|:
name|last_event
operator|=
literal|"reachable"
expr_stmt|;
break|break;
case|case
name|PEVNT_UNREACH
case|:
name|last_event
operator|=
literal|"unreachable"
expr_stmt|;
break|break;
case|case
name|PEVNT_RESTART
case|:
name|last_event
operator|=
literal|"restart"
expr_stmt|;
break|break;
case|case
name|PEVNT_REPLY
case|:
name|last_event
operator|=
literal|"no_reply"
expr_stmt|;
break|break;
case|case
name|PEVNT_RATE
case|:
name|last_event
operator|=
literal|"rate_exceeded"
expr_stmt|;
break|break;
case|case
name|PEVNT_DENY
case|:
name|last_event
operator|=
literal|"access_denied"
expr_stmt|;
break|break;
case|case
name|PEVNT_ARMED
case|:
name|last_event
operator|=
literal|"leap_armed"
expr_stmt|;
break|break;
case|case
name|PEVNT_NEWPEER
case|:
name|last_event
operator|=
literal|"sys_peer"
expr_stmt|;
break|break;
case|case
name|PEVNT_CLOCK
case|:
name|last_event
operator|=
literal|"clock_alarm"
expr_stmt|;
break|break;
default|default:
name|last_event
operator|=
literal|""
expr_stmt|;
break|break;
block|}
name|cnt
operator|=
name|uinttoa
argument_list|(
name|event_count
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%3d %5u  %04x   %3.3s  %4s  %4.4s %9.9s %11s %2s"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|,
name|conf
argument_list|,
name|reach
argument_list|,
name|auth
argument_list|,
name|condition
argument_list|,
name|last_event
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|>
name|buf
operator|&&
literal|' '
operator|==
name|bp
index|[
operator|-
literal|1
index|]
condition|)
operator|--
name|bp
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * associations - get, record and print a list of associations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|associations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
name|printassoc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lassociations - get, record and print a long list of associations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lassociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
name|printassoc
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * passociations - print the association list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|passociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|printassoc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lpassociations - print the long association list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lpassociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|printassoc
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  saveconfig - dump ntp server configuration to server file  */
end_comment

begin_function
specifier|static
name|void
name|saveconfig
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|pcmd
operator|->
name|nargs
condition|)
return|return;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_SAVECONFIG
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|dsize
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(no response message, curiously)"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.*s"
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_comment
comment|/*  * radiostatus - print the radio status returned by the server  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|radiostatus
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READCLOCK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No radio status string returned\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|asciize
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/*  * pstatus - print peer status returned by the server  */
end_comment

begin_function
specifier|static
name|void
name|pstatus
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READSTAT
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No information returned for association %u\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"associd=%u "
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|TYPE_PEER
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * when - print how long its been since his last packet arrived  */
end_comment

begin_function
specifier|static
name|long
name|when
parameter_list|(
name|l_fp
modifier|*
name|ts
parameter_list|,
name|l_fp
modifier|*
name|rec
parameter_list|,
name|l_fp
modifier|*
name|reftime
parameter_list|)
block|{
name|l_fp
modifier|*
name|lasttime
decl_stmt|;
if|if
condition|(
name|rec
operator|->
name|l_ui
operator|!=
literal|0
condition|)
name|lasttime
operator|=
name|rec
expr_stmt|;
elseif|else
if|if
condition|(
name|reftime
operator|->
name|l_ui
operator|!=
literal|0
condition|)
name|lasttime
operator|=
name|reftime
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
operator|(
name|ts
operator|->
name|l_ui
operator|-
name|lasttime
operator|->
name|l_ui
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pretty-print an interval into the given buffer, in a human-friendly format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|prettyinterval
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|cb
parameter_list|,
name|long
name|diff
parameter_list|)
block|{
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|diff
operator|<=
literal|2048
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ld"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|29
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|300
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ldm"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|29
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|96
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ldh"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|11
operator|)
operator|/
literal|24
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|cb
argument_list|,
literal|"%ldd"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|decodeaddrtype
parameter_list|(
name|sockaddr_u
modifier|*
name|sock
parameter_list|)
block|{
name|char
name|ch
init|=
literal|'-'
decl_stmt|;
name|u_int32
name|dummy
decl_stmt|;
switch|switch
condition|(
name|AF
argument_list|(
name|sock
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|dummy
operator|=
name|SRCADR
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|ch
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|dummy
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0xe0000000
operator|)
condition|?
literal|'m'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0x000000ff
operator|)
operator|==
literal|0x000000ff
operator|)
condition|?
literal|'b'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0x7f000001
operator|)
condition|?
literal|'l'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0xffffffe0
operator|)
operator|==
literal|0x00000000
operator|)
condition|?
literal|'-'
else|:
literal|'u'
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|PSOCK_ADDR6
argument_list|(
name|sock
argument_list|)
argument_list|)
condition|)
name|ch
operator|=
literal|'m'
expr_stmt|;
else|else
name|ch
operator|=
literal|'u'
expr_stmt|;
break|break;
default|default:
name|ch
operator|=
literal|'-'
expr_stmt|;
break|break;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * A list of variables required by the peers command  */
end_comment

begin_decl_stmt
name|struct
name|varlist
name|opeervarlist
index|[]
init|=
block|{
block|{
literal|"srcadr"
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|"dstadr"
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|"stratum"
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|"hpoll"
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|"ppoll"
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
literal|"reach"
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
literal|"delay"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"offset"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|"jitter"
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
literal|"dispersion"
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
literal|"rec"
block|,
literal|0
block|}
block|,
comment|/* 10 */
block|{
literal|"reftime"
block|,
literal|0
block|}
block|,
comment|/* 11 */
block|{
literal|"srcport"
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|varlist
name|peervarlist
index|[]
init|=
block|{
block|{
literal|"srcadr"
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|"refid"
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|"stratum"
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|"hpoll"
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|"ppoll"
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
literal|"reach"
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
literal|"delay"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"offset"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|"jitter"
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
literal|"dispersion"
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
literal|"rec"
block|,
literal|0
block|}
block|,
comment|/* 10 */
block|{
literal|"reftime"
block|,
literal|0
block|}
block|,
comment|/* 11 */
block|{
literal|"srcport"
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAVE_SRCADR
value|0
end_define

begin_define
define|#
directive|define
name|HAVE_DSTADR
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_REFID
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_STRATUM
value|2
end_define

begin_define
define|#
directive|define
name|HAVE_HPOLL
value|3
end_define

begin_define
define|#
directive|define
name|HAVE_PPOLL
value|4
end_define

begin_define
define|#
directive|define
name|HAVE_REACH
value|5
end_define

begin_define
define|#
directive|define
name|HAVE_DELAY
value|6
end_define

begin_define
define|#
directive|define
name|HAVE_OFFSET
value|7
end_define

begin_define
define|#
directive|define
name|HAVE_JITTER
value|8
end_define

begin_define
define|#
directive|define
name|HAVE_DISPERSION
value|9
end_define

begin_define
define|#
directive|define
name|HAVE_REC
value|10
end_define

begin_define
define|#
directive|define
name|HAVE_REFTIME
value|11
end_define

begin_define
define|#
directive|define
name|HAVE_SRCPORT
value|12
end_define

begin_define
define|#
directive|define
name|MAXHAVE
value|13
end_define

begin_comment
comment|/*  * Decode an incoming data buffer and print a line in the peer list  */
end_comment

begin_function
specifier|static
name|int
name|doprintpeers
parameter_list|(
name|struct
name|varlist
modifier|*
name|pvl
parameter_list|,
name|int
name|associd
parameter_list|,
name|int
name|rstatus
parameter_list|,
name|int
name|datalen
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|sockaddr_u
name|srcadr
decl_stmt|;
name|sockaddr_u
name|dstadr
decl_stmt|;
name|sockaddr_u
name|refidadr
decl_stmt|;
name|u_long
name|srcport
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dstadr_refid
init|=
literal|"0.0.0.0"
decl_stmt|;
name|char
modifier|*
name|serverlocal
decl_stmt|;
name|size_t
name|drlen
decl_stmt|;
name|u_long
name|stratum
init|=
literal|0
decl_stmt|;
name|long
name|ppoll
init|=
literal|0
decl_stmt|;
name|long
name|hpoll
init|=
literal|0
decl_stmt|;
name|u_long
name|reach
init|=
literal|0
decl_stmt|;
name|l_fp
name|estoffset
decl_stmt|;
name|l_fp
name|estdelay
decl_stmt|;
name|l_fp
name|estjitter
decl_stmt|;
name|l_fp
name|estdisp
decl_stmt|;
name|l_fp
name|reftime
decl_stmt|;
name|l_fp
name|rec
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|u_char
name|havevar
index|[
name|MAXHAVE
index|]
decl_stmt|;
name|u_long
name|poll_sec
decl_stmt|;
name|char
name|type
init|=
literal|'?'
decl_stmt|;
name|char
name|refid_string
index|[
literal|10
index|]
decl_stmt|;
name|char
name|whenbuf
index|[
literal|8
index|]
decl_stmt|,
name|pollbuf
index|[
literal|8
index|]
decl_stmt|;
name|char
name|clock_name
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|havevar
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|havevar
argument_list|)
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|srcadr
argument_list|)
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|dstadr
argument_list|)
expr_stmt|;
comment|/* Initialize by zeroing out estimate variables */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|estoffset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|estdelay
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|estjitter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|estdisp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|datalen
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|sockaddr_u
name|dum_store
decl_stmt|;
name|i
operator|=
name|findvar
argument_list|(
name|name
argument_list|,
name|peer_var
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't know this one */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|CP_SRCADR
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|srcadr
argument_list|)
condition|)
block|{
name|havevar
index|[
name|HAVE_SRCADR
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CP_DSTADR
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|dum_store
argument_list|)
condition|)
block|{
name|type
operator|=
name|decodeaddrtype
argument_list|(
operator|&
name|dum_store
argument_list|)
expr_stmt|;
name|havevar
index|[
name|HAVE_DSTADR
index|]
operator|=
literal|1
expr_stmt|;
name|dstadr
operator|=
name|dum_store
expr_stmt|;
if|if
condition|(
name|pvl
operator|==
name|opeervarlist
condition|)
block|{
name|dstadr_refid
operator|=
name|trunc_left
argument_list|(
name|stoa
argument_list|(
operator|&
name|dstadr
argument_list|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CP_REFID
case|:
if|if
condition|(
name|pvl
operator|==
name|peervarlist
condition|)
block|{
name|havevar
index|[
name|HAVE_REFID
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'\0'
condition|)
block|{
name|dstadr_refid
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|<=
literal|4
condition|)
block|{
name|refid_string
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|refid_string
index|[
literal|1
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|refid_string
argument_list|)
expr_stmt|;
name|refid_string
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|refid_string
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dstadr_refid
operator|=
name|refid_string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|refidadr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SOCK_UNSPEC
argument_list|(
operator|&
name|refidadr
argument_list|)
condition|)
name|dstadr_refid
operator|=
literal|"0.0.0.0"
expr_stmt|;
elseif|else
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|refidadr
argument_list|)
condition|)
name|dstadr_refid
operator|=
name|refnumtoa
argument_list|(
operator|&
name|refidadr
argument_list|)
expr_stmt|;
else|else
name|dstadr_refid
operator|=
name|stoa
argument_list|(
operator|&
name|refidadr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|havevar
index|[
name|HAVE_REFID
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CP_STRATUM
case|:
if|if
condition|(
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|stratum
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_STRATUM
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_HPOLL
case|:
if|if
condition|(
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|hpoll
argument_list|)
condition|)
block|{
name|havevar
index|[
name|HAVE_HPOLL
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hpoll
operator|<
literal|0
condition|)
name|hpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
break|break;
case|case
name|CP_PPOLL
case|:
if|if
condition|(
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|ppoll
argument_list|)
condition|)
block|{
name|havevar
index|[
name|HAVE_PPOLL
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ppoll
operator|<
literal|0
condition|)
name|ppoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
break|break;
case|case
name|CP_REACH
case|:
if|if
condition|(
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|reach
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_REACH
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_DELAY
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estdelay
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_DELAY
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_OFFSET
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estoffset
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_OFFSET
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_JITTER
case|:
if|if
condition|(
name|pvl
operator|==
name|peervarlist
condition|)
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estjitter
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_JITTER
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_DISPERSION
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estdisp
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_DISPERSION
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_REC
case|:
if|if
condition|(
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|rec
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_REC
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_SRCPORT
case|:
if|if
condition|(
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|srcport
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_SRCPORT
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_REFTIME
case|:
name|havevar
index|[
name|HAVE_REFTIME
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|reftime
argument_list|)
condition|)
name|L_CLR
argument_list|(
operator|&
name|reftime
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * Check to see if the srcport is NTP's port.  If not this probably 	 * isn't a valid peer association. 	 */
if|if
condition|(
name|havevar
index|[
name|HAVE_SRCPORT
index|]
operator|&&
name|srcport
operator|!=
name|NTP_PORT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Got everything, format the line 	 */
name|poll_sec
operator|=
literal|1
operator|<<
name|max
argument_list|(
name|min3
argument_list|(
name|ppoll
argument_list|,
name|hpoll
argument_list|,
name|NTP_MAXPOLL
argument_list|)
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktversion
operator|>
name|NTP_OLDVERSION
condition|)
name|c
operator|=
name|flash3
index|[
name|CTL_PEER_STATVAL
argument_list|(
name|rstatus
argument_list|)
operator|&
literal|0x7
index|]
expr_stmt|;
else|else
name|c
operator|=
name|flash2
index|[
name|CTL_PEER_STATVAL
argument_list|(
name|rstatus
argument_list|)
operator|&
literal|0x3
index|]
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|peervarlist
operator|==
name|pvl
operator|&&
name|havevar
index|[
name|HAVE_DSTADR
index|]
condition|)
block|{
name|serverlocal
operator|=
name|nntohost_col
argument_list|(
operator|&
name|dstadr
argument_list|,
operator|(
name|size_t
operator|)
name|min
argument_list|(
name|LIB_BUFLENGTH
operator|-
literal|1
argument_list|,
name|maxhostlen
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currenthostisnum
condition|)
name|serverlocal
operator|=
name|trunc_left
argument_list|(
name|currenthost
argument_list|,
name|maxhostlen
argument_list|)
expr_stmt|;
else|else
name|serverlocal
operator|=
name|currenthost
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*s "
argument_list|,
name|maxhostlen
argument_list|,
name|serverlocal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AF_UNSPEC
operator|==
name|af
operator|||
name|AF
argument_list|(
operator|&
name|srcadr
argument_list|)
operator|==
name|af
condition|)
block|{
name|strncpy
argument_list|(
name|clock_name
argument_list|,
name|nntohost
argument_list|(
operator|&
name|srcadr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|clock_name
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c%-15.15s "
argument_list|,
name|c
argument_list|,
name|clock_name
argument_list|)
expr_stmt|;
name|drlen
operator|=
name|strlen
argument_list|(
name|dstadr_refid
argument_list|)
expr_stmt|;
name|makeascii
argument_list|(
name|drlen
argument_list|,
name|dstadr_refid
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|drlen
operator|++
operator|<
literal|15
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %2ld %c %4.4s %4.4s  %3lo  %7.7s %8.7s %7.7s\n"
argument_list|,
name|stratum
argument_list|,
name|type
argument_list|,
name|prettyinterval
argument_list|(
name|whenbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|whenbuf
argument_list|)
argument_list|,
name|when
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|rec
argument_list|,
operator|&
name|reftime
argument_list|)
argument_list|)
argument_list|,
name|prettyinterval
argument_list|(
name|pollbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pollbuf
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|poll_sec
argument_list|)
argument_list|,
name|reach
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|estdelay
argument_list|,
literal|3
argument_list|)
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|estoffset
argument_list|,
literal|3
argument_list|)
argument_list|,
operator|(
name|havevar
index|[
name|HAVE_JITTER
index|]
operator|)
condition|?
name|lfptoms
argument_list|(
operator|&
name|estjitter
argument_list|,
literal|3
argument_list|)
else|:
name|lfptoms
argument_list|(
operator|&
name|estdisp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|HAVE_SRCADR
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_DSTADR
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_STRATUM
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_PPOLL
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_HPOLL
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REACH
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_ESTDELAY
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_ESTOFFSET
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_JITTER
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_ESTDISP
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REFID
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REC
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_SRCPORT
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REFTIME
end_undef

begin_undef
undef|#
directive|undef
name|MAXHAVE
end_undef

begin_comment
comment|/*  * dogetpeers - given an association ID, read and print the spreadsheet  *		peer variables.  */
end_comment

begin_function
specifier|static
name|int
name|dogetpeers
parameter_list|(
name|struct
name|varlist
modifier|*
name|pvl
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|res
operator|=
name|doquerylist
argument_list|(
name|pvl
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Damn fuzzballs 	 */
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No information returned for association %u\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|doprintpeers
argument_list|(
name|pvl
argument_list|,
name|associd
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * peers - print a peer spreadsheet  */
end_comment

begin_function
specifier|static
name|void
name|dopeers
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|fullname
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|sockaddr_u
name|netnum
decl_stmt|;
name|char
modifier|*
name|name_or_num
decl_stmt|;
name|size_t
name|sl
decl_stmt|;
if|if
condition|(
operator|!
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numhosts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|getnetnum
argument_list|(
name|chosts
index|[
name|i
index|]
argument_list|,
operator|&
name|netnum
argument_list|,
name|fullname
argument_list|,
name|af
argument_list|)
condition|)
block|{
name|name_or_num
operator|=
name|nntohost
argument_list|(
operator|&
name|netnum
argument_list|)
expr_stmt|;
name|sl
operator|=
name|strlen
argument_list|(
name|name_or_num
argument_list|)
expr_stmt|;
name|maxhostlen
operator|=
name|max
argument_list|(
name|maxhostlen
argument_list|,
operator|(
name|int
operator|)
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s "
argument_list|,
name|maxhostlen
argument_list|,
name|maxhostlen
argument_list|,
literal|"server (local)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"     remote           refid      st t when poll reach   delay   offset  jitter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxhostlen
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dogetpeers
argument_list|(
name|peervarlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * peers - print a peer spreadsheet  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|peers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|dopeers
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lpeers - print a peer spreadsheet including all fuzzball peers  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lpeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|dopeers
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * opeers - print a peer spreadsheet  */
end_comment

begin_function
specifier|static
name|void
name|doopeers
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|af
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|fullname
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|sockaddr_u
name|netnum
decl_stmt|;
if|if
condition|(
operator|!
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numhosts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|getnetnum
argument_list|(
name|chosts
index|[
name|i
index|]
argument_list|,
operator|&
name|netnum
argument_list|,
name|fullname
argument_list|,
name|af
argument_list|)
condition|)
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fullname
argument_list|)
operator|>
name|maxhostlen
condition|)
name|maxhostlen
operator|=
name|strlen
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s "
argument_list|,
name|maxhostlen
argument_list|,
name|maxhostlen
argument_list|,
literal|"server"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"     remote           local      st t when poll reach   delay   offset    disp\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxhostlen
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dogetpeers
argument_list|(
name|opeervarlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * opeers - print a peer spreadsheet the old way  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|opeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|doopeers
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lopeers - print a peer spreadsheet including all fuzzball peers  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lopeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
operator|->
name|ival
operator|==
literal|6
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET
expr_stmt|;
block|}
name|doopeers
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * config - send a configuration command to a remote host  */
end_comment

begin_function
specifier|static
name|void
name|config
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|cfgcmd
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|char
modifier|*
name|resp
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cfgcmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In Config\n"
literal|"Keyword = %s\n"
literal|"Command = %s\n"
argument_list|,
name|pcmd
operator|->
name|keyword
argument_list|,
name|cfgcmd
argument_list|)
expr_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_CONFIGURE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|cfgcmd
argument_list|)
argument_list|,
name|cfgcmd
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|rsize
operator|>
literal|0
operator|&&
literal|'\n'
operator|==
name|rdata
index|[
name|rsize
operator|-
literal|1
index|]
condition|)
name|rsize
operator|--
expr_stmt|;
name|resp
operator|=
name|emalloc
argument_list|(
name|rsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|resp
argument_list|,
name|rdata
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|resp
index|[
name|rsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|col
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|resp
argument_list|,
literal|"column %d syntax error"
argument_list|,
operator|&
name|col
argument_list|)
operator|&&
name|col
operator|>=
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|col
operator|<=
name|strlen
argument_list|(
name|cfgcmd
argument_list|)
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
block|{
name|printf
argument_list|(
literal|"______"
argument_list|)
expr_stmt|;
comment|/* "ntpq> " */
name|printf
argument_list|(
literal|"________"
argument_list|)
expr_stmt|;
comment|/* ":config " */
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cfgcmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|col
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"^\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * config_from_file - remotely configure an ntpd daemon using the  * specified configuration file  * SK: This function is a kludge at best and is full of bad design  * bugs:  * 1. ntpq uses UDP, which means that there is no guarantee of in-order,  *    error-free delivery.   * 2. The maximum length of a packet is constrained, and as a result, the  *    maximum length of a line in a configuration file is constrained.   *    Longer lines will lead to unpredictable results.  * 3. Since this function is sending a line at a time, we can't update  *    the control key through the configuration file (YUCK!!)  */
end_comment

begin_function
specifier|static
name|void
name|config_from_file
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|u_short
name|rstatus
decl_stmt|;
name|int
name|rsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|rdata
decl_stmt|;
name|int
name|res
decl_stmt|;
name|FILE
modifier|*
name|config_fd
decl_stmt|;
name|char
name|config_cmd
index|[
name|MAXLINE
index|]
decl_stmt|;
name|size_t
name|config_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retry_limit
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In Config\n"
literal|"Keyword = %s\n"
literal|"Filename = %s\n"
argument_list|,
name|pcmd
operator|->
name|keyword
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|config_fd
operator|=
name|fopen
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|config_fd
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR!! Couldn't open file: %s\n"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Sending configuration file, one line at a time.\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|config_cmd
argument_list|,
name|MAXLINE
argument_list|,
name|config_fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|config_len
operator|=
name|strlen
argument_list|(
name|config_cmd
argument_list|)
expr_stmt|;
comment|/* ensure even the last line has newline, if possible */
if|if
condition|(
name|config_len
operator|>
literal|0
operator|&&
name|config_len
operator|+
literal|2
operator|<
sizeof|sizeof
argument_list|(
name|config_cmd
argument_list|)
operator|&&
literal|'\n'
operator|!=
name|config_cmd
index|[
name|config_len
operator|-
literal|1
index|]
condition|)
name|config_cmd
index|[
name|config_len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|retry_limit
operator|=
literal|2
expr_stmt|;
do|do
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_CONFIGURE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|config_cmd
argument_list|)
argument_list|,
name|config_cmd
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
do|while
condition|(
name|res
operator|!=
literal|0
operator|&&
name|retry_limit
operator|--
condition|)
do|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Line No: %d query failed: %s"
argument_list|,
name|i
argument_list|,
name|config_cmd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Subsequent lines not sent.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|config_fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rsize
operator|>
literal|0
operator|&&
literal|'\n'
operator|==
name|rdata
index|[
name|rsize
operator|-
literal|1
index|]
condition|)
name|rsize
operator|--
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
literal|0
operator|&&
literal|'\r'
operator|==
name|rdata
index|[
name|rsize
operator|-
literal|1
index|]
condition|)
name|rsize
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"Line No: %d %.*s: %s"
argument_list|,
name|i
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|config_cmd
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Done sending file\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|config_fd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

