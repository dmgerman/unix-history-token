begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2011-2015 Samy Al Bahra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CK_COMMON_H
end_ifndef

begin_define
define|#
directive|define
name|CK_COMMON_H
end_define

begin_include
include|#
directive|include
file|<ck_cc.h>
end_include

begin_include
include|#
directive|include
file|<ck_pr.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__MACH__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<mach/mach.h>
end_include

begin_include
include|#
directive|include
file|<mach/thread_policy.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|NOMINMAX
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_define
define|#
directive|define
name|DELTA_EPOCH
value|11644473600000000ULL
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CORES
end_ifndef

begin_define
define|#
directive|define
name|CORES
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|CK_CC_INLINE
specifier|static
name|void
name|common_srand
parameter_list|(
name|unsigned
name|int
name|i
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|srand
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|int
name|common_rand
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
return|return
name|rand
argument_list|()
return|;
else|#
directive|else
return|return
name|random
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|int
name|common_rand_r
parameter_list|(
name|unsigned
name|int
modifier|*
name|i
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
operator|(
name|void
operator|)
name|i
expr_stmt|;
comment|/* 	 * When linked with -mthreads, rand() is thread-safe. 	 * rand_s is also an option. 	 */
return|return
name|rand
argument_list|()
return|;
else|#
directive|else
return|return
name|rand_r
argument_list|(
name|i
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|void
name|common_srand48
parameter_list|(
name|long
name|int
name|i
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|srand
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|srand48
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|long
name|int
name|common_lrand48
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
return|return
name|rand
argument_list|()
return|;
else|#
directive|else
return|return
name|lrand48
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|double
name|common_drand48
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
return|return
operator|(
name|double
operator|)
name|rand
argument_list|()
operator|/
name|RAND_MAX
return|;
else|#
directive|else
return|return
name|drand48
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|void
name|common_sleep
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|Sleep
argument_list|(
name|n
operator|*
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|sleep
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|int
name|common_gettimeofday
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
name|void
modifier|*
name|tz
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|FILETIME
name|ft
decl_stmt|;
name|uint64_t
name|tmp_time
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|tzflag
init|=
name|false
decl_stmt|;
name|struct
name|timezone
modifier|*
name|tzp
init|=
name|tz
decl_stmt|;
if|if
condition|(
name|tv
operator|!=
name|NULL
condition|)
block|{
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|ft
argument_list|)
expr_stmt|;
name|tmp_time
operator||=
name|ft
operator|.
name|dwHighDateTime
expr_stmt|;
name|tmp_time
operator|<<=
literal|32
expr_stmt|;
name|tmp_time
operator||=
name|ft
operator|.
name|dwLowDateTime
expr_stmt|;
comment|/* GetSystemTimeAsFileTime returns 100 nanosecond intervals. */
name|tmp_time
operator|/=
literal|10
expr_stmt|;
comment|/* Windows' epoch starts on 01/01/1601, while Unix' starts on 01/01/1970. */
name|tmp_time
operator|-=
name|DELTA_EPOCH
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
call|(
name|long
call|)
argument_list|(
name|tmp_time
operator|/
literal|1000000UL
argument_list|)
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|tmp_time
operator|%
literal|1000000UL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tz
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tzflag
operator|==
name|false
condition|)
block|{
name|_tzset
argument_list|()
expr_stmt|;
name|tzflag
operator|=
name|true
expr_stmt|;
block|}
name|tzp
operator|->
name|tz_minuteswest
operator|=
name|_timezone
operator|/
literal|60
expr_stmt|;
name|tzp
operator|->
name|tz_dsttime
operator|=
name|_daylight
expr_stmt|;
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
name|gettimeofday
argument_list|(
name|tv
argument_list|,
name|tz
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_UNUSED
specifier|static
name|unsigned
name|int
name|common_alarm
parameter_list|(
name|void
function_decl|(
modifier|*
name|sig_handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
name|void
modifier|*
name|alarm_event
parameter_list|,
name|unsigned
name|int
name|duration
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
operator|(
name|void
operator|)
name|sig_handler
expr_stmt|;
operator|(
name|void
operator|)
name|duration
expr_stmt|;
name|bool
name|success
decl_stmt|;
name|HANDLE
modifier|*
name|alarm_handle
init|=
name|alarm_event
decl_stmt|;
name|success
operator|=
name|SetEvent
argument_list|(
operator|*
name|alarm_handle
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|success
operator|!=
name|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|alarm_event
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sig_handler
argument_list|)
expr_stmt|;
return|return
name|alarm
argument_list|(
name|duration
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SECOND_TIMER
end_ifndef

begin_define
define|#
directive|define
name|SECOND_TIMER
value|10000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COMMON_ALARM_DECLARE_GLOBAL
parameter_list|(
name|prefix
parameter_list|,
name|alarm_event_name
parameter_list|,
name|flag_name
parameter_list|)
define|\
value|static HANDLE prefix##_common_win_alarm_timer;								\ static HANDLE alarm_event_name;										\ static LARGE_INTEGER prefix##_common_alarm_timer_length;						\ 													\ static void CALLBACK											\ prefix##_common_win_alarm_handler(LPVOID arg, DWORD timer_low_value, DWORD timer_high_value)		\ {													\ 	(void)arg;											\ 	(void)timer_low_value;										\ 	(void)timer_high_value;										\ 	flag_name = true;										\ 	return;												\ }													\ 													\ static void *												\ prefix##_common_win_alarm(void *unused)									\ {													\ 	(void)unused;											\ 	bool timer_success = false;									\ 	for (;;) {											\ 		WaitForSingleObjectEx(alarm_event_name, INFINITE, true);				\ 		timer_success = SetWaitableTimer(prefix##_common_win_alarm_timer,			\&prefix##_common_alarm_timer_length,			\ 						 0,							\ 						 prefix##_common_win_alarm_handler, NULL, false);	\ 		assert(timer_success != false);								\ 		WaitForSingleObjectEx(prefix##_common_win_alarm_timer, INFINITE, true);			\ 	}												\ 													\ 	return NULL;											\ }
end_define

begin_define
define|#
directive|define
name|COMMON_ALARM_DECLARE_LOCAL
parameter_list|(
name|prefix
parameter_list|,
name|alarm_event_name
parameter_list|)
define|\
value|int64_t prefix##_common_alarm_tl;			\ 	pthread_t prefix##_common_win_alarm_thread;
end_define

begin_define
define|#
directive|define
name|COMMON_ALARM_INIT
parameter_list|(
name|prefix
parameter_list|,
name|alarm_event_name
parameter_list|,
name|duration
parameter_list|)
define|\
value|prefix##_common_alarm_tl = -1 * (duration) * SECOND_TIMER;			\ 	prefix##_common_alarm_timer_length.LowPart =					\ 		(DWORD) (prefix##_common_alarm_tl& 0xFFFFFFFF);			\ 	prefix##_common_alarm_timer_length.HighPart = 					\ 		(LONG) (prefix##_common_alarm_tl>> 32);				\ 	alarm_event_name = CreateEvent(NULL, false, false, NULL);			\ 	assert(alarm_event_name != NULL);						\ 	prefix##_common_win_alarm_timer = CreateWaitableTimer(NULL, true, NULL);	\ 	assert(prefix##_common_win_alarm_timer != NULL);				\ 	if (pthread_create(&prefix##_common_win_alarm_thread,				\ 			   NULL,							\ 			   prefix##_common_win_alarm,					\ 			   NULL) != 0)							\ 		ck_error("ERROR: Failed to create common_win_alarm thread.\n");
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COMMON_ALARM_DECLARE_GLOBAL
parameter_list|(
name|prefix
parameter_list|,
name|alarm_event_name
parameter_list|,
name|flag_name
parameter_list|)
end_define

begin_define
define|#
directive|define
name|COMMON_ALARM_DECLARE_LOCAL
parameter_list|(
name|prefix
parameter_list|,
name|alarm_event_name
parameter_list|)
define|\
value|int alarm_event_name = 0;
end_define

begin_define
define|#
directive|define
name|COMMON_ALARM_INIT
parameter_list|(
name|prefix
parameter_list|,
name|alarm_event_name
parameter_list|,
name|duration
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|affinity
block|{
name|unsigned
name|int
name|delta
decl_stmt|;
name|unsigned
name|int
name|request
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AFFINITY_INITIALIZER
value|{0, 0}
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|gettid
end_ifndef

begin_function
specifier|static
name|pid_t
name|gettid
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|syscall
argument_list|(
name|__NR_gettid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* gettid */
end_comment

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
parameter_list|)
block|{
name|cpu_set_t
name|s
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ck_pr_faa_uint
argument_list|(
operator|&
name|acb
operator|->
name|request
argument_list|,
name|acb
operator|->
name|delta
argument_list|)
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
name|c
operator|%
name|CORES
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
name|sched_setaffinity
argument_list|(
name|gettid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate_core
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
parameter_list|,
name|unsigned
name|int
modifier|*
name|core
parameter_list|)
block|{
name|cpu_set_t
name|s
decl_stmt|;
operator|*
name|core
operator|=
name|ck_pr_faa_uint
argument_list|(
operator|&
name|acb
operator|->
name|request
argument_list|,
name|acb
operator|->
name|delta
argument_list|)
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
operator|(
operator|*
name|core
operator|)
operator|%
name|CORES
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
name|sched_setaffinity
argument_list|(
name|gettid
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__MACH__
argument_list|)
end_elif

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
parameter_list|)
block|{
name|thread_affinity_policy_data_t
name|policy
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ck_pr_faa_uint
argument_list|(
operator|&
name|acb
operator|->
name|request
argument_list|,
name|acb
operator|->
name|delta
argument_list|)
operator|%
name|CORES
expr_stmt|;
name|policy
operator|.
name|affinity_tag
operator|=
name|c
expr_stmt|;
return|return
name|thread_policy_set
argument_list|(
name|mach_thread_self
argument_list|()
argument_list|,
name|THREAD_AFFINITY_POLICY
argument_list|,
operator|(
name|thread_policy_t
operator|)
operator|&
name|policy
argument_list|,
name|THREAD_AFFINITY_POLICY_COUNT
argument_list|)
return|;
block|}
end_function

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate_core
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
parameter_list|,
name|unsigned
name|int
modifier|*
name|core
parameter_list|)
block|{
name|thread_affinity_policy_data_t
name|policy
decl_stmt|;
operator|*
name|core
operator|=
name|ck_pr_faa_uint
argument_list|(
operator|&
name|acb
operator|->
name|request
argument_list|,
name|acb
operator|->
name|delta
argument_list|)
operator|%
name|CORES
expr_stmt|;
name|policy
operator|.
name|affinity_tag
operator|=
operator|*
name|core
expr_stmt|;
return|return
name|thread_policy_set
argument_list|(
name|mach_thread_self
argument_list|()
argument_list|,
name|THREAD_AFFINITY_POLICY
argument_list|,
operator|(
name|thread_policy_t
operator|)
operator|&
name|policy
argument_list|,
name|THREAD_AFFINITY_POLICY_COUNT
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
name|CK_CC_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|cpuset_t
name|mask
decl_stmt|;
name|c
operator|=
name|ck_pr_faa_uint
argument_list|(
operator|&
name|acb
operator|->
name|request
argument_list|,
name|acb
operator|->
name|delta
argument_list|)
operator|%
name|CORES
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
name|c
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpuset_setaffinity
argument_list|(
name|CPU_LEVEL_WHICH
argument_list|,
name|CPU_WHICH_TID
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate_core
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
name|CK_CC_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|core
parameter_list|)
block|{
name|cpuset_t
name|mask
decl_stmt|;
operator|*
name|core
operator|=
name|ck_pr_faa_uint
argument_list|(
operator|&
name|acb
operator|->
name|request
argument_list|,
name|acb
operator|->
name|delta
argument_list|)
operator|%
name|CORES
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
operator|*
name|core
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpuset_setaffinity
argument_list|(
name|CPU_LEVEL_WHICH
argument_list|,
name|CPU_WHICH_TID
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
name|CK_CC_UNUSED
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|CK_CC_UNUSED
specifier|static
name|int
name|aff_iterate_core
parameter_list|(
name|struct
name|affinity
modifier|*
name|acb
name|CK_CC_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|core
parameter_list|)
block|{
operator|*
name|core
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|CK_CC_INLINE
specifier|static
name|uint64_t
name|rdtsc
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
name|uint32_t
name|eax
init|=
literal|0
decl_stmt|,
name|edx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CK_MD_RDTSCP
argument_list|)
asm|__asm__
specifier|__volatile__
asm|("rdtscp" 				: "+a" (eax), "=d" (edx) 				: 				: "%ecx", "memory");
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator|)
operator||
name|eax
operator|)
return|;
else|#
directive|else
asm|__asm__
specifier|__volatile__
asm|("cpuid;"                              "rdtsc;"                                 : "+a" (eax), "=d" (edx)                                 :                                 : "%ebx", "%ecx", "memory");
asm|__asm__
specifier|__volatile__
asm|("xorl %%eax, %%eax;"                              "cpuid;"                                 :                                 :                                 : "%eax", "%ebx", "%ecx", "%edx", "memory");
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator|)
operator||
name|eax
operator|)
return|;
endif|#
directive|endif
comment|/* !CK_MD_RDTSCP */
elif|#
directive|elif
name|defined
argument_list|(
name|__x86__
argument_list|)
name|uint32_t
name|eax
init|=
literal|0
decl_stmt|,
name|edx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CK_MD_RDTSCP
argument_list|)
asm|__asm__
specifier|__volatile__
asm|("rdtscp" 				: "+a" (eax), "=d" (edx) 				: 				: "%ecx", "memory");
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator|)
operator||
name|eax
operator|)
return|;
else|#
directive|else
asm|__asm__
specifier|__volatile__
asm|("pushl %%ebx;" 			     "cpuid;"                              "rdtsc;"                                 : "+a" (eax), "=d" (edx)                                 :                                 : "%ecx", "memory");
asm|__asm__
specifier|__volatile__
asm|("xorl %%eax, %%eax;"                              "cpuid;" 			     "popl %%ebx;"                                 :                                 :                                 : "%eax", "%ecx", "%edx", "memory");
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator|)
operator||
name|eax
operator|)
return|;
endif|#
directive|endif
comment|/* !CK_MD_RDTSCP */
elif|#
directive|elif
name|defined
argument_list|(
name|__sparcv9__
argument_list|)
name|uint64_t
name|r
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("rd %%tick, %0" 				: "=r" (r) 				: 				: "memory");
return|return
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__ppc64__
argument_list|)
name|uint32_t
name|high
decl_stmt|,
name|low
decl_stmt|,
name|snapshot
decl_stmt|;
do|do
block|{
asm|__asm__
specifier|__volatile__
asm|("isync;" 			       "mftbu %0;" 			       "mftb  %1;" 			       "mftbu %2;" 				: "=r" (high), "=r" (low), "=r" (snapshot) 				: 				: "memory");
block|}
do|while
condition|(
name|snapshot
operator|!=
name|high
condition|)
do|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|high
operator|<<
literal|32
operator|)
operator||
name|low
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CK_CC_USED
specifier|static
name|void
name|ck_error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ck_test
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if (A)					\ 		ck_error(B, ##__VA_ARGS__);	\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_COMMON_H */
end_comment

end_unit

