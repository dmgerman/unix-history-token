begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2008-2013, Troy D. Hanson   http://troydhanson.github.com/uthash/ All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_comment
comment|/* a dynamic string implementation using macros   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UTSTRING_H
end_ifndef

begin_define
define|#
directive|define
name|UTSTRING_H
end_define

begin_define
define|#
directive|define
name|UTSTRING_VERSION
value|1.9.8
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|_UNUSED_
value|__attribute__ ((__unused__))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_UNUSED_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|oom
end_ifndef

begin_define
define|#
directive|define
name|oom
parameter_list|()
value|exit(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|void
modifier|*
modifier|*
name|pd
decl_stmt|;
name|size_t
name|n
decl_stmt|;
comment|/* allocd size */
name|size_t
name|i
decl_stmt|;
comment|/* index of first unused byte */
block|}
name|UT_string
typedef|;
end_typedef

begin_define
define|#
directive|define
name|utstring_reserve
parameter_list|(
name|s
parameter_list|,
name|amt
parameter_list|)
define|\
value|do {                                                       \   if (((s)->n - (s)->i)< (size_t)(amt)) {                 \      (s)->d = (char*)realloc((s)->d, (s)->n + amt);        \      if ((s)->d == NULL) oom();                            \      (s)->n += amt;                                        \      if ((s)->pd) *((s)->pd) = (s)->d;                     \   }                                                        \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_init
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                       \   (s)->n = 0; (s)->i = 0; (s)->d = NULL;                   \   utstring_reserve(s,128);                                 \   (s)->d[0] = '\0'; \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_done
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                       \   if ((s)->d != NULL) free((s)->d);                        \   (s)->n = 0;                                              \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_free
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                       \   utstring_done(s);                                        \   free(s);                                                 \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_new
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                       \    s = (UT_string*)calloc(1, sizeof(UT_string));          \    if (!s) oom();                                          \    utstring_init(s);                                       \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_renew
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                       \    if (s) {                                                \      utstring_clear(s);                                    \    } else {                                                \      utstring_new(s);                                      \    }                                                       \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_clear
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                       \   (s)->i = 0;                                              \   (s)->d[0] = '\0';                                        \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_bincpy
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|,
name|l
parameter_list|)
define|\
value|do {                                                       \   utstring_reserve((s),(l)+1);                               \   if (l) memcpy(&(s)->d[(s)->i], b, l);                    \   (s)->i += l;                                               \   (s)->d[(s)->i]='\0';                                         \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_concat
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|do {                                                             \   utstring_reserve((dst),((src)->i)+1);                          \   if ((src)->i) memcpy(&(dst)->d[(dst)->i], (src)->d, (src)->i); \   (dst)->i += (src)->i;                                          \   (dst)->d[(dst)->i]='\0';                                       \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_len
parameter_list|(
name|s
parameter_list|)
value|((unsigned)((s)->i))
end_define

begin_define
define|#
directive|define
name|utstring_body
parameter_list|(
name|s
parameter_list|)
value|((s)->d)
end_define

begin_function
name|_UNUSED_
specifier|static
name|void
name|utstring_printf_va
parameter_list|(
name|UT_string
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|va_list
name|cp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|cp
operator|=
name|ap
expr_stmt|;
else|#
directive|else
name|va_copy
argument_list|(
name|cp
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|vsnprintf
argument_list|(
operator|&
name|s
operator|->
name|d
index|[
name|s
operator|->
name|i
index|]
argument_list|,
name|s
operator|->
name|n
operator|-
name|s
operator|->
name|i
argument_list|,
name|fmt
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|n
operator|<
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|n
operator|-
name|s
operator|->
name|i
argument_list|)
operator|)
condition|)
block|{
name|s
operator|->
name|i
operator|+=
name|n
expr_stmt|;
return|return;
block|}
comment|/* Else try again with more space. */
if|if
condition|(
name|n
operator|>
operator|-
literal|1
condition|)
name|utstring_reserve
argument_list|(
name|s
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* exact */
else|else
name|utstring_reserve
argument_list|(
name|s
argument_list|,
operator|(
name|s
operator|->
name|n
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 2x */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_comment
comment|/* support printf format checking (2=the format string, 3=start of varargs) */
end_comment

begin_function_decl
specifier|static
name|void
name|utstring_printf
parameter_list|(
name|UT_string
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|( format
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|) ))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|_UNUSED_
specifier|static
name|void
name|utstring_printf
parameter_list|(
name|UT_string
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|utstring_printf_va
argument_list|(
name|s
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|utstring_append_len
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
define|\
value|do {                                                                           \     while ((dst)->n-(dst)->i<= (len)) utstring_reserve((dst),((dst)->n)*2);   \     memcpy(&(dst)->d[(dst)->i], (src), (len));                                 \     (dst)->i+=(len);                                                           \     (dst)->d[(dst)->i]='\0';                                                   \ } while(0)
end_define

begin_define
define|#
directive|define
name|utstring_append_c
parameter_list|(
name|dst
parameter_list|,
name|c
parameter_list|)
define|\
value|do {                                                                           \     if ((dst)->n-(dst)->i< 2) utstring_reserve((dst),((dst)->n)*2);            \     (dst)->d[(dst)->i++] = (c);                                                \     (dst)->d[(dst)->i]='\0';                                                   \ } while(0)
end_define

begin_comment
comment|/*******************************************************************************  * begin substring search functions                                            *  ******************************************************************************/
end_comment

begin_comment
comment|/* Build KMP table from left to right. */
end_comment

begin_function
name|_UNUSED_
specifier|static
name|void
name|_utstring_BuildTable
parameter_list|(
specifier|const
name|char
modifier|*
name|P_Needle
parameter_list|,
name|ssize_t
name|P_NeedleLen
parameter_list|,
name|long
modifier|*
name|P_KMP_Table
parameter_list|)
block|{
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|P_KMP_Table
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|P_NeedleLen
condition|)
block|{
while|while
condition|(
operator|(
name|j
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|P_Needle
index|[
name|i
index|]
operator|!=
name|P_Needle
index|[
name|j
index|]
operator|)
condition|)
block|{
name|j
operator|=
name|P_KMP_Table
index|[
name|j
index|]
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|P_NeedleLen
condition|)
block|{
if|if
condition|(
name|P_Needle
index|[
name|i
index|]
operator|==
name|P_Needle
index|[
name|j
index|]
condition|)
block|{
name|P_KMP_Table
index|[
name|i
index|]
operator|=
name|P_KMP_Table
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|P_KMP_Table
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
else|else
block|{
name|P_KMP_Table
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Build KMP table from right to left. */
end_comment

begin_function
name|_UNUSED_
specifier|static
name|void
name|_utstring_BuildTableR
parameter_list|(
specifier|const
name|char
modifier|*
name|P_Needle
parameter_list|,
name|ssize_t
name|P_NeedleLen
parameter_list|,
name|long
modifier|*
name|P_KMP_Table
parameter_list|)
block|{
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|P_NeedleLen
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|P_KMP_Table
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|j
operator|<
name|P_NeedleLen
operator|)
operator|&&
operator|(
name|P_Needle
index|[
name|i
index|]
operator|!=
name|P_Needle
index|[
name|j
index|]
operator|)
condition|)
block|{
name|j
operator|=
name|P_KMP_Table
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|P_Needle
index|[
name|i
index|]
operator|==
name|P_Needle
index|[
name|j
index|]
condition|)
block|{
name|P_KMP_Table
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|P_KMP_Table
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|P_KMP_Table
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
else|else
block|{
name|P_KMP_Table
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Search data from left to right. ( Multiple search mode. ) */
end_comment

begin_function
name|_UNUSED_
specifier|static
name|long
name|_utstring_find
parameter_list|(
specifier|const
name|char
modifier|*
name|P_Haystack
parameter_list|,
name|size_t
name|P_HaystackLen
parameter_list|,
specifier|const
name|char
modifier|*
name|P_Needle
parameter_list|,
name|size_t
name|P_NeedleLen
parameter_list|,
name|long
modifier|*
name|P_KMP_Table
parameter_list|)
block|{
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|V_FindPosition
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Search from left to right. */
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|<
operator|(
name|int
operator|)
name|P_HaystackLen
operator|)
operator|&&
operator|(
operator|(
operator|(
name|P_HaystackLen
operator|-
name|j
operator|)
operator|+
name|i
operator|)
operator|>=
name|P_NeedleLen
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|P_Needle
index|[
name|i
index|]
operator|!=
name|P_Haystack
index|[
name|j
index|]
operator|)
condition|)
block|{
name|i
operator|=
name|P_KMP_Table
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|int
operator|)
name|P_NeedleLen
condition|)
block|{
comment|/* Found. */
name|V_FindPosition
operator|=
name|j
operator|-
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
name|V_FindPosition
return|;
block|}
end_function

begin_comment
comment|/* Search data from right to left. ( Multiple search mode. ) */
end_comment

begin_function
name|_UNUSED_
specifier|static
name|long
name|_utstring_findR
parameter_list|(
specifier|const
name|char
modifier|*
name|P_Haystack
parameter_list|,
name|size_t
name|P_HaystackLen
parameter_list|,
specifier|const
name|char
modifier|*
name|P_Needle
parameter_list|,
name|size_t
name|P_NeedleLen
parameter_list|,
name|long
modifier|*
name|P_KMP_Table
parameter_list|)
block|{
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|V_FindPosition
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Search from right to left. */
name|j
operator|=
operator|(
name|P_HaystackLen
operator|-
literal|1
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|P_NeedleLen
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|j
operator|>=
name|i
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|P_NeedleLen
operator|)
operator|&&
operator|(
name|P_Needle
index|[
name|i
index|]
operator|!=
name|P_Haystack
index|[
name|j
index|]
operator|)
condition|)
block|{
name|i
operator|=
name|P_KMP_Table
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Found. */
name|V_FindPosition
operator|=
name|j
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|V_FindPosition
return|;
block|}
end_function

begin_comment
comment|/* Search data from left to right. ( One time search mode. ) */
end_comment

begin_function
name|_UNUSED_
specifier|static
name|long
name|utstring_find
parameter_list|(
name|UT_string
modifier|*
name|s
parameter_list|,
name|long
name|P_StartPosition
parameter_list|,
comment|/* Start from 0. -1 means last position. */
specifier|const
name|char
modifier|*
name|P_Needle
parameter_list|,
name|ssize_t
name|P_NeedleLen
parameter_list|)
block|{
name|long
name|V_StartPosition
decl_stmt|;
name|long
name|V_HaystackLen
decl_stmt|;
name|long
modifier|*
name|V_KMP_Table
decl_stmt|;
name|long
name|V_FindPosition
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|P_StartPosition
operator|<
literal|0
condition|)
block|{
name|V_StartPosition
operator|=
name|s
operator|->
name|i
operator|+
name|P_StartPosition
expr_stmt|;
block|}
else|else
block|{
name|V_StartPosition
operator|=
name|P_StartPosition
expr_stmt|;
block|}
name|V_HaystackLen
operator|=
name|s
operator|->
name|i
operator|-
name|V_StartPosition
expr_stmt|;
if|if
condition|(
operator|(
name|V_HaystackLen
operator|>=
name|P_NeedleLen
operator|)
operator|&&
operator|(
name|P_NeedleLen
operator|>
literal|0
operator|)
condition|)
block|{
name|V_KMP_Table
operator|=
operator|(
name|long
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
operator|(
name|P_NeedleLen
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_KMP_Table
operator|!=
name|NULL
condition|)
block|{
name|_utstring_BuildTable
argument_list|(
name|P_Needle
argument_list|,
name|P_NeedleLen
argument_list|,
name|V_KMP_Table
argument_list|)
expr_stmt|;
name|V_FindPosition
operator|=
name|_utstring_find
argument_list|(
name|s
operator|->
name|d
operator|+
name|V_StartPosition
argument_list|,
name|V_HaystackLen
argument_list|,
name|P_Needle
argument_list|,
name|P_NeedleLen
argument_list|,
name|V_KMP_Table
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_FindPosition
operator|>=
literal|0
condition|)
block|{
name|V_FindPosition
operator|+=
name|V_StartPosition
expr_stmt|;
block|}
name|free
argument_list|(
name|V_KMP_Table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|V_FindPosition
return|;
block|}
end_function

begin_comment
comment|/* Search data from right to left. ( One time search mode. ) */
end_comment

begin_function
name|_UNUSED_
specifier|static
name|long
name|utstring_findR
parameter_list|(
name|UT_string
modifier|*
name|s
parameter_list|,
name|long
name|P_StartPosition
parameter_list|,
comment|/* Start from 0. -1 means last position. */
specifier|const
name|char
modifier|*
name|P_Needle
parameter_list|,
name|ssize_t
name|P_NeedleLen
parameter_list|)
block|{
name|long
name|V_StartPosition
decl_stmt|;
name|long
name|V_HaystackLen
decl_stmt|;
name|long
modifier|*
name|V_KMP_Table
decl_stmt|;
name|long
name|V_FindPosition
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|P_StartPosition
operator|<
literal|0
condition|)
block|{
name|V_StartPosition
operator|=
name|s
operator|->
name|i
operator|+
name|P_StartPosition
expr_stmt|;
block|}
else|else
block|{
name|V_StartPosition
operator|=
name|P_StartPosition
expr_stmt|;
block|}
name|V_HaystackLen
operator|=
name|V_StartPosition
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|V_HaystackLen
operator|>=
name|P_NeedleLen
operator|)
operator|&&
operator|(
name|P_NeedleLen
operator|>
literal|0
operator|)
condition|)
block|{
name|V_KMP_Table
operator|=
operator|(
name|long
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
operator|(
name|P_NeedleLen
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_KMP_Table
operator|!=
name|NULL
condition|)
block|{
name|_utstring_BuildTableR
argument_list|(
name|P_Needle
argument_list|,
name|P_NeedleLen
argument_list|,
name|V_KMP_Table
argument_list|)
expr_stmt|;
name|V_FindPosition
operator|=
name|_utstring_findR
argument_list|(
name|s
operator|->
name|d
argument_list|,
name|V_HaystackLen
argument_list|,
name|P_Needle
argument_list|,
name|P_NeedleLen
argument_list|,
name|V_KMP_Table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|V_KMP_Table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|V_FindPosition
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  * end substring search functions                                              *  ******************************************************************************/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTSTRING_H */
end_comment

end_unit

