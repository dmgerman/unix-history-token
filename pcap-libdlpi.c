begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This code contributed by Sagun Shakya (sagun.shakya@sun.com)  */
end_comment

begin_comment
comment|/*  * Packet capture routines for DLPI using libdlpi under SunOS 5.11.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bufmod.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<libdlpi.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"dlpisubs.h"
end_include

begin_comment
comment|/* Forwards. */
end_comment

begin_function_decl
specifier|static
name|int
name|dlpromiscon
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|bpf_u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_read_libdlpi
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|pcap_handler
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_inject_libdlpi
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_libdlpi_err
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcap_cleanup_libdlpi
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * list_interfaces() will list all the network links that are  * available on a system.  */
end_comment

begin_function_decl
specifier|static
name|boolean_t
name|list_interfaces
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|linknamelist
block|{
name|char
name|linkname
index|[
name|DLPI_LINKNAME_MAX
index|]
decl_stmt|;
name|struct
name|linknamelist
modifier|*
name|lnl_next
decl_stmt|;
block|}
name|linknamelist_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|linkwalk
block|{
name|linknamelist_t
modifier|*
name|lw_list
decl_stmt|;
name|int
name|lw_err
decl_stmt|;
block|}
name|linkwalk_t
typedef|;
end_typedef

begin_comment
comment|/*  * The caller of this function should free the memory allocated  * for each linknamelist_t "entry" allocated.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|list_interfaces
parameter_list|(
specifier|const
name|char
modifier|*
name|linkname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|linkwalk_t
modifier|*
name|lwp
init|=
name|arg
decl_stmt|;
name|linknamelist_t
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|linknamelist_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|lwp
operator|->
name|lw_err
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|entry
operator|->
name|linkname
argument_list|,
name|linkname
argument_list|,
name|DLPI_LINKNAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwp
operator|->
name|lw_list
operator|==
name|NULL
condition|)
block|{
name|lwp
operator|->
name|lw_list
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|lnl_next
operator|=
name|lwp
operator|->
name|lw_list
expr_stmt|;
name|lwp
operator|->
name|lw_list
operator|=
name|entry
expr_stmt|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_activate_libdlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|retv
decl_stmt|;
name|dlpi_handle_t
name|dh
decl_stmt|;
name|dlpi_info_t
name|dlinfo
decl_stmt|;
comment|/* 	 * Enable Solaris raw and passive DLPI extensions; 	 * dlpi_open() will not fail if the underlying link does not support 	 * passive mode. See dlpi(7P) for details. 	 */
name|retv
operator|=
name|dlpi_open
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
operator|&
name|dh
argument_list|,
name|DLPI_RAW
operator||
name|DLPI_PASSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|!=
name|DLPI_SUCCESS
condition|)
block|{
if|if
condition|(
name|retv
operator|==
name|DLPI_ELINKNAMEINVAL
operator|||
name|retv
operator|==
name|DLPI_ENOLINK
condition|)
name|status
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
elseif|else
if|if
condition|(
name|retv
operator|==
name|DL_SYSERR
operator|&&
operator|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
operator|)
condition|)
name|status
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
else|else
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_libdlpi_err
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"dlpi_open"
argument_list|,
name|retv
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|pd
operator|->
name|dlpi_hd
operator|=
name|dh
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 		 * This device exists, but we don't support monitor mode 		 * any platforms that support DLPI. 		 */
name|status
operator|=
name|PCAP_ERROR_RFMON_NOTSUP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Bind with DLPI_ANY_SAP. */
if|if
condition|(
operator|(
name|retv
operator|=
name|dlpi_bind
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|,
name|DLPI_ANY_SAP
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|DLPI_SUCCESS
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_libdlpi_err
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"dlpi_bind"
argument_list|,
name|retv
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Enable promiscuous mode. */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
name|retv
operator|=
name|dlpromiscon
argument_list|(
name|p
argument_list|,
name|DL_PROMISC_PHYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
comment|/* 			 * "You don't have permission to capture on 			 * this device" and "you don't have permission 			 * to capture in promiscuous mode on this 			 * device" are different; let the user know, 			 * so if they can't get permission to 			 * capture in promiscuous mode, they can at 			 * least try to capture in non-promiscuous 			 * mode. 			 * 			 * XXX - you might have to capture in 			 * promiscuous mode to see outgoing packets. 			 */
if|if
condition|(
name|retv
operator|==
name|PCAP_ERROR_PERM_DENIED
condition|)
name|status
operator|=
name|PCAP_ERROR_PROMISC_PERM_DENIED
expr_stmt|;
else|else
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* Try to enable multicast. */
name|retv
operator|=
name|dlpromiscon
argument_list|(
name|p
argument_list|,
name|DL_PROMISC_MULTI
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* Try to enable SAP promiscuity. */
name|retv
operator|=
name|dlpromiscon
argument_list|(
name|p
argument_list|,
name|DL_PROMISC_SAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Not fatal, since the DL_PROMISC_PHYS mode worked. 		 * Report it as a warning, however. 		 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
name|status
operator|=
name|PCAP_WARNING
expr_stmt|;
else|else
block|{
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* Determine link type.  */
if|if
condition|(
operator|(
name|retv
operator|=
name|dlpi_info
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|,
operator|&
name|dlinfo
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|DLPI_SUCCESS
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_libdlpi_err
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"dlpi_info"
argument_list|,
name|retv
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|pcap_process_mactype
argument_list|(
name|p
argument_list|,
name|dlinfo
operator|.
name|di_mactype
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|fd
operator|=
name|dlpi_fd
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|)
expr_stmt|;
comment|/* Push and configure bufmod. */
if|if
condition|(
name|pcap_conf_bufmod
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|snapshot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Flush the read side. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|I_FLUSH
argument_list|,
name|FLUSHR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"FLUSHR: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Allocate data buffer. */
if|if
condition|(
name|pcap_alloc_databuf
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * "p->fd" is a FD for a STREAMS device, so "select()" and 	 * "poll()" should work on it. 	 */
name|p
operator|->
name|selectable_fd
operator|=
name|p
operator|->
name|fd
expr_stmt|;
name|p
operator|->
name|read_op
operator|=
name|pcap_read_libdlpi
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
name|pcap_inject_libdlpi
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|install_bpf_program
expr_stmt|;
comment|/* No kernel filtering */
name|p
operator|->
name|setdirection_op
operator|=
name|NULL
expr_stmt|;
comment|/* Not implemented */
name|p
operator|->
name|set_datalink_op
operator|=
name|NULL
expr_stmt|;
comment|/* Can't change data link type */
name|p
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_fd
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_dlpi
expr_stmt|;
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_libdlpi
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
name|bad
label|:
name|pcap_cleanup_libdlpi
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|n
parameter_list|)
value|#n
end_define

begin_function
specifier|static
name|int
name|dlpromiscon
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|bpf_u_int32
name|level
parameter_list|)
block|{
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|retv
decl_stmt|;
name|int
name|err
decl_stmt|;
name|retv
operator|=
name|dlpi_promiscon
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|!=
name|DLPI_SUCCESS
condition|)
block|{
if|if
condition|(
name|retv
operator|==
name|DL_SYSERR
operator|&&
operator|(
name|errno
operator|==
name|EPERM
operator|||
name|errno
operator|==
name|EACCES
operator|)
condition|)
name|err
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
else|else
name|err
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_libdlpi_err
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"dlpi_promiscon"
name|STRINGIFY
argument_list|(
name|level
argument_list|)
argument_list|,
name|retv
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Presumably everything returned by dlpi_walk() is a DLPI device,  * so there's no work to be done here to check whether name refers  * to a DLPI device.  */
end_comment

begin_function
specifier|static
name|int
name|is_dlpi_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|_U_
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In Solaris, the "standard" mechanism" i.e SIOCGLIFCONF will only find  * network links that are plumbed and are up. dlpi_walk(3DLPI) will find  * additional network links present in the system.  */
end_comment

begin_function
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|retv
init|=
literal|0
decl_stmt|;
name|linknamelist_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|linkwalk_t
name|lw
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
comment|/* 	 * Get the list of regular interfaces first. 	 */
if|if
condition|(
name|pcap_findalldevs_interfaces
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|,
name|is_dlpi_interface
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failure */
comment|/* dlpi_walk() for loopback will be added here. */
name|dlpi_walk
argument_list|(
name|list_interfaces
argument_list|,
operator|&
name|lw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lw
operator|.
name|lw_err
operator|!=
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dlpi_walk: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|lw
operator|.
name|lw_err
argument_list|)
argument_list|)
expr_stmt|;
name|retv
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Add linkname if it does not exist on the list. */
for|for
control|(
name|entry
operator|=
name|lw
operator|.
name|lw_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|lnl_next
control|)
block|{
if|if
condition|(
name|pcap_add_if
argument_list|(
name|alldevsp
argument_list|,
name|entry
operator|->
name|linkname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
name|retv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|done
label|:
name|save_errno
operator|=
name|errno
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|lw
operator|.
name|lw_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|next
control|)
block|{
name|next
operator|=
name|entry
operator|->
name|lnl_next
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read data received on DLPI handle. Returns -2 if told to terminate, else  * returns the number of packets read.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_read_libdlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|count
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|bufp
decl_stmt|;
name|size_t
name|msglen
decl_stmt|;
name|int
name|retv
decl_stmt|;
name|len
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|bufp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
goto|goto
name|process_pkts
goto|;
block|}
do|do
block|{
comment|/* Has "pcap_breakloop()" been called? */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 			 * Yes - clear the flag that indicates that it has, 			 * and return -2 to indicate that we were told to 			 * break out of the loop. 			 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|msglen
operator|=
name|p
operator|->
name|bufsize
expr_stmt|;
name|bufp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
operator|+
name|p
operator|->
name|offset
expr_stmt|;
name|retv
operator|=
name|dlpi_recv
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bufp
argument_list|,
operator|&
name|msglen
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|!=
name|DLPI_SUCCESS
condition|)
block|{
comment|/* 			 * This is most likely a call to terminate out of the 			 * loop. So, do not return an error message, instead 			 * check if "pcap_breakloop()" has been called above. 			 */
if|if
condition|(
name|retv
operator|==
name|DL_SYSERR
operator|&&
name|errno
operator|==
name|EINTR
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pcap_libdlpi_err
argument_list|(
name|dlpi_linkname
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|)
argument_list|,
literal|"dlpi_recv"
argument_list|,
name|retv
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|len
operator|=
name|msglen
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|==
literal|0
condition|)
do|;
name|process_pkts
label|:
return|return
operator|(
name|pcap_process_pkts
argument_list|(
name|p
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|count
argument_list|,
name|bufp
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_inject_libdlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|retv
decl_stmt|;
name|retv
operator|=
name|dlpi_send
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|!=
name|DLPI_SUCCESS
condition|)
block|{
name|pcap_libdlpi_err
argument_list|(
name|dlpi_linkname
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|)
argument_list|,
literal|"dlpi_send"
argument_list|,
name|retv
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * dlpi_send(3DLPI) does not provide a way to return the number of 	 * bytes sent on the wire. Based on the fact that DLPI_SUCCESS was 	 * returned we are assuming 'size' bytes were sent. 	 */
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close dlpi handle.  */
end_comment

begin_function
specifier|static
name|void
name|pcap_cleanup_libdlpi
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_dlpi
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|dlpi_hd
operator|!=
name|NULL
condition|)
block|{
name|dlpi_close
argument_list|(
name|pd
operator|->
name|dlpi_hd
argument_list|)
expr_stmt|;
name|pd
operator|->
name|dlpi_hd
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|pcap_cleanup_live_common
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write error message to buffer.  */
end_comment

begin_function
specifier|static
name|void
name|pcap_libdlpi_err
parameter_list|(
specifier|const
name|char
modifier|*
name|linkname
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"libpcap: %s failed on %s: %s"
argument_list|,
name|func
argument_list|,
name|linkname
argument_list|,
name|dlpi_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
name|_U_
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_dlpi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|activate_op
operator|=
name|pcap_activate_libdlpi
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

