begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// reloc.h -- relocate input files for gold   -*- C++ -*-
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GOLD_RELOC_H
end_ifndef

begin_define
define|#
directive|define
name|GOLD_RELOC_H
end_define

begin_include
include|#
directive|include
file|<byteswap.h>
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_decl_stmt
name|namespace
name|gold
block|{
name|class
name|General_options
decl_stmt|;
name|class
name|Relobj
decl_stmt|;
name|class
name|Read_relocs_data
decl_stmt|;
name|class
name|Symbol
decl_stmt|;
name|class
name|Layout
decl_stmt|;
name|template
operator|<
name|int
name|size
operator|>
name|class
name|Sized_symbol
expr_stmt|;
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|class
name|Sized_relobj
expr_stmt|;
name|template
operator|<
name|int
name|size
operator|>
name|class
name|Symbol_value
expr_stmt|;
name|template
operator|<
name|int
name|sh_type
operator|,
name|bool
name|dynamic
operator|,
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|class
name|Output_data_reloc
expr_stmt|;
comment|// A class to read the relocations for an object file, and then queue
comment|// up a task to see if they require any GOT/PLT/COPY relocations in
comment|// the symbol table.
name|class
name|Read_relocs
range|:
name|public
name|Task
block|{
name|public
operator|:
comment|// SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
comment|// unblocked when the Scan_relocs task completes.
name|Read_relocs
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|,
name|Symbol_table
operator|*
name|symtab
argument_list|,
name|Layout
operator|*
name|layout
argument_list|,
name|Relobj
operator|*
name|object
argument_list|,
name|Task_token
operator|*
name|symtab_lock
argument_list|,
name|Task_token
operator|*
name|blocker
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|object_
argument_list|(
name|object
argument_list|)
block|,
name|symtab_lock_
argument_list|(
name|symtab_lock
argument_list|)
block|,
name|blocker_
argument_list|(
argument|blocker
argument_list|)
block|{ }
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
specifier|const
name|General_options
operator|&
name|options_
block|;
name|Symbol_table
operator|*
name|symtab_
block|;
name|Layout
operator|*
name|layout_
block|;
name|Relobj
operator|*
name|object_
block|;
name|Task_token
operator|*
name|symtab_lock_
block|;
name|Task_token
operator|*
name|blocker_
block|; }
decl_stmt|;
comment|// Scan the relocations for an object to see if they require any
comment|// GOT/PLT/COPY relocations.
name|class
name|Scan_relocs
range|:
name|public
name|Task
block|{
name|public
operator|:
comment|// SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
comment|// unblocked when the task completes.
name|Scan_relocs
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|,
name|Symbol_table
operator|*
name|symtab
argument_list|,
name|Layout
operator|*
name|layout
argument_list|,
name|Relobj
operator|*
name|object
argument_list|,
name|Read_relocs_data
operator|*
name|rd
argument_list|,
name|Task_token
operator|*
name|symtab_lock
argument_list|,
name|Task_token
operator|*
name|blocker
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|object_
argument_list|(
name|object
argument_list|)
block|,
name|rd_
argument_list|(
name|rd
argument_list|)
block|,
name|symtab_lock_
argument_list|(
name|symtab_lock
argument_list|)
block|,
name|blocker_
argument_list|(
argument|blocker
argument_list|)
block|{ }
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
name|class
name|Scan_relocs_locker
block|;
specifier|const
name|General_options
operator|&
name|options_
block|;
name|Symbol_table
operator|*
name|symtab_
block|;
name|Layout
operator|*
name|layout_
block|;
name|Relobj
operator|*
name|object_
block|;
name|Read_relocs_data
operator|*
name|rd_
block|;
name|Task_token
operator|*
name|symtab_lock_
block|;
name|Task_token
operator|*
name|blocker_
block|; }
decl_stmt|;
comment|// A class to perform all the relocations for an object file.
name|class
name|Relocate_task
range|:
name|public
name|Task
block|{
name|public
operator|:
name|Relocate_task
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|,
specifier|const
name|Symbol_table
operator|*
name|symtab
argument_list|,
specifier|const
name|Layout
operator|*
name|layout
argument_list|,
name|Relobj
operator|*
name|object
argument_list|,
name|Output_file
operator|*
name|of
argument_list|,
name|Task_token
operator|*
name|final_blocker
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|object_
argument_list|(
name|object
argument_list|)
block|,
name|of_
argument_list|(
name|of
argument_list|)
block|,
name|final_blocker_
argument_list|(
argument|final_blocker
argument_list|)
block|{ }
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
name|class
name|Relocate_locker
block|;
specifier|const
name|General_options
operator|&
name|options_
block|;
specifier|const
name|Symbol_table
operator|*
name|symtab_
block|;
specifier|const
name|Layout
operator|*
name|layout_
block|;
name|Relobj
operator|*
name|object_
block|;
name|Output_file
operator|*
name|of_
block|;
name|Task_token
operator|*
name|final_blocker_
block|; }
decl_stmt|;
comment|// Standard relocation routines which are used on many targets.  Here
comment|// SIZE and BIG_ENDIAN refer to the target, not the relocation type.
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|class
name|Relocate_functions
block|{
name|private
operator|:
comment|// Do a simple relocation with the addend in the section contents.
comment|// VALSIZE is the size of the value.
name|template
operator|<
name|int
name|valsize
operator|>
specifier|static
specifier|inline
name|void
name|rel
argument_list|(
argument|unsigned char* view
argument_list|,
argument|typename elfcpp::Swap<valsize
argument_list|,
argument|big_endian>::Valtype value
argument_list|)
block|{
typedef|typedef
name|typename
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
name|Valtype
operator|*
name|wv
operator|=
name|reinterpret_cast
operator|<
name|Valtype
operator|*
operator|>
operator|(
name|view
operator|)
block|;
name|Valtype
name|x
operator|=
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
block|,
name|big_endian
operator|>
operator|::
name|readval
argument_list|(
name|wv
argument_list|)
block|;
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
block|,
name|big_endian
operator|>
operator|::
name|writeval
argument_list|(
name|wv
argument_list|,
name|x
operator|+
name|value
argument_list|)
block|;   }
comment|// Do a simple relocation using a Symbol_value with the addend in
comment|// the section contents.  VALSIZE is the size of the value to
comment|// relocate.
name|template
operator|<
name|int
name|valsize
operator|>
specifier|static
specifier|inline
name|void
name|rel
argument_list|(
argument|unsigned char* view
argument_list|,
argument|const Sized_relobj<size
argument_list|,
argument|big_endian>* object
argument_list|,
argument|const Symbol_value<size>* psymval
argument_list|)
block|{
typedef|typedef
name|typename
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
name|Valtype
operator|*
name|wv
operator|=
name|reinterpret_cast
operator|<
name|Valtype
operator|*
operator|>
operator|(
name|view
operator|)
expr_stmt|;
name|Valtype
name|x
init|=
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
decl_stmt|,
name|big_endian
decl|>::
name|readval
argument_list|(
name|wv
argument_list|)
decl_stmt|;
name|x
operator|=
name|psymval
operator|->
name|value
argument_list|(
name|object
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|writeval
argument_list|(
name|wv
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple PC relative relocation with the addend in the section
end_comment

begin_comment
comment|// contents.  VALSIZE is the size of the value.
end_comment

begin_expr_stmt
name|template
operator|<
name|int
name|valsize
operator|>
specifier|static
specifier|inline
name|void
name|pcrel
argument_list|(
argument|unsigned char* view
argument_list|,
argument|typename elfcpp::Swap<valsize
argument_list|,
argument|big_endian>::Valtype value
argument_list|,
argument|typename elfcpp::Elf_types<size>::Elf_Addr address
argument_list|)
block|{
typedef|typedef
name|typename
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
name|Valtype
operator|*
name|wv
operator|=
name|reinterpret_cast
operator|<
name|Valtype
operator|*
operator|>
operator|(
name|view
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Valtype
name|x
init|=
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
decl_stmt|,
name|big_endian
decl|>::
name|readval
argument_list|(
name|wv
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|writeval
argument_list|(
name|wv
argument_list|,
name|x
operator|+
name|value
operator|-
name|address
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Do a simple PC relative relocation with a Symbol_value with the
end_comment

begin_comment
comment|// addend in the section contents.  VALSIZE is the size of the
end_comment

begin_comment
comment|// value.
end_comment

begin_expr_stmt
unit|template
operator|<
name|int
name|valsize
operator|>
specifier|static
specifier|inline
name|void
name|pcrel
argument_list|(
argument|unsigned char* view
argument_list|,
argument|const Sized_relobj<size
argument_list|,
argument|big_endian>* object
argument_list|,
argument|const Symbol_value<size>* psymval
argument_list|,
argument|typename elfcpp::Elf_types<size>::Elf_Addr address
argument_list|)
block|{
typedef|typedef
name|typename
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
name|Valtype
operator|*
name|wv
operator|=
name|reinterpret_cast
operator|<
name|Valtype
operator|*
operator|>
operator|(
name|view
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Valtype
name|x
init|=
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
decl_stmt|,
name|big_endian
decl|>::
name|readval
argument_list|(
name|wv
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|x
operator|=
name|psymval
operator|->
name|value
argument_list|(
name|object
argument_list|,
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|elfcpp
operator|::
name|Swap
operator|<
name|valsize
operator|,
name|big_endian
operator|>
operator|::
name|writeval
argument_list|(
name|wv
argument_list|,
name|x
operator|-
name|address
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    typedef
name|Relocate_functions
operator|<
name|size
operator|,
name|big_endian
operator|>
name|This
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// Do a simple 8-bit REL relocation with the addend in the section
end_comment

begin_comment
comment|// contents.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|rel8
parameter_list|(
name|unsigned
name|char
modifier|*
name|view
parameter_list|,
name|unsigned
name|char
name|value
parameter_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|8
operator|>
operator|(
name|view
operator|,
name|value
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel8
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|8
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 8-bit PC relative relocation with the addend in the
end_comment

begin_comment
comment|// section contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel8
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|unsigned
name|char
name|value
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|8
operator|>
operator|(
name|view
operator|,
name|value
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel8
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|8
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 16-bit REL relocation with the addend in the section
end_comment

begin_comment
comment|// contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel16
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|elfcpp
operator|::
name|Elf_Half
name|value
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|16
operator|>
operator|(
name|view
operator|,
name|value
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel16
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|16
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 32-bit PC relative REL relocation with the addend in
end_comment

begin_comment
comment|// the section contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel16
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|value
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|16
operator|>
operator|(
name|view
operator|,
name|value
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel16
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|16
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 32-bit REL relocation with the addend in the section
end_comment

begin_comment
comment|// contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel32
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|value
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|32
operator|>
operator|(
name|view
operator|,
name|value
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel32
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|32
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 32-bit PC relative REL relocation with the addend in
end_comment

begin_comment
comment|// the section contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel32
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|value
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|32
operator|>
operator|(
name|view
operator|,
name|value
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel32
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|32
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 64-bit REL relocation with the addend in the section
end_comment

begin_comment
comment|// contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel64
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|elfcpp
operator|::
name|Elf_Xword
name|value
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|64
operator|>
operator|(
name|view
operator|,
name|value
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|rel64
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|)
block|{
name|This
operator|::
name|template
name|rel
operator|<
literal|64
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Do a simple 64-bit PC relative REL relocation with the addend in
end_comment

begin_comment
comment|// the section contents.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel64
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
name|elfcpp
operator|::
name|Elf_Xword
name|value
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|64
operator|>
operator|(
name|view
operator|,
name|value
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pcrel64
argument_list|(
name|unsigned
name|char
operator|*
name|view
argument_list|,
specifier|const
name|Sized_relobj
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|*
name|object
argument_list|,
specifier|const
name|Symbol_value
operator|<
name|size
operator|>
operator|*
name|psymval
argument_list|,
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|address
argument_list|)
block|{
name|This
operator|::
name|template
name|pcrel
operator|<
literal|64
operator|>
operator|(
name|view
operator|,
name|object
operator|,
name|psymval
operator|,
name|address
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|// We try to avoid COPY relocations when possible.  A COPY relocation
end_comment

begin_comment
comment|// may be required when an executable refers to a variable defined in
end_comment

begin_comment
comment|// a shared library.  COPY relocations are problematic because they
end_comment

begin_comment
comment|// tie the executable to the exact size of the variable in the shared
end_comment

begin_comment
comment|// library.  We can avoid them if all the references to the variable
end_comment

begin_comment
comment|// are in a writeable section.  In that case we can simply use dynamic
end_comment

begin_comment
comment|// relocations.  However, when scanning relocs, we don't know when we
end_comment

begin_comment
comment|// see the relocation whether we will be forced to use a COPY
end_comment

begin_comment
comment|// relocation or not.  So we have to save the relocation during the
end_comment

begin_comment
comment|// reloc scanning, and then emit it as a dynamic relocation if
end_comment

begin_comment
comment|// necessary.  This class implements that.  It is used by the target
end_comment

begin_comment
comment|// specific code.
end_comment

begin_expr_stmt
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|class
name|Copy_relocs
block|{
name|public
operator|:
name|Copy_relocs
argument_list|()
operator|:
name|entries_
argument_list|()
block|{ }
comment|// Return whether we need a COPY reloc for a reloc against GSYM,
comment|// which is being applied to section SHNDX in OBJECT.
specifier|static
name|bool
name|need_copy_reloc
argument_list|(
argument|const General_options*
argument_list|,
argument|Relobj* object
argument_list|,
argument|unsigned int shndx
argument_list|,
argument|Sized_symbol<size>* gsym
argument_list|)
block|;
comment|// Save a Rel against SYM for possible emission later.  SHNDX is the
comment|// index of the section to which the reloc is being applied.
name|void
name|save
argument_list|(
argument|Symbol* sym
argument_list|,
argument|Relobj*
argument_list|,
argument|unsigned int shndx
argument_list|,
argument|const elfcpp::Rel<size
argument_list|,
argument|big_endian>&
argument_list|)
block|;
comment|// Save a Rela against SYM for possible emission later.
name|void
name|save
argument_list|(
argument|Symbol* sym
argument_list|,
argument|Relobj*
argument_list|,
argument|unsigned int shndx
argument_list|,
argument|const elfcpp::Rela<size
argument_list|,
argument|big_endian>&
argument_list|)
block|;
comment|// Return whether there are any relocs to emit.  This also discards
comment|// entries which need not be emitted.
name|bool
name|any_to_emit
argument_list|()
block|;
comment|// Emit relocs for each symbol which did not get a COPY reloc (i.e.,
comment|// is still defined in the dynamic object).
name|template
operator|<
name|int
name|sh_type
operator|>
name|void
name|emit
argument_list|(
name|Output_data_reloc
operator|<
name|sh_type
argument_list|,
name|true
argument_list|,
name|size
argument_list|,
name|big_endian
operator|>
operator|*
argument_list|)
block|;
name|private
operator|:
typedef|typedef
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|Address
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|elfcpp
operator|::
name|Elf_types
operator|<
name|size
operator|>
operator|::
name|Elf_Addr
name|Addend
expr_stmt|;
end_typedef

begin_comment
comment|// This POD class holds the entries we are saving.
end_comment

begin_decl_stmt
name|class
name|Copy_reloc_entry
block|{
name|public
label|:
name|Copy_reloc_entry
argument_list|(
argument|Symbol* sym
argument_list|,
argument|unsigned int reloc_type
argument_list|,
argument|Relobj* relobj
argument_list|,
argument|unsigned int shndx
argument_list|,
argument|Address address
argument_list|,
argument|Addend addend
argument_list|)
block|:
name|sym_
argument_list|(
name|sym
argument_list|)
operator|,
name|reloc_type_
argument_list|(
name|reloc_type
argument_list|)
operator|,
name|relobj_
argument_list|(
name|relobj
argument_list|)
operator|,
name|shndx_
argument_list|(
name|shndx
argument_list|)
operator|,
name|address_
argument_list|(
name|address
argument_list|)
operator|,
name|addend_
argument_list|(
argument|addend
argument_list|)
block|{ }
comment|// Return whether we should emit this reloc.  If we should not
comment|// emit, we clear it.
name|bool
name|should_emit
argument_list|()
expr_stmt|;
comment|// Emit this reloc.
name|void
name|emit
argument_list|(
name|Output_data_reloc
operator|<
name|elfcpp
operator|::
name|SHT_REL
argument_list|,
name|true
argument_list|,
name|size
argument_list|,
name|big_endian
operator|>
operator|*
argument_list|)
decl_stmt|;
name|void
name|emit
argument_list|(
name|Output_data_reloc
operator|<
name|elfcpp
operator|::
name|SHT_RELA
argument_list|,
name|true
argument_list|,
name|size
argument_list|,
name|big_endian
operator|>
operator|*
argument_list|)
decl_stmt|;
name|private
label|:
name|Symbol
modifier|*
name|sym_
decl_stmt|;
name|unsigned
name|int
name|reloc_type_
decl_stmt|;
name|Relobj
modifier|*
name|relobj_
decl_stmt|;
name|unsigned
name|int
name|shndx_
decl_stmt|;
name|Address
name|address_
decl_stmt|;
name|Addend
name|addend_
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// A list of relocs to be saved.
end_comment

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Copy_reloc_entry
operator|>
name|Copy_reloc_entries
expr_stmt|;
end_typedef

begin_comment
comment|// The list of relocs we are saving.
end_comment

begin_decl_stmt
name|Copy_reloc_entries
name|entries_
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// End namespace gold.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(GOLD_RELOC_H)
end_comment

end_unit

