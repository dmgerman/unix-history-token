begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// layout.h -- lay out output file sections for gold  -*- C++ -*-
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GOLD_LAYOUT_H
end_ifndef

begin_define
define|#
directive|define
name|GOLD_LAYOUT_H
end_define

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"dynobj.h"
end_include

begin_include
include|#
directive|include
file|"stringpool.h"
end_include

begin_decl_stmt
name|namespace
name|gold
block|{
name|class
name|General_options
decl_stmt|;
name|class
name|Input_objects
decl_stmt|;
name|class
name|Symbol_table
decl_stmt|;
name|class
name|Output_section_data
decl_stmt|;
name|class
name|Output_section
decl_stmt|;
name|class
name|Output_section_headers
decl_stmt|;
name|class
name|Output_segment
decl_stmt|;
name|class
name|Output_data
decl_stmt|;
name|class
name|Output_data_dynamic
decl_stmt|;
name|class
name|Target
decl_stmt|;
comment|// This task function handles mapping the input sections to output
comment|// sections and laying them out in memory.
name|class
name|Layout_task_runner
range|:
name|public
name|Task_function_runner
block|{
name|public
operator|:
comment|// OPTIONS is the command line options, INPUT_OBJECTS is the list of
comment|// input objects, SYMTAB is the symbol table, LAYOUT is the layout
comment|// object.
name|Layout_task_runner
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|,
specifier|const
name|Input_objects
operator|*
name|input_objects
argument_list|,
name|Symbol_table
operator|*
name|symtab
argument_list|,
name|Layout
operator|*
name|layout
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|input_objects_
argument_list|(
name|input_objects
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
argument|layout
argument_list|)
block|{ }
comment|// Run the operation.
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
name|Layout_task_runner
argument_list|(
specifier|const
name|Layout_task_runner
operator|&
argument_list|)
block|;
name|Layout_task_runner
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Layout_task_runner
operator|&
operator|)
block|;
specifier|const
name|General_options
operator|&
name|options_
block|;
specifier|const
name|Input_objects
operator|*
name|input_objects_
block|;
name|Symbol_table
operator|*
name|symtab_
block|;
name|Layout
operator|*
name|layout_
block|; }
decl_stmt|;
comment|// This class handles the details of laying out input sections.
name|class
name|Layout
block|{
name|public
label|:
name|Layout
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|)
expr_stmt|;
comment|// Given an input section SHNDX, named NAME, with data in SHDR, from
comment|// the object file OBJECT, return the output section where this
comment|// input section should go.  Set *OFFSET to the offset within the
comment|// output section.
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|Output_section
operator|*
name|layout
argument_list|(
argument|Relobj *object
argument_list|,
argument|unsigned int shndx
argument_list|,
argument|const char* name
argument_list|,
argument|const elfcpp::Shdr<size
argument_list|,
argument|big_endian>& shdr
argument_list|,
argument|off_t* offset
argument_list|)
expr_stmt|;
comment|// Add an Output_section_data to the layout.  This is used for
comment|// special sections like the GOT section.
name|void
name|add_output_section_data
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|type
argument_list|,
name|elfcpp
operator|::
name|Elf_Xword
name|flags
argument_list|,
name|Output_section_data
operator|*
argument_list|)
decl_stmt|;
comment|// Create dynamic sections if necessary.
name|void
name|create_initial_dynamic_sections
parameter_list|(
specifier|const
name|Input_objects
modifier|*
parameter_list|,
name|Symbol_table
modifier|*
parameter_list|)
function_decl|;
comment|// Return the Stringpool used for symbol names.
specifier|const
name|Stringpool
operator|*
name|sympool
argument_list|()
specifier|const
block|{
return|return
operator|&
name|this
operator|->
name|sympool_
return|;
block|}
comment|// Return the Stringpool used for dynamic symbol names and dynamic
comment|// tags.
specifier|const
name|Stringpool
operator|*
name|dynpool
argument_list|()
specifier|const
block|{
return|return
operator|&
name|this
operator|->
name|dynpool_
return|;
block|}
comment|// Return whether a section is a .gnu.linkonce section, given the
comment|// section name.
specifier|static
specifier|inline
name|bool
name|is_linkonce
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
return|;
block|}
comment|// Record the signature of a comdat section, and return whether to
comment|// include it in the link.  The GROUP parameter is true for a
comment|// section group signature, false for a signature derived from a
comment|// .gnu.linkonce section.
name|bool
name|add_comdat
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
name|group
parameter_list|)
function_decl|;
comment|// Finalize the layout after all the input sections have been added.
name|off_t
name|finalize
parameter_list|(
specifier|const
name|Input_objects
modifier|*
parameter_list|,
name|Symbol_table
modifier|*
parameter_list|)
function_decl|;
comment|// Return the TLS segment.  This will return NULL if there isn't
comment|// one.
name|Output_segment
operator|*
name|tls_segment
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|tls_segment_
return|;
block|}
comment|// Return the normal symbol table.
name|Output_section
operator|*
name|symtab_section
argument_list|()
specifier|const
block|{
name|gold_assert
argument_list|(
name|this
operator|->
name|symtab_section_
operator|!=
name|NULL
argument_list|)
block|;
return|return
name|this
operator|->
name|symtab_section_
return|;
block|}
comment|// Return the dynamic symbol table.
name|Output_section
operator|*
name|dynsym_section
argument_list|()
specifier|const
block|{
name|gold_assert
argument_list|(
name|this
operator|->
name|dynsym_section_
operator|!=
name|NULL
argument_list|)
block|;
return|return
name|this
operator|->
name|dynsym_section_
return|;
block|}
comment|// Return the dynamic tags.
name|Output_data_dynamic
operator|*
name|dynamic_data
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|dynamic_data_
return|;
block|}
comment|// Write out data not associated with an input file or the symbol
comment|// table.
name|void
name|write_data
argument_list|(
specifier|const
name|Symbol_table
operator|*
argument_list|,
specifier|const
name|Target
operator|*
argument_list|,
name|Output_file
operator|*
argument_list|)
decl|const
decl_stmt|;
comment|// Return an output section named NAME, or NULL if there is none.
name|Output_section
modifier|*
name|find_output_section
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|)
decl|const
decl_stmt|;
comment|// Return an output segment of type TYPE, with segment flags SET set
comment|// and segment flags CLEAR clear.  Return NULL if there is none.
name|Output_segment
modifier|*
name|find_output_segment
argument_list|(
name|elfcpp
operator|::
name|PT
name|type
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|set
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|clear
argument_list|)
decl|const
decl_stmt|;
comment|// The list of segments.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Output_segment
operator|*
operator|>
name|Segment_list
expr_stmt|;
comment|// The list of sections not attached to a segment.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Output_section
operator|*
operator|>
name|Section_list
expr_stmt|;
comment|// The list of information to write out which is not attached to
comment|// either a section or a segment.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Output_data
operator|*
operator|>
name|Data_list
expr_stmt|;
name|private
label|:
name|Layout
argument_list|(
specifier|const
name|Layout
operator|&
argument_list|)
expr_stmt|;
name|Layout
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Layout
operator|&
operator|)
decl_stmt|;
comment|// Mapping from .gnu.linkonce section names to output section names.
struct|struct
name|Linkonce_mapping
block|{
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
name|int
name|tolen
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|Linkonce_mapping
name|linkonce_mapping
index|[]
decl_stmt|;
specifier|static
specifier|const
name|int
name|linkonce_mapping_count
decl_stmt|;
comment|// Find the first read-only PT_LOAD segment, creating one if
comment|// necessary.
name|Output_segment
modifier|*
name|find_first_load_seg
parameter_list|()
function_decl|;
comment|// Create the output sections for the symbol table.
name|void
name|create_symtab_sections
parameter_list|(
name|int
name|size
parameter_list|,
specifier|const
name|Input_objects
modifier|*
parameter_list|,
name|Symbol_table
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
comment|// Create the .shstrtab section.
name|Output_section
modifier|*
name|create_shstrtab
parameter_list|()
function_decl|;
comment|// Create the section header table.
name|Output_section_headers
modifier|*
name|create_shdrs
parameter_list|(
name|int
name|size
parameter_list|,
name|bool
name|big_endian
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
comment|// Create the dynamic symbol table.
name|void
name|create_dynamic_symtab
argument_list|(
specifier|const
name|Target
operator|*
argument_list|,
name|Symbol_table
operator|*
argument_list|,
name|Output_section
operator|*
operator|*
name|pdynstr
argument_list|,
name|unsigned
name|int
operator|*
name|plocal_dynamic_count
argument_list|,
name|std
operator|::
name|vector
operator|<
name|Symbol
operator|*
operator|>
operator|*
name|pdynamic_symbols
argument_list|,
name|Versions
operator|*
name|versions
argument_list|)
decl_stmt|;
comment|// Finish the .dynamic section and PT_DYNAMIC segment.
name|void
name|finish_dynamic_section
parameter_list|(
specifier|const
name|Input_objects
modifier|*
parameter_list|,
specifier|const
name|Symbol_table
modifier|*
parameter_list|)
function_decl|;
comment|// Create the .interp section and PT_INTERP segment.
name|void
name|create_interp
parameter_list|(
specifier|const
name|Target
modifier|*
name|target
parameter_list|)
function_decl|;
comment|// Create the version sections.
name|void
name|create_version_sections
argument_list|(
specifier|const
name|Target
operator|*
argument_list|,
specifier|const
name|Versions
operator|*
argument_list|,
name|unsigned
name|int
name|local_symcount
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Symbol
operator|*
operator|>
operator|&
name|dynamic_symbols
argument_list|,
specifier|const
name|Output_section
operator|*
name|dynstr
argument_list|)
decl_stmt|;
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|void
name|sized_create_version_sections
argument_list|(
argument|const Versions* versions
argument_list|,
argument|unsigned int local_symcount
argument_list|,
argument|const std::vector<Symbol*>& dynamic_symbols
argument_list|,
argument|const Output_section* dynstr                                 ACCEPT_SIZE_ENDIAN
argument_list|)
expr_stmt|;
comment|// Return whether to include this section in the link.
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
name|bool
name|include_section
argument_list|(
name|Object
operator|*
name|object
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|elfcpp
operator|::
name|Shdr
operator|<
name|size
argument_list|,
name|big_endian
operator|>
operator|&
argument_list|)
expr_stmt|;
comment|// Return the output section name to use given an input section
comment|// name.  Set *PLEN to the length of the name.  *PLEN must be
comment|// initialized to the length of NAME.
specifier|static
specifier|const
name|char
modifier|*
name|output_section_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|)
function_decl|;
comment|// Return the output section name to use for a linkonce section
comment|// name.  PLEN is as for output_section_name.
specifier|static
specifier|const
name|char
modifier|*
name|linkonce_output_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|)
function_decl|;
comment|// Return the output section for NAME, TYPE and FLAGS.
name|Output_section
modifier|*
name|get_output_section
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|Stringpool
operator|::
name|Key
name|name_key
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|type
argument_list|,
name|elfcpp
operator|::
name|Elf_Xword
name|flags
argument_list|)
decl_stmt|;
comment|// Create a new Output_section.
name|Output_section
modifier|*
name|make_output_section
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|elfcpp
operator|::
name|Elf_Word
name|type
argument_list|,
name|elfcpp
operator|::
name|Elf_Xword
name|flags
argument_list|)
decl_stmt|;
comment|// Set the final file offsets of all the segments.
name|off_t
name|set_segment_offsets
parameter_list|(
specifier|const
name|Target
modifier|*
parameter_list|,
name|Output_segment
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
name|pshndx
parameter_list|)
function_decl|;
comment|// Set the final file offsets and section indexes of all the
comment|// sections not associated with a segment.
name|off_t
name|set_section_offsets
parameter_list|(
name|off_t
parameter_list|,
name|unsigned
name|int
modifier|*
name|pshndx
parameter_list|)
function_decl|;
comment|// Return whether SEG1 comes before SEG2 in the output file.
specifier|static
name|bool
name|segment_precedes
parameter_list|(
specifier|const
name|Output_segment
modifier|*
name|seg1
parameter_list|,
specifier|const
name|Output_segment
modifier|*
name|seg2
parameter_list|)
function_decl|;
comment|// Map from section flags to segment flags.
specifier|static
name|elfcpp
operator|::
name|Elf_Word
name|section_flags_to_segment
argument_list|(
argument|elfcpp::Elf_Xword flags
argument_list|)
expr_stmt|;
comment|// A mapping used for group signatures.
typedef|typedef
name|Unordered_map
operator|<
name|std
operator|::
name|string
operator|,
name|bool
operator|>
name|Signatures
expr_stmt|;
comment|// Mapping from input section name/type/flags to output section.  We
comment|// use canonicalized strings here.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|Stringpool
operator|::
name|Key
operator|,
name|std
operator|::
name|pair
operator|<
name|elfcpp
operator|::
name|Elf_Word
operator|,
name|elfcpp
operator|::
name|Elf_Xword
operator|>
expr|>
name|Key
expr_stmt|;
struct|struct
name|Hash_key
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|Key
operator|&
name|k
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
typedef|typedef
name|Unordered_map
operator|<
name|Key
operator|,
name|Output_section
operator|*
operator|,
name|Hash_key
operator|>
name|Section_name_map
expr_stmt|;
comment|// A comparison class for segments.
struct|struct
name|Compare_segments
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Output_segment
operator|*
name|seg1
operator|,
specifier|const
name|Output_segment
operator|*
name|seg2
operator|)
block|{
return|return
name|Layout
operator|::
name|segment_precedes
argument_list|(
name|seg1
argument_list|,
name|seg2
argument_list|)
return|;
block|}
block|}
struct|;
comment|// A reference to the options on the command line.
specifier|const
name|General_options
modifier|&
name|options_
decl_stmt|;
comment|// The output section names.
name|Stringpool
name|namepool_
decl_stmt|;
comment|// The output symbol names.
name|Stringpool
name|sympool_
decl_stmt|;
comment|// The dynamic strings, if needed.
name|Stringpool
name|dynpool_
decl_stmt|;
comment|// The list of group sections and linkonce sections which we have seen.
name|Signatures
name|signatures_
decl_stmt|;
comment|// The mapping from input section name/type/flags to output sections.
name|Section_name_map
name|section_name_map_
decl_stmt|;
comment|// The list of output segments.
name|Segment_list
name|segment_list_
decl_stmt|;
comment|// The list of output sections.
name|Section_list
name|section_list_
decl_stmt|;
comment|// The list of output sections which are not attached to any output
comment|// segment.
name|Section_list
name|unattached_section_list_
decl_stmt|;
comment|// The list of unattached Output_data objects which require special
comment|// handling because they are not Output_sections.
name|Data_list
name|special_output_list_
decl_stmt|;
comment|// A pointer to the PT_TLS segment if there is one.
name|Output_segment
modifier|*
name|tls_segment_
decl_stmt|;
comment|// The SHT_SYMTAB output section.
name|Output_section
modifier|*
name|symtab_section_
decl_stmt|;
comment|// The SHT_DYNSYM output section if there is one.
name|Output_section
modifier|*
name|dynsym_section_
decl_stmt|;
comment|// The SHT_DYNAMIC output section if there is one.
name|Output_section
modifier|*
name|dynamic_section_
decl_stmt|;
comment|// The dynamic data which goes into dynamic_section_.
name|Output_data_dynamic
modifier|*
name|dynamic_data_
decl_stmt|;
block|}
empty_stmt|;
comment|// This task handles writing out data which is not part of a section
comment|// or segment.
name|class
name|Write_data_task
range|:
name|public
name|Task
block|{
name|public
operator|:
name|Write_data_task
argument_list|(
specifier|const
name|Layout
operator|*
name|layout
argument_list|,
specifier|const
name|Symbol_table
operator|*
name|symtab
argument_list|,
specifier|const
name|Target
operator|*
name|target
argument_list|,
name|Output_file
operator|*
name|of
argument_list|,
name|Task_token
operator|*
name|final_blocker
argument_list|)
operator|:
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|target_
argument_list|(
name|target
argument_list|)
block|,
name|of_
argument_list|(
name|of
argument_list|)
block|,
name|final_blocker_
argument_list|(
argument|final_blocker
argument_list|)
block|{ }
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
specifier|const
name|Layout
operator|*
name|layout_
block|;
specifier|const
name|Symbol_table
operator|*
name|symtab_
block|;
specifier|const
name|Target
operator|*
name|target_
block|;
name|Output_file
operator|*
name|of_
block|;
name|Task_token
operator|*
name|final_blocker_
block|; }
decl_stmt|;
comment|// This task handles writing out the global symbols.
name|class
name|Write_symbols_task
range|:
name|public
name|Task
block|{
name|public
operator|:
name|Write_symbols_task
argument_list|(
specifier|const
name|Symbol_table
operator|*
name|symtab
argument_list|,
specifier|const
name|Target
operator|*
name|target
argument_list|,
specifier|const
name|Stringpool
operator|*
name|sympool
argument_list|,
specifier|const
name|Stringpool
operator|*
name|dynpool
argument_list|,
name|Output_file
operator|*
name|of
argument_list|,
name|Task_token
operator|*
name|final_blocker
argument_list|)
operator|:
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|target_
argument_list|(
name|target
argument_list|)
block|,
name|sympool_
argument_list|(
name|sympool
argument_list|)
block|,
name|dynpool_
argument_list|(
name|dynpool
argument_list|)
block|,
name|of_
argument_list|(
name|of
argument_list|)
block|,
name|final_blocker_
argument_list|(
argument|final_blocker
argument_list|)
block|{ }
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
specifier|const
name|Symbol_table
operator|*
name|symtab_
block|;
specifier|const
name|Target
operator|*
name|target_
block|;
specifier|const
name|Stringpool
operator|*
name|sympool_
block|;
specifier|const
name|Stringpool
operator|*
name|dynpool_
block|;
name|Output_file
operator|*
name|of_
block|;
name|Task_token
operator|*
name|final_blocker_
block|; }
decl_stmt|;
comment|// This task function handles closing the file.
name|class
name|Close_task_runner
range|:
name|public
name|Task_function_runner
block|{
name|public
operator|:
name|Close_task_runner
argument_list|(
name|Output_file
operator|*
name|of
argument_list|)
operator|:
name|of_
argument_list|(
argument|of
argument_list|)
block|{ }
comment|// Run the operation.
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
name|Output_file
operator|*
name|of_
block|; }
decl_stmt|;
comment|// A small helper function to align an address.
specifier|inline
name|uint64_t
name|align_address
parameter_list|(
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|addralign
parameter_list|)
block|{
if|if
condition|(
name|addralign
operator|!=
literal|0
condition|)
name|address
operator|=
operator|(
name|address
operator|+
name|addralign
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|addralign
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|address
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// End namespace gold.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(GOLD_LAYOUT_H)
end_comment

end_unit

