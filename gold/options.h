begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// options.h -- handle command line options for gold  -*- C++ -*-
end_comment

begin_comment
comment|// Command_line
end_comment

begin_comment
comment|//   Holds everything we get from the command line.
end_comment

begin_comment
comment|// General_options (from Command_line::options())
end_comment

begin_comment
comment|//   Options which are not position dependent.
end_comment

begin_comment
comment|// Input_argument (from Command_line::inputs())
end_comment

begin_comment
comment|//   The list of input files, including -l options.
end_comment

begin_comment
comment|// Position_dependent_options (from Input_argument::options())
end_comment

begin_comment
comment|//   Position dependent options which apply to this argument.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GOLD_OPTIONS_H
end_ifndef

begin_define
define|#
directive|define
name|GOLD_OPTIONS_H
end_define

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|gold
block|{
name|class
name|Command_line
decl_stmt|;
name|class
name|Input_file_group
decl_stmt|;
name|namespace
name|options
block|{
name|class
name|Command_line_options
decl_stmt|;
struct_decl|struct
name|One_option
struct_decl|;
block|}
comment|// End namespace gold::options.
comment|// The position independent options which apply to the whole link.
comment|// There are a lot of them.
name|class
name|General_options
block|{
name|public
label|:
name|General_options
argument_list|()
expr_stmt|;
comment|// -I: dynamic linker name.
specifier|const
name|char
operator|*
name|dynamic_linker
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|dynamic_linker_
return|;
block|}
comment|// -L: Library search path.
typedef|typedef
name|std
operator|::
name|list
operator|<
specifier|const
name|char
operator|*
operator|>
name|Dir_list
expr_stmt|;
specifier|const
name|Dir_list
operator|&
name|search_path
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|search_path_
return|;
block|}
comment|// -o: Output file name.
specifier|const
name|char
operator|*
name|output_file_name
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|output_file_name_
return|;
block|}
comment|// -r: Whether we are doing a relocatable link.
name|bool
name|is_relocatable
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|is_relocatable_
return|;
block|}
comment|// --shared: Whether generating a shared object.
name|bool
name|is_shared
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|is_shared_
return|;
block|}
comment|// --static: Whether doing a static link.
name|bool
name|is_static
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|is_static_
return|;
block|}
name|private
label|:
comment|// Don't copy this structure.
name|General_options
argument_list|(
specifier|const
name|General_options
operator|&
argument_list|)
expr_stmt|;
name|General_options
modifier|&
name|operator
init|=
operator|(
specifier|const
name|General_options
operator|&
operator|)
decl_stmt|;
name|friend
name|class
name|Command_line
decl_stmt|;
name|friend
name|class
name|options
operator|::
name|Command_line_options
expr_stmt|;
name|void
name|set_dynamic_linker
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|this
operator|->
name|dynamic_linker_
operator|=
name|arg
expr_stmt|;
block|}
name|void
name|add_to_search_path
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|this
operator|->
name|search_path_
operator|.
name|push_back
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|void
name|set_output_file_name
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|this
operator|->
name|output_file_name_
operator|=
name|arg
expr_stmt|;
block|}
name|void
name|set_relocatable
parameter_list|()
block|{
name|this
operator|->
name|is_relocatable_
operator|=
name|true
expr_stmt|;
block|}
name|void
name|set_shared
parameter_list|()
block|{
name|this
operator|->
name|is_shared_
operator|=
name|true
expr_stmt|;
block|}
name|void
name|set_static
parameter_list|()
block|{
name|this
operator|->
name|is_static_
operator|=
name|true
expr_stmt|;
block|}
name|void
name|ignore
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
block|{ }
specifier|const
name|char
modifier|*
name|dynamic_linker_
decl_stmt|;
name|Dir_list
name|search_path_
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_file_name_
decl_stmt|;
name|bool
name|is_relocatable_
decl_stmt|;
name|bool
name|is_shared_
decl_stmt|;
name|bool
name|is_static_
decl_stmt|;
block|}
empty_stmt|;
comment|// The current state of the position dependent options.
name|class
name|Position_dependent_options
block|{
name|public
label|:
name|Position_dependent_options
argument_list|()
expr_stmt|;
comment|// -Bstatic: Whether we are searching for a static archive rather
comment|// than a shared object.
name|bool
name|do_static_search
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|do_static_search_
return|;
block|}
comment|// --as-needed: Whether to add a DT_NEEDED argument only if the
comment|// dynamic object is used.
name|bool
name|as_needed
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|as_needed_
return|;
block|}
name|void
name|set_static_search
parameter_list|()
block|{
name|this
operator|->
name|do_static_search_
operator|=
name|true
expr_stmt|;
block|}
name|void
name|set_dynamic_search
parameter_list|()
block|{
name|this
operator|->
name|do_static_search_
operator|=
name|false
expr_stmt|;
block|}
name|void
name|set_as_needed
parameter_list|()
block|{
name|this
operator|->
name|as_needed_
operator|=
name|true
expr_stmt|;
block|}
name|void
name|clear_as_needed
parameter_list|()
block|{
name|this
operator|->
name|as_needed_
operator|=
name|false
expr_stmt|;
block|}
name|private
label|:
name|bool
name|do_static_search_
decl_stmt|;
name|bool
name|as_needed_
decl_stmt|;
block|}
empty_stmt|;
comment|// A single file or library argument from the command line.
name|class
name|Input_file_argument
block|{
name|public
label|:
name|Input_file_argument
argument_list|()
operator|:
name|name_
argument_list|()
operator|,
name|is_lib_
argument_list|(
name|false
argument_list|)
operator|,
name|options_
argument_list|()
block|{ }
name|Input_file_argument
argument_list|(
argument|const char* name
argument_list|,
argument|bool is_lib
argument_list|,
argument|const Position_dependent_options& options
argument_list|)
operator|:
name|name_
argument_list|(
name|name
argument_list|)
operator|,
name|is_lib_
argument_list|(
name|is_lib
argument_list|)
operator|,
name|options_
argument_list|(
argument|options
argument_list|)
block|{ }
specifier|const
name|char
operator|*
name|name
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|name_
operator|.
name|c_str
argument_list|()
return|;
block|}
specifier|const
name|Position_dependent_options
operator|&
name|options
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|options_
return|;
block|}
name|bool
name|is_lib
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|is_lib_
return|;
block|}
name|private
label|:
comment|// We use std::string, not const char*, here for convenience when
comment|// using script files, so that we do not have to preserve the string
comment|// in that case.
name|std
operator|::
name|string
name|name_
expr_stmt|;
name|bool
name|is_lib_
decl_stmt|;
name|Position_dependent_options
name|options_
decl_stmt|;
block|}
empty_stmt|;
comment|// A file or library, or a group, from the command line.
name|class
name|Input_argument
block|{
name|public
label|:
comment|// Create a file or library argument.
name|explicit
name|Input_argument
argument_list|(
argument|Input_file_argument file
argument_list|)
block|:
name|is_file_
argument_list|(
name|true
argument_list|)
operator|,
name|file_
argument_list|(
name|file
argument_list|)
operator|,
name|group_
argument_list|(
argument|NULL
argument_list|)
block|{ }
comment|// Create a group argument.
name|explicit
name|Input_argument
argument_list|(
name|Input_file_group
operator|*
name|group
argument_list|)
operator|:
name|is_file_
argument_list|(
name|false
argument_list|)
operator|,
name|group_
argument_list|(
argument|group
argument_list|)
block|{ }
comment|// Return whether this is a file.
name|bool
name|is_file
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|is_file_
return|;
block|}
comment|// Return whether this is a group.
name|bool
name|is_group
argument_list|()
specifier|const
block|{
return|return
operator|!
name|this
operator|->
name|is_file_
return|;
block|}
comment|// Return the information about the file.
specifier|const
name|Input_file_argument
operator|&
name|file
argument_list|()
specifier|const
block|{
name|gold_assert
argument_list|(
name|this
operator|->
name|is_file_
argument_list|)
block|;
return|return
name|this
operator|->
name|file_
return|;
block|}
comment|// Return the information about the group.
specifier|const
name|Input_file_group
operator|*
name|group
argument_list|()
specifier|const
block|{
name|gold_assert
argument_list|(
operator|!
name|this
operator|->
name|is_file_
argument_list|)
block|;
return|return
name|this
operator|->
name|group_
return|;
block|}
name|Input_file_group
modifier|*
name|group
parameter_list|()
block|{
name|gold_assert
argument_list|(
operator|!
name|this
operator|->
name|is_file_
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|group_
return|;
block|}
name|private
label|:
name|bool
name|is_file_
decl_stmt|;
name|Input_file_argument
name|file_
decl_stmt|;
name|Input_file_group
modifier|*
name|group_
decl_stmt|;
block|}
empty_stmt|;
comment|// A group from the command line.  This is a set of arguments within
comment|// --start-group ... --end-group.
name|class
name|Input_file_group
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Input_argument
operator|>
name|Files
expr_stmt|;
typedef|typedef
name|Files
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|Input_file_group
argument_list|()
operator|:
name|files_
argument_list|()
block|{ }
comment|// Add a file to the end of the group.
name|void
name|add_file
argument_list|(
argument|const Input_file_argument& arg
argument_list|)
block|{
name|this
operator|->
name|files_
operator|.
name|push_back
argument_list|(
name|Input_argument
argument_list|(
name|arg
argument_list|)
argument_list|)
block|; }
comment|// Iterators to iterate over the group contents.
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|files_
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|files_
operator|.
name|end
argument_list|()
return|;
block|}
name|private
label|:
name|Files
name|files_
decl_stmt|;
block|}
empty_stmt|;
comment|// A list of files from the command line or a script.
name|class
name|Input_arguments
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Input_argument
operator|>
name|Input_argument_list
expr_stmt|;
typedef|typedef
name|Input_argument_list
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|Input_arguments
argument_list|()
operator|:
name|input_argument_list_
argument_list|()
operator|,
name|in_group_
argument_list|(
argument|false
argument_list|)
block|{ }
comment|// Add a file.
name|void
name|add_file
argument_list|(
specifier|const
name|Input_file_argument
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|// Start a group (the --start-group option).
name|void
name|start_group
parameter_list|()
function_decl|;
comment|// End a group (the --end-group option).
name|void
name|end_group
parameter_list|()
function_decl|;
comment|// Return whether we are currently in a group.
name|bool
name|in_group
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|in_group_
return|;
block|}
comment|// Iterators to iterate over the list of input files.
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|input_argument_list_
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|input_argument_list_
operator|.
name|end
argument_list|()
return|;
block|}
comment|// Return whether the list is empty.
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|input_argument_list_
operator|.
name|empty
argument_list|()
return|;
block|}
name|private
label|:
name|Input_argument_list
name|input_argument_list_
decl_stmt|;
name|bool
name|in_group_
decl_stmt|;
block|}
empty_stmt|;
comment|// All the information read from the command line.
name|class
name|Command_line
block|{
name|public
label|:
typedef|typedef
name|Input_arguments
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|Command_line
argument_list|()
expr_stmt|;
comment|// Process the command line options.  This will exit with an
comment|// appropriate error message if an unrecognized option is seen.
name|void
name|process
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
comment|// Handle a -l option.
name|int
name|process_l_option
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
comment|// Handle a --start-group option.
name|void
name|start_group
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|// Handle a --end-group option.
name|void
name|end_group
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|// Get the general options.
specifier|const
name|General_options
operator|&
name|options
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|options_
return|;
block|}
comment|// Iterators to iterate over the list of input files.
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|inputs_
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|inputs_
operator|.
name|end
argument_list|()
return|;
block|}
name|private
label|:
name|Command_line
argument_list|(
specifier|const
name|Command_line
operator|&
argument_list|)
expr_stmt|;
name|Command_line
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Command_line
operator|&
operator|)
decl_stmt|;
comment|// Report usage error.
name|void
name|usage
argument_list|()
name|ATTRIBUTE_NORETURN
expr_stmt|;
name|void
name|usage
argument_list|(
specifier|const
name|char
operator|*
name|msg
argument_list|,
specifier|const
name|char
operator|*
name|opt
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
name|void
name|usage
argument_list|(
specifier|const
name|char
operator|*
name|msg
argument_list|,
name|char
name|opt
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
comment|// Apply a command line option.
name|void
name|apply_option
argument_list|(
specifier|const
name|gold
operator|::
name|options
operator|::
name|One_option
operator|&
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|// Add a file.
name|void
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|is_lib
parameter_list|)
function_decl|;
name|General_options
name|options_
decl_stmt|;
name|Position_dependent_options
name|position_options_
decl_stmt|;
name|Input_arguments
name|inputs_
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// End namespace gold.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(GOLD_OPTIONS_H)
end_comment

end_unit

