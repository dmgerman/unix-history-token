begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// readsyms.h -- read input file symbols for gold   -*- C++ -*-
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GOLD_READSYMS_H
end_ifndef

begin_define
define|#
directive|define
name|GOLD_READSYMS_H
end_define

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_decl_stmt
name|namespace
name|gold
block|{
name|class
name|Input_objects
decl_stmt|;
name|class
name|Symbol_table
decl_stmt|;
name|class
name|Input_group
decl_stmt|;
name|class
name|Archive
decl_stmt|;
comment|// This Task is responsible for reading the symbols from an input
comment|// file.  This also includes reading the relocations so that we can
comment|// check for any that require a PLT and/or a GOT.  After the data has
comment|// been read, this queues up another task to actually add the symbols
comment|// to the symbol table.  The tasks are separated because the file
comment|// reading can occur in parallel but adding the symbols must be done
comment|// in the order of the input files.
name|class
name|Read_symbols
range|:
name|public
name|Task
block|{
name|public
operator|:
comment|// DIRPATH is the list of directories to search for libraries.
comment|// INPUT is the file to read.  INPUT_GROUP is not NULL if we are in
comment|// the middle of an input group.  THIS_BLOCKER is used to prevent
comment|// the associated Add_symbols task from running before the previous
comment|// one has completed; it will be NULL for the first task.
comment|// NEXT_BLOCKER is used to block the next input file from adding
comment|// symbols.
name|Read_symbols
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|,
name|Input_objects
operator|*
name|input_objects
argument_list|,
name|Symbol_table
operator|*
name|symtab
argument_list|,
name|Layout
operator|*
name|layout
argument_list|,
specifier|const
name|Dirsearch
operator|&
name|dirpath
argument_list|,
specifier|const
name|Input_argument
operator|*
name|input_argument
argument_list|,
name|Input_group
operator|*
name|input_group
argument_list|,
name|Task_token
operator|*
name|this_blocker
argument_list|,
name|Task_token
operator|*
name|next_blocker
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|input_objects_
argument_list|(
name|input_objects
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|dirpath_
argument_list|(
name|dirpath
argument_list|)
block|,
name|input_argument_
argument_list|(
name|input_argument
argument_list|)
block|,
name|input_group_
argument_list|(
name|input_group
argument_list|)
block|,
name|this_blocker_
argument_list|(
name|this_blocker
argument_list|)
block|,
name|next_blocker_
argument_list|(
argument|next_blocker
argument_list|)
block|{ }
operator|~
name|Read_symbols
argument_list|()
block|;
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
comment|// Handle an archive group.
name|void
name|do_group
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
specifier|const
name|General_options
operator|&
name|options_
block|;
name|Input_objects
operator|*
name|input_objects_
block|;
name|Symbol_table
operator|*
name|symtab_
block|;
name|Layout
operator|*
name|layout_
block|;
specifier|const
name|Dirsearch
operator|&
name|dirpath_
block|;
specifier|const
name|Input_argument
operator|*
name|input_argument_
block|;
name|Input_group
operator|*
name|input_group_
block|;
name|Task_token
operator|*
name|this_blocker_
block|;
name|Task_token
operator|*
name|next_blocker_
block|; }
decl_stmt|;
comment|// This Task handles adding the symbols to the symbol table.  These
comment|// tasks must be run in the same order as the arguments appear on the
comment|// command line.
name|class
name|Add_symbols
range|:
name|public
name|Task
block|{
name|public
operator|:
comment|// THIS_BLOCKER is used to prevent this task from running before the
comment|// one for the previous input file.  NEXT_BLOCKER is used to prevent
comment|// the next task from running.
name|Add_symbols
argument_list|(
specifier|const
name|General_options
operator|&
name|options
argument_list|,
name|Input_objects
operator|*
name|input_objects
argument_list|,
name|Symbol_table
operator|*
name|symtab
argument_list|,
name|Layout
operator|*
name|layout
argument_list|,
name|Object
operator|*
name|object
argument_list|,
name|Read_symbols_data
operator|*
name|sd
argument_list|,
name|Task_token
operator|*
name|this_blocker
argument_list|,
name|Task_token
operator|*
name|next_blocker
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|input_objects_
argument_list|(
name|input_objects
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|object_
argument_list|(
name|object
argument_list|)
block|,
name|sd_
argument_list|(
name|sd
argument_list|)
block|,
name|this_blocker_
argument_list|(
name|this_blocker
argument_list|)
block|,
name|next_blocker_
argument_list|(
argument|next_blocker
argument_list|)
block|{ }
operator|~
name|Add_symbols
argument_list|()
block|;
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
name|class
name|Add_symbols_locker
block|;
specifier|const
name|General_options
operator|&
name|options_
block|;
name|Input_objects
operator|*
name|input_objects_
block|;
name|Symbol_table
operator|*
name|symtab_
block|;
name|Layout
operator|*
name|layout_
block|;
name|Object
operator|*
name|object_
block|;
name|Read_symbols_data
operator|*
name|sd_
block|;
name|Task_token
operator|*
name|this_blocker_
block|;
name|Task_token
operator|*
name|next_blocker_
block|; }
decl_stmt|;
comment|// This class is used to track the archives in a group.
name|class
name|Input_group
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Archive
operator|*
operator|>
name|Archives
expr_stmt|;
typedef|typedef
name|Archives
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|Input_group
argument_list|()
operator|:
name|archives_
argument_list|()
block|{ }
comment|// Add an archive to the group.
name|void
name|add_archive
argument_list|(
argument|Archive* arch
argument_list|)
block|{
name|this
operator|->
name|archives_
operator|.
name|push_back
argument_list|(
name|arch
argument_list|)
block|; }
comment|// Loop over the archives in the group.
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|archives_
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|archives_
operator|.
name|end
argument_list|()
return|;
block|}
name|private
label|:
name|Archives
name|archives_
decl_stmt|;
block|}
empty_stmt|;
comment|// This class is used to finish up handling a group.  It is just a
comment|// closure.
name|class
name|Finish_group
range|:
name|public
name|Task
block|{
name|public
operator|:
name|Finish_group
argument_list|(
argument|const General_options& options
argument_list|,
argument|Input_objects* input_objects
argument_list|,
argument|Symbol_table* symtab
argument_list|,
argument|Layout* layout
argument_list|,
argument|Input_group* input_group
argument_list|,
argument|int saw_undefined
argument_list|,
argument|Task_token* this_blocker
argument_list|,
argument|Task_token* next_blocker
argument_list|)
operator|:
name|options_
argument_list|(
name|options
argument_list|)
block|,
name|input_objects_
argument_list|(
name|input_objects
argument_list|)
block|,
name|symtab_
argument_list|(
name|symtab
argument_list|)
block|,
name|layout_
argument_list|(
name|layout
argument_list|)
block|,
name|input_group_
argument_list|(
name|input_group
argument_list|)
block|,
name|saw_undefined_
argument_list|(
name|saw_undefined
argument_list|)
block|,
name|this_blocker_
argument_list|(
name|this_blocker
argument_list|)
block|,
name|next_blocker_
argument_list|(
argument|next_blocker
argument_list|)
block|{ }
operator|~
name|Finish_group
argument_list|()
block|;
comment|// The standard Task methods.
name|Is_runnable_type
name|is_runnable
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|Task_locker
operator|*
name|locks
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|void
name|run
argument_list|(
name|Workqueue
operator|*
argument_list|)
block|;
name|private
operator|:
specifier|const
name|General_options
operator|&
name|options_
block|;
name|Input_objects
operator|*
name|input_objects_
block|;
name|Symbol_table
operator|*
name|symtab_
block|;
name|Layout
operator|*
name|layout_
block|;
name|Input_group
operator|*
name|input_group_
block|;
name|int
name|saw_undefined_
block|;
name|Task_token
operator|*
name|this_blocker_
block|;
name|Task_token
operator|*
name|next_blocker_
block|; }
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace gold
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(GOLD_READSYMS_H)
end_comment

end_unit

