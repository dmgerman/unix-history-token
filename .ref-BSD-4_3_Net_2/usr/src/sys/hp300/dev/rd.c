begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah $Hdr: rd.c 1.38 90/10/12$  *  *	@(#)rd.c	7.9 (Berkeley) 5/7/91  */
end_comment

begin_comment
comment|/*  * CS80/SS80 disk driver  */
end_comment

begin_include
include|#
directive|include
file|"rd.h"
end_include

begin_if
if|#
directive|if
name|NRD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"sys/dkstat.h"
end_include

begin_include
include|#
directive|include
file|"sys/disklabel.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/uio.h"
end_include

begin_include
include|#
directive|include
file|"device.h"
end_include

begin_include
include|#
directive|include
file|"rdreg.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_param.h"
end_include

begin_include
include|#
directive|include
file|"vm/lock.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_statistics.h"
end_include

begin_include
include|#
directive|include
file|"vm/pmap.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_prot.h"
end_include

begin_decl_stmt
name|int
name|rdinit
argument_list|()
decl_stmt|,
name|rdstart
argument_list|()
decl_stmt|,
name|rdgo
argument_list|()
decl_stmt|,
name|rdintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|rddriver
init|=
block|{
name|rdinit
block|,
literal|"rd"
block|,
name|rdstart
block|,
name|rdgo
block|,
name|rdintr
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rd_softc
block|{
name|struct
name|hp_device
modifier|*
name|sc_hd
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
name|short
name|sc_type
decl_stmt|;
name|short
name|sc_punit
decl_stmt|;
name|char
modifier|*
name|sc_addr
decl_stmt|;
name|int
name|sc_resid
decl_stmt|;
name|u_int
name|sc_wpms
decl_stmt|;
name|struct
name|rdinfo
modifier|*
name|sc_info
decl_stmt|;
name|struct
name|devqueue
name|sc_dq
decl_stmt|;
name|struct
name|rd_iocmd
name|sc_ioc
decl_stmt|;
name|struct
name|rd_rscmd
name|sc_rsc
decl_stmt|;
name|struct
name|rd_stat
name|sc_stat
decl_stmt|;
name|struct
name|rd_ssmcmd
name|sc_ssmc
decl_stmt|;
name|struct
name|rd_srcmd
name|sc_src
decl_stmt|;
name|struct
name|rd_clearcmd
name|sc_clear
decl_stmt|;
block|}
name|rd_softc
index|[
name|NRD
index|]
struct|;
end_struct

begin_comment
comment|/* sc_flags values */
end_comment

begin_define
define|#
directive|define
name|RDF_ALIVE
value|0x1
end_define

begin_define
define|#
directive|define
name|RDF_SEEK
value|0x2
end_define

begin_define
define|#
directive|define
name|RDF_SWAIT
value|0x4
end_define

begin_struct
struct|struct
name|size
block|{
name|daddr_t
name|nblocks
decl_stmt|;
name|int
name|cyloff
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|rddebug
init|=
literal|0x80
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RDB_FOLLOW
value|0x01
end_define

begin_define
define|#
directive|define
name|RDB_STATUS
value|0x02
end_define

begin_define
define|#
directive|define
name|RDB_IDENT
value|0x04
end_define

begin_define
define|#
directive|define
name|RDB_IO
value|0x08
end_define

begin_define
define|#
directive|define
name|RDB_ASYNC
value|0x10
end_define

begin_define
define|#
directive|define
name|RDB_ERROR
value|0x80
end_define

begin_define
define|#
directive|define
name|RDB_DUMP
value|0x80000000
end_define

begin_struct
struct|struct
name|rdstats
block|{
name|long
name|rdretries
decl_stmt|;
name|long
name|rdresets
decl_stmt|;
name|long
name|rdtimeouts
decl_stmt|;
name|long
name|rdpolltries
decl_stmt|;
name|long
name|rdpollwaits
decl_stmt|;
block|}
name|rdstats
index|[
name|NRD
index|]
struct|;
end_struct

begin_comment
comment|/* error message tables */
end_comment

begin_decl_stmt
name|char
modifier|*
name|err_reject
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"channel parity error"
block|,
comment|/* 0x2000 */
literal|0
block|,
literal|0
block|,
literal|"illegal opcode"
block|,
comment|/* 0x0400 */
literal|"module addressing"
block|,
comment|/* 0x0200 */
literal|"address bounds"
block|,
comment|/* 0x0100 */
literal|"parameter bounds"
block|,
comment|/* 0x0080 */
literal|"illegal parameter"
block|,
comment|/* 0x0040 */
literal|"message sequence"
block|,
comment|/* 0x0020 */
literal|0
block|,
literal|"message length"
block|,
comment|/* 0x0008 */
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err_fault
index|[]
init|=
block|{
literal|0
block|,
literal|"cross unit"
block|,
comment|/* 0x4000 */
literal|0
block|,
literal|"controller fault"
block|,
comment|/* 0x1000 */
literal|0
block|,
literal|0
block|,
literal|"unit fault"
block|,
comment|/* 0x0200 */
literal|0
block|,
literal|"diagnostic result"
block|,
comment|/* 0x0080 */
literal|0
block|,
literal|"operator release request"
block|,
comment|/* 0x0020 */
literal|"diagnostic release request"
block|,
comment|/* 0x0010 */
literal|"internal maintenance release request"
block|,
comment|/* 0x0008 */
literal|0
block|,
literal|"power fail"
block|,
comment|/* 0x0002 */
literal|"retransmit"
comment|/* 0x0001 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err_access
index|[]
init|=
block|{
literal|"illegal parallel operation"
block|,
comment|/* 0x8000 */
literal|"uninitialized media"
block|,
comment|/* 0x4000 */
literal|"no spares available"
block|,
comment|/* 0x2000 */
literal|"not ready"
block|,
comment|/* 0x1000 */
literal|"write protect"
block|,
comment|/* 0x0800 */
literal|"no data found"
block|,
comment|/* 0x0400 */
literal|0
block|,
literal|0
block|,
literal|"unrecoverable data overflow"
block|,
comment|/* 0x0080 */
literal|"unrecoverable data"
block|,
comment|/* 0x0040 */
literal|0
block|,
literal|"end of file"
block|,
comment|/* 0x0010 */
literal|"end of volume"
block|,
comment|/* 0x0008 */
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err_info
index|[]
init|=
block|{
literal|"operator release request"
block|,
comment|/* 0x8000 */
literal|"diagnostic release request"
block|,
comment|/* 0x4000 */
literal|"internal maintenance release request"
block|,
comment|/* 0x2000 */
literal|"media wear"
block|,
comment|/* 0x1000 */
literal|"latency induced"
block|,
comment|/* 0x0800 */
literal|0
block|,
literal|0
block|,
literal|"auto sparing invoked"
block|,
comment|/* 0x0100 */
literal|0
block|,
literal|"recoverable data overflow"
block|,
comment|/* 0x0040 */
literal|"marginal data"
block|,
comment|/* 0x0020 */
literal|"recoverable data"
block|,
comment|/* 0x0010 */
literal|0
block|,
literal|"maintenance track overflow"
block|,
comment|/* 0x0004 */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CS/80 partitions.  We reserve the first cylinder for a LIF  * style boot directory (the 8k allowed in the BSD filesystem  * is just way too small).  This boot area is outside of all but  * the C partition.  This implies that you cannot use the C   * partition on a bootable disk since the filesystem would overlay  * the boot area.  You must use the A partition.  *  * These maps support four basic layouts:  *  *	A/B/G:   This is the "traditional" setup for a bootable disk.  *	         A is the root partition, B the swap, and G a user partition.  *	A/D/H:   This is a setup for bootable systems requiring more swap  *		 (e.g. those who use HPCL).  It has A as the root, D as a  *		 larger swap, and H as a smaller user partition.  *	A/D/E/F: Similar to A/D/H with E and F breaking H into two partitions.  *		 E could be used for /usr and F for users.  *	C:       This gives a single, non-bootable, large user filesystem.  *	         Good for second drives on a machine (e.g. /usr/src).  */
end_comment

begin_decl_stmt
name|struct
name|size
name|rd7945A_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|15904
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 142 */
name|RDSZ
argument_list|(
literal|20160
argument_list|)
block|,
literal|143
block|,
comment|/* B=cyl 143 thru 322 */
name|RDSZ
argument_list|(
literal|108416
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 967 */
name|RDSZ
argument_list|(
literal|40320
argument_list|)
block|,
literal|143
block|,
comment|/* D=cyl 143 thru 502 */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* E=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* F=<undefined> */
name|RDSZ
argument_list|(
literal|72240
argument_list|)
block|,
literal|323
block|,
comment|/* G=cyl 323 thru 967 */
name|RDSZ
argument_list|(
literal|52080
argument_list|)
block|,
literal|503
block|,
comment|/* H=cyl 503 thru 967 */
block|}
decl_stmt|,
name|rd9134D_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|15936
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 166 */
name|RDSZ
argument_list|(
literal|13056
argument_list|)
block|,
literal|167
block|,
comment|/* B=cyl 167 thru 302 */
name|RDSZ
argument_list|(
literal|29088
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 302 */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* D=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* E=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* F=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* G=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* H=<undefined> */
block|}
decl_stmt|,
name|rd9122S_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* A=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* B=<undefined> */
name|RDSZ
argument_list|(
literal|1232
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 76 */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* D=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* E=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* F=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* G=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* H=<undefined> */
block|}
decl_stmt|,
name|rd7912P_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|15904
argument_list|)
block|,
literal|0
block|,
comment|/* A=cyl 1 thru 71 */
name|RDSZ
argument_list|(
literal|22400
argument_list|)
block|,
literal|72
block|,
comment|/* B=cyl 72 thru 171 */
name|RDSZ
argument_list|(
literal|128128
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 571 */
name|RDSZ
argument_list|(
literal|42560
argument_list|)
block|,
literal|72
block|,
comment|/* D=cyl 72 thru 261 */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|292
block|,
comment|/* E=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|542
block|,
comment|/* F=<undefined> */
name|RDSZ
argument_list|(
literal|89600
argument_list|)
block|,
literal|172
block|,
comment|/* G=cyl 221 thru 571 */
name|RDSZ
argument_list|(
literal|69440
argument_list|)
block|,
literal|262
block|,
comment|/* H=cyl 262 thru 571 */
block|}
decl_stmt|,
name|rd7914P_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|15904
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 71 */
name|RDSZ
argument_list|(
literal|40320
argument_list|)
block|,
literal|72
block|,
comment|/* B=cyl 72 thru 251 */
name|RDSZ
argument_list|(
literal|258048
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1151 */
name|RDSZ
argument_list|(
literal|64960
argument_list|)
block|,
literal|72
block|,
comment|/* D=cyl 72 thru 361 */
name|RDSZ
argument_list|(
literal|98560
argument_list|)
block|,
literal|362
block|,
comment|/* E=cyl 362 thru 801 */
name|RDSZ
argument_list|(
literal|78400
argument_list|)
block|,
literal|802
block|,
comment|/* F=cyl 802 thru 1151 */
name|RDSZ
argument_list|(
literal|201600
argument_list|)
block|,
literal|252
block|,
comment|/* G=cyl 221 thru 1151 */
name|RDSZ
argument_list|(
literal|176960
argument_list|)
block|,
literal|362
block|,
comment|/* H=cyl 362 thru 1151 */
block|}
decl_stmt|,
name|rd7933H_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16146
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 27 */
name|RDSZ
argument_list|(
literal|66976
argument_list|)
block|,
literal|28
block|,
comment|/* B=cyl 28 thru 139 */
name|RDSZ
argument_list|(
literal|789958
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1320 */
name|RDSZ
argument_list|(
literal|16146
argument_list|)
block|,
literal|140
block|,
comment|/* D=cyl 140 thru 166 */
name|RDSZ
argument_list|(
literal|165646
argument_list|)
block|,
literal|167
block|,
comment|/* E=cyl 167 thru 443 */
name|RDSZ
argument_list|(
literal|165646
argument_list|)
block|,
literal|444
block|,
comment|/* F=cyl 444 thru 720 */
name|RDSZ
argument_list|(
literal|706238
argument_list|)
block|,
literal|140
block|,
comment|/* G=cyl 140 thru 1320 */
name|RDSZ
argument_list|(
literal|358800
argument_list|)
block|,
literal|721
block|,
comment|/* H=cyl 721 thru 1320 */
block|}
decl_stmt|,
name|rd9134L_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|15920
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 199 */
name|RDSZ
argument_list|(
literal|20000
argument_list|)
block|,
literal|200
block|,
comment|/* B=cyl 200 thru 449 */
name|RDSZ
argument_list|(
literal|77840
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 972 */
name|RDSZ
argument_list|(
literal|32000
argument_list|)
block|,
literal|200
block|,
comment|/* D=cyl 200 thru 599 */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* E=<undefined> */
name|RDSZ
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* F=<undefined> */
name|RDSZ
argument_list|(
literal|41840
argument_list|)
block|,
literal|450
block|,
comment|/* G=cyl 450 thru 972 */
name|RDSZ
argument_list|(
literal|29840
argument_list|)
block|,
literal|600
block|,
comment|/* H=cyl 600 thru 972 */
block|}
decl_stmt|,
name|rd7957A_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16016
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 104 */
name|RDSZ
argument_list|(
literal|24640
argument_list|)
block|,
literal|105
block|,
comment|/* B=cyl 105 thru 264 */
name|RDSZ
argument_list|(
literal|159544
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1035 */
name|RDSZ
argument_list|(
literal|42350
argument_list|)
block|,
literal|105
block|,
comment|/* D=cyl 105 thru 379 */
name|RDSZ
argument_list|(
literal|54824
argument_list|)
block|,
literal|380
block|,
comment|/* E=cyl 380 thru 735 */
name|RDSZ
argument_list|(
literal|46200
argument_list|)
block|,
literal|736
block|,
comment|/* F=cyl 736 thru 1035 */
name|RDSZ
argument_list|(
literal|118734
argument_list|)
block|,
literal|265
block|,
comment|/* G=cyl 265 thru 1035 */
name|RDSZ
argument_list|(
literal|101024
argument_list|)
block|,
literal|380
block|,
comment|/* H=cyl 380 thru 1035 */
block|}
decl_stmt|,
name|rd7958A_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16128
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 64 */
name|RDSZ
argument_list|(
literal|32256
argument_list|)
block|,
literal|65
block|,
comment|/* B=cyl 65 thru 192 */
name|RDSZ
argument_list|(
literal|255276
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1012 */
name|RDSZ
argument_list|(
literal|48384
argument_list|)
block|,
literal|65
block|,
comment|/* D=cyl 65 thru 256 */
name|RDSZ
argument_list|(
literal|100800
argument_list|)
block|,
literal|257
block|,
comment|/* E=cyl 257 thru 656 */
name|RDSZ
argument_list|(
literal|89712
argument_list|)
block|,
literal|657
block|,
comment|/* F=cyl 657 thru 1012 */
name|RDSZ
argument_list|(
literal|206640
argument_list|)
block|,
literal|193
block|,
comment|/* G=cyl 193 thru 1012 */
name|RDSZ
argument_list|(
literal|190512
argument_list|)
block|,
literal|257
block|,
comment|/* H=cyl 257 thru 1012 */
block|}
decl_stmt|,
name|rd7957B_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16002
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 127 */
name|RDSZ
argument_list|(
literal|32760
argument_list|)
block|,
literal|128
block|,
comment|/* B=cyl 128 thru 387 */
name|RDSZ
argument_list|(
literal|159894
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1268 */
name|RDSZ
argument_list|(
literal|49140
argument_list|)
block|,
literal|128
block|,
comment|/* D=cyl 128 thru 517 */
name|RDSZ
argument_list|(
literal|50400
argument_list|)
block|,
literal|518
block|,
comment|/* E=cyl 518 thru 917 */
name|RDSZ
argument_list|(
literal|44226
argument_list|)
block|,
literal|918
block|,
comment|/* F=cyl 918 thru 1268 */
name|RDSZ
argument_list|(
literal|111006
argument_list|)
block|,
literal|388
block|,
comment|/* G=cyl 388 thru 1268 */
name|RDSZ
argument_list|(
literal|94626
argument_list|)
block|,
literal|518
block|,
comment|/* H=cyl 518 thru 1268 */
block|}
decl_stmt|,
name|rd7958B_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16254
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 43 */
name|RDSZ
argument_list|(
literal|32886
argument_list|)
block|,
literal|44
block|,
comment|/* B=cyl 44 thru 130 */
name|RDSZ
argument_list|(
literal|297108
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 785 */
name|RDSZ
argument_list|(
literal|49140
argument_list|)
block|,
literal|44
block|,
comment|/* D=cyl 44 thru 173 */
name|RDSZ
argument_list|(
literal|121716
argument_list|)
block|,
literal|174
block|,
comment|/* E=cyl 174 thru 495 */
name|RDSZ
argument_list|(
literal|109620
argument_list|)
block|,
literal|496
block|,
comment|/* F=cyl 496 thru 785 */
name|RDSZ
argument_list|(
literal|247590
argument_list|)
block|,
literal|131
block|,
comment|/* G=cyl 131 thru 785 */
name|RDSZ
argument_list|(
literal|231336
argument_list|)
block|,
literal|174
block|,
comment|/* H=cyl 174 thru 785 */
block|}
decl_stmt|,
name|rd7959B_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16254
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 43 */
name|RDSZ
argument_list|(
literal|49140
argument_list|)
block|,
literal|44
block|,
comment|/* B=cyl 44 thru 173 */
name|RDSZ
argument_list|(
literal|594216
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1571 */
name|RDSZ
argument_list|(
literal|65772
argument_list|)
block|,
literal|44
block|,
comment|/* D=cyl 44 thru 217 */
name|RDSZ
argument_list|(
literal|303912
argument_list|)
block|,
literal|218
block|,
comment|/* E=cyl 218 thru 1021 */
name|RDSZ
argument_list|(
literal|207900
argument_list|)
block|,
literal|1022
block|,
comment|/* F=cyl 1022 thru 1571 */
name|RDSZ
argument_list|(
literal|528444
argument_list|)
block|,
literal|174
block|,
comment|/* G=cyl 174 thru 1571 */
name|RDSZ
argument_list|(
literal|511812
argument_list|)
block|,
literal|218
block|,
comment|/* H=cyl 218 thru 1571 */
block|}
decl_stmt|,
name|rd2200A_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16272
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 36 */
name|RDSZ
argument_list|(
literal|49720
argument_list|)
block|,
literal|37
block|,
comment|/* B=cyl 37 thru 146 */
name|RDSZ
argument_list|(
literal|654948
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1448 */
name|RDSZ
argument_list|(
literal|65992
argument_list|)
block|,
literal|37
block|,
comment|/* D=cyl 37 thru 182 */
name|RDSZ
argument_list|(
literal|304648
argument_list|)
block|,
literal|183
block|,
comment|/* E=cyl 183 thru 856 */
name|RDSZ
argument_list|(
literal|267584
argument_list|)
block|,
literal|857
block|,
comment|/* F=cyl 857 thru 1448 */
name|RDSZ
argument_list|(
literal|588504
argument_list|)
block|,
literal|147
block|,
comment|/* G=cyl 147 thru 1448 */
name|RDSZ
argument_list|(
literal|572232
argument_list|)
block|,
literal|183
block|,
comment|/* H=cyl 183 thru 1448 */
block|}
decl_stmt|,
name|rd2203A_sizes
index|[
literal|8
index|]
init|=
block|{
comment|/* modelled after the 7937; i.e. bogus */
name|RDSZ
argument_list|(
literal|16272
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 18 */
name|RDSZ
argument_list|(
literal|67800
argument_list|)
block|,
literal|19
block|,
comment|/* B=cyl 19 thru 93 */
name|RDSZ
argument_list|(
literal|1309896
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 1448 */
name|RDSZ
argument_list|(
literal|16272
argument_list|)
block|,
literal|94
block|,
comment|/* D=cyl 19 thru 111 */
name|RDSZ
argument_list|(
literal|305552
argument_list|)
block|,
literal|112
block|,
comment|/* E=cyl 112 thru 449 */
name|RDSZ
argument_list|(
literal|305552
argument_list|)
block|,
literal|450
block|,
comment|/* F=cyl 450 thru 787 */
name|RDSZ
argument_list|(
literal|1224920
argument_list|)
block|,
literal|94
block|,
comment|/* G=cyl 94 thru 1448 */
name|RDSZ
argument_list|(
literal|597544
argument_list|)
block|,
literal|788
block|,
comment|/* H=cyl 788 thru 1448 */
if|#
directive|if
name|DEV_BSIZE
operator|==
literal|512
comment|/*  * These values would not work for 1k,  * since the number of cylinders would be different.  */
block|}
decl_stmt|,
name|rd7936H_sizes
index|[
literal|8
index|]
init|=
block|{
name|RDSZ
argument_list|(
literal|16359
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 19 */
name|RDSZ
argument_list|(
literal|67158
argument_list|)
block|,
literal|20
block|,
comment|/* B=cyl 20 thru 97 */
name|RDSZ
argument_list|(
literal|600978
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 697 */
name|RDSZ
argument_list|(
literal|16359
argument_list|)
block|,
literal|98
block|,
comment|/* D=cyl 98 thru 116 */
name|RDSZ
argument_list|(
literal|120540
argument_list|)
block|,
literal|117
block|,
comment|/* E=cyl 117 thru 256 */
name|RDSZ
argument_list|(
literal|120540
argument_list|)
block|,
literal|256
block|,
comment|/* F=cyl 256 thru 396 */
name|RDSZ
argument_list|(
literal|516600
argument_list|)
block|,
literal|98
block|,
comment|/* G=cyl 98 thru 697 */
name|RDSZ
argument_list|(
literal|259161
argument_list|)
block|,
literal|397
block|,
comment|/* H=cyl 397 thru 697 */
block|}
decl_stmt|,
name|rd7937H_sizes
index|[
literal|8
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|UTAH
name|RDSZ
argument_list|(
literal|15990
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 10 */
name|RDSZ
argument_list|(
literal|67158
argument_list|)
block|,
literal|11
block|,
comment|/* B=cyl 11 thru 52 */
name|RDSZ
argument_list|(
literal|1116102
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 697 */
name|RDSZ
argument_list|(
literal|124722
argument_list|)
block|,
literal|53
block|,
comment|/* D=cyl 53 thru 130 */
name|RDSZ
argument_list|(
literal|163098
argument_list|)
block|,
literal|131
block|,
comment|/* E=cyl 131 thru 232 */
name|RDSZ
argument_list|(
literal|287820
argument_list|)
block|,
literal|233
block|,
comment|/* F=cyl 233 thru 412 */
name|RDSZ
argument_list|(
literal|1031355
argument_list|)
block|,
literal|53
block|,
comment|/* G=cyl 53 thru 697 */
name|RDSZ
argument_list|(
literal|455715
argument_list|)
block|,
literal|413
block|,
comment|/* H=cyl 413 thru 697 */
else|#
directive|else
name|RDSZ
argument_list|(
literal|15990
argument_list|)
block|,
literal|1
block|,
comment|/* A=cyl 1 thru 10 */
name|RDSZ
argument_list|(
literal|67158
argument_list|)
block|,
literal|11
block|,
comment|/* B=cyl 11 thru 52 */
name|RDSZ
argument_list|(
literal|1116102
argument_list|)
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 697 */
name|RDSZ
argument_list|(
literal|15990
argument_list|)
block|,
literal|53
block|,
comment|/* D=cyl 53 thru 62 */
name|RDSZ
argument_list|(
literal|246246
argument_list|)
block|,
literal|63
block|,
comment|/* E=cyl 63 thru 216 */
name|RDSZ
argument_list|(
literal|246246
argument_list|)
block|,
literal|217
block|,
comment|/* F=cyl 217 thru 370 */
name|RDSZ
argument_list|(
literal|1031355
argument_list|)
block|,
literal|53
block|,
comment|/* G=cyl 53 thru 697 */
name|RDSZ
argument_list|(
literal|522873
argument_list|)
block|,
literal|371
block|,
comment|/* H=cyl 371 thru 697 */
endif|#
directive|endif
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rdinfo
block|{
name|int
name|nbpt
decl_stmt|;
comment|/* DEV_BSIZE blocks per track */
name|int
name|ntpc
decl_stmt|;
comment|/* tracks per cylinder */
name|int
name|nbpc
decl_stmt|;
comment|/* blocks per cylinder */
name|struct
name|size
modifier|*
name|sizes
decl_stmt|;
comment|/* default partition info (if no disklabel) */
name|short
name|hwid
decl_stmt|;
comment|/* 2 byte HW id */
name|short
name|maxunum
decl_stmt|;
comment|/* maximum allowed unit number */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* drive type description */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|rdinfo
name|rdinfo
index|[]
init|=
block|{
name|NRD7945ABPT
block|,
name|NRD7945ATRK
block|,
name|NRD7945ABPT
operator|*
name|NRD7945ATRK
block|,
name|rd7945A_sizes
block|,
name|RD7946AID
block|,
literal|0
block|,
literal|"7945A"
block|,
name|NRD9134DBPT
block|,
name|NRD9134DTRK
block|,
name|NRD9134DBPT
operator|*
name|NRD9134DTRK
block|,
name|rd9134D_sizes
block|,
name|RD9134DID
block|,
literal|1
block|,
literal|"9134D"
block|,
name|NRD9122SBPT
block|,
name|NRD9122STRK
block|,
name|NRD9122SBPT
operator|*
name|NRD9122STRK
block|,
name|rd9122S_sizes
block|,
name|RD9134LID
block|,
literal|1
block|,
literal|"9122S"
block|,
name|NRD7912PBPT
block|,
name|NRD7912PTRK
block|,
name|NRD7912PBPT
operator|*
name|NRD7912PTRK
block|,
name|rd7912P_sizes
block|,
name|RD7912PID
block|,
literal|0
block|,
literal|"7912P"
block|,
name|NRD7914PBPT
block|,
name|NRD7914PTRK
block|,
name|NRD7914PBPT
operator|*
name|NRD7914PTRK
block|,
name|rd7914P_sizes
block|,
name|RD7914PID
block|,
literal|0
block|,
literal|"7914P"
block|,
name|NRD7958ABPT
block|,
name|NRD7958ATRK
block|,
name|NRD7958ABPT
operator|*
name|NRD7958ATRK
block|,
name|rd7958A_sizes
block|,
name|RD7958AID
block|,
literal|0
block|,
literal|"7958A"
block|,
name|NRD7957ABPT
block|,
name|NRD7957ATRK
block|,
name|NRD7957ABPT
operator|*
name|NRD7957ATRK
block|,
name|rd7957A_sizes
block|,
name|RD7957AID
block|,
literal|0
block|,
literal|"7957A"
block|,
name|NRD7933HBPT
block|,
name|NRD7933HTRK
block|,
name|NRD7933HBPT
operator|*
name|NRD7933HTRK
block|,
name|rd7933H_sizes
block|,
name|RD7933HID
block|,
literal|0
block|,
literal|"7933H"
block|,
name|NRD9134LBPT
block|,
name|NRD9134LTRK
block|,
name|NRD9134LBPT
operator|*
name|NRD9134LTRK
block|,
name|rd9134L_sizes
block|,
name|RD9134LID
block|,
literal|1
block|,
literal|"9134L"
block|,
name|NRD7936HBPT
block|,
name|NRD7936HTRK
block|,
name|NRD7936HBPT
operator|*
name|NRD7936HTRK
block|,
name|rd7936H_sizes
block|,
name|RD7936HID
block|,
literal|0
block|,
literal|"7936H"
block|,
name|NRD7937HBPT
block|,
name|NRD7937HTRK
block|,
name|NRD7937HBPT
operator|*
name|NRD7937HTRK
block|,
name|rd7937H_sizes
block|,
name|RD7937HID
block|,
literal|0
block|,
literal|"7937H"
block|,
name|NRD7914PBPT
block|,
name|NRD7914PTRK
block|,
name|NRD7914PBPT
operator|*
name|NRD7914PTRK
block|,
name|rd7914P_sizes
block|,
name|RD7914CTID
block|,
literal|0
block|,
literal|"7914CT"
block|,
name|NRD7945ABPT
block|,
name|NRD7945ATRK
block|,
name|NRD7945ABPT
operator|*
name|NRD7945ATRK
block|,
name|rd7945A_sizes
block|,
name|RD7946AID
block|,
literal|0
block|,
literal|"7946A"
block|,
name|NRD9122SBPT
block|,
name|NRD9122STRK
block|,
name|NRD9122SBPT
operator|*
name|NRD9122STRK
block|,
name|rd9122S_sizes
block|,
name|RD9134LID
block|,
literal|1
block|,
literal|"9122D"
block|,
name|NRD7957BBPT
block|,
name|NRD7957BTRK
block|,
name|NRD7957BBPT
operator|*
name|NRD7957BTRK
block|,
name|rd7957B_sizes
block|,
name|RD7957BID
block|,
literal|0
block|,
literal|"7957B"
block|,
name|NRD7958BBPT
block|,
name|NRD7958BTRK
block|,
name|NRD7958BBPT
operator|*
name|NRD7958BTRK
block|,
name|rd7958B_sizes
block|,
name|RD7958BID
block|,
literal|0
block|,
literal|"7958B"
block|,
name|NRD7959BBPT
block|,
name|NRD7959BTRK
block|,
name|NRD7959BBPT
operator|*
name|NRD7959BTRK
block|,
name|rd7959B_sizes
block|,
name|RD7959BID
block|,
literal|0
block|,
literal|"7959B"
block|,
name|NRD2200ABPT
block|,
name|NRD2200ATRK
block|,
name|NRD2200ABPT
operator|*
name|NRD2200ATRK
block|,
name|rd2200A_sizes
block|,
name|RD2200AID
block|,
literal|0
block|,
literal|"2200A"
block|,
name|NRD2203ABPT
block|,
name|NRD2203ATRK
block|,
name|NRD2203ABPT
operator|*
name|NRD2203ATRK
block|,
name|rd2203A_sizes
block|,
name|RD2203AID
block|,
literal|0
block|,
literal|"2203A"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrdinfo
init|=
sizeof|sizeof
argument_list|(
name|rdinfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rdinfo
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|rdtab
index|[
name|NRD
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rdunit
parameter_list|(
name|x
parameter_list|)
value|(minor(x)>> 3)
end_define

begin_define
define|#
directive|define
name|rdpart
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 0x7)
end_define

begin_define
define|#
directive|define
name|rdpunit
parameter_list|(
name|x
parameter_list|)
value|((x)& 7)
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|RDRETRY
value|5
end_define

begin_define
define|#
directive|define
name|RDWAITC
value|1
end_define

begin_comment
comment|/* min time for timeout in seconds */
end_comment

begin_decl_stmt
name|int
name|rderrthresh
init|=
name|RDRETRY
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when to start reporting errors */
end_comment

begin_expr_stmt
name|rdinit
argument_list|(
name|hd
argument_list|)
specifier|register
expr|struct
name|hp_device
operator|*
name|hd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
name|rs
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
name|rs
operator|->
name|sc_punit
operator|=
name|rdpunit
argument_list|(
name|hd
operator|->
name|hp_flags
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_type
operator|=
name|rdident
argument_list|(
name|rs
argument_list|,
name|hd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|sc_type
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|rddriver
expr_stmt|;
name|rs
operator|->
name|sc_info
operator|=
operator|&
name|rdinfo
index|[
name|rs
operator|->
name|sc_type
index|]
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator|=
name|RDF_ALIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* always report errors */
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
name|rderrthresh
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rdident
argument_list|(
argument|rs
argument_list|,
argument|hd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rd_softc
modifier|*
name|rs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rd_describe
name|desc
decl_stmt|;
name|u_char
name|stat
decl_stmt|,
name|cmd
index|[
literal|3
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|lunit
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|id
decl_stmt|,
name|i
decl_stmt|;
name|ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|unit
operator|=
name|rs
operator|->
name|sc_punit
expr_stmt|;
name|lunit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
comment|/* 	 * Grab device id and make sure: 	 * 1. It is a CS80 device. 	 * 2. It is one of the types we support. 	 * 3. If it is a 7946, we are accessing the disk unit (0) 	 */
name|id
operator|=
name|hpibid
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IDENT
condition|)
name|printf
argument_list|(
literal|"hpibid(%d, %d) -> %x\n"
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|id
operator|&
literal|0x200
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrdinfo
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|id
operator|==
name|rdinfo
index|[
name|i
index|]
operator|.
name|hwid
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nrdinfo
operator|||
name|unit
operator|>
name|rdinfo
index|[
name|i
index|]
operator|.
name|maxunum
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|id
operator|=
name|i
expr_stmt|;
comment|/* 	 * Reset drive and collect device description. 	 * Don't really use the description info right now but 	 * might come in handy in the future (for disk labels). 	 */
name|rdreset
argument_list|(
name|rs
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|C_SUNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|C_DESC
expr_stmt|;
name|hpibsend
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|C_CMD
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|C_EXEC
argument_list|,
operator|&
name|desc
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
condition|)
block|{
specifier|register
name|int
name|n
init|=
name|desc
operator|.
name|d_name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|name
index|[
name|i
index|]
operator|=
operator|(
name|n
operator|&
literal|0xf
operator|)
operator|+
literal|'0'
expr_stmt|;
name|n
operator|>>=
literal|4
expr_stmt|;
block|}
comment|/* use drive characteristics to calculate xfer rate */
name|rs
operator|->
name|sc_wpms
operator|=
literal|1000000
operator|*
operator|(
name|desc
operator|.
name|d_sectsize
operator|/
literal|2
operator|)
operator|/
name|desc
operator|.
name|d_blocktime
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IDENT
condition|)
block|{
name|printf
argument_list|(
literal|"rd%d: name: %x ('%s')\n"
argument_list|,
name|lunit
argument_list|,
name|desc
operator|.
name|d_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  iuw %x, maxxfr %d, ctype %d\n"
argument_list|,
name|desc
operator|.
name|d_iuw
argument_list|,
name|desc
operator|.
name|d_cmaxxfr
argument_list|,
name|desc
operator|.
name|d_ctype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  utype %d, bps %d, blkbuf %d, burst %d, blktime %d\n"
argument_list|,
name|desc
operator|.
name|d_utype
argument_list|,
name|desc
operator|.
name|d_sectsize
argument_list|,
name|desc
operator|.
name|d_blkbuf
argument_list|,
name|desc
operator|.
name|d_burstsize
argument_list|,
name|desc
operator|.
name|d_blocktime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  avxfr %d, ort %d, atp %d, maxint %d, fv %x, rv %x\n"
argument_list|,
name|desc
operator|.
name|d_uavexfr
argument_list|,
name|desc
operator|.
name|d_retry
argument_list|,
name|desc
operator|.
name|d_access
argument_list|,
name|desc
operator|.
name|d_maxint
argument_list|,
name|desc
operator|.
name|d_fvbyte
argument_list|,
name|desc
operator|.
name|d_rvbyte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  maxcyl/head/sect %d/%d/%d, maxvsect %d, inter %d\n"
argument_list|,
name|desc
operator|.
name|d_maxcyl
argument_list|,
name|desc
operator|.
name|d_maxhead
argument_list|,
name|desc
operator|.
name|d_maxsect
argument_list|,
name|desc
operator|.
name|d_maxvsectl
argument_list|,
name|desc
operator|.
name|d_interleave
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Take care of a couple of anomolies: 	 * 1. 7945A and 7946A both return same HW id 	 * 2. 9122S and 9134D both return same HW id 	 * 3. 9122D and 9134L both return same HW id 	 */
switch|switch
condition|(
name|rdinfo
index|[
name|id
index|]
operator|.
name|hwid
condition|)
block|{
case|case
name|RD7946AID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"079450"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|id
operator|=
name|RD7945A
expr_stmt|;
else|else
name|id
operator|=
name|RD7946A
expr_stmt|;
break|break;
case|case
name|RD9134LID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"091340"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|id
operator|=
name|RD9134L
expr_stmt|;
else|else
name|id
operator|=
name|RD9122D
expr_stmt|;
break|break;
case|case
name|RD9134DID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"091220"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|id
operator|=
name|RD9122S
expr_stmt|;
else|else
name|id
operator|=
name|RD9134D
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"rd%d: %s\n"
argument_list|,
name|lunit
argument_list|,
name|rdinfo
index|[
name|id
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rdreset
argument_list|(
name|rs
argument_list|,
name|hd
argument_list|)
specifier|register
expr|struct
name|rd_softc
operator|*
name|rs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|stat
decl_stmt|;
name|rs
operator|->
name|sc_clear
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_clear
operator|.
name|c_cmd
operator|=
name|C_CLEAR
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_TCMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_clear
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_clear
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|RDCTLR
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_nop
operator|=
name|C_NOP
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_cmd
operator|=
name|C_SREL
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_param
operator|=
name|C_REL
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_src
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_src
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_cmd
operator|=
name|C_SSM
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_refm
operator|=
name|REF_MASK
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_fefm
operator|=
name|FEF_MASK
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_aefm
operator|=
name|AEF_MASK
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_iefm
operator|=
name|IEF_MASK
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ssmc
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ssmc
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|hd
operator|->
name|hp_unit
index|]
operator|.
name|rdresets
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|int
name|rdopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRD
operator|||
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|rs
operator|->
name|sc_hd
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
block|{
comment|/* guess at xfer rate based on 3600 rpm (60 rps) */
if|if
condition|(
name|rs
operator|->
name|sc_wpms
operator|==
literal|0
condition|)
name|rs
operator|->
name|sc_wpms
operator|=
literal|60
operator|*
name|rs
operator|->
name|sc_info
operator|->
name|nbpt
operator|*
name|DEV_BSIZE
operator|/
literal|2
expr_stmt|;
name|dk_wpms
index|[
name|rs
operator|->
name|sc_hd
operator|->
name|hp_dk
index|]
operator|=
name|rs
operator|->
name|sc_wpms
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|rdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|size
modifier|*
name|pinfo
init|=
operator|&
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
init|=
operator|&
name|rdtab
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|daddr_t
name|bn
decl_stmt|;
specifier|register
name|int
name|sz
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"rdstrategy(%x): dev %x, bn %x, bcount %x, %c\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|'R'
else|:
literal|'W'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|sz
operator|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|<
literal|0
operator|||
name|bn
operator|+
name|sz
operator|>
name|pinfo
operator|->
name|nblocks
condition|)
block|{
name|sz
operator|=
name|pinfo
operator|->
name|nblocks
operator|-
name|bn
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|dbtob
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|bn
operator|/
name|rs
operator|->
name|sc_info
operator|->
name|nbpc
operator|+
name|pinfo
operator|->
name|cyloff
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|rdustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Called from timeout() when handling maintenance releases  */
end_comment

begin_macro
name|rdrestart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|rdustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdustart
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
name|bp
operator|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|rs
operator|->
name|sc_addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|rs
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|hpibreq
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
condition|)
name|rdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdstart
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
specifier|register
name|int
name|part
decl_stmt|;
name|again
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"rdstart(%d): bp %x, %c\n"
argument_list|,
name|unit
argument_list|,
name|bp
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|'R'
else|:
literal|'W'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|part
operator|=
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_SEEK
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_volume
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_saddr
operator|=
name|C_SADDR
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_hiaddr
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
operator|=
name|RDBTOS
argument_list|(
name|bp
operator|->
name|b_blkno
operator|+
name|rs
operator|->
name|sc_info
operator|->
name|nbpc
operator|*
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|part
index|]
operator|.
name|cyloff
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_nop2
operator|=
name|C_NOP
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_slen
operator|=
name|C_SLEN
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_len
operator|=
name|rs
operator|->
name|sc_resid
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|C_READ
else|:
name|C_WRITE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IO
condition|)
name|printf
argument_list|(
literal|"rdstart: hpibsend(%x, %x, %x, %x, %x)\n"
argument_list|,
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpibsend
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
expr_stmt|;
name|dk_seek
index|[
name|hp
operator|->
name|hp_dk
index|]
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IO
condition|)
name|printf
argument_list|(
literal|"rdstart: hpibawait(%x)\n"
argument_list|,
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hpibawait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Experience has shown that the hpibwait in this hpibsend will 	 * occasionally timeout.  It appears to occur mostly on old 7914 	 * drives with full maintenance tracks.  We should probably 	 * integrate this with the backoff code in rderror. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
name|printf
argument_list|(
literal|"rd%d: rdstart: cmd %x adr %d blk %d len %d ecnt %d\n"
argument_list|,
name|unit
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|rs
operator|->
name|sc_resid
argument_list|,
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
argument_list|)
expr_stmt|;
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdretries
operator|++
expr_stmt|;
endif|#
directive|endif
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_SEEK
expr_stmt|;
name|rdreset
argument_list|(
name|rs
argument_list|,
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|++
operator|<
name|RDRETRY
condition|)
goto|goto
name|again
goto|;
name|printf
argument_list|(
literal|"rd%d: rdstart err: cmd 0x%x sect %d blk %d len %d\n"
argument_list|,
name|unit
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|rs
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hpibfree
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
name|bp
operator|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|rs
operator|->
name|sc_addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|rs
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|hpibreq
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
condition|)
goto|goto
name|again
goto|;
block|}
end_block

begin_expr_stmt
name|rdgo
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
expr_stmt|;
name|dk_xfer
index|[
name|hp
operator|->
name|hp_dk
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|hp
operator|->
name|hp_dk
index|]
operator|+=
name|rs
operator|->
name|sc_resid
operator|>>
literal|6
expr_stmt|;
block|}
name|hpibgo
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
name|rs
operator|->
name|sc_addr
argument_list|,
name|rs
operator|->
name|sc_resid
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdintr
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
name|u_char
name|stat
init|=
literal|13
decl_stmt|;
comment|/* in case hpibrecv fails */
name|int
name|rv
decl_stmt|,
name|restart
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"rdintr(%d): bp %x, %c, flags %x\n"
argument_list|,
name|unit
argument_list|,
name|bp
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|'R'
else|:
literal|'W'
argument_list|,
name|rs
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rd%d: bp == NULL\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
operator|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_SEEK
condition|)
block|{
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_SEEK
expr_stmt|;
if|if
condition|(
name|hpibustart
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
condition|)
name|rdgo
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_SWAIT
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdpolltries
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpibpptest
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdpollwaits
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
name|dk_busy
operator||=
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_SWAIT
expr_stmt|;
name|hpibawait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_SWAIT
expr_stmt|;
name|rv
operator|=
name|hpibrecv
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
operator|||
name|stat
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
name|printf
argument_list|(
literal|"rdintr: recv failed or bad stat %d\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restart
operator|=
name|rderror
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdretries
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|++
operator|<
name|RDRETRY
condition|)
block|{
if|if
condition|(
name|restart
condition|)
name|rdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
block|}
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hpibfree
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
condition|)
name|rdustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|else
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdstatus
argument_list|(
name|rs
argument_list|)
specifier|register
expr|struct
name|rd_softc
operator|*
name|rs
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|c
operator|=
name|rs
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|s
operator|=
name|rs
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_sram
operator|=
name|C_SRAM
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_ram
operator|=
name|C_RAM
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_cmd
operator|=
name|C_STATUS
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rs
operator|->
name|sc_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|hpibsend
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_rsc
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_rsc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_rsc
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_STATUS
condition|)
name|printf
argument_list|(
literal|"rdstatus: send C_CMD failed %d != %d\n"
argument_list|,
name|rv
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_rsc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|hpibrecv
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|C_EXEC
argument_list|,
operator|&
name|rs
operator|->
name|sc_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_STATUS
condition|)
name|printf
argument_list|(
literal|"rdstatus: send C_EXEC failed %d != %d\n"
argument_list|,
name|rv
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|hpibrecv
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
operator|||
name|stat
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_STATUS
condition|)
name|printf
argument_list|(
literal|"rdstatus: recv failed %d or bad stat %d\n"
argument_list|,
name|rv
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Deal with errors.  * Returns 1 if request should be restarted,  * 0 if we should just quietly give up.  */
end_comment

begin_macro
name|rderror
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rd_stat
modifier|*
name|sp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|hwbn
decl_stmt|,
name|pbn
decl_stmt|;
if|if
condition|(
name|rdstatus
argument_list|(
name|rs
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"rd%d: couldn't get status\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdreset
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sp
operator|=
operator|&
name|rs
operator|->
name|sc_stat
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_REXMT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_PF
condition|)
block|{
name|rdreset
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Unit requests release for internal maintenance. 	 * We just delay awhile and try again later.  Use expontially 	 * increasing backoff ala ethernet drivers since we don't really 	 * know how long the maintenance will take.  With RDWAITC and 	 * RDRETRY as defined, the range is 1 to 32 seconds. 	 */
if|if
condition|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_IMR
condition|)
block|{
specifier|extern
name|int
name|hz
decl_stmt|;
name|int
name|rdtimo
init|=
name|RDWAITC
operator|<<
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"rd%d: internal maintenance, %d second timeout\n"
argument_list|,
name|unit
argument_list|,
name|rdtimo
argument_list|)
expr_stmt|;
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdtimeouts
operator|++
expr_stmt|;
endif|#
directive|endif
name|hpibfree
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|rdrestart
argument_list|,
name|unit
argument_list|,
name|rdtimo
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Only report error if we have reached the error reporting 	 * threshhold.  By default, this will only report after the 	 * retry limit has been exceeded. 	 */
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|<
name|rderrthresh
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * First conjure up the block number at which the error occured. 	 * Note that not all errors report a block number, in that case 	 * we just use b_blkno.  	 */
name|bp
operator|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|pbn
operator|=
name|rs
operator|->
name|sc_info
operator|->
name|nbpc
operator|*
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|cyloff
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_CU
operator|)
operator|||
operator|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_DR
operator|)
operator|||
operator|(
name|sp
operator|->
name|c_ief
operator|&
name|IEF_RRMASK
operator|)
condition|)
block|{
name|hwbn
operator|=
name|RDBTOS
argument_list|(
name|pbn
operator|+
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|pbn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
block|}
else|else
block|{
name|hwbn
operator|=
name|sp
operator|->
name|c_blk
expr_stmt|;
name|pbn
operator|=
name|RDSTOB
argument_list|(
name|hwbn
argument_list|)
operator|-
name|pbn
expr_stmt|;
block|}
comment|/* 	 * Now output a generic message suitable for badsect. 	 * Note that we don't use harderr cuz it just prints 	 * out b_blkno which is just the beginning block number 	 * of the transfer, not necessary where the error occured. 	 */
name|printf
argument_list|(
literal|"rd%d%c: hard error sn%d\n"
argument_list|,
name|rdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
literal|'a'
operator|+
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|pbn
argument_list|)
expr_stmt|;
comment|/* 	 * Now report the status as returned by the hardware with 	 * attempt at interpretation (unless debugging). 	 */
name|printf
argument_list|(
literal|"rd%d %s error:"
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
block|{
comment|/* status info */
name|printf
argument_list|(
literal|"\n    volume: %d, unit: %d\n"
argument_list|,
operator|(
name|sp
operator|->
name|c_vu
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|sp
operator|->
name|c_vu
operator|&
literal|0xF
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"reject"
argument_list|,
name|sp
operator|->
name|c_ref
argument_list|,
name|err_reject
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"fault"
argument_list|,
name|sp
operator|->
name|c_fef
argument_list|,
name|err_fault
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"access"
argument_list|,
name|sp
operator|->
name|c_aef
argument_list|,
name|err_access
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"info"
argument_list|,
name|sp
operator|->
name|c_ief
argument_list|,
name|err_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    block: %d, P1-P10: "
argument_list|,
name|hwbn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|4
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|8
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* command */
name|printf
argument_list|(
literal|"    ioc: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_pad
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_hiaddr
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_nop2
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_len
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|" v%d u%d, R0x%x F0x%x A0x%x I0x%x\n"
argument_list|,
operator|(
name|sp
operator|->
name|c_vu
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|sp
operator|->
name|c_vu
operator|&
literal|0xF
argument_list|,
name|sp
operator|->
name|c_ref
argument_list|,
name|sp
operator|->
name|c_fef
argument_list|,
name|sp
operator|->
name|c_aef
argument_list|,
name|sp
operator|->
name|c_ief
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"P1-P10: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|4
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|8
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|int
name|rdread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|rdstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|rdstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdsize
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRD
operator|||
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|rdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|nblocks
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|rdprinterr
argument_list|(
argument|str
argument_list|,
argument|err
argument_list|,
argument|tab
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tab
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|printed
decl_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"    %s error field:"
argument_list|,
name|str
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|err
operator|&
operator|(
literal|0x8000
operator|>>
name|i
operator|)
condition|)
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|printed
operator|++
condition|?
literal|" + "
else|:
literal|" "
argument_list|,
name|tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Non-interrupt driven, non-dma dump routine.  */
end_comment

begin_function
name|int
name|rddump
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|int
name|part
init|=
name|rdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
specifier|register
name|daddr_t
name|baddr
decl_stmt|;
specifier|register
name|int
name|maddr
decl_stmt|,
name|pages
decl_stmt|,
name|i
decl_stmt|;
name|char
name|stat
decl_stmt|;
specifier|extern
name|int
name|lowram
decl_stmt|,
name|dumpsize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|int
name|pmapdebug
decl_stmt|;
name|pmapdebug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pages
operator|=
name|dumpsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_DUMP
condition|)
name|printf
argument_list|(
literal|"rddump(%x): u %d p %d dumplo %d ram %x pmem %d\n"
argument_list|,
name|dev
argument_list|,
name|unit
argument_list|,
name|part
argument_list|,
name|dumplo
argument_list|,
name|lowram
argument_list|,
name|ctod
argument_list|(
name|pages
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* is drive ok? */
if|if
condition|(
name|unit
operator|>=
name|NRD
operator|||
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* HPIB idle? */
if|if
condition|(
operator|!
name|hpibreq
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* is this a safe thing to do?? */
name|hpibreset
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
name|rdreset
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[ drive %d reset ] "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
operator|(
name|EFAULT
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* dump parameters in range? */
if|if
condition|(
name|dumplo
operator|<
literal|0
operator|||
name|dumplo
operator|>=
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|part
index|]
operator|.
name|nblocks
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dumplo
operator|+
name|ctod
argument_list|(
name|pages
argument_list|)
operator|>
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|part
index|]
operator|.
name|nblocks
condition|)
name|pages
operator|=
name|dtoc
argument_list|(
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|part
index|]
operator|.
name|nblocks
operator|-
name|dumplo
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|lowram
expr_stmt|;
name|baddr
operator|=
name|dumplo
operator|+
name|rs
operator|->
name|sc_info
operator|->
name|nbpc
operator|*
name|rs
operator|->
name|sc_info
operator|->
name|sizes
index|[
name|part
index|]
operator|.
name|cyloff
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_DUMP
condition|)
name|printf
argument_list|(
literal|"rddump: dumping %d pages from %x to disk block %d\n"
argument_list|,
name|pages
argument_list|,
name|maddr
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
define|#
directive|define
name|NPGMB
value|(1024*1024/NBPG)
comment|/* print out how many Mbs we have dumped */
if|if
condition|(
name|i
operator|&&
operator|(
name|i
operator|%
name|NPGMB
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|i
operator|/
name|NPGMB
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NPBMG
endif|#
directive|endif
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_volume
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_saddr
operator|=
name|C_SADDR
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_hiaddr
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
operator|=
name|RDBTOS
argument_list|(
name|baddr
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_nop2
operator|=
name|C_NOP
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_slen
operator|=
name|C_SLEN
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_len
operator|=
name|NBPG
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
operator|=
name|C_WRITE
expr_stmt|;
name|hpibsend
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpibswait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_DUMP
condition|)
name|printf
argument_list|(
literal|"rddump: IOC wait timeout\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pmap_enter
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|vmmap
argument_list|,
name|maddr
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|hpibsend
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
name|vmmap
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpibswait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_DUMP
condition|)
name|printf
argument_list|(
literal|"rddump: write wait timeout\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hpibrecv
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_DUMP
condition|)
name|printf
argument_list|(
literal|"rddump: write failed, status %x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|maddr
operator|+=
name|NBPG
expr_stmt|;
name|baddr
operator|+=
name|ctod
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

