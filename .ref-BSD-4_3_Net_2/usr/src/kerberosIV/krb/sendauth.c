begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Source: /usr/src/kerberosIV/krb/RCS/sendauth.c,v $  * $Author: kfall $  *  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid_sendauth_c
index|[]
init|=
literal|"$Header: /usr/src/kerberosIV/krb/RCS/sendauth.c,v 4.5 90/06/25 20:57:24 kfall Exp Locker: kfall $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<mit-copyright.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|KRB_SENDAUTH_VERS
value|"AUTHV0.1"
end_define

begin_comment
comment|/* MUST be KRB_SENDAUTH_VLEN chars */
end_comment

begin_comment
comment|/*  * If the protocol changes, you will need to change the version string  * and make appropriate changes in krb_recvauth.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|krb_get_phost
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * This file contains two routines: krb_sendauth() and krb_sendsrv().  *  * krb_sendauth() transmits a ticket over a file descriptor for a  * desired service, instance, and realm, doing mutual authentication  * with the server if desired.  *  * krb_sendsvc() sends a service name to a remote knetd server.  */
end_comment

begin_comment
comment|/*  * The first argument to krb_sendauth() contains a bitfield of  * options (the options are defined in "krb.h"):  *  * KOPT_DONT_CANON	Don't canonicalize instance as a hostname.  *			(If this option is not chosen, krb_get_phost()  *			is called to canonicalize it.)  *  * KOPT_DONT_MK_REQ 	Don't request server ticket from Kerberos.  *			A ticket must be supplied in the "ticket"  *			argument.  *			(If this option is not chosen, and there  *			is no ticket for the given server in the  *			ticket cache, one will be fetched using  *			krb_mk_req() and returned in "ticket".)  *  * KOPT_DO_MUTUAL	Do mutual authentication, requiring that the  * 			receiving server return the checksum+1 encrypted  *			in the session key.  The mutual authentication  *			is done using krb_mk_priv() on the other side  *			(see "recvauth.c") and krb_rd_priv() on this  *			side.  *  * The "fd" argument is a file descriptor to write to the remote  * server on.  The "ticket" argument is used to store the new ticket  * from the krb_mk_req() call. If the KOPT_DONT_MK_REQ options is  * chosen, the ticket must be supplied in the "ticket" argument.  * The "service", "inst", and "realm" arguments identify the ticket.  * If "realm" is null, the local realm is used.  *  * The following arguments are only needed if the KOPT_DO_MUTUAL option  * is chosen:  *  *   The "checksum" argument is a number that the server will add 1 to  *   to authenticate itself back to the client; the "msg_data" argument  *   holds the returned mutual-authentication message from the server  *   (i.e., the checksum+1); the "cred" structure is used to hold the  *   session key of the server, extracted from the ticket file, for use  *   in decrypting the mutual authentication message from the server;  *   and "schedule" holds the key schedule for that decryption.  The  *   the local and server addresses are given in "laddr" and "faddr".  *  * The application protocol version number (of up to KRB_SENDAUTH_VLEN  * characters) is passed in "version".  *  * If all goes well, KSUCCESS is returned, otherwise some error code.  *  * The format of the message sent to the server is:  *  * Size			Variable		Field  * ----			--------		-----  *  * KRB_SENDAUTH_VLEN	KRB_SENDAUTH_VER	sendauth protocol  * bytes					version number  *  * KRB_SENDAUTH_VLEN	version			application protocol  * bytes					version number  *  * 4 bytes		ticket->length		length of ticket  *  * ticket->length	ticket->dat		ticket itself  */
end_comment

begin_comment
comment|/*  * XXX: Note that krb_rd_priv() is coded in such a way that  * "msg_data->app_data" will be pointing into "priv_buf", which  * will disappear when krb_sendauth() returns.  */
end_comment

begin_function
name|int
name|krb_sendauth
parameter_list|(
name|options
parameter_list|,
name|fd
parameter_list|,
name|ticket
parameter_list|,
name|service
parameter_list|,
name|inst
parameter_list|,
name|realm
parameter_list|,
name|checksum
parameter_list|,
name|msg_data
parameter_list|,
name|cred
parameter_list|,
name|schedule
parameter_list|,
name|laddr
parameter_list|,
name|faddr
parameter_list|,
name|version
parameter_list|)
name|long
name|options
decl_stmt|;
comment|/* bit-pattern of options */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor to write onto */
name|KTEXT
name|ticket
decl_stmt|;
comment|/* where to put ticket (return); or 				  * supplied in case of KOPT_DONT_MK_REQ */
name|char
modifier|*
name|service
decl_stmt|,
decl|*
name|inst
decl_stmt|,
modifier|*
name|realm
decl_stmt|;
end_function

begin_comment
comment|/* service name, instance, realm */
end_comment

begin_decl_stmt
name|u_long
name|checksum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* checksum to include in request */
end_comment

begin_decl_stmt
name|MSG_DAT
modifier|*
name|msg_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mutual auth MSG_DAT (return) */
end_comment

begin_decl_stmt
name|CREDENTIALS
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* credentials (return) */
end_comment

begin_decl_stmt
name|Key_schedule
name|schedule
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key schedule (return) */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|laddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local address */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|faddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of foreign host on fd */
end_comment

begin_decl_stmt
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version string */
end_comment

begin_block
block|{
name|int
name|rem
decl_stmt|,
name|i
decl_stmt|,
name|cc
decl_stmt|;
name|char
name|srv_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|char
name|krb_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|long
name|tkt_len
decl_stmt|;
name|u_char
name|priv_buf
index|[
literal|1024
index|]
decl_stmt|;
name|u_long
name|cksum
decl_stmt|;
name|rem
operator|=
name|KSUCCESS
expr_stmt|;
comment|/* get current realm if not passed in */
if|if
condition|(
operator|!
name|realm
condition|)
block|{
name|rem
operator|=
name|krb_get_lrealm
argument_list|(
name|krb_realm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|rem
operator|)
return|;
name|realm
operator|=
name|krb_realm
expr_stmt|;
block|}
comment|/* copy instance into local storage, canonicalizing if desired */
if|if
condition|(
name|options
operator|&
name|KOPT_DONT_CANON
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|srv_inst
argument_list|,
name|inst
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|srv_inst
argument_list|,
name|krb_get_phost
argument_list|(
name|inst
argument_list|)
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
comment|/* get the ticket if desired */
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|KOPT_DONT_MK_REQ
operator|)
condition|)
block|{
name|rem
operator|=
name|krb_mk_req
argument_list|(
name|ticket
argument_list|,
name|service
argument_list|,
name|srv_inst
argument_list|,
name|realm
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|rem
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ATHENA_COMPAT
comment|/* this is only for compatibility with old servers */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_OLDSTYLE
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ticket
operator|->
name|dat
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|rem
operator|)
return|;
block|}
endif|#
directive|endif
endif|ATHENA_COMPAT
comment|/* if mutual auth, get credentials so we have service session        keys for decryption below */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
if|if
condition|(
name|cc
operator|=
name|krb_get_cred
argument_list|(
name|service
argument_list|,
name|srv_inst
argument_list|,
name|realm
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
comment|/* zero the buffer */
operator|(
name|void
operator|)
name|bzero
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
comment|/* insert version strings */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|KRB_SENDAUTH_VERS
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
operator|+
name|KRB_SENDAUTH_VLEN
argument_list|,
name|version
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
expr_stmt|;
comment|/* increment past vers strings */
name|i
operator|=
literal|2
operator|*
name|KRB_SENDAUTH_VLEN
expr_stmt|;
comment|/* put ticket length into buffer */
name|tkt_len
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
name|buf
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
expr_stmt|;
comment|/* put ticket into buffer */
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ticket
operator|->
name|dat
argument_list|,
name|buf
operator|+
name|i
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ticket
operator|->
name|length
expr_stmt|;
comment|/* write the request to the server */
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
name|i
condition|)
return|return
operator|(
name|cc
operator|)
return|;
comment|/* mutual authentication, if desired */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
block|{
comment|/* get the length of the reply */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|tkt_len
operator|=
name|ntohl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|tkt_len
argument_list|)
expr_stmt|;
comment|/* if the length is negative, the server failed to recognize us. */
if|if
condition|(
name|tkt_len
operator|<
literal|0
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* XXX */
comment|/* read the reply... */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|priv_buf
argument_list|,
operator|(
name|int
operator|)
name|tkt_len
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|tkt_len
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* ...and decrypt it */
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|key_sched
argument_list|(
name|cred
operator|->
name|session
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NOENCRYPTION */
if|if
condition|(
name|cc
operator|=
name|krb_rd_priv
argument_list|(
name|priv_buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tkt_len
argument_list|,
name|schedule
argument_list|,
name|cred
operator|->
name|session
argument_list|,
name|faddr
argument_list|,
name|laddr
argument_list|,
name|msg_data
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
comment|/* fetch the (modified) checksum */
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg_data
operator|->
name|app_data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|ntohl
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
comment|/* if it doesn't match, fail */
if|if
condition|(
name|cksum
operator|!=
name|checksum
operator|+
literal|1
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* XXX */
block|}
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|ATHENA_COMPAT
end_ifdef

begin_comment
comment|/*  * krb_sendsvc  */
end_comment

begin_function
name|int
name|krb_sendsvc
parameter_list|(
name|fd
parameter_list|,
name|service
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|service
decl_stmt|;
block|{
comment|/* write the service name length and then the service name to        the fd */
name|long
name|serv_length
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|serv_length
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|strlen
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|serv_length
argument_list|,
sizeof|sizeof
argument_list|(
name|serv_length
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|serv_length
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|service
argument_list|,
name|strlen
argument_list|(
name|service
argument_list|)
argument_list|)
operator|)
operator|!=
name|strlen
argument_list|(
name|service
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ATHENA_COMPAT
end_endif

end_unit

