begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dynamic memory allocation for GNU.    Copyright (C) 1985, 1987 Free Software Foundation, Inc.  		       NO WARRANTY    BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC, RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M. STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS PROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.  		GENERAL PUBLIC LICENSE TO COPY    1. You may copy and distribute verbatim copies of this source file as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy a valid copyright notice "Copyright (C) 1985 Free Software Foundation, Inc."; and include following the copyright notice a verbatim copy of the above disclaimer of warranty and of this License.  You may charge a distribution fee for the physical act of transferring a copy.    2. You may modify your copy or copies of this source file or any portion of it, and copy and distribute such modifications under the terms of Paragraph 1 above, provided that you also do the following:      a) cause the modified files to carry prominent notices stating     that you changed the files and the date of any change; and      b) cause the whole of any work that you distribute or publish,     that in whole or in part contains or is a derivative of this     program or any part thereof, to be licensed at no charge to all     third parties on terms identical to those contained in this     License Agreement (except that you may choose to grant more extensive     warranty protection to some or all third parties, at your option).      c) You may charge a distribution fee for the physical act of     transferring a copy, and you may at your option offer warranty     protection in exchange for a fee.  Mere aggregation of another unrelated program with this program (or its derivative) on a volume of a storage or distribution medium does not bring the other program under the scope of these terms.    3. You may copy and distribute this program (or a portion or derivative of it, under Paragraph 2) in object code or executable form under the terms of Paragraphs 1 and 2 above provided that you also do one of the following:      a) accompany it with the complete corresponding machine-readable     source code, which must be distributed under the terms of     Paragraphs 1 and 2 above; or,      b) accompany it with a written offer, valid for at least three     years, to give any third party free (except for a nominal     shipping charge) a complete machine-readable copy of the     corresponding source code, to be distributed under the terms of     Paragraphs 1 and 2 above; or,      c) accompany it with the information you received as to where the     corresponding source code may be obtained.  (This alternative is     allowed only for noncommercial distribution and only if you     received the program in object code or executable form alone.)  For an executable file, complete source code means all the source code for all modules it contains; but, as a special exception, it need not include source code for modules which are standard libraries that accompany the operating system on which the executable file runs.    4. You may not copy, sublicense, distribute or transfer this program except as expressly provided under this License Agreement.  Any attempt otherwise to copy, sublicense, distribute or transfer this program is void and your rights to use the program under this License agreement shall be automatically terminated.  However, parties who have received computer software programs from you with this License Agreement will not have their licenses terminated so long as such parties remain in full compliance.    5. If you wish to incorporate parts of this program into other free programs whose distribution conditions are different, write to the Free Software Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet worked out a simple rule that can be stated here, but we will often permit this.  We will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software.   In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/*  * @(#)nmalloc.c 1 (Caltech) 2/21/82  *  *	U of M Modified: 20 Jun 1983 ACT: strange hacks for Emacs  *  *	Nov 1983, Mike@BRL, Added support for 4.1C/4.2 BSD.  *  * This is a very fast storage allocator.  It allocates blocks of a small   * number of different sizes, and keeps free lists of each size.  Blocks  * that don't exactly fit are passed up to the next larger size.  In this   * implementation, the available sizes are (2^n)-4 (or -16) bytes long.  * This is designed for use in a program that uses vast quantities of  * memory, but bombs when it runs out.  To make it a little better, it  * warns the user when he starts to get near the end.  *  * June 84, ACT: modified rcheck code to check the range given to malloc,  * rather than the range determined by the 2-power used.  *  * Jan 85, RMS: calls malloc_warning to issue warning on nearly full.  * No longer Emacs-specific; can serve as all-purpose malloc for GNU.  * You should call malloc_init to reinitialize after loading dumped Emacs.  * Call malloc_stats to get info on memory stats if MSTATS turned on.  * realloc knows how to return same block given, just changing its size,  * if the power of 2 is correct.  */
end_comment

begin_comment
comment|/*  * nextf[i] is the pointer to the next free block of size 2^(i+3).  The  * smallest allocatable block is 8 bytes.  The overhead information will  * go in the first int of the block, and the returned pointer will point  * to the second.  * #ifdef MSTATS  * nmalloc[i] is the difference between the number of mallocs and frees  * for a given block size. #endif MSTATS  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|emacs
argument_list|)
operator|||
literal|1
end_if

begin_comment
comment|/* config.h specifies which kind of system this is.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Determine which kind of system this is.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIGTSTP
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_define
define|#
directive|define
name|USG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SIGTSTP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_define
define|#
directive|define
name|BSD4_2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGIO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGTSTP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* Define getpagesize () if the system does not.  */
end_comment

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/vlimit.h>
end_include

begin_comment
comment|/* warn the user when near the end */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if BSD4_2 */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_2 */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_SEG_BITS
end_ifndef

begin_define
define|#
directive|define
name|start_of_data
parameter_list|()
value|&etext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_define
define|#
directive|define
name|start_of_data
parameter_list|()
value|&etext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISALLOC
value|((char) 0xf7)
end_define

begin_comment
comment|/* magic byte that implies allocation */
end_comment

begin_define
define|#
directive|define
name|ISFREE
value|((char) 0x54)
end_define

begin_comment
comment|/* magic byte that implies free block */
end_comment

begin_comment
comment|/* this is for error checking only */
end_comment

begin_define
define|#
directive|define
name|ISMEMALIGN
value|((char) 0xd6)
end_define

begin_comment
comment|/* Stored before the value returned by 				     memalign, with the rest of the word 				     being the distance to the true 				     beginning of the block.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|etext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These two are for user programs to look at, when they are interested.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|malloc_sbrk_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amount of data space used now */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|malloc_sbrk_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amount more we can have */
end_comment

begin_comment
comment|/* start of data space; can be changed by calling init_malloc */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|data_space_start
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSTATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|nmalloc
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nmal
decl_stmt|,
name|nfre
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSTATS */
end_comment

begin_comment
comment|/* If range checking is not turned on, all we have is a flag indicating    whether memory is allocated, an index in nextf[], and a size field; to    realloc() memory we copy either size bytes or 1<<(index+3) bytes depending    on whether the former can hold the exact size (given the value of    'index').  If range checking is on, we always need to know how much space    is allocated, so the 'size' field is never used. */
end_comment

begin_struct
struct|struct
name|mhead
block|{
name|char
name|mh_alloc
decl_stmt|;
comment|/* ISALLOC or ISFREE */
name|char
name|mh_index
decl_stmt|;
comment|/* index in nextf[] */
comment|/* Remainder are valid only when block is allocated */
name|unsigned
name|short
name|mh_size
decl_stmt|;
comment|/* size, if< 0x10000 */
ifdef|#
directive|ifdef
name|rcheck
name|unsigned
name|mh_nbytes
decl_stmt|;
comment|/* number of bytes allocated */
name|int
name|mh_magic4
decl_stmt|;
comment|/* should be == MAGIC4 */
endif|#
directive|endif
comment|/* rcheck */
block|}
struct|;
end_struct

begin_comment
comment|/* Access free-list pointer of a block.   It is stored at block + 4.   This is not a field in the mhead structure   because we want sizeof (struct mhead)   to describe the overhead for when the block is in use,   and we do not want the free-list pointer to count in that.  */
end_comment

begin_define
define|#
directive|define
name|CHAIN
parameter_list|(
name|a
parameter_list|)
define|\
value|(*(struct mhead **) (sizeof (char *) + (char *) (a)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|rcheck
end_ifdef

begin_comment
comment|/* To implement range checking, we write magic values in at the beginning and    end of each allocated block, and make sure they are undisturbed whenever a    free or a realloc occurs. */
end_comment

begin_comment
comment|/* Written in each of the 4 bytes following the block's real space */
end_comment

begin_define
define|#
directive|define
name|MAGIC1
value|0x55
end_define

begin_comment
comment|/* Written in the 4 bytes before the block's real space */
end_comment

begin_define
define|#
directive|define
name|MAGIC4
value|0x55555555
end_define

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|)
value|if (!(p)) botch("p"); else
end_define

begin_define
define|#
directive|define
name|EXTRA
value|4
end_define

begin_comment
comment|/* 4 bytes extra for MAGIC1s */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|)
end_define

begin_define
define|#
directive|define
name|EXTRA
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* rcheck */
end_comment

begin_comment
comment|/* nextf[i] is free list of blocks of size 2**(i + 3)  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mhead
modifier|*
name|nextf
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* busy[i] is nonzero while allocation of block size i is in progress.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|busy
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes of writable memory we can expect to be able to get */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lim_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level number of warnings already issued.   0 -- no warnings issued.   1 -- 75% warning already issued.   2 -- 85% warning already issued. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warnlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to issue a warning;    0 means don't issue them.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|warnfunction
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* nonzero once initial bunch of free blocks made */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gotpool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_malloc_base
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|getpool
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Cause reinitialization based on job parameters;   also declare where the end of pure storage is. */
end_comment

begin_decl_stmt
name|void
name|malloc_init
argument_list|(
name|start
argument_list|,
name|warnfun
argument_list|)
name|char
modifier|*
name|start
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|warnfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|start
condition|)
name|data_space_start
operator|=
name|start
expr_stmt|;
name|lim_data
operator|=
literal|0
expr_stmt|;
name|warnlevel
operator|=
literal|0
expr_stmt|;
name|warnfunction
operator|=
name|warnfun
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the maximum size to which MEM can be realloc'd    without actually requiring copying.  */
end_comment

begin_function
name|int
name|malloc_usable_size
parameter_list|(
name|mem
parameter_list|)
name|char
modifier|*
name|mem
decl_stmt|;
block|{
name|int
name|blocksize
init|=
literal|8
operator|<<
operator|(
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|mem
operator|)
operator|-
literal|1
operator|)
operator|->
name|mh_index
decl_stmt|;
return|return
name|blocksize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mhead
argument_list|)
operator|-
name|EXTRA
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|morecore
parameter_list|(
name|nu
parameter_list|)
comment|/* ask system for more memory */
specifier|register
name|int
name|nu
decl_stmt|;
comment|/* size index to get more of  */
block|{
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|nblks
decl_stmt|;
specifier|register
name|unsigned
name|int
name|siz
decl_stmt|;
name|int
name|oldmask
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
comment|/* ?? There was a suggestion not to block SIGILL, somehow for GDB's sake.  */
name|oldmask
operator|=
name|sigsetmask
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|data_space_start
condition|)
block|{
name|data_space_start
operator|=
name|start_of_data
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lim_data
operator|==
literal|0
condition|)
name|get_lim_data
argument_list|()
expr_stmt|;
comment|/* On initial startup, get two blocks of each size up to 1k bytes */
if|if
condition|(
operator|!
name|gotpool
condition|)
block|{
name|getpool
argument_list|()
expr_stmt|;
name|getpool
argument_list|()
expr_stmt|;
name|gotpool
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find current end of memory and issue warning if getting near max */
ifndef|#
directive|ifndef
name|VMS
comment|/* Maximum virtual memory on VMS is difficult to calculate since it    * depends on several dynmacially changing things. Also, alignment    * isn't that important. That is why much of the code here is ifdef'ed    * out for VMS systems.    */
name|cp
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|siz
operator|=
name|cp
operator|-
name|data_space_start
expr_stmt|;
if|if
condition|(
name|warnfunction
condition|)
switch|switch
condition|(
name|warnlevel
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|siz
operator|>
operator|(
name|lim_data
operator|/
literal|4
operator|)
operator|*
literal|3
condition|)
block|{
name|warnlevel
operator|++
expr_stmt|;
call|(
modifier|*
name|warnfunction
call|)
argument_list|(
literal|"Warning: past 75% of memory limit"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|siz
operator|>
operator|(
name|lim_data
operator|/
literal|20
operator|)
operator|*
literal|17
condition|)
block|{
name|warnlevel
operator|++
expr_stmt|;
call|(
modifier|*
name|warnfunction
call|)
argument_list|(
literal|"Warning: past 85% of memory limit"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|siz
operator|>
operator|(
name|lim_data
operator|/
literal|20
operator|)
operator|*
literal|19
condition|)
block|{
name|warnlevel
operator|++
expr_stmt|;
call|(
modifier|*
name|warnfunction
call|)
argument_list|(
literal|"Warning: past 95% of memory limit"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
condition|)
comment|/* land on 1K boundaries */
name|sbrk
argument_list|(
literal|1024
operator|-
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
comment|/* Take at least 2k, and figure out how many blocks of the desired size     we're about to get */
name|nblks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|siz
operator|=
name|nu
operator|)
operator|<
literal|8
condition|)
name|nblks
operator|=
literal|1
operator|<<
operator|(
operator|(
name|siz
operator|=
literal|8
operator|)
operator|-
name|nu
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|sbrk
argument_list|(
literal|1
operator|<<
operator|(
name|siz
operator|+
literal|3
operator|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return;
comment|/* no more room! */
block|}
name|malloc_sbrk_used
operator|=
name|siz
expr_stmt|;
name|malloc_sbrk_unused
operator|=
name|lim_data
operator|-
name|siz
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|7
condition|)
block|{
comment|/* shouldn't happen, but just in case */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|cp
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
name|nblks
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS */
comment|/* save new header and link the nblks blocks together */
name|nextf
index|[
name|nu
index|]
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
expr_stmt|;
name|siz
operator|=
literal|1
operator|<<
operator|(
name|nu
operator|+
literal|3
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_index
operator|=
name|nu
expr_stmt|;
if|if
condition|(
operator|--
name|nblks
operator|<=
literal|0
condition|)
break|break;
name|CHAIN
argument_list|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
argument_list|)
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|cp
operator|+
name|siz
operator|)
expr_stmt|;
name|cp
operator|+=
name|siz
expr_stmt|;
block|}
name|CHAIN
argument_list|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|getpool
parameter_list|()
block|{
specifier|register
name|int
name|nu
decl_stmt|;
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
condition|)
comment|/* land on 1K boundaries */
name|sbrk
argument_list|(
literal|1024
operator|-
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
operator|)
argument_list|)
expr_stmt|;
comment|/* Record address of start of space allocated by malloc.  */
if|if
condition|(
name|_malloc_base
operator|==
literal|0
condition|)
name|_malloc_base
operator|=
name|cp
expr_stmt|;
comment|/* Get 2k of storage */
name|cp
operator|=
name|sbrk
argument_list|(
literal|04000
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return;
comment|/* Divide it into an initial 8-word block      plus one block of size 2**nu for nu = 3 ... 10.  */
name|CHAIN
argument_list|(
name|cp
argument_list|)
operator|=
name|nextf
index|[
literal|0
index|]
expr_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_index
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
literal|8
expr_stmt|;
for|for
control|(
name|nu
operator|=
literal|0
init|;
name|nu
operator|<
literal|7
condition|;
name|nu
operator|++
control|)
block|{
name|CHAIN
argument_list|(
name|cp
argument_list|)
operator|=
name|nextf
index|[
name|nu
index|]
expr_stmt|;
name|nextf
index|[
name|nu
index|]
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_index
operator|=
name|nu
expr_stmt|;
name|cp
operator|+=
literal|8
operator|<<
name|nu
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|malloc
parameter_list|(
name|n
parameter_list|)
comment|/* get a block */
name|unsigned
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|nbytes
decl_stmt|;
specifier|register
name|int
name|nunits
init|=
literal|0
decl_stmt|;
comment|/* Figure out how many bytes are required, rounding up to the nearest      multiple of 8, then figure out which nestf[] area to use.      Both the beginning of the header and the beginning of the      block should be on an eight byte boundary.  */
name|nbytes
operator|=
operator|(
name|n
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|EXTRA
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|shiftr
init|=
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|>>
literal|2
decl_stmt|;
while|while
condition|(
name|shiftr
operator|>>=
literal|1
condition|)
name|nunits
operator|++
expr_stmt|;
block|}
comment|/* In case this is reentrant use of malloc from signal handler,      pick a block size that no other malloc level is currently      trying to allocate.  That's the easiest harmless way not to      interfere with the other level of execution.  */
while|while
condition|(
name|busy
index|[
name|nunits
index|]
condition|)
name|nunits
operator|++
expr_stmt|;
name|busy
index|[
name|nunits
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If there are no blocks of the appropriate size, go get some */
comment|/* COULD SPLIT UP A LARGER BLOCK HERE ... ACT */
if|if
condition|(
name|nextf
index|[
name|nunits
index|]
operator|==
literal|0
condition|)
name|morecore
argument_list|(
name|nunits
argument_list|)
expr_stmt|;
comment|/* Get one block off the list, and set the new list head */
if|if
condition|(
operator|(
name|p
operator|=
name|nextf
index|[
name|nunits
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|busy
index|[
name|nunits
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nextf
index|[
name|nunits
index|]
operator|=
name|CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|busy
index|[
name|nunits
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Check for free block clobbered */
comment|/* If not for this check, we would gobble a clobbered free chain ptr */
comment|/* and bomb out on the NEXT allocate of this size block */
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|!=
name|ISFREE
operator|||
name|p
operator|->
name|mh_index
operator|!=
name|nunits
condition|)
ifdef|#
directive|ifdef
name|rcheck
name|botch
argument_list|(
literal|"block on free list clobbered"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not rcheck */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
comment|/* Fill in the info, and if range checking, set up the magic numbers */
name|p
operator|->
name|mh_alloc
operator|=
name|ISALLOC
expr_stmt|;
ifdef|#
directive|ifdef
name|rcheck
name|p
operator|->
name|mh_nbytes
operator|=
name|n
expr_stmt|;
name|p
operator|->
name|mh_magic4
operator|=
name|MAGIC4
expr_stmt|;
block|{
comment|/* Get the location n after the beginning of the user's space.  */
specifier|register
name|char
modifier|*
name|m
init|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|n
decl_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
operator|,
operator|*
name|m
operator|++
operator|=
name|MAGIC1
operator|,
operator|*
name|m
operator|++
operator|=
name|MAGIC1
operator|,
operator|*
name|m
operator|=
name|MAGIC1
expr_stmt|;
block|}
else|#
directive|else
comment|/* not rcheck */
name|p
operator|->
name|mh_size
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
ifdef|#
directive|ifdef
name|MSTATS
name|nmalloc
index|[
name|nunits
index|]
operator|++
expr_stmt|;
name|nmal
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MSTATS */
return|return
operator|(
name|char
operator|*
operator|)
name|p
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
return|;
block|}
end_function

begin_macro
name|free
argument_list|(
argument|mem
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mem
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
init|=
name|mem
decl_stmt|;
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|ap
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|==
name|ISMEMALIGN
condition|)
block|{
name|ap
operator|-=
name|p
operator|->
name|mh_size
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|ap
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|rcheck
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|!=
name|ISALLOC
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
else|rcheck
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|!=
name|ISALLOC
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|==
name|ISFREE
condition|)
name|botch
argument_list|(
literal|"free: Called with already freed block argument\n"
argument_list|)
expr_stmt|;
else|else
name|botch
argument_list|(
literal|"free: Called with bad argument\n"
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|p
operator|->
name|mh_magic4
operator|==
name|MAGIC4
argument_list|)
expr_stmt|;
name|ap
operator|+=
name|p
operator|->
name|mh_nbytes
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* rcheck */
block|}
block|{
specifier|register
name|int
name|nunits
init|=
name|p
operator|->
name|mh_index
decl_stmt|;
name|ASSERT
argument_list|(
name|nunits
operator|<=
literal|29
argument_list|)
expr_stmt|;
name|p
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
comment|/* Protect against signal handlers calling malloc.  */
name|busy
index|[
name|nunits
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Put this block on the free list.  */
name|CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|nextf
index|[
name|nunits
index|]
expr_stmt|;
name|nextf
index|[
name|nunits
index|]
operator|=
name|p
expr_stmt|;
name|busy
index|[
name|nunits
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MSTATS
name|nmalloc
index|[
name|nunits
index|]
operator|--
expr_stmt|;
name|nfre
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MSTATS */
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|realloc
parameter_list|(
name|mem
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|mem
decl_stmt|;
specifier|register
name|unsigned
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|tocopy
decl_stmt|;
specifier|register
name|unsigned
name|int
name|nbytes
decl_stmt|;
specifier|register
name|int
name|nunits
decl_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
name|malloc
argument_list|(
name|n
argument_list|)
return|;
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|mem
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
name|nunits
operator|=
name|p
operator|->
name|mh_index
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|mh_alloc
operator|==
name|ISALLOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|rcheck
name|ASSERT
argument_list|(
name|p
operator|->
name|mh_magic4
operator|==
name|MAGIC4
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|m
init|=
name|mem
operator|+
operator|(
name|tocopy
operator|=
name|p
operator|->
name|mh_nbytes
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not rcheck */
if|if
condition|(
name|p
operator|->
name|mh_index
operator|>=
literal|13
condition|)
name|tocopy
operator|=
operator|(
literal|1
operator|<<
operator|(
name|p
operator|->
name|mh_index
operator|+
literal|3
operator|)
operator|)
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
else|else
name|tocopy
operator|=
name|p
operator|->
name|mh_size
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
comment|/* See if desired size rounds to same power of 2 as actual size. */
name|nbytes
operator|=
operator|(
name|n
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|EXTRA
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* If ok, use the same block, just marking its size as changed.  */
if|if
condition|(
name|nbytes
operator|>
operator|(
literal|4
operator|<<
name|nunits
operator|)
operator|&&
name|nbytes
operator|<=
operator|(
literal|8
operator|<<
name|nunits
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|rcheck
specifier|register
name|char
modifier|*
name|m
init|=
name|mem
operator|+
name|tocopy
decl_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|mh_nbytes
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|mem
operator|+
name|n
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
else|#
directive|else
comment|/* not rcheck */
name|p
operator|->
name|mh_size
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
return|return
name|mem
return|;
block|}
if|if
condition|(
name|n
operator|<
name|tocopy
condition|)
name|tocopy
operator|=
name|n
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|mem
argument_list|,
name|new
argument_list|,
name|tocopy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_function
name|char
modifier|*
name|memalign
parameter_list|(
name|alignment
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|alignment
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
name|size
operator|+
name|alignment
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|aligned
decl_stmt|;
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If entire block has the desired alignment, just accept it.  */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ptr
return|;
comment|/* Otherwise, get address of byte in the block that has that alignment.  */
name|aligned
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|alignment
operator|)
expr_stmt|;
comment|/* Store a suitable indication of how to free the block,      so that free can find the true beginning of it.  */
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|aligned
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|mh_size
operator|=
name|aligned
operator|-
name|ptr
expr_stmt|;
name|p
operator|->
name|mh_alloc
operator|=
name|ISMEMALIGN
expr_stmt|;
return|return
name|aligned
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|hpux
end_ifndef

begin_comment
comment|/* This runs into trouble with getpagesize on HPUX.    Patching out seems cleaner than the ugly fix needed.  */
end_comment

begin_function
name|char
modifier|*
name|valloc
parameter_list|(
name|size
parameter_list|)
block|{
return|return
name|memalign
argument_list|(
name|getpagesize
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|MSTATS
end_ifdef

begin_comment
comment|/* Return statistics describing allocation of blocks of size 2**n. */
end_comment

begin_struct
struct|struct
name|mstats_value
block|{
name|int
name|blocksize
decl_stmt|;
name|int
name|nfree
decl_stmt|;
name|int
name|nused
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|mstats_value
name|malloc_stats
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|struct
name|mstats_value
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
name|v
operator|.
name|nfree
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>=
literal|30
condition|)
block|{
name|v
operator|.
name|blocksize
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|nused
operator|=
literal|0
expr_stmt|;
return|return
name|v
return|;
block|}
name|v
operator|.
name|blocksize
operator|=
literal|1
operator|<<
operator|(
name|size
operator|+
literal|3
operator|)
expr_stmt|;
name|v
operator|.
name|nused
operator|=
name|nmalloc
index|[
name|size
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nextf
index|[
name|size
index|]
init|;
name|p
condition|;
name|p
operator|=
name|CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|v
operator|.
name|nfree
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|int
name|malloc_mem_used
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|size_used
decl_stmt|;
name|size_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|int
name|allocation_size
init|=
literal|1
operator|<<
operator|(
name|i
operator|+
literal|3
operator|)
decl_stmt|;
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
name|size_used
operator|+=
name|nmalloc
index|[
name|i
index|]
operator|*
name|allocation_size
expr_stmt|;
block|}
return|return
name|size_used
return|;
block|}
end_function

begin_function
name|int
name|malloc_mem_free
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|size_unused
decl_stmt|;
name|size_unused
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|int
name|allocation_size
init|=
literal|1
operator|<<
operator|(
name|i
operator|+
literal|3
operator|)
decl_stmt|;
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|nextf
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|size_unused
operator|+=
name|allocation_size
expr_stmt|;
block|}
return|return
name|size_unused
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSTATS */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *	This function returns the total number of bytes that the process  *	will be allowed to allocate via the sbrk(2) system call.  On  *	BSD systems this is the total space allocatable to stack and  *	data.  On USG systems this is the data space only.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_macro
name|get_lim_data
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|long
name|ulimit
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|ULIMIT_BREAK_VALUE
name|lim_data
operator|=
name|ULIMIT_BREAK_VALUE
expr_stmt|;
else|#
directive|else
name|lim_data
operator|=
name|ulimit
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lim_data
operator|-=
operator|(
name|long
operator|)
name|data_space_start
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_macro
name|get_lim_data
argument_list|()
end_macro

begin_block
block|{
name|lim_data
operator|=
name|vlimit
argument_list|(
name|LIM_DATA
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BSD4_2 */
end_comment

begin_macro
name|get_lim_data
argument_list|()
end_macro

begin_block
block|{
name|struct
name|rlimit
name|XXrlimit
decl_stmt|;
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|XXrlimit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIM_INFINITY
name|lim_data
operator|=
name|XXrlimit
operator|.
name|rlim_cur
operator|&
name|RLIM_INFINITY
expr_stmt|;
comment|/* soft limit */
else|#
directive|else
name|lim_data
operator|=
name|XXrlimit
operator|.
name|rlim_cur
expr_stmt|;
comment|/* soft limit */
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* There is a problem when dumping and restoring things on VMS. Calls  * to SBRK don't necessarily result in contiguous allocation. Dumping  * doesn't work when it isn't. Therefore, we make the initial  * allocation contiguous by allocating a big chunk, and do SBRKs from  * there. Once Emacs has dumped there is no reason to continue  * contiguous allocation, malloc doesn't depend on it.  *  * There is a further problem of using brk and sbrk while using VMS C  * run time library routines malloc, calloc, etc. The documentation  * says that this is a no-no, although I'm not sure why this would be  * a problem. In any case, we remove the necessity to call brk and  * sbrk, by calling calloc (to assure zero filled data) rather than  * sbrk.  *  * VMS_ALLOCATION_SIZE is the size of the allocation array. This  * should be larger than the malloc size before dumping. Making this  * too large will result in the startup procedure slowing down since  * it will require more space and time to map it in.  *  * The value for VMS_ALLOCATION_SIZE in the following define was determined  * by running emacs linked (and a large allocation) with the debugger and  * looking to see how much storage was used. The allocation was 201 pages,  * so I rounded it up to a power of two.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS_ALLOCATION_SIZE
end_ifndef

begin_define
define|#
directive|define
name|VMS_ALLOCATION_SIZE
value|(512*256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use VMS RTL definitions */
end_comment

begin_undef
undef|#
directive|undef
name|sbrk
end_undef

begin_undef
undef|#
directive|undef
name|brk
end_undef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_decl_stmt
name|int
name|vms_out_initial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|vms_initial_buffer
index|[
name|VMS_ALLOCATION_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vms_current_brk
init|=
operator|&
name|vms_initial_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vms_end_brk
init|=
operator|&
name|vms_initial_buffer
index|[
name|VMS_ALLOCATION_SIZE
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|char
modifier|*
name|sys_sbrk
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
name|char
modifier|*
name|sbrk
argument_list|()
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|vms_out_initial
condition|)
block|{
comment|/* out of initial allocation... */
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|malloc
argument_list|(
name|incr
argument_list|)
operator|)
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, go out of our area */
name|ptr
operator|=
name|vms_current_brk
operator|+
name|incr
expr_stmt|;
comment|/* new current_brk */
if|if
condition|(
name|ptr
operator|<=
name|vms_end_brk
condition|)
block|{
name|temp
operator|=
name|vms_current_brk
expr_stmt|;
name|vms_current_brk
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|vms_out_initial
operator|=
literal|1
expr_stmt|;
comment|/* mark as out of initial allocation */
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|malloc
argument_list|(
name|incr
argument_list|)
operator|)
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|temp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

