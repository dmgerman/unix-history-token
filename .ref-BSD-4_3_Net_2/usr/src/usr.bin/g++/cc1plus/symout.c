begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output GDB-format symbol table information from GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"symseg.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"gdbfiles.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/*<...> used here so one can prevent use of ./stddef.h    by changing the -I options used.  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* Get N_SO from stab.h if we can expect the file to exist.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|"stab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* On BSD, use the system's stab.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .stabs code for source file name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SO
end_ifndef

begin_define
define|#
directive|define
name|N_SO
value|0x64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Unix maximum on file name length.  Needed for getwd.  */
end_comment

begin_define
define|#
directive|define
name|MAXNAMLEN
value|1024
end_define

begin_comment
comment|/* Get the number to output for a reference to type TYPE.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_OUTPUT_ADDRESS
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|TYPE_SYMTAB_ADDRESS (TYPE_MAIN_VARIANT (TYPE))
end_define

begin_comment
comment|/* Stream for writing symbol table file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|symfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of symbol table file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symfile_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stream for writing to assembler file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|asmfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address for allocating space in symbol table file.    Changes in this variable are paired globally with writes to symfile,    but often we allocate many structures, advancing next_address,    before writing any of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain recording all the types that have been output,    giving the address-in-the-symseg of each one.  */
end_comment

begin_struct
struct|struct
name|typevec_elt
block|{
name|int
name|address
decl_stmt|;
name|struct
name|typevec_elt
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|typevec_elt
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of types recorded so far in the chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lists of types to which forward references have been made.    Separate lists for temporary and permanent types.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|temporary_fwd_refs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|permanent_fwd_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `blockvec' is a chain recording all the symbol-blocks that have been output,    giving the address-in-the-symseg of each one.  */
end_comment

begin_struct
struct|struct
name|blockvec_elt
block|{
name|int
name|address
decl_stmt|;
name|struct
name|blockvec_elt
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|blockvec_elt
modifier|*
name|blockvec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of blocks recorded so far in the chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_blocks
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|symout_range_bounds
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_array_domain
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_record_fields
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_enum_values
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_record_field_names
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_enum_value_names
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|subrange_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_strings_skip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symout_strings_print
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* At the beginning of compilation, start writing the symbol table.    Initialize the type and block chain.    Also open and initialize the symseg file.  */
end_comment

begin_function
name|void
name|symout_init
parameter_list|(
name|filename
parameter_list|,
name|asm_file
parameter_list|,
name|sourcename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|asm_file
decl_stmt|;
name|char
modifier|*
name|sourcename
decl_stmt|;
block|{
name|struct
name|symbol_root
name|buffer
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|fatal
argument_list|(
literal|"Cannot write GDB debugging format on VMS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asmfile
operator|=
name|asm_file
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".text 0\n.gdbbeg 0\n.gdbbeg 1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"Ltext:\t.stabs \"%s\",%d,0,0,Ltext\n"
argument_list|,
name|sourcename
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".data 0\nLdata:\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asmfile
argument_list|,
literal|"Lbss"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".gdbsym Ldata,%d\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
operator|.
name|databeg
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".gdbsym Lbss,%d\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
operator|.
name|bssbeg
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|symfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|symfile_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symfile_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|typevec
operator|=
literal|0
expr_stmt|;
name|blockvec
operator|=
literal|0
expr_stmt|;
name|total_types
operator|=
literal|0
expr_stmt|;
name|total_blocks
operator|=
literal|0
expr_stmt|;
name|permanent_fwd_refs
operator|=
literal|0
expr_stmt|;
name|temporary_fwd_refs
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|=
sizeof|sizeof
name|buffer
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for outputting strings into the symbol table.    The string to be output is effectively the concatenation of    the two strings P1 and P2.  Their lengths are given as S1 and S2.    If P1 or P2 is zero, that string is not used.     A null character is output to terminate the string,    and it is followed by more nulls as padding to a word boundary.  */
end_comment

begin_function
specifier|static
name|void
name|symout_strings
parameter_list|(
name|p1
parameter_list|,
name|s1
parameter_list|,
name|p2
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|s1
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|int
name|s2
decl_stmt|;
block|{
name|symout_strings_print
argument_list|(
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|symout_strings_skip
argument_list|(
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like symout_strings but only output; do not update next_address.  */
end_comment

begin_function
specifier|static
name|void
name|symout_strings_print
parameter_list|(
name|p1
parameter_list|,
name|s1
parameter_list|,
name|p2
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|s1
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|int
name|s2
decl_stmt|;
block|{
specifier|register
name|int
name|total
decl_stmt|;
if|if
condition|(
name|p1
operator|&&
name|s1
operator|==
literal|0
condition|)
name|s1
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|&&
name|s2
operator|==
literal|0
condition|)
name|s2
operator|=
name|strlen
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|fwrite
argument_list|(
name|p1
argument_list|,
name|s1
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|fwrite
argument_list|(
name|p2
argument_list|,
name|s2
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|total
operator|=
name|s1
operator|+
name|s2
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|total
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|0
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|total
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like symout_strings but just update next_address; do not output.  */
end_comment

begin_function
specifier|static
name|void
name|symout_strings_skip
parameter_list|(
name|p1
parameter_list|,
name|s1
parameter_list|,
name|p2
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|s1
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|int
name|s2
decl_stmt|;
block|{
specifier|register
name|int
name|total
decl_stmt|;
if|if
condition|(
name|p1
operator|&&
name|s1
operator|==
literal|0
condition|)
name|s1
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|&&
name|s2
operator|==
literal|0
condition|)
name|s2
operator|=
name|strlen
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|total
operator|=
name|s1
operator|+
name|s2
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|total
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|total
operator|++
expr_stmt|;
name|next_address
operator|+=
name|total
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call here to output a chain of types.    After each function, this is done first for the chain of permanent types    made during the function, and then for the chain of temporary types.    This must be done before outputting the symbols and blocks of the function.     At the end of compilation, this is done for all the permanent types    made since the last function.     Each permanent type is done once, at the beginning of the next function,    or at the end of the compilation if no functions follow.    Once a type has been processed here, its TYPE_SYMTAB_ADDRESS remains    set up.  */
end_comment

begin_function
name|void
name|symout_types
parameter_list|(
name|types
parameter_list|)
name|tree
name|types
decl_stmt|;
block|{
struct|struct
name|typerec
block|{
name|int
name|number
decl_stmt|;
name|int
name|address
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|int
name|fields_address
decl_stmt|;
name|int
name|name_address
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|name_prefix
decl_stmt|;
block|}
struct|;
specifier|register
name|int
name|n_types
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|typerec
modifier|*
name|records
decl_stmt|;
specifier|register
name|tree
name|next
decl_stmt|;
name|struct
name|type
name|buffer
decl_stmt|;
name|int
name|this_run_address
init|=
name|next_address
decl_stmt|;
comment|/* Count the number of types to be handled here.  */
for|for
control|(
name|next
operator|=
name|types
operator|,
name|n_types
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
operator|,
name|n_types
operator|++
control|)
empty_stmt|;
name|records
operator|=
operator|(
expr|struct
name|typerec
operator|*
operator|)
name|alloca
argument_list|(
name|n_types
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typerec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the amount of space each type needs, updating next_address      and storing the address of the data for each type.  */
for|for
control|(
name|next
operator|=
name|types
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|typevec_elt
modifier|*
name|velt
init|=
operator|(
expr|struct
name|typevec_elt
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|typevec_elt
argument_list|)
argument_list|)
decl_stmt|;
name|velt
operator|->
name|next
operator|=
name|typevec
expr_stmt|;
name|typevec
operator|=
name|velt
expr_stmt|;
name|total_types
operator|++
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|records
index|[
name|i
index|]
operator|.
name|name_address
operator|=
name|next_address
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|records
index|[
name|i
index|]
operator|.
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
operator|=
literal|"struct "
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
operator|=
literal|"union "
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
operator|=
literal|"enum "
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|records
index|[
name|i
index|]
operator|.
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
operator|=
literal|0
expr_stmt|;
block|}
name|symout_strings_skip
argument_list|(
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
argument_list|,
literal|0
argument_list|,
name|records
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|records
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|records
index|[
name|i
index|]
operator|.
name|name_address
operator|=
literal|0
expr_stmt|;
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this type was forward-referenced from a previous call 	 to symout_types, store this type's address into the reference.  */
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|next
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|next
argument_list|)
argument_list|)
operator|<
name|this_run_address
condition|)
block|{
name|int
name|pos
init|=
name|ftell
argument_list|(
name|symfile
argument_list|)
decl_stmt|;
name|int
name|myaddr
init|=
name|next_address
decl_stmt|;
name|fflush
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|symfile
argument_list|,
operator|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|next
argument_list|)
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|type
argument_list|,
name|target_type
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|myaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|symfile
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|records
index|[
name|i
index|]
operator|.
name|address
operator|=
name|next_address
expr_stmt|;
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|next
argument_list|)
operator|=
name|next_address
expr_stmt|;
name|velt
operator|->
name|address
operator|=
name|next_address
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
expr_stmt|;
name|records
index|[
name|i
index|]
operator|.
name|nfields
operator|=
literal|0
expr_stmt|;
name|records
index|[
name|i
index|]
operator|.
name|fields_address
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|records
index|[
name|i
index|]
operator|.
name|nfields
operator|=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|next
argument_list|)
condition|?
operator|!
name|integer_zerop
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|subrange_p
argument_list|(
name|next
argument_list|)
condition|)
name|buffer
operator|.
name|nfields
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|records
index|[
name|i
index|]
operator|.
name|nfields
operator|=
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|records
index|[
name|i
index|]
operator|.
name|nfields
condition|)
name|records
index|[
name|i
index|]
operator|.
name|fields_address
operator|=
name|next_address
expr_stmt|;
name|next_address
operator|+=
name|records
index|[
name|i
index|]
operator|.
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Now write the data whose space we have assigned.      First fill the data into BUFFER, then write BUFFER.  */
for|for
control|(
name|next
operator|=
name|types
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|records
index|[
name|i
index|]
operator|.
name|name
condition|)
name|symout_strings_print
argument_list|(
name|records
index|[
name|i
index|]
operator|.
name|name_prefix
argument_list|,
literal|0
argument_list|,
name|records
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We are making a forward-reference to our target type. 	     Make a list of all of these.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|next
argument_list|)
condition|)
name|permanent_fwd_refs
operator|=
name|perm_tree_cons
argument_list|(
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
name|permanent_fwd_refs
argument_list|)
expr_stmt|;
else|else
name|temporary_fwd_refs
operator|=
name|tree_cons
argument_list|(
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
name|temporary_fwd_refs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|next
argument_list|)
operator|==
literal|0
condition|)
name|buffer
operator|.
name|length
operator|=
literal|0
expr_stmt|;
else|else
name|buffer
operator|.
name|length
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|next
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|buffer
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|records
index|[
name|i
index|]
operator|.
name|name_address
expr_stmt|;
name|buffer
operator|.
name|target_type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
operator|(
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
condition|?
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|TREE_TYPE
argument_list|(
name|next
argument_list|)
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|buffer
operator|.
name|pointer_type
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|function_type
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|flags
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|next
argument_list|)
operator|)
condition|?
name|TYPE_FLAG_UNSIGNED
else|:
literal|0
expr_stmt|;
name|buffer
operator|.
name|nfields
operator|=
name|records
index|[
name|i
index|]
operator|.
name|nfields
expr_stmt|;
name|buffer
operator|.
name|fields
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|records
index|[
name|i
index|]
operator|.
name|fields_address
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_INT
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|nfields
condition|)
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_FLT
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_VOID
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|buffer
operator|.
name|nfields
operator|==
literal|0
condition|)
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
else|else
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_PASCAL_ARRAY
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_FUNC
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|buffer
operator|.
name|code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
comment|/* Now write the `struct field's that certain kinds of type have. 	 This allocates space for the names of those fields, 	 incrementing next_address for the names.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|buffer
operator|.
name|nfields
condition|)
name|symout_array_domain
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|symout_record_fields
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|symout_enum_values
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|buffer
operator|.
name|nfields
condition|)
name|symout_range_bounds
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now output the strings referred to by the fields of certain types.      (next_address was already updated for these strings.)  */
for|for
control|(
name|next
operator|=
name|types
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|symout_record_field_names
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|symout_enum_value_names
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a list of types TYPES, return a chain of just those    that haven't been written in the symbol table.  */
end_comment

begin_function
specifier|static
name|tree
name|filter_undefined_types
parameter_list|(
name|types
parameter_list|)
name|tree
name|types
decl_stmt|;
block|{
name|tree
name|new
init|=
literal|0
decl_stmt|;
name|tree
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|types
init|;
name|next
condition|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
name|new
operator|=
name|TREE_PURPOSE
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if TYPE's range of possible values    is not the full range allowed by the number of bits it has.    TYPE is assumed to be an INTEGER_TYPE or ENUMERAL_TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|subrange_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|HOST_BITS_PER_INT
condition|)
block|{
if|if
condition|(
name|uns
condition|)
return|return
name|integer_zerop
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|-
literal|1
operator|)
return|;
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
operator|-
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
operator|-
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|uns
condition|)
block|{
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|HOST_BITS_PER_INT
condition|)
comment|/* Shifting by 32 loses on some machines.  */
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|(
literal|1
operator|<<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|integer_zerop
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|mask
operator|)
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Functions to output the "fields" of various kinds of types.    These assume that next_address has already been incremented to    cover these fields, and the fields of all the other types being    output in this batch; so next_address can be used to allocate    space to store field names, etc.  */
end_comment

begin_function
specifier|static
name|void
name|symout_array_domain
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|field
name|buffer
decl_stmt|;
name|buffer
operator|.
name|bitpos
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|symout_range_bounds
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|field
name|buffer
decl_stmt|;
name|buffer
operator|.
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|symout_record_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|field
name|buffer
decl_stmt|;
specifier|register
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|buffer
operator|.
name|bitpos
operator|=
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|bitsize
operator|=
operator|(
name|TREE_PACKED
argument_list|(
name|field
argument_list|)
condition|?
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|buffer
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings_skip
argument_list|(
literal|0
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|buffer
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|symout_enum_values
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|field
name|buffer
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|,
name|value
decl_stmt|;
for|for
control|(
name|link
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings_skip
argument_list|(
literal|0
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output field names or value names for the fields of a type.    This is called, for the types that need it, after the fields    have been output for all the types in the batch.    We do not update next_address here, because it has already been     updated for all the names in all the fields in all the types.  */
end_comment

begin_function
specifier|static
name|void
name|symout_record_field_names
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|symout_strings_print
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|symout_enum_value_names
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|;
for|for
control|(
name|value
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|value
condition|;
name|value
operator|=
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
control|)
name|symout_strings_print
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbols of a block, given the list of decl nodes.    Store the file addresses at which the symbols are output    into ADDR_BUFFER, a vector which has just the right length.     If FILTER is 1, do only the private symbols in DECLS.    If FILTER is 2, do only the public ones (but no externals).    If FILTER is 0, do all (except external functions).  */
end_comment

begin_function
specifier|static
name|void
name|symout_block_symbols
parameter_list|(
name|decls
parameter_list|,
name|addr_buffer
parameter_list|,
name|filter
parameter_list|)
name|tree
name|decls
decl_stmt|;
name|int
modifier|*
name|addr_buffer
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
name|struct
name|symbol
name|buffer
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|decls
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
specifier|register
name|int
name|name_address
init|=
name|next_address
decl_stmt|;
if|if
condition|(
name|filter
operator|==
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
literal|1
else|:
literal|2
operator|)
condition|)
continue|continue;
comment|/* Do not mention external functions. 	 Let their own files mention them. 	 In the top blocks, don't mention external anything.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|filter
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|symout_strings
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_buffer
index|[
name|i
index|]
operator|=
name|next_address
expr_stmt|;
name|buffer
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|name_address
expr_stmt|;
name|buffer
operator|.
name|namespace
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|PARM_DECL
case|:
name|buffer
operator|.
name|class
operator|=
name|LOC_ARG
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|DECL_OFFSET
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.gdbsym "
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABELREF
argument_list|(
name|asmfile
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d\n"
argument_list|,
name|next_address
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
operator|.
name|value
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
block|}
else|else
comment|/* Uninitialized public symbols are output as .comm; 		   Tell GDB to get address from loader global symbol. 		   Also come here for symbols declared extern.  */
name|buffer
operator|.
name|class
operator|=
name|LOC_EXTERNAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|buffer
operator|.
name|class
operator|=
name|LOC_REGISTER
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect vars that were optimized entirely away.  */
if|if
condition|(
name|buffer
operator|.
name|value
operator|.
name|value
operator|==
operator|-
literal|1
condition|)
name|buffer
operator|.
name|class
operator|=
name|LOC_CONST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register 		   that isn't the frame pointer 		   then it means the object is variable-sized and address through 		   that register or stack slot. 		   If we have a pointer-type (which we should, for an array), 		   output the variable as a pointer. 		   Otherwise ignore it, since it is hard to create the ptr 		   type now and output it, and -gg is being retired.  */
block|{
name|tree
name|ptype
init|=
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptype
operator|==
literal|0
operator|||
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|ptype
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|buffer
operator|.
name|class
operator|=
name|LOC_REGISTER
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect vars that were optimized entirely away.  */
if|if
condition|(
name|buffer
operator|.
name|value
operator|.
name|value
operator|==
operator|-
literal|1
condition|)
name|buffer
operator|.
name|class
operator|=
name|LOC_CONST
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|MINUS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|class
operator|=
name|LOC_LOCAL
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MINUS
condition|)
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
operator|-
name|buffer
operator|.
name|value
operator|.
name|value
expr_stmt|;
block|}
block|}
comment|/* Locals in memory are expected to be addressed as 		 (PLUS (REG ...) (CONST_INT ...)). 		 Bomb out if that is not so.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|MINUS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|class
operator|=
name|LOC_LOCAL
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MINUS
condition|)
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
operator|-
name|buffer
operator|.
name|value
operator|.
name|value
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DECL
case|:
name|buffer
operator|.
name|class
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
name|buffer
operator|.
name|class
operator|=
name|LOC_CONST
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|buffer
operator|.
name|class
operator|=
name|LOC_BLOCK
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
name|DECL_BLOCK_SYMTAB_ADDRESS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|buffer
operator|.
name|class
operator|=
name|LOC_EXTERNAL
expr_stmt|;
block|}
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
name|buffer
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the tags (struct, union and enum definitions) for a block,    given a list of them (a chain of TREE_LIST nodes) in TAGS.    Store their addresses in the file into ADDR_BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|symout_block_tags
parameter_list|(
name|tags
parameter_list|,
name|addr_buffer
parameter_list|)
name|tree
name|tags
decl_stmt|;
name|int
modifier|*
name|addr_buffer
decl_stmt|;
block|{
specifier|register
name|tree
name|tag
decl_stmt|;
name|struct
name|symbol
name|buffer
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|tag
operator|=
name|tags
operator|,
name|i
operator|=
literal|0
init|;
name|tag
condition|;
name|tag
operator|=
name|TREE_CHAIN
argument_list|(
name|tag
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tag
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tag
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_buffer
index|[
name|i
index|]
operator|=
name|next_address
expr_stmt|;
name|buffer
operator|.
name|namespace
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
name|buffer
operator|.
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|TYPE_OUTPUT_ADDRESS
argument_list|(
name|TREE_VALUE
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|class
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|buffer
operator|.
name|value
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
name|buffer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output all the data structure for a "block"    (any binding contour).    DECLS is the chain of declarations of variables in this block.    TAGS is the list of struct, union and enum tag definitions of this block.    SUPERBLOCK_ADDRESS is the symtab file address of the containing block's    data structure.  */
end_comment

begin_function
name|int
name|symout_block
parameter_list|(
name|decls
parameter_list|,
name|tags
parameter_list|,
name|args
parameter_list|,
name|superblock_address
parameter_list|)
name|tree
name|decls
decl_stmt|;
name|tree
name|tags
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|superblock_address
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|addr_buffer
decl_stmt|;
name|struct
name|block
name|buffer
decl_stmt|;
name|int
name|n_decls
decl_stmt|,
name|n_tags
decl_stmt|,
name|n_args
decl_stmt|,
name|total
decl_stmt|;
specifier|register
name|struct
name|blockvec_elt
modifier|*
name|velt
decl_stmt|;
name|int
name|block_address
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|decls
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|i
operator|++
expr_stmt|;
name|n_decls
operator|=
name|i
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|args
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|n_args
operator|=
name|i
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|tags
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|n_tags
operator|=
name|i
expr_stmt|;
name|total
operator|=
name|n_decls
operator|+
name|n_args
operator|+
name|n_tags
expr_stmt|;
name|addr_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|total
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|symout_block_symbols
argument_list|(
name|args
argument_list|,
name|addr_buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symout_block_symbols
argument_list|(
name|decls
argument_list|,
name|addr_buffer
operator|+
name|n_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symout_block_tags
argument_list|(
name|tags
argument_list|,
name|addr_buffer
operator|+
name|n_decls
operator|+
name|n_args
argument_list|)
expr_stmt|;
name|velt
operator|=
operator|(
expr|struct
name|blockvec_elt
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvec_elt
argument_list|)
argument_list|)
expr_stmt|;
name|velt
operator|->
name|next
operator|=
name|blockvec
expr_stmt|;
name|velt
operator|->
name|address
operator|=
name|next_address
expr_stmt|;
name|blockvec
operator|=
name|velt
expr_stmt|;
name|buffer
operator|.
name|startaddr
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|endaddr
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|superblock
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|superblock_address
expr_stmt|;
name|buffer
operator|.
name|function
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|nsyms
operator|=
name|total
expr_stmt|;
name|block_address
operator|=
name|next_address
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|.
name|sym
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|.
name|sym
expr_stmt|;
name|fwrite
argument_list|(
name|addr_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|total
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
name|total
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.gdbblock %d,%d\n"
argument_list|,
name|total_blocks
operator|+
literal|2
argument_list|,
name|block_address
argument_list|)
expr_stmt|;
name|total_blocks
operator|++
expr_stmt|;
return|return
name|block_address
return|;
block|}
end_function

begin_comment
comment|/* Walk STMT, the body of a function, and output symtab data on    all the blocks that compose it and all symbols inside them.    ARGS is a chain of decls for argument variables of the function.    SUPERBLOCK_ADDRESS is the address of symbol data for the    innermost block containing STMT; it is used for recursive calls,    and is always 0 for the outermost call (since the containing    block for a function is output later than the function).  */
end_comment

begin_function
name|int
name|symout_function
parameter_list|(
name|stmt
parameter_list|,
name|args
parameter_list|,
name|superblock_address
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|superblock_address
decl_stmt|;
block|{
name|int
name|address
init|=
name|superblock_address
decl_stmt|;
while|while
condition|(
name|stmt
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_STMT
case|:
case|case
name|LOOP_STMT
case|:
name|symout_function
argument_list|(
name|STMT_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|symout_function
argument_list|(
name|STMT_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|symout_function
argument_list|(
name|STMT_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|LET_STMT
case|:
comment|/* Ignore LET_STMTs for blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
break|break;
name|address
operator|=
name|symout_block
argument_list|(
name|STMT_VARS
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|STMT_TYPE_TAGS
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|args
argument_list|,
name|superblock_address
argument_list|)
expr_stmt|;
name|symout_function
argument_list|(
name|STMT_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
name|TREE_CHAIN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|address
return|;
block|}
end_function

begin_macro
name|symout_function_end
argument_list|()
end_macro

begin_block
block|{
comment|/* Output dummy entries for any undefined structure references.  */
name|symout_types
argument_list|(
name|filter_undefined_types
argument_list|(
name|temporary_fwd_refs
argument_list|)
argument_list|)
expr_stmt|;
name|temporary_fwd_refs
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Output all the data structure for a top two blocks in a compilation.    The top block is for public (global) symbols;    the next one is for private (this file only) symbols.     DECLS is the chain of declarations of variables in this block.    TAGS is the list of struct, union and enum tag definitions.  */
end_comment

begin_function
name|void
name|symout_top_blocks
parameter_list|(
name|decls
parameter_list|,
name|tags
parameter_list|)
name|tree
name|decls
decl_stmt|;
name|tree
name|tags
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|addr_buffer
decl_stmt|;
name|struct
name|block
name|buffer
decl_stmt|;
name|int
name|n_decls
decl_stmt|,
name|n_tags
decl_stmt|;
specifier|register
name|struct
name|blockvec_elt
modifier|*
name|velt
decl_stmt|;
name|int
name|top_block_addr
decl_stmt|;
comment|/* First do the public-symbols block.  */
for|for
control|(
name|decl
operator|=
name|decls
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|n_decls
operator|=
name|i
expr_stmt|;
name|addr_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_decls
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|symout_block_symbols
argument_list|(
name|decls
argument_list|,
name|addr_buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".text 0\n\t.gdbend 0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.gdbblock 0,%d\n"
argument_list|,
name|next_address
argument_list|)
expr_stmt|;
name|total_blocks
operator|++
expr_stmt|;
name|velt
operator|=
operator|(
expr|struct
name|blockvec_elt
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvec_elt
argument_list|)
argument_list|)
expr_stmt|;
name|velt
operator|->
name|next
operator|=
name|blockvec
expr_stmt|;
name|velt
operator|->
name|address
operator|=
name|next_address
expr_stmt|;
name|blockvec
operator|=
name|velt
expr_stmt|;
name|top_block_addr
operator|=
name|next_address
expr_stmt|;
name|buffer
operator|.
name|startaddr
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|endaddr
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|superblock
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|function
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|nsyms
operator|=
name|n_decls
expr_stmt|;
empty_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|.
name|sym
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|.
name|sym
expr_stmt|;
name|fwrite
argument_list|(
name|addr_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|n_decls
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
name|n_decls
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Next do the private-symbols block.  */
for|for
control|(
name|decl
operator|=
name|decls
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|n_decls
operator|=
name|i
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|tags
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|n_tags
operator|=
name|i
expr_stmt|;
name|addr_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_decls
operator|+
name|n_tags
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|symout_block_symbols
argument_list|(
name|decls
argument_list|,
name|addr_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symout_block_tags
argument_list|(
name|tags
argument_list|,
name|addr_buffer
operator|+
name|n_decls
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.gdbend 1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.gdbblock 1,%d\n"
argument_list|,
name|next_address
argument_list|)
expr_stmt|;
name|total_blocks
operator|++
expr_stmt|;
name|velt
operator|=
operator|(
expr|struct
name|blockvec_elt
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvec_elt
argument_list|)
argument_list|)
expr_stmt|;
name|velt
operator|->
name|next
operator|=
name|blockvec
expr_stmt|;
name|velt
operator|->
name|address
operator|=
name|next_address
expr_stmt|;
name|blockvec
operator|=
name|velt
expr_stmt|;
name|buffer
operator|.
name|startaddr
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|endaddr
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|superblock
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|top_block_addr
expr_stmt|;
name|buffer
operator|.
name|function
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|nsyms
operator|=
name|n_decls
operator|+
name|n_tags
expr_stmt|;
empty_stmt|;
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|.
name|sym
argument_list|,
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|.
name|sym
expr_stmt|;
name|fwrite
argument_list|(
name|addr_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|n_decls
operator|+
name|n_tags
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
operator|(
name|n_decls
operator|+
name|n_tags
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the source-line-number information.  */
end_comment

begin_comment
comment|/* Output a `struct source' for the source file described by F.    Return the address-in-the-symseg of the `struct source'.  */
end_comment

begin_function
specifier|static
name|int
name|symout_source_file
parameter_list|(
name|f
parameter_list|)
name|struct
name|gdbfile
modifier|*
name|f
decl_stmt|;
block|{
comment|/* Make the `struct source' big enough for as many lines as      this file has.  */
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|source
argument_list|)
operator|+
operator|(
name|f
operator|->
name|nlines
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
decl_stmt|;
name|struct
name|source
modifier|*
name|buffer
init|=
operator|(
expr|struct
name|source
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Use zero for the line data, since assembler will store the real data.  */
name|bzero
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Output the file's name as a string.  The assembler doesn't know this.  */
name|buffer
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|nlines
operator|=
name|f
operator|->
name|nlines
expr_stmt|;
comment|/* Write the structure.  */
name|addr
operator|=
name|next_address
expr_stmt|;
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
name|size
expr_stmt|;
comment|/* Tell assembler where to write the real line-number data.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.gdblinetab %d,%d\n"
argument_list|,
name|f
operator|->
name|filenum
argument_list|,
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Output the `struct sourcevector' which describes all the    source files and points a `struct source' for each one.  */
end_comment

begin_function
specifier|static
name|int
name|symout_sources
parameter_list|()
block|{
specifier|register
name|struct
name|gdbfile
modifier|*
name|f
decl_stmt|;
name|int
name|nfiles
init|=
literal|0
decl_stmt|;
name|struct
name|sourcevector
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Count number of files to determine size of the sourcevector.  */
for|for
control|(
name|f
operator|=
name|gdbfiles
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
operator|++
name|nfiles
expr_stmt|;
comment|/* Allocate buffer for the sourcevector and record its length.  */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|source
operator|*
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|sourcevector
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|s
operator|->
name|length
operator|=
name|nfiles
expr_stmt|;
comment|/* Output a `struct source' for each file; put address into sourcevector.  */
for|for
control|(
name|f
operator|=
name|gdbfiles
operator|,
name|i
operator|=
literal|0
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|s
operator|->
name|source
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|source
operator|*
operator|)
name|symout_source_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Output the sourcevector.  */
name|addr
operator|=
name|next_address
expr_stmt|;
name|fwrite
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
name|size
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call here at the end of compilation, after outputting all the    blocks and symbols, to output the blockvector and typevector    and close the symbol table file.  FILETIME is source file's    creation time.  */
end_comment

begin_function
name|void
name|symout_finish
parameter_list|(
name|filename
parameter_list|,
name|filetime
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|filetime
decl_stmt|;
block|{
name|int
modifier|*
name|blockvector
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|total_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|typevector
decl_stmt|;
name|int
name|now
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|symbol_root
name|buffer
decl_stmt|;
name|char
name|dir
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
comment|/* Output dummy entries for any undefined structure references.  */
name|symout_types
argument_list|(
name|filter_undefined_types
argument_list|(
name|permanent_fwd_refs
argument_list|)
argument_list|)
expr_stmt|;
name|typevector
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|total_types
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|language
operator|=
name|language_c
expr_stmt|;
name|buffer
operator|.
name|blockvector
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|next_address
expr_stmt|;
comment|/* The two blocks at the beginning of the chain      are the file's private symbols block and public symbols block.      They belong at the front of the blockvector, in that order.  */
name|blockvector
index|[
literal|2
index|]
operator|=
name|blockvec
operator|->
name|address
expr_stmt|;
name|blockvec
operator|=
name|blockvec
operator|->
name|next
expr_stmt|;
name|blockvector
index|[
literal|1
index|]
operator|=
name|blockvec
operator|->
name|address
expr_stmt|;
name|blockvec
operator|=
name|blockvec
operator|->
name|next
expr_stmt|;
comment|/* The rest of the blocks are in the chain in reverse order.  */
for|for
control|(
name|i
operator|=
name|total_blocks
init|;
name|i
operator|>
literal|2
condition|;
name|i
operator|--
control|)
block|{
name|blockvector
index|[
name|i
index|]
operator|=
name|blockvec
operator|->
name|address
expr_stmt|;
name|blockvec
operator|=
name|blockvec
operator|->
name|next
expr_stmt|;
block|}
name|blockvector
index|[
literal|0
index|]
operator|=
name|total_blocks
expr_stmt|;
name|fwrite
argument_list|(
name|blockvector
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|total_blocks
operator|+
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|total_blocks
operator|+
literal|1
operator|)
expr_stmt|;
name|buffer
operator|.
name|typevector
operator|=
operator|(
expr|struct
name|typevector
operator|*
operator|)
name|next_address
expr_stmt|;
for|for
control|(
name|i
operator|=
name|total_types
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|typevector
index|[
name|i
index|]
operator|=
name|typevec
operator|->
name|address
expr_stmt|;
name|typevec
operator|=
name|typevec
operator|->
name|next
expr_stmt|;
block|}
name|typevector
index|[
literal|0
index|]
operator|=
name|total_types
expr_stmt|;
name|fwrite
argument_list|(
name|typevector
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|total_types
operator|+
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|next_address
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|total_types
operator|+
literal|1
operator|)
expr_stmt|;
name|buffer
operator|.
name|sourcevector
operator|=
operator|(
expr|struct
name|sourcevector
operator|*
operator|)
name|symout_sources
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|format
operator|=
literal|1
expr_stmt|;
name|buffer
operator|.
name|textrel
operator|=
literal|0
expr_stmt|;
comment|/* These four will be set up by linker.  */
name|buffer
operator|.
name|datarel
operator|=
literal|0
expr_stmt|;
comment|/* Make them 0 now, which is right for */
name|buffer
operator|.
name|bssrel
operator|=
literal|0
expr_stmt|;
comment|/* looking at the .o file in gdb.  */
name|buffer
operator|.
name|ldsymoff
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|version
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings
argument_list|(
name|ctime
argument_list|(
operator|&
name|filetime
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|compilation
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings
argument_list|(
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
name|symout_strings
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|filedir
operator|=
operator|(
name|char
operator|*
operator|)
name|next_address
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|strcpy
argument_list|(
name|dir
argument_list|,
name|getcwd
argument_list|(
name|dir
argument_list|,
name|MAXNAMLEN
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
name|getwd
argument_list|(
name|dir
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|symout_strings
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|symfile
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_io_error
argument_list|(
name|symfile_name
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|length
operator|=
name|next_address
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fileno
argument_list|(
name|symfile
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|symfile_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fileno
argument_list|(
name|symfile
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|symfile_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fileno
argument_list|(
name|symfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

