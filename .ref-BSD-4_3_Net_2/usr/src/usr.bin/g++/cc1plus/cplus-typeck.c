begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_function_decl
specifier|extern
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warning
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|mark_addressable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_for_assignment
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static */
end_comment

begin_function_decl
name|tree
name|convert_for_initialization
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compparms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compparms1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|comp_target_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|shorten_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|binary_op_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_int_sum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_diff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_sequence
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static */
end_comment

begin_function_decl
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|truthvalue_conversion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|invert_truthvalue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|readonly_warning_or_error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|message_2_types
argument_list|(
name|pfn
argument_list|,
name|s
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
name|void
argument_list|(
operator|*
name|pfn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|name1
init|=
name|TYPE_NAME
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|tree
name|name2
init|=
name|TYPE_NAME
argument_list|(
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name1
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name1
operator|=
name|DECL_NAME
argument_list|(
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name2
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name2
operator|=
name|DECL_NAME
argument_list|(
name|name2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|s
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name1
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the _TYPE node describing the data type    of the data which NODE represents as a C expression.    Arrays and functions are converted to pointers    just as they are when they appear as C expressions.     C++: Member types are converted to the data    type of the member they are.  */
end_comment

begin_function
name|tree
name|datatype
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|type
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|datatype
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return the target type of TYPE, which meas return T for:    T*, T&, T[], T (...), and otherwise, just T.  */
end_comment

begin_function
name|tree
name|target_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
name|value
return|;
comment|/* If we see X::Y, we build an OFFSET_TYPE which has      not been laid out.  Try to avoid an error by interpreting      it as this->X::Y, if reasonable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|C_C_D
operator|!=
literal|0
operator|&&
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|C_C_D
condition|)
block|{
name|tree
name|base
decl_stmt|,
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|base
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|value
argument_list|)
return|;
block|}
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether type of EXP is instantiated.  */
end_comment

begin_function
name|int
name|type_unknown_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
operator|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_instantiated_type (type, exp);' to make sure EXP    does not have an uninstantiated type.    TYPE is type to instantiate with, if uninstantiated.  */
end_comment

begin_function
name|tree
name|require_instantiated_type
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|,
name|errval
parameter_list|)
name|tree
name|type
decl_stmt|,
name|exp
decl_stmt|,
name|errval
decl_stmt|;
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
operator|)
condition|)
block|{
name|exp
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|errval
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
name|int
name|constflag
init|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|like
argument_list|)
decl_stmt|;
name|int
name|volflag
init|=
name|TREE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|like
argument_list|)
decl_stmt|;
comment|/* @@ Must do member pointers here.  */
return|return
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constflag
argument_list|,
name|volflag
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two parameter lists.     As an optimization, free the space we allocate if the parameter    lists are already common.  */
end_comment

begin_function
name|tree
name|commonparms
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|tree
name|oldargs
init|=
name|p1
decl_stmt|,
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|any_change
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|first_obj
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|current_obstack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (! any_warning) 	    { 	      warning ("default argument given in prototype and not in declaration of function"); 	      any_warning++; 	    }
endif|#
directive|endif
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"redeclaration of default argument %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|commontype
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_change
condition|)
block|{
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|first_obj
argument_list|)
expr_stmt|;
return|return
name|oldargs
return|;
block|}
return|return
name|newargs
return|;
block|}
end_function

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This is the type for the result of most arithmetic operations    if the operands have the given two types.     We do not deal with enumeral types here because they have already been    converted to integer types.  */
end_comment

begin_function
name|tree
name|commontype
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|form1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form2
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|form1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|form2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|form1
operator|==
name|REAL_TYPE
operator|&&
name|form2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|form2
operator|==
name|REAL_TYPE
operator|&&
name|form1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t2
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|t1
operator|==
name|long_unsigned_type_node
operator|||
name|t2
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|t1
operator|==
name|long_integer_type_node
operator|||
name|t2
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|long_unsigned_type_node
return|;
return|return
name|long_integer_type_node
return|;
block|}
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
else|else
return|return
name|t2
return|;
if|#
directive|if
literal|1
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
block|{
name|tree
name|target
init|=
name|commontype
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|target
operator|=
name|build_type_variant
argument_list|(
name|target
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|form1
operator|==
name|POINTER_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|target
argument_list|)
return|;
else|else
return|return
name|build_reference_type
argument_list|(
name|target
argument_list|)
return|;
block|}
else|#
directive|else
case|case
name|POINTER_TYPE
case|:
return|return
name|build_pointer_type
argument_list|(
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|build_reference_type
argument_list|(
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
return|return
name|build_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|raises
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* If both args specify argument types, we must merge the two 	   lists, argument by argument.  */
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|commonparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_exception_variant
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|raises
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|assert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|t1
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype_or_else
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
name|compiler_error
argument_list|(
literal|"commontype called with uncommon aggregate types"
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Get this value the long way, since TYPE_METHOD_BASETYPE 	     is just the main variant of this.  */
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|raises
decl_stmt|,
name|t3
decl_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
comment|/* If this was a member function type, get back to the 	     original type of type member function (i.e., without 	     the class instance variable up front.  */
name|t1
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|commontype
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|t3
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|t3
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t3
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_exception_variant
argument_list|(
name|basetype
argument_list|,
name|t3
argument_list|,
name|raises
argument_list|)
return|;
block|}
name|compiler_error
argument_list|(
literal|"commontype called with uncommon method types"
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
return|return
name|build_member_type
argument_list|(
name|basetype
argument_list|,
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|compiler_error
argument_list|(
literal|"commontype called with uncommon member types"
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
default|default:
return|return
name|t1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 raise the same exceptions.  */
end_comment

begin_function
name|int
name|compexcepttypes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
return|return
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|comp_array_types
argument_list|(
name|cmp
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
decl|register
name|int
argument_list|(
operator|*
name|cmp
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  This is what ANSI C speaks of as    "being the same".     For C++: argument STRICT says we should be strict about this    comparison:  	1 : strict (compared according to ANSI C) 	0 :<= (compared according to C++) 	-1:<= or>= (relaxed)     Otherwise, pointers involving base classes and derived classes    can be mixed as legal: i.e. a pointer to a base class may be assigned    to a pointer to one of its derived classes, as per C++. A pointer to    a derived class may be passed as a paramter to a function expecting a    pointer to a base classes. These allowances do not commute. In this    case, TYPE1 is assumed to be the base class, and TYPE2 is assumed to    be the derived class.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|type1
decl_stmt|;
specifier|register
name|tree
name|t2
init|=
name|type2
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* This should never happen.  */
name|assert
argument_list|(
name|t1
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* We don't want this to happen.  */
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
block|{
name|warning
argument_list|(
literal|"t2 == error_mark_node in `comptypes'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strict
operator|<=
literal|0
condition|)
goto|goto
name|look_hard
goto|;
return|return
literal|0
return|;
case|case
name|OFFSET_TYPE
case|:
return|return
operator|(
name|comptypes
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This case is anti-symmetrical! 	 One can pass a base member (or member function) 	 to something expecting a derived member (or member function), 	 but not vice-versa!  */
return|return
operator|(
name|comptypes
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strict
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|int
name|rval
decl_stmt|;
name|look_hard
label|:
name|rval
operator|=
name|t1
operator|==
name|t2
operator|||
name|get_base_distance
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
return|return
operator|(
name|get_base_type
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
else|else
return|return
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
return|;
case|case
name|ARRAY_TYPE
case|:
comment|/* Target types must match incl. qualifiers.  */
return|return
name|comp_array_types
argument_list|(
operator|&
name|comptypes
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.     NPTRS is the number of pointers we can strip off and keep cool.    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,    but to not permit B** to convert to A**.  */
end_comment

begin_function
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|nptrs
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
name|ttr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|comp_array_types
argument_list|(
operator|&
name|comp_target_types
argument_list|,
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
if|if
condition|(
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
condition|)
switch|switch
condition|(
name|comp_target_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|ttr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|2
case|:
name|warning
argument_list|(
literal|"contravariance violation for method types ignored"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* for C++ */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Contravariance: we can assign a pointer to base member to a pointer 	 to derived member.  Note difference from simple pointer case, where 	 we can pass a pointer to derived to a pointer to base.  */
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
return|;
elseif|else
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"contravariance violation for member types ignored"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
condition|)
block|{
if|if
condition|(
name|nptrs
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|comptypes
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|ttr
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If two types share a common base type, return that basetype.    There is not a unique most-derived base type, this function    returns ERROR_MARK_NODE.  */
end_comment

begin_function
name|tree
name|common_base_type
parameter_list|(
name|tt1
parameter_list|,
name|tt2
parameter_list|)
name|tree
name|tt1
decl_stmt|,
name|tt2
decl_stmt|;
block|{
name|tree
name|first
init|=
name|NULL_TREE
decl_stmt|,
name|second
init|=
name|NULL_TREE
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt1
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|tt1
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|tt2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|tmp
operator|=
name|common_base_type
argument_list|(
name|basetype
argument_list|,
name|tt2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|first
operator|!=
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|first
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|first
operator|=
name|error_mark_node
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|first
operator|!=
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|first
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|tt1
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt2
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|tt1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|tmp
operator|=
name|common_base_type
argument_list|(
name|basetype
argument_list|,
name|tt1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|second
operator|!=
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|second
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|second
operator|=
name|error_mark_node
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|second
operator|!=
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|second
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|first
operator|!=
name|NULL_TREE
operator|&&
name|second
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|first
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|second
argument_list|)
condition|)
return|return
name|first
return|;
if|if
condition|(
name|first
condition|)
return|return
name|first
return|;
if|if
condition|(
name|second
condition|)
return|return
name|second
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two parameter type lists PARMS1 and PARMS2    are equivalent in the sense that functions with those parameter types    can have equivalent types.    If either list is empty, we win.    Otherwise, the two lists must be equivalent, element by element.     C++: See comment above about TYPE1, TYPE2, STRICT.  */
end_comment

begin_function
name|int
name|compparms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
name|compparms1
argument_list|(
name|t2
argument_list|)
return|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|compparms1
argument_list|(
name|t1
argument_list|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match, unless STRICT is<= 0.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|t1
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
return|;
return|return
operator|(
operator|(
name|t1
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|)
operator|||
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|t2
operator|==
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
return|;
return|return
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This really wants return whether or not parameter type lists    would make their owning functions assignment compatible or not.  */
end_comment

begin_function
name|int
name|comp_target_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
name|int
name|warn_contravariance
init|=
literal|0
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
name|compparms1
argument_list|(
name|t2
argument_list|)
return|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|compparms1
argument_list|(
name|t1
argument_list|)
return|;
for|for
control|(
init|;
name|t1
operator|||
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match, unless STRICT is<= 0.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
return|return
literal|1
operator|+
name|warn_contravariance
return|;
return|return
operator|(
operator|(
name|t1
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|)
operator|+
name|warn_contravariance
operator|)
return|;
block|}
name|p1
operator|=
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
block|{
comment|/* The following is wrong for contravariance, 	     but many programs depend on it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
continue|continue;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
continue|continue;
block|}
block|}
comment|/* Note backwards order due to contravariance.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* What good do these cases do?  */
block|if (strict == 0) 	    return p2 == void_type_node&& TREE_PURPOSE (t1); 	  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);
endif|#
directive|endif
block|}
comment|/* Target types are compatible--just make sure that if 	 we use parameter lists, that they are ok as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
switch|switch
condition|(
name|comp_target_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|p2
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
operator|+
name|warn_contravariance
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|compparms1
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.     C++: must make these work for type variants as well.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|signed_char_type_node
operator|||
name|type
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|unsigned_char_type_node
operator|||
name|type
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|get_floating_type
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"sizeof applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"sizeof applied to a method type"
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"sizeof applied to a void type"
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/* C++: this is really correct!  */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|size_in_bytes
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|size_in_bytes
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
condition|)
return|return
name|build_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
comment|/* C++: this is really correct!  */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Arrays and functions are converted to pointers;    enumeral types or short or char, to int.    In addition, manifest constants symbols are replaced by their values.     C++: this will automatically bash references to their target type.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|dt
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|#
directive|if
literal|0
block|warning ("conversion from member type");
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
return|return
name|default_conversion
argument_list|(
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
name|dt
operator|=
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|exp
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|dt
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|dt
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since EXP is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|ENUMERAL_TYPE
operator|||
operator|(
name|form
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|dt
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Traditionally, unsignedness is preserved in default promotions.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|dt
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
name|dt
operator|==
name|float_type_node
condition|)
return|return
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|form
operator|==
name|FUNCTION_TYPE
operator|||
name|form
operator|==
name|METHOD_TYPE
condition|)
block|{
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|form
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Stripping away the INDIRECT_REF is not the right 	     thing to do for references...  */
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|inner
operator|=
name|build1
argument_list|(
name|REFERENCE_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|default_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|restype
operator|=
name|build_type_variant
argument_list|(
name|restype
argument_list|,
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_LITERAL
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like `build_component_ref, but uses an already found field.    Must compute visibility for C_C_D.  Otherwise, ok.  */
end_comment

begin_function
name|tree
name|build_component_ref_1
parameter_list|(
name|datum
parameter_list|,
name|field
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|field
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
specifier|register
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|form
argument_list|)
condition|)
block|{
if|if
condition|(
name|form
operator|!=
name|ERROR_MARK
condition|)
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"request for member `%s' in something not a class, structure or union"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|field
return|;
if|if
condition|(
name|datum
operator|==
name|C_C_D
operator|&&
operator|!
name|TREE_FIELD_PUBLIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|enum
name|visibility_type
name|visibility
init|=
name|compute_visibility
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_type
argument_list|)
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"field `%s' is private"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
block|{
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"field `%s' is protected"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|basetypes
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* REFERENCE_EXPRs are not converted by `convert_from_reference'. 	 @@ Maybe that is not right.  */
block|if (TREE_CODE (datum) == REFERENCE_EXPR) 	datum = build1 (INDIRECT_REF, TREE_TYPE (basetype), datum);       else
endif|#
directive|endif
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* First, see if there is a field or component with name COMPONENT. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|TREE_CHAIN
argument_list|(
name|component
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|component
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TYPE_EXPR
condition|)
return|return
name|build_component_type_expr
argument_list|(
name|datum
argument_list|,
name|component
argument_list|,
name|NULL_TREE
argument_list|,
name|protect
argument_list|)
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|form
argument_list|)
condition|)
block|{
if|if
condition|(
name|form
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a class, structure or union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|basetypes
operator|=
name|basetype_path
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetypes
argument_list|,
name|component
argument_list|,
name|protect
operator|&&
operator|!
name|VFIELD_NAME_P
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Not found as a data field, look for it as a method.  If found, 	 then if this is the only possible one, return it, else 	 report ambiguity error.  */
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|component
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basename
init|=
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|enum
name|visibility_type
name|visibility
decl_stmt|;
comment|/* Unique, so use this one now.  */
name|basetype
operator|=
name|TREE_PURPOSE
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_public
condition|)
block|{
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|datum
argument_list|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_VCONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|datum
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|datum
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|addr
argument_list|,
name|datum
argument_list|,
name|DECL_VINDEX
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|field
return|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"member function `%s' is protected"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"member function `%s' is private"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|datum
argument_list|,
name|fields
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basename
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basename
operator|=
name|DECL_NAME
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|component
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s `%s' has no such type conversion operator"
argument_list|,
name|form
operator|==
name|RECORD_TYPE
condition|?
literal|"structure"
else|:
literal|"union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|basename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|form
operator|==
name|RECORD_TYPE
condition|?
literal|"structure `%s' has no member named `%s'"
else|:
literal|"union `%s' has no member named `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|basename
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|TREE_USED
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|field
return|;
block|}
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|basetype
operator|&&
operator|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|datum
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|datum
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.     This function may need to overload OPERATOR_FNNAME.    Must also handle REFERENCE_TYPEs for C++.  */
end_comment

begin_function
name|tree
name|build_x_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|INDIRECT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build_indirect_ref
argument_list|(
name|ptr
argument_list|,
name|errorstring
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|dt
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|current_class_decl
condition|)
return|return
name|C_C_D
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|pointer
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).     If INDEX is of some user-defined type, it must be converted to    integer type.  Otherwise, to make a compatible PLUS_EXPR, it    will inherit the type of the array, which will be some pointer type.  */
end_comment

begin_function
name|tree
name|build_x_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_opfncall
argument_list|(
name|ARRAY_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|array
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build_array_ref
argument_list|(
name|array
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
name|tree
name|itype
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|index
operator|=
name|convert_from_reference
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|itype
argument_list|)
condition|)
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|itype
argument_list|)
condition|)
name|index
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|itype
argument_list|,
literal|"type `%s' requires integer conversion for array indexing"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|index
operator|=
name|default_conversion
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_REGDECL
argument_list|(
name|foo
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|,
name|array
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are.  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
name|PLUS_EXPR
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.     For C++: If FUNCTION's data type is a TREE_LIST, then the tree list    is the list of possible methods that FUNCTION could conceivably    be.  If the list of methods comes from a class, then it will be    a list of lists (where each element is associated with the class    that produced it), otherwise it will be a simple list (for    functions overloaded in global scope).     In the first case, TREE_VALUE (function) is the head of one of those    lists, and TREE_PURPOSE is the name of the function.     In the second case, TREE_PURPOSE (function) is the function's    name directly.     DECL is the class instance variable, usually CURRENT_CLASS_DECL.  */
end_comment

begin_function
name|tree
name|build_x_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|decl
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|int
name|may_be_method
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|function
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
comment|/* Handle methods, friends, and overloaded functions, respectively.  */
if|if
condition|(
name|may_be_method
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|function
operator|=
name|DECL_ORIGINAL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|#
directive|if
literal|0
block|if (TREE_CODE (TREE_VALUE (function)) == TREE_LIST) 	    function = TREE_PURPOSE (TREE_VALUE (function)); 	  else 	    function = TREE_PURPOSE (function);
else|#
directive|else
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Call via a pointer to member function.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|function
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|function
argument_list|)
expr_stmt|;
goto|goto
name|do_x_function
goto|;
block|}
comment|/* this is an abbreviated method call.          must go through here in case it is a virtual function. 	 @@ Perhaps this could be optimized.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object missing in call to method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Yow: call from a static member function.  */
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type
operator|==
name|unknown_type_node
condition|)
block|{
name|function
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_overload_call
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|,
name|params
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"function `%s' declared overloaded, but no definitions appear with which to resolve it"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FIELD_DECL
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"call via pointer-to-member-function `%s' must be composed with object"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|do_x_function
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
comment|/* If the component is a data element (or a virtual function), we play 	 games here to make things work.  */
name|tree
name|decl_addr
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|C_C_D
expr_stmt|;
name|decl_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|function
operator|=
name|get_member_function
argument_list|(
operator|&
name|decl_addr
argument_list|,
name|decl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl_addr
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|function
argument_list|,
name|params
argument_list|)
return|;
if|if
condition|(
name|may_be_method
condition|)
block|{
name|tree
name|ctypeptr
init|=
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid call to member function needing `this' in static member function scope"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|decl
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctypeptr
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_c_cast
argument_list|(
name|ctypeptr
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|,
name|fndecl
decl_stmt|;
specifier|register
name|tree
name|value_type
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|actualparameterlist
parameter_list|()
function_decl|;
name|int
name|is_method
decl_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|FIELD_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|fndecl
operator|=
name|function
expr_stmt|;
else|else
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot call `main' from within program"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
if|if
condition|(
operator|!
name|TREE_INLINE
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|is_method
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|is_method
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object is not a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|actualparameterlist
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
if|if
condition|(
name|is_method
condition|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
if|if
condition|(
name|parmtype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_WRAPPER
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
operator|||
operator|!
name|WRAPPER_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|bytecount
init|=
name|get_arglist_len_in_bytes
argument_list|(
name|coerced_params
argument_list|)
decl_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|bytecount
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|function
argument_list|,
name|TREE_CHAIN
argument_list|(
name|coerced_params
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
name|wrapper_name
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
block|}
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|value_type
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator||=
operator|!
operator|!
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_type
operator|==
name|void_type_node
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the actual parameter expressions in the list VALUES    to the types in the list TYPELIST.    If parmdecls is exhausted, or when an element has NULL as its type,    perform the default conversions.     RETURN_LOC is the location of the return value, if known, NULL_TREE    otherwise.  This is useful in the case where we can avoid creating    a temporary variable in the case where we can initialize the return    value directly.  If we are not eliding constructors, then we set this    to NULL_TREE to avoid this avoidance.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.        Return a list of expressions for the parameters as converted.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.     In C++, unspecified trailing parameters can be filled in with their    default arguments, if such were specified.  Do so here.  */
end_comment

begin_function
name|tree
name|actualparameterlist
parameter_list|(
name|return_loc
parameter_list|,
name|typelist
parameter_list|,
name|values
parameter_list|,
name|fndecl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|return_loc
decl_stmt|,
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|char
modifier|*
name|called_thing
decl_stmt|;
name|int
name|maybe_raises
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|flag_elide_constructors
condition|)
name|return_loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|called_thing
operator|=
literal|"constructor"
expr_stmt|;
else|else
name|called_thing
operator|=
literal|"member function"
expr_stmt|;
else|else
name|called_thing
operator|=
literal|"function"
expr_stmt|;
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|80
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"too many arguments to %s `%%s'"
argument_list|,
name|called_thing
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
comment|/* In case anybody wants to know if this argument 	     list is valid.  */
if|if
condition|(
name|result
condition|)
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* The tree type of the parameter being passed may not yet be 	 known.  In this case, its type is TYPE_UNKNOWN, and will 	 be instantiated by the type given by TYPE.  If TYPE 	 is also NULL, the tree type of VAL is ERROR_MARK_NODE.  */
if|if
condition|(
name|type
operator|&&
name|type_unknown_p
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|require_instantiated_type
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|val
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|unknown_type_node
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
comment|/* Instantiates automatically.  */
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"insufficient type information in parameter list"
argument_list|)
expr_stmt|;
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
block|}
block|{
comment|/* Convert FUNCTION_DECLs for virtual functions 	   to proper representation.  */
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ttype
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|basetype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
comment|/* If BASETYPE is set here, default_conversion will do the 	   actual conversion for us.  */
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
block|{
name|val
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|ttype
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|basetype
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|maybe_raises
operator||=
name|TREE_RAISES
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"parameter type of called function is incomplete"
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
comment|/* Rather than truncating and then reextending, 		 convert directly to int, if that's the type we will want.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|return_loc
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
literal|"argument passing"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|parm
operator|=
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|val
operator|=
name|convert_from_reference
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|parm
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|||
name|TYPE_GETS_ASSIGN_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|"cannot pass objects of type `%s' through `...'"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"cannot pass objects of type `%s' through `...'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|parm
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|chainon
argument_list|(
name|result
argument_list|,
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|typetail
operator|!=
name|void_list_node
condition|)
block|{
comment|/* See if there are default arguments that can be used */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
condition|)
block|{
while|while
condition|(
name|typetail
operator|!=
name|void_list_node
condition|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|parmval
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|parmval
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|parmval
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|return_loc
argument_list|,
name|type
argument_list|,
name|parmval
argument_list|,
literal|"default constructor"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|return_loc
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
literal|"default argument"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|maybe_raises
operator||=
name|TREE_RAISES
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|)
expr_stmt|;
name|result
operator|=
name|chainon
argument_list|(
name|result
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
comment|/* ends with `...'.  */
if|if
condition|(
name|typetail
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|32
operator|+
name|strlen
argument_list|(
name|called_thing
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"too few arguments to %s `%%s'"
argument_list|,
name|called_thing
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_list
return|;
block|}
block|}
if|if
condition|(
name|result
condition|)
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
name|maybe_raises
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression, after performing default    conversions on the operands.  CODE is the kind of expression to build.  */
end_comment

begin_function
name|tree
name|build_x_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|rval
operator|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|rval
return|;
name|rval
operator|=
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|tree
name|args
index|[
literal|2
index|]
decl_stmt|;
name|arg1
operator|=
name|default_conversion
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|default_conversion
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|default_conversion
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|require_instantiated_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg2
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|default_conversion
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
block|{
comment|/* Try to convert this to something reasonable.  */
if|if
condition|(
operator|!
name|build_default_binary_type_conversion
argument_list|(
name|code
argument_list|,
operator|&
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|int
name|convert_index
init|=
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
decl_stmt|;
comment|/* Avoid being tripped up by things like (ARG1 != 0).  */
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|,
name|try
decl_stmt|;
name|types
index|[
literal|0
index|]
operator|=
name|type1
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
name|type2
expr_stmt|;
name|try
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|types
index|[
name|convert_index
operator|^
literal|1
index|]
argument_list|,
name|args
index|[
name|convert_index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
operator|&&
name|arg2
operator|==
name|integer_zero_node
operator|&&
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
condition|)
name|try
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|ptr_type_node
argument_list|,
name|args
index|[
name|convert_index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|types
index|[
name|convert_index
index|]
argument_list|,
literal|"type conversion required for type `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|try
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
name|args
index|[
name|convert_index
index|]
operator|=
name|try
expr_stmt|;
block|}
return|return
name|build_binary_op_nodefault
argument_list|(
name|code
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     ERROR_CODE is the code that determines what to say in error messages.    It is usually, but not always, the same as CODE.     Note that the operands will never have enumeral types    because either they have just had the default conversions performed    or they have both just been converted to some other type in which    the arithmetic is to be done.     C++: must do special pointer arithmetic when implementing    multiple inheritance.  */
end_comment

begin_function
name|tree
name|build_binary_op_nodefault
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|error_code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tree_code
name|error_code
decl_stmt|;
block|{
name|tree
name|dt0
init|=
name|datatype
argument_list|(
name|op0
argument_list|)
decl_stmt|,
name|dt1
init|=
name|datatype
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
specifier|register
name|enum
name|tree_code
name|code0
init|=
name|TREE_CODE
argument_list|(
name|dt0
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
init|=
name|TREE_CODE
argument_list|(
name|dt1
argument_list|)
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      give it this type.  Otherwise, give it type RESULT_TYPE.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
name|shorten
operator|=
literal|1
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If one operand is a constant, and the other is a short type 	 that has been converted to an int, 	 really do the work in the short type and then convert the 	 result to int.  If we are lucky, the constant will be 0 or 1 	 in the short type, making the entire operation go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|dt1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|dt0
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
comment|/* Result of these operations is always an int, 	     but that does not mean the operands should be 	     converted to ints!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
comment|/* If these two expressions perform the same operation 	     on what are (or could be given alignment constraints) parts of 	     the same word, try chaining the operations.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* Do they look like (x.p == y.p&& x.q == y.q) 		     or (x.p != y.p || x.q != y.q).  */
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|EQ_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NE_EXPR
operator|)
operator|)
operator|&&
operator|(
name|rval
operator|=
name|merge_component_comparisons
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
return|return
name|rval
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
condition|)
comment|/* Associate the operation.  */
block|{
comment|/* Now try to simplify right-hand term.  */
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|EQ_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NE_EXPR
operator|)
operator|)
operator|&&
operator|(
name|rval
operator|=
name|merge_component_comparisons
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|=
name|rval
expr_stmt|;
return|return
name|op0
return|;
block|}
block|}
block|}
block|}
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|dt0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|dt0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|dt0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
comment|/* Result of comparison is always int, 	 but don't convert the args to int!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|tt0
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tt1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be the same.  */
if|if
condition|(
name|tt0
operator|!=
name|tt1
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|tt0
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|tt1
argument_list|)
condition|)
block|{
name|tree
name|base
init|=
name|common_base_type
argument_list|(
name|tt0
argument_list|,
name|tt1
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL_TREE
condition|)
name|warning
argument_list|(
literal|"comparison of distinct object pointer types"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"comparison of pointer types `%s*' and `%s*' requires conversion to ambiguous supertype"
argument_list|,
name|tt0
argument_list|,
name|tt1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|op0
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|base
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|base
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|tt0
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt1
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If args are not valid, clear out RESULT_TYPE 	   to cause an error message later.  */
name|result_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|,
literal|1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|commontype
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|,
literal|1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|converted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|commontype
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|arg0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|arg1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
operator|,
name|result_type
operator|=
name|xresult_type
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|error_code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_LITERAL
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_LITERAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|tree
name|folded
init|=
name|fold
argument_list|(
name|intop
argument_list|)
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
specifier|register
name|tree
name|result_type
init|=
name|datatype
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
comment|/* Needed to make OOPS V2R3 work.  */
name|intop
operator|=
name|folded
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|intop
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|intop
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ptrop
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"pointer of type `void *' used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"pointer to a function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"pointer to a method used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"pointer to a member used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_LITERAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_LITERAL
argument_list|(
name|size_exp
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intop
operator|=
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as a pointer      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument      with a suitable product by the object size.  */
name|intop
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|size_exp
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_LITERAL
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_LITERAL
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|tree
name|dt0
init|=
name|datatype
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"pointer of type `void *' used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"pointer to a function used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|warning
argument_list|(
literal|"pointer to a method used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|warning
argument_list|(
literal|"pointer to a member used in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|?
name|integer_one_node
else|:
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_LITERAL
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_LITERAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation CODE.    NOP_EXPR is used as a special case (see truthvalue_conversion).  */
end_comment

begin_function
specifier|static
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op_nodefault, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.     The arguments of this function are all pointers to local variables    of build_binary_op_nodefault: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
specifier|static
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  */
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|primop0
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
specifier|register
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_lt
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
comment|/* This is the case of (char)x>?< 0x80, which people used to use 	     expecting old C compilers to change the 0x80 into -0x80.  */
if|if
condition|(
name|val
operator|==
name|integer_zero_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|integer_one_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|integer_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Handle the case of taking the address of a COMPONENT_REF.    Called by `build_unary_op' and `build_up_reference'.     ARG is the COMPONENT_REF whose address we want.    ARGTYPE is the pointer type that this address should have.    MSG is an error message to print if this COMPONENT_REF is not    addressable (such as a bitfield).  */
end_comment

begin_function
name|tree
name|build_component_addr
parameter_list|(
name|arg
parameter_list|,
name|argtype
parameter_list|,
name|msg
parameter_list|)
name|tree
name|arg
decl_stmt|,
name|argtype
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|decl_type_context
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
comment|/* Can't convert directly to ARGTYPE, since that        may have the same pointer type as one of our        baseclasses.  */
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|argtype
argument_list|,
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|rval
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* This conversion is harmless.  */
name|rval
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|offset
init|=
name|build_int_2
argument_list|(
operator|(
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
operator|=
name|argtype
expr_stmt|;
name|rval
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|rval
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  */
end_comment

begin_function
name|tree
name|build_x_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|rval
operator|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|xarg
argument_list|)
condition|)
return|return
name|rval
return|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|xarg
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* C++: Must handle pointers to members.     Perhaps type instantiation should be extended to handle conversion    from aggregates to types we don't yet know we want?  (Or are those    cases typically errors which should be reported?)     NOCONVERT nonzero suppresses the default promotions    (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|int
name|isaggrtype
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|REFERENCE_TYPE
operator|&&
name|code
operator|!=
name|ADDR_EXPR
operator|&&
operator|!
name|noconvert
condition|)
block|{
name|arg
operator|=
name|convert_from_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
name|isaggrtype
operator|=
name|IS_AGGR_TYPE_CODE
argument_list|(
name|typecode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary plus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"type conversion for type `%s' not allowed"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|noconvert
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary minus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"type conversion for type `%s' not allowed"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|noconvert
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"type conversion for type `%s' not allowed"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|noconvert
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
name|arg
operator|=
name|truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
operator|&&
name|typecode
operator|!=
name|POINTER_TYPE
comment|/* These will convert to a pointer.  */
operator|&&
name|typecode
operator|!=
name|ARRAY_TYPE
operator|&&
name|typecode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|errstring
operator|=
literal|"wrong type argument to unary exclamation mark"
expr_stmt|;
break|break;
block|}
name|arg
operator|=
name|truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
break|break;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Report invalid types.  */
if|if
condition|(
name|isaggrtype
condition|)
block|{
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"wrong type argument to increment"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"wrong type argument to decrement"
expr_stmt|;
break|break;
block|}
comment|/* Report something read-only.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_warning_or_error
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"wrong type argument to %s"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg
operator|=
name|resolve_offset_ref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"references are not lvalues"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|typecode
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|build1
argument_list|(
name|REFERENCE_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Keep `default_conversion' from converting if 	     ARG is of REFERENCE_TYPE.  */
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|arg
argument_list|)
condition|)
name|arg
operator|=
name|DECL_INITIAL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|REFERENCE_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Uninstantiated types are all functions.  Taking the 	 address of a function is a no-op, so just return the 	 arguemnt.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OP_IDENTIFIER
condition|)
comment|/* We don't know the type yet, so just work around the problem. 	   We know that this will resolve to an lvalue.  */
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Look at methods with only this name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|targ
init|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* If this function is unique, or it is a unique 		 constructor, we can takes its address easily.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|targ
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|targ
argument_list|)
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|targ
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|targ
argument_list|)
condition|)
name|targ
operator|=
name|TREE_CHAIN
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|targ
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|,
name|C_C_D
argument_list|,
name|targ
argument_list|)
expr_stmt|;
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
block|}
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Unique overloaded member function.  */
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Address of a cast is just a cast of the address 	 of the operand of the cast.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids the address of a cast expression"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_LITERAL
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
name|typecode
operator|!=
name|METHOD_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
name|argtype
operator|=
name|build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|addr
operator|=
name|build_component_addr
argument_list|(
name|arg
argument_list|,
name|argtype
argument_list|,
literal|"attempt to take address of bit-field structure member `%s'"
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   function counts as a constant */
name|TREE_LITERAL
argument_list|(
name|addr
argument_list|)
operator|=
name|staticp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_sequence
parameter_list|(
name|conversions
parameter_list|,
name|arg
parameter_list|)
name|tree
name|conversions
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|conversions
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|conversions
argument_list|)
argument_list|,
name|convert_sequence
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conversions
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|arg
return|;
block|}
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
operator|(
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Handle (a = b) used as an "lvalue" for `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|arg
argument_list|,
name|real_result
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|real_result
operator|=
name|build
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|real_result
argument_list|,
literal|0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|real_result
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The representation of something of type OFFSET_TYPE 	 is really the representation of a pointer to it. 	 Here give the representation its true type.  */
name|tree
name|t
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SCOPE_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|error_mark_node
operator|)
condition|)
block|{
comment|/* Don't know if this should return address to just 	     _DECL, or actual address resolved in this expression.  */
name|sorry
argument_list|(
literal|"address of bound pointer-to-member expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|t
argument_list|)
ifdef|#
directive|ifdef
name|SOS
operator|||
name|flag_all_virtual
operator|==
literal|2
endif|#
directive|endif
operator|||
operator|(
name|flag_all_virtual
operator|==
literal|1
operator|&&
operator|(
operator|(
name|context
operator|=
name|decl_type_context
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|context
argument_list|)
operator|||
name|TYPE_NEEDS_WRAPPER
argument_list|(
name|context
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|)
operator|)
condition|)
block|{
name|offset
operator|=
name|copy_node
argument_list|(
name|DECL_VINDEX
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
condition|)
name|offset
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Can't build a pointer to member if the member must 	     go through virtual base classes.  */
if|if
condition|(
name|virtual_member
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"pointer to member via virtual baseclass"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* @@ What is the correct machine-independent way to do this?  */
name|offset
operator|=
name|build_int_2
argument_list|(
name|DECL_OFFSET
argument_list|(
name|t
argument_list|)
operator|/
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|tree
name|left
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|left_addr
decl_stmt|;
name|tree
name|right_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
if|if
condition|(
name|current_class_decl
condition|)
name|left_addr
operator|=
name|current_class_decl
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"no `this' for pointer to member"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|left_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|left_addr
argument_list|)
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|right_addr
argument_list|)
argument_list|)
return|;
block|}
comment|/* We permit compiler to make function calls returning      objects of aggregate type look like lvalues.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
decl_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
comment|/* Don't let anything else be handled specially.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, integer_zero_node),    but we optimize comparisons,&&, ||, and !  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|form
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since EXPR is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* A one-bit unsigned bit-field is already acceptable.  */
if|if
condition|(
name|form
operator|==
name|COMPONENT_REF
operator|&&
literal|1
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
literal|1
operator|==
name|DECL_SIZE_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|form
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|form
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|form
operator|==
name|TRUTH_AND_EXPR
operator|||
name|form
operator|==
name|TRUTH_OR_EXPR
operator|||
name|form
operator|==
name|TRUTH_NOT_EXPR
operator|||
name|form
operator|==
name|EQ_EXPR
operator|||
name|form
operator|==
name|NE_EXPR
operator|||
name|form
operator|==
name|LE_EXPR
operator|||
name|form
operator|==
name|GE_EXPR
operator|||
name|form
operator|==
name|LT_EXPR
operator|||
name|form
operator|==
name|GT_EXPR
operator|||
name|form
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
comment|/* Unary minus has no effect on whether its argument is nonzero.  */
if|if
condition|(
name|form
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
if|if
condition|(
name|form
operator|==
name|COND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Sign-extension and zero-extension has no effect.  */
if|if
condition|(
name|form
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG    (perhaps by altering ARG).    If it can't be simplified, return 0.  */
end_comment

begin_function
specifier|static
name|tree
name|invert_truthvalue
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|EQ_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|GE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|LT_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|GT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|LE_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|LE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|GT_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|LT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|GE_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
if|#
directive|if
literal|0
block|case TRUTH_AND_EXPR:       return build (TRUTH_OR_EXPR, TREE_TYPE (arg), 		    build_unary_op (TRUTH_NOT_EXPR, 				    TREE_OPERAND (arg, 0), 0), 		    build_unary_op (TRUTH_NOT_EXPR, 				    TREE_OPERAND (arg, 1), 0));      case TRUTH_OR_EXPR:       return build (TRUTH_AND_EXPR, TREE_TYPE (arg), 		    build_unary_op (TRUTH_NOT_EXPR, 				    TREE_OPERAND (arg, 0), 0), 		    build_unary_op (TRUTH_NOT_EXPR, 				    TREE_OPERAND (arg, 1), 0));
endif|#
directive|endif
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.     Return 1 if taking address of this expression is ok.    Return 0 otherwise.     C++: we do not allow `current_class_decl' to be addressable.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|x
operator|==
name|current_class_decl
condition|)
block|{
name|error
argument_list|(
literal|"address of `this' not available"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* so compiler doesn't die later */
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|memory_operand
argument_list|(
name|DECL_RTL
argument_list|(
name|x
argument_list|)
argument_list|,
name|DECL_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We thought this would make a good constant variable, 	       but we were wrong.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Caller should not be trying to mark initialized 	   constant fields addressable.  */
name|assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of global register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|warning
argument_list|(
literal|"address requested for `%s', which is declared `register'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|RESULT_DECL
case|:
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|x
argument_list|)
condition|)
name|mark_inline_for_output
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_x_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|op1
operator|!=
literal|0
operator|&&
operator|(
name|rval
operator|=
name|build_opfncall
argument_list|(
name|COND_EXPR
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
operator|)
condition|)
return|return
name|rval
return|;
name|rval
operator|=
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
literal|0
operator|&&
name|rval
operator|==
name|error_mark_node
condition|)
name|build_opfncall
argument_list|(
name|COND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
specifier|register
name|tree
name|type1
decl_stmt|;
specifier|register
name|tree
name|type2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
specifier|register
name|tree
name|result_type
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If second operand is omitted, it is the same as the first one;      make sure it is calculated only once.  */
if|if
condition|(
name|op1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
name|ifexp
operator|=
name|op1
operator|=
name|save_expr
argument_list|(
name|ifexp
argument_list|)
expr_stmt|;
block|}
name|ifexp
operator|=
name|truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|ifexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|op1
operator|=
name|require_instantiated_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|,
name|op1
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|op2
operator|=
name|require_instantiated_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op2
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* C++: REFERENCE_TYPES must be dereferenced.  */
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|op1
operator|=
name|convert_from_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code2
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|op2
operator|=
name|convert_from_reference
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
block|}
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
operator|&&
name|code2
operator|!=
name|ARRAY_TYPE
if|#
directive|if
literal|0
comment|/* For C++, let the enumeral type come through.  */
expr|&& code2 != ENUMERAL_TYPE
endif|#
directive|endif
operator|&&
name|code2
operator|!=
name|FUNCTION_TYPE
operator|&&
name|code2
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|ifexp
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|)
return|return
operator|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
operator|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|op1
operator|=
name|DECL_INITIAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|decl_constant_value
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|op2
operator|=
name|DECL_INITIAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|decl_constant_value
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
name|int
name|constp
init|=
name|TREE_READONLY
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TREE_VOLATILE
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|type1
operator|=
name|build_type_variant
argument_list|(
name|type1
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
block|}
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type1
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
comment|/* They don't match; promote them both and then try to reconcile them.      But don't permit mismatching enum types.  */
if|if
condition|(
name|code1
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"enumeral mismatch in conditional expression: `%s' vs `%s'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code2
argument_list|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|code2
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
name|VOID_TYPE
condition|)
block|{
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code2
operator|!=
name|VOID_TYPE
condition|)
block|{
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
block|}
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
name|int
name|constp
init|=
name|TREE_READONLY
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TREE_VOLATILE
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|type1
operator|=
name|build_type_variant
argument_list|(
name|type1
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|commontype
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|commontype
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
comment|/* C++ */
elseif|else
if|if
condition|(
name|comptypes
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|,
literal|0
argument_list|)
condition|)
name|result_type
operator|=
name|type2
expr_stmt|;
elseif|else
if|if
condition|(
name|result_type
operator|=
name|common_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|result_type
operator|==
name|error_mark_node
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"common base type of types `%s' and `%s' is ambiguous"
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
else|else
name|result_type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op2
argument_list|)
condition|)
name|warning
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr between 0 and function pointer"
argument_list|)
expr_stmt|;
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr between 0 and function pointer"
argument_list|)
expr_stmt|;
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
comment|/* The match does not look good.  If either is 	 an aggregate value, try converting to a scalar type.  */
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|code2
operator|==
name|RECORD_TYPE
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"aggregate mismatch in conditional expression: `%s' vs `%s'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type2
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|type1
argument_list|,
literal|"aggregate type `%s' could not convert on lhs of `:'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type2
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type1
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|type2
argument_list|,
literal|"aggregate type `%s' could not convert on rhs of `:'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type1
expr_stmt|;
name|op2
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (IS_AGGR_TYPE_CODE (code1))     {       result_type = TREE_TYPE (op1);       if (TREE_LITERAL (ifexp)) 	return (integer_zerop (ifexp) ? op2 : op1);        if (TYPE_MODE (result_type) == BLKmode) 	{ 	  register tree tempvar 	    = build_decl (VAR_DECL, NULL_TREE, result_type); 	  register tree xop1 = build_modify_expr (tempvar, NOP_EXPR, op1); 	  register tree xop2 = build_modify_expr (tempvar, NOP_EXPR, op2); 	  register tree result = build (COND_EXPR, result_type, 					ifexp, xop1, xop2);  	  layout_decl (tempvar);
comment|/* No way to handle variable-sized objects here. 	     I fear that the entire handling of BLKmode conditional exprs 	     needs to be redone.  */
block|assert (TREE_LITERAL (DECL_SIZE (tempvar))); 	  DECL_RTL (tempvar) 	    = assign_stack_local (DECL_MODE (tempvar), 				  (TREE_INT_CST_LOW (DECL_SIZE (tempvar)) 				   * DECL_SIZE_UNIT (tempvar) 				   + BITS_PER_UNIT - 1) 				  / BITS_PER_UNIT);  	  TREE_VOLATILE (result) 	    = TREE_VOLATILE (ifexp) | TREE_VOLATILE (op1) 	      | TREE_VOLATILE (op2); 	  return build (COMPOUND_EXPR, result_type, result, tempvar); 	}     }
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|ifexp
argument_list|)
condition|)
return|return
operator|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
operator|)
return|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle overloading of the ',' operator when needed.  Otherwise,    this function just builds an expression list.  */
end_comment

begin_function
name|tree
name|build_x_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|rest
init|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|rest
operator|==
name|NULL_TREE
condition|)
return|return
name|build_compound_expr
argument_list|(
name|list
argument_list|)
return|;
name|result
operator|=
name|build_opfncall
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|rest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|build_x_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|TREE_CHAIN
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_compound_expr
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|cleanup_after_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|decl_constant_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since LIST is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
name|rest
operator|=
name|build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is patched out so that sizeof (0, array) is distinguishable from      sizeof array.  */
if|#
directive|if
literal|0
block|if (! TREE_VOLATILE (TREE_VALUE (list)))     return rest;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TREE_VOLATILE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
return|return
name|rest
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids casting nonscalar to the same type"
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/* If there's only one function in the overloaded space,      just take it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|type_unknown_p
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Did we lose?  */
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Reference-to-reference conversion is special.  */
name|value
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|;
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrysome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast discards `volatile' from pointer target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast discards `const' from pointer target type"
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|convert_force
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|expr
condition|)
comment|/* Always produce some operator for an explicit cast,        so we can tell (for -pedantic) that the cast is no lvalue.  */
block|{
name|tree
name|nvalue
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|TREE_LITERAL
argument_list|(
name|nvalue
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|nvalue
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|cleanup_after_call
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.     In C++, if the left hand side of the assignment is a REFERENCE_TYPE,    that reference becomes deferenced down to it base type. */
end_comment

begin_comment
comment|/* Return a reference to the BASE_INDEX part of EXPR.  TYPE is    the type to which BASE_INDEX applies.  */
end_comment

begin_function
specifier|static
name|tree
name|get_base_ref
parameter_list|(
name|type
parameter_list|,
name|base_index
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|base_index
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|base_index
argument_list|)
decl_stmt|;
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
operator|!=
name|integer_zero_node
operator|||
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|base_index
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
operator|=
name|basetype
expr_stmt|;
block|}
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.     C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.     `build_modify_expr_1' implements recursive part of memberwise    assignment operation.  */
end_comment

begin_function
specifier|static
name|tree
name|build_modify_expr_1
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|,
name|basetype_path
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
init|=
name|rhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* must deal with overloading of `operator=' here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|lhstype
operator|=
name|olhstype
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|modifycode
operator|=
name|NOP_EXPR
expr_stmt|;
block|}
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++: The semantics of C++ differ from those of C when an      assignment of an aggregate is desired.  Assignment in C++ is      now defined as memberwise assignment of non-static members      and base class objects.  This rule applies recursively      until a member of a built-in type is found.       Also, we cannot do a bit-wise copy of aggregates which      contain virtual function table pointers.  Those      pointer values must be preserved through the copy.      However, this is handled in expand_expr, and not here.      This is because much better code can be generated at      that stage than this one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|lhstype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform operation on object.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
operator|&&
name|TYPE_HAS_INIT_REF
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_method_call
argument_list|(
name|lhs
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|lhstype
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|basetype_path
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* `operator=' is not an inheritable operator.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|(
name|tree
operator|)
name|NOP_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
name|modifycode
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|||
operator|(
name|modifycode
operator|==
name|INIT_EXPR
operator|&&
name|TYPE_GETS_INIT_REF
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
block|{
name|result
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Perform operation on each member, depth-first, left-right.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|lhstype
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_lhs
decl_stmt|,
name|base_rhs
decl_stmt|;
name|tree
name|new_result
decl_stmt|;
comment|/* Assignments from virtual baseclasses handled elsewhere.  */
if|if
condition|(
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|base_lhs
operator|=
name|get_base_ref
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|base_rhs
operator|=
name|get_base_ref
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|new_result
operator|=
name|build_modify_expr_1
argument_list|(
name|base_lhs
argument_list|,
name|modifycode
argument_list|,
name|base_rhs
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_lhs
argument_list|)
argument_list|,
name|basetype_path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We either get back a compound stmt, or a simple one.  */
if|if
condition|(
name|new_result
operator|&&
name|TREE_CODE
argument_list|(
name|new_result
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|new_result
operator|=
name|build_compound_expr
argument_list|(
name|new_result
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_result
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|elt
operator|=
name|TYPE_FIELDS
argument_list|(
name|lhstype
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|tree
name|vbases
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|elt_lhs
decl_stmt|,
name|elt_rhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|CONST_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|elt
argument_list|)
operator|&&
operator|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|elt_lhs
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|elt_rhs
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|newrhs
argument_list|,
name|elt
argument_list|)
expr_stmt|;
comment|/* It is not always safe to go through `build_modify_expr_1' 		 when performing element-wise copying.  This is because 		 an element may be of ARRAY_TYPE, which will not 		 be properly copied as a naked element.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|basetype_path
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|elt_lhs_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|elt_lhs
argument_list|)
decl_stmt|;
name|tree
name|elt_rhs_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|elt_rhs
argument_list|)
decl_stmt|;
name|elt_lhs_addr
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|elt_lhs_addr
argument_list|)
expr_stmt|;
name|elt_rhs_addr
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|elt_rhs_addr
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr_1
argument_list|(
name|build_indirect_ref
argument_list|(
name|elt_lhs_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|build_indirect_ref
argument_list|(
name|elt_rhs_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|basetype_path
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|elt_lhs
operator|=
name|build_modify_expr_1
argument_list|(
name|elt_lhs
argument_list|,
name|modifycode
argument_list|,
name|elt_rhs
argument_list|,
name|basetype_path
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|elt_lhs
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
return|return
name|build_compound_expr
argument_list|(
name|result
argument_list|)
return|;
comment|/* No fields to move.  */
return|return
name|integer_zero_node
return|;
block|}
else|else
block|{
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|return
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|newrhs
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
init|=
name|rhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle control structure constructs used as "lvalues".  */
if|if
condition|(
operator|!
name|pedantic
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	     except that the RHS goes through a save-expr 	     so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure the code to compute the rhs comes out 	     before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* Case to void to suppress warning 			   from warn_if_unused_value.  */
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* must deal with overloading of `operator=' here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* `operator=' is not an inheritable operator.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|(
name|tree
operator|)
name|NOP_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
else|#
directive|else
comment|/* Treat `operator=' as an inheritable operator.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|tree
name|orig_lhstype
init|=
name|lhstype
decl_stmt|;
while|while
condition|(
operator|!
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|lhstype
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"base classes `%s' and `%s' both have operator ='"
argument_list|,
name|basetype
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lhstype
operator|=
name|basetype
expr_stmt|;
block|}
if|if
condition|(
name|orig_lhstype
operator|!=
name|lhstype
condition|)
block|{
name|lhs
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|lhstype
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|lhstype
argument_list|,
literal|"conversion to private basetype `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|(
name|tree
operator|)
name|NOP_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
name|lhstype
operator|=
name|olhstype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* This case must convert to some sort of lvalue that 	 can participate in a op= operation.  */
name|tree
name|lhs_tmp
init|=
name|lhs
decl_stmt|;
name|tree
name|rhs_tmp
init|=
name|rhs
decl_stmt|;
if|if
condition|(
name|build_default_binary_type_conversion
argument_list|(
name|modifycode
argument_list|,
operator|&
name|lhs_tmp
argument_list|,
operator|&
name|rhs_tmp
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs_tmp
argument_list|)
expr_stmt|;
comment|/* Forget is was ever anything else.  */
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs_tmp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the true type of the lhs and store there;      then cast the result back to the specified type to be the value      of the assignment.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|newrhs
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Static class member?  */
name|tree
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|lhs
operator|=
name|member
expr_stmt|;
else|else
block|{
name|compiler_error
argument_list|(
literal|"invalid static class member"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|tree
name|base
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|member
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|lhs
operator|=
name|build_indirect_ref
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|,
name|base
argument_list|,
name|member
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_assign
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Warn about storing in something that is `const'.  */
comment|/* For C++, don't warn if this is initialization.  */
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|readonly_warning_or_error
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check to see if there is an assignment to `this' */
if|if
condition|(
name|lhs
operator|==
name|current_class_decl
condition|)
block|{
if|if
condition|(
name|flag_this_is_variable
operator|&&
name|current_class_name
operator|!=
name|DECL_ORIGINAL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"assignment to `this' not in constructor or destructor"
argument_list|)
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The TREE_TYPE of RHS may be TYPE_UNKNOWN.  This can happen      when the type of RHS is not yet known, i.e. its type      is inherited from LHS.  */
name|rhs
operator|=
name|require_instantiated_type
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
condition|)
block|{
comment|/* Make modifycode now either a NOP_EXPR or an INIT_EXPR.  */
name|modifycode
operator|=
name|NOP_EXPR
expr_stmt|;
comment|/* Reference-bashing */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|lhstype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|lhs
operator|=
name|tmp
expr_stmt|;
name|olhstype
operator|=
name|lhstype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|newrhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|newrhs
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|newrhs
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|newrhs
argument_list|)
condition|)
name|newrhs
operator|=
name|stabilize_reference
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
comment|/* C++: The semantics of C++ differ from those of C when an      assignment of an aggregate is desired.  Assignment in C++ is      now defined as memberwise assignment of non-static members      and base class objects.  This rule applies recursively      until a member of a built-in type is found.       Also, we cannot do a bit-wise copy of aggregates which      contain virtual function table pointers.  Those      pointer values must be preserved through the copy.      However, this is handled in expand_expr, and not here.      This is because much better code can be generated at      that stage than this one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
operator|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|&&
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|||
operator|(
name|modifycode
operator|==
name|INIT_EXPR
operator|&&
name|TYPE_GETS_INIT_REF
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|lhstype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|get_base_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|lhstype
argument_list|)
decl_stmt|;
name|tree
name|lhs_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|rhs_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|newrhs
argument_list|)
decl_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs_addr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs_addr
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|rhs_addr
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs_addr
argument_list|)
argument_list|)
argument_list|,
name|rhs_addr
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_indirect_ref
argument_list|(
name|rhs_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|elt_lhs
init|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|lhs_addr
argument_list|)
decl_stmt|;
name|tree
name|elt_rhs
init|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|rhs_addr
argument_list|)
decl_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr_1
argument_list|(
name|build_indirect_ref
argument_list|(
name|elt_lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|build_indirect_ref
argument_list|(
name|elt_rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|lhstype
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr_1
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|newrhs
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|lhstype
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|build_compound_expr
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/* If storing in a field that is in actuality a short or narrower than one,      we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
name|newrhs
operator|=
name|convert_for_initialization
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|lhs
argument_list|)
condition|)
name|warning
argument_list|(
literal|"return value from function receives multiple initializations"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|lhs
argument_list|)
operator|=
name|newrhs
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|lhstype
argument_list|,
literal|"assignment not defined for type `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|,
name|NOP_EXPR
argument_list|)
condition|)
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Have to wrap this in RTL_EXPR for two cases: 	     in base or member initialization and if we 	     are a branch of a ?: operator.  Since we 	     can't easily know the latter, just do it always.  */
specifier|extern
name|struct
name|rtx_def
modifier|*
name|get_insns
argument_list|()
decl_stmt|,
modifier|*
name|const0_rtx
decl_stmt|;
name|result
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|expand_vec_init
argument_list|(
name|lhs
argument_list|,
name|lhs
argument_list|,
name|array_type_nelts
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|newrhs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|result
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_elide_constructors
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
comment|/* Can't initialized directly from a CALL_EXPR, since 	     we don't know about what doesn't alias what.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|lhstype
argument_list|)
condition|)
name|newrhs
operator|=
name|cleanup_after_call
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|temp
init|=
name|get_temp_name
argument_list|(
name|lhstype
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|newrhs
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|build_modify_expr
argument_list|(
name|temp
argument_list|,
name|INIT_EXPR
argument_list|,
name|newrhs
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if EXP is not a valid lvalue in this language    even though `lvalue_or_else' would accept it.  */
end_comment

begin_function
name|int
name|language_lvalue_valid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.     C++: attempts to allow `convert' to find conversions involving    implicit type conversion between aggregate and scalar types    as per 8.5.6 of C++ manual.  Does not randomly dereference    pointers to aggregates!  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
init|=
name|datatype
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
init|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|codel
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|codel
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|rhs
return|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
comment|/* This should no longer change types on us.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|rhs
operator|=
name|DECL_INITIAL
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|rhstype
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Arithmetic types all interconvert.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
comment|/* But we should warn if assigning REAL_TYPE to INTEGER_TYPE.  */
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
operator|&&
name|codel
operator|==
name|INTEGER_TYPE
condition|)
name|warning
argument_list|(
literal|"float or double assigned to integer data type"
argument_list|)
expr_stmt|;
comment|/* And we should warn if assigning a negative value to 	 an unsigned variable.  */
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_NEGATED_INT
argument_list|(
name|rhs
argument_list|)
condition|)
name|warning
argument_list|(
literal|"negative value assigned to unsigned quantity"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions involving enums.  */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|)
operator|)
operator|||
operator|(
name|coder
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|)
operator|)
condition|)
block|{
specifier|extern
name|int
name|warn_enum_clash
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|warn_enum_clash
condition|)
block|{
if|if
condition|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
name|coder
operator|==
name|ENUMERAL_TYPE
condition|)
name|message_2_types
argument_list|(
name|warning
argument_list|,
literal|"conversion between incompatible enumeral types `%s' and `%s'"
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
name|warning
argument_list|(
literal|"float or double assigned to enumeral data type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|codel
operator|==
name|REAL_TYPE
condition|)
name|warning
argument_list|(
literal|"enumeral value assigned to real data type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|coder
operator|==
name|INTEGER_TYPE
condition|)
name|warning
argument_list|(
literal|"assignment of integer to enumeral data type"
argument_list|)
expr_stmt|;
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* If both pointers are of aggregate type, then we 	 can give better error messages, and save some work 	 as well.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
name|tree
name|basetype
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
condition|)
name|basetype
operator|=
name|ttl
expr_stmt|;
else|else
name|basetype
operator|=
name|get_base_type
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|basetype
operator|==
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s of non-const * pointer from const *"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s of non-volatile * pointer from volatile *"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
block|}
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"%s between incompatible pointer types"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|virtual_member
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"%s between pointer to members converting across virtual baseclasses"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s of non-const * pointer from const *"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s of non-volatile * pointer from volatile *"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
block|{
comment|/* Normally, pointers to different type codes (other 	     than void) are not compatible, but we perform 	     some type instantiation if that resolves the 	     ambiguity of (X Y::*) and (X *).  */
if|if
condition|(
name|current_class_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|rhs
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
argument_list|,
name|current_class_decl
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|error
argument_list|(
literal|"%s between pointer-to-method and pointer-to-member types"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s between pointer and pointer-to-member types"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|int
name|const_parity
init|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
operator|^
name|TREE_READONLY
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
name|int
name|volatile_parity
init|=
name|TREE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|^
name|TREE_VOLATILE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
name|int
name|unsigned_parity
decl_stmt|;
name|int
name|nptrs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|nptrs
operator|-=
literal|1
expr_stmt|;
name|const_parity
operator||=
name|TREE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_READONLY
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
name|volatile_parity
operator||=
name|TREE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_VOLATILE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
block|}
name|unsigned_parity
operator|=
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|-
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsigned_parity
condition|)
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
condition|)
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
else|else
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
condition|)
block|{
if|if
condition|(
name|const_parity
condition|)
name|warning
argument_list|(
literal|"%s of non-const * pointer from const *"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatile_parity
condition|)
name|warning
argument_list|(
literal|"%s of non-volatile * pointer from volatile *"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsigned_parity
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|"%s of unsigned pointer from signed pointer"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unsigned_parity
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"%s of signed pointer from unsigned pointer"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
comment|/* C++ is not so friendly about converting function and 		 member function pointers as C.  Emit warnings here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
name|lhsbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|rhsbuf
index|[
literal|2048
index|]
decl_stmt|;
name|tree
name|null_name
init|=
name|get_identifier
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|tree
name|lhs
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|null_name
argument_list|,
name|ttl
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|null_name
argument_list|,
name|ttr
argument_list|)
decl_stmt|;
name|fndecl_as_string
argument_list|(
name|lhsbuf
argument_list|,
literal|0
argument_list|,
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fndecl_as_string
argument_list|(
name|rhsbuf
argument_list|,
literal|0
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"conflicting function types in %s:"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"\t`%s' != `%s'"
argument_list|,
name|lhsbuf
argument_list|,
name|rhsbuf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* When does this happen?  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Conversion of a pointer-to-member type to void *.  */
name|rhs
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|rhs
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* When does this happen?  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Conversion of a pointer-to-member type to void *.  */
name|rhs
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|rhs
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%s between incompatible pointer types"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%s of pointer from integer lacks a cast"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|null_pointer_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|"%s of integer from pointer lacks a cast"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* C++ */
elseif|else
if|if
condition|(
name|codel
operator|==
name|ERROR_MARK
operator|||
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* This should no longer happen.  References are initialzed via      `convert_for_initialization'.  They should otherwise be      bashed before coming here.  */
elseif|else
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
name|assert
argument_list|(
name|codel
operator|!=
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
name|error
argument_list|(
literal|"incompatible types in %s"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Convert RHS to be of type TYPE.  If EXP is non-zero,    it is the target of the initialization.    ERRTYPE is a string to use in error messages.     Two major differences between the behavior of    `convert_for_assignment' and `convert_for_initialization'    are that references are bashed in the former, while    copied in the latter, and aggregates are assigned in    the former (operator=) while initialized in the    latter (X(X&)).  */
end_comment

begin_function
name|tree
name|convert_for_initialization
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|flags
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* This is *not* the quick way out!  It is the way to disaster.  */
block|if (type == rhstype)     goto converted;
endif|#
directive|endif
comment|/* We accept references to incomplete types, so we can      return here before checking if RHS is of complete type.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|convert_to_reference
argument_list|(
operator|(
name|exp
condition|?
name|exp
else|:
name|error_mark_node
operator|)
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
return|;
name|rhs
operator|=
name|require_complete_type
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
name|exp
operator|=
name|require_complete_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
block|{
comment|/* This is sufficient to perform initialization.  No need, apparently, 	     to go through X(X&) to do first-cut initialization.  Return through 	     a NEW_EXPR so that we get cleanups if it is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|rhs
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
operator|||
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|rhstype
argument_list|)
operator|&&
name|get_base_type
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
name|exp
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"bitwise copy: `%s' defines operator=()"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|rhstype
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
return|;
return|return
name|rhs
return|;
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"bitwise copy: `%s' defines operator=()"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|converted
label|:
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* Record the contents of OUTPUTS before it is modifed.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Don't do this--it screws up operands expected to be in memory.  */
comment|/* Perform default conversions on all inputs.  */
block|for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), i++)     TREE_VALUE (tail) = default_conversion (TREE_VALUE (tail));
endif|#
directive|endif
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|extern
name|struct
name|rtx_def
modifier|*
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_warning_or_error
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.     C++: upon seeing a `return', we must call destructors on all    variables in scope which had constructors called on them.    This means that if in a destructor, the base class destructors    must be called before returning.     The RETURN statement in C++ has initialization semantics.  */
end_comment

begin_function
name|void
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
specifier|extern
name|struct
name|rtx_def
modifier|*
name|original_result_rtx
decl_stmt|;
specifier|extern
name|tree
name|dtor_label
decl_stmt|,
name|ctor_label
decl_stmt|;
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|tree
name|save_from_destructor
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `volatile' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|retval
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* A non-named return value does not count.  */
specifier|extern
name|tree
name|value_identifier
decl_stmt|;
comment|/* Can't just return from a destructor.  */
if|if
condition|(
name|dtor_label
condition|)
block|{
name|expand_goto
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|retval
operator|=
name|current_class_decl
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|!=
name|NULL_TREE
operator|&&
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|!=
name|value_identifier
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|retval
operator|=
name|result
expr_stmt|;
else|else
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|valtype
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
specifier|extern
name|tree
name|value_identifier
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|value_identifier
condition|)
name|warning
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
block|}
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|valtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|use_temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|retval
operator|==
name|result
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|valtype
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
name|expand_aggr_init
argument_list|(
name|result
argument_list|,
name|retval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save_from_destructor
operator|=
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Watch out for constructors, which "return" aggregates 	     via initialization, but which otherwise "return" a pointer.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|retval
operator|!=
name|current_class_decl
condition|)
block|{
name|error
argument_list|(
literal|"return from a constructor: use `this = ...' instead"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|current_class_decl
expr_stmt|;
block|}
block|}
else|else
block|{
name|retval
operator|=
name|convert_for_initialization
argument_list|(
name|result
argument_list|,
name|valtype
argument_list|,
name|retval
argument_list|,
literal|"return"
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
return|return;
name|save_from_destructor
operator|=
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Add some useful error checking for C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|whats_returned
init|=
name|retval
decl_stmt|;
comment|/* Sort through common things to see what it is 		 we are returning.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|whats_returned
operator|=
name|retval
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NEW_EXPR
condition|)
comment|/* Get the target.  */
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
condition|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TEMP_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"reference to non-lvalue returned"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|whats_returned
argument_list|,
literal|"reference to local variable `%s' returned"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now deal with possible C++ hair: 	 (1) Compute the return value. 	 (2) If there are aggregate values with destructors which 	     must be cleaned up, clean them (taking care 	     not to clobber the return value). 	 (3) If an X(X&) constructor is defined, the return 	     value must be returned via that.  */
comment|/* Keep anybody from thinking that our return value 	 is up for grabs (i.e., later inline function expansion). 	 We cannot use a `save_expr' here, because the 	 return value must be calculated _now_, 	 and wrapping it in a SAVE_EXPR just make it 	 be calculated _once_.  	 We look up the binding contours to see whether there are 	 any cleanups to perform to avoid, where possible, the need 	 to pass the value through a temporary.  This is needed to make 	 tail-recursion work in GCC.  */
comment|/* use_variable (DECL_RTL (result)); */
if|if
condition|(
name|retval
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|any_pending_cleanups
argument_list|()
condition|)
block|{
name|t
operator|=
name|get_temp_regvar
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|use_temp
operator|=
name|obey_regdecls
expr_stmt|;
block|}
else|else
name|t
operator|=
name|retval
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|result
condition|)
block|{
if|if
condition|(
name|original_result_rtx
condition|)
name|store_expr
argument_list|(
name|result
argument_list|,
name|original_result_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctor_label
condition|)
name|expand_goto
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
else|else
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|original_result_rtx
condition|)
block|{
if|if
condition|(
name|t
condition|)
name|expand_assignment
argument_list|(
name|result
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|result
argument_list|,
name|original_result_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|error_mark_node
argument_list|,
name|original_result_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctor_label
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|original_result_rtx
condition|)
name|use_variable
argument_list|(
name|original_result_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_temp
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* One way to clear out cleanups that EXPR might      generate.  Note that this code will really be      dead code, but that is ok--cleanups that were      needed were handled by the magic of `return'.  */
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a C switch statement, testing expression EXP.    Return EXP if it is valid, an error node otherwise.  */
end_comment

begin_function
name|tree
name|c_expand_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|exp
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|INTEGER_TYPE
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|index
decl_stmt|;
name|index
operator|=
name|get_unwidened
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	 because if we did, int_fits_type_p would do the wrong thing 	 when checking case values for being in range, 	 and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|index
expr_stmt|;
block|}
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|exp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

end_unit

