begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Procedure integration for GNU CC.    Copyright (C) 1988 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|,
name|maybepermanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|,
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|stack_slot_list
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x< y) ? x : y)
end_define

begin_function_decl
specifier|extern
name|tree
name|pushdecl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|poplevel
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Default max number of insns a function can have and still be inline.    This is overridden on RISC machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATE_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|INTEGRATE_THRESHOLD
parameter_list|(
name|DECL
parameter_list|)
define|\
value|(8 * (8 + list_length (DECL_ARGUMENTS (DECL)) + 16*TREE_INLINE (DECL)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is the target of the inline function being expanded,    or NULL if there is none.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|inline_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We must take special care not to disrupt life too severely    when performing procedure integration.  One thing that that    involves is not creating illegitimate address which reload    cannot fix.  Since we don't know what the frame pointer is    not capable of (in a machine independent way), we create    a pseudo-frame pointer which will have to do for now.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|before_inline_fp_rtx
decl_stmt|,
name|inline_fp_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert old frame-pointer offsets to new.  Parameters which only    produce values (no addresses, and are never assigned), map directly    to the pseudo-reg of the incoming value.  Parameters that are    assigned to but do not have their address taken are given a fresh    pseudo-register.  Parameters that have their address take are    given a fresh stack-slot.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|parm_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ?? Should this be done here??  It is not right now.    Keep track of whether a given pseudo-register is the sum    of the frame pointer and a const_int (or zero).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fp_addr_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For the local variables of the procdure being integrated that live    on the frame, FRAME_POINTER_DELTA says how much to change their    offsets by, so that they now live in the correct place on the    frame of the function being compiled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fp_delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_rtx_and_substitute,    this is nonzero if we have copied an ASM_OPERANDS.    In that case, it is the original input-operand vector.    Likewise in copy_for_inline.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_rtx_and_substitute,    this is nonzero if we have copied an ASM_OPERANDS.    In that case, it is the copied input-operand vector.    Likewise in copy_for_inline.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, this is the copied constraints vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In save_for_inline, nonzero if past the parm-initialization insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_nonparm_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a copy of an rtx (as needed), substituting pseudo-register,    labels, and frame-pointer offsets as necessary.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|copy_rtx_and_substitute
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Variant, used for memory addresses that are not memory_address_p.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|copy_address
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return the rtx corresponding to a given index in the stack arguments.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|access_parm_map
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_parm_decls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_decl_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|try_fold_cc0
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* We do some simple constant folding optimization.  This optimization    really exists primarily to save time inlining a function.  It    also helps users who ask for inline functions without -O.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|fold_out_const_cc0
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Zero if the current function (whose FUNCTION_DECL is FNDECL)    is safe and reasonable to integrate into other functions.    Nonzero means value is a warning message with a single %s    for the function's name.  */
end_comment

begin_function
name|char
modifier|*
name|function_cannot_inline_p
parameter_list|(
name|fndecl
parameter_list|)
specifier|register
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|max_insns
init|=
name|INTEGRATE_THRESHOLD
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ninsns
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|parms
decl_stmt|;
comment|/* No inlines with varargs.  `grokdeclarator' gives a warning      message about that if `inline' is specified.  This code      it put in to catch the volunteers.  */
if|if
condition|(
name|last
operator|&&
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|!=
name|void_type_node
condition|)
return|return
literal|"varargs function cannot be inline"
return|;
comment|/* If its not even close, don't even look.  */
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
literal|4
operator|*
name|max_insns
condition|)
return|return
literal|"function too large to be inline"
return|;
comment|/* Don't inline functions with large stack usage,      since they can make other recursive functions burn up stack.  */
if|if
condition|(
operator|!
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|get_frame_size
argument_list|()
operator|>
literal|100
condition|)
return|return
literal|"function stack frame for inlining"
return|;
comment|/* We can't inline functions that return structures      the old-fashioned PCC way, copying into a static block.  */
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|flag_pcc_struct_return
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|||
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|"inline functions not supported for this return value type"
return|;
endif|#
directive|endif
comment|/* Don't inline functions which have BLKmode arguments.      Don't inline functions that take the address of        a parameter and do not specify a function prototype.  */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
if|#
directive|if
literal|0
block|return "function with large aggregate parameter cannot be inline";
else|#
directive|else
name|TREE_ADDRESSABLE
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|last
operator|==
name|NULL_TREE
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|parms
argument_list|)
condition|)
return|return
literal|"no prototype, and parameter address used; cannot be inline"
return|;
if|#
directive|if
literal|0
comment|/* If an aggregate is thought of as "in memory" 	 then its components are referred to by narrower memory refs. 	 If the actual parameter is a reg, these refs can't be translated, 	 esp. since copy_rtx_and_substitute doesn't know whether it is 	 reading or writing.  */
block|if ((TREE_CODE (TREE_TYPE (parms)) == RECORD_TYPE 	   || TREE_CODE (TREE_TYPE (parms)) == UNION_TYPE)&& GET_CODE (DECL_RTL (parms)) == MEM) 	return "address of an aggregate parameter is used; cannot be inline";
endif|#
directive|endif
block|}
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
name|max_insns
condition|)
block|{
for|for
control|(
name|ninsns
operator|=
literal|0
operator|,
name|insn
operator|=
name|get_first_nonparm_insn
argument_list|()
init|;
name|insn
operator|&&
name|ninsns
operator|<
name|max_insns
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|ninsns
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ninsns
operator|>=
name|max_insns
condition|)
return|return
literal|"function too large to be inline"
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables used within save_for_inline.  */
end_comment

begin_comment
comment|/* Mapping from old pesudo-register to new pseudo-registers.    The first element of this map is reg_map[FIRST_PSEUDO_REGISTER].    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from old code-labels to new code-labels.    The first element of this map is label_map[min_labelno].    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|label_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from old insn uid's to copied insns.    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|insn_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map pseudo reg number into the PARM_DECL for the parm living in the reg.    Zero for a reg that isn't a parm's home.    Only reg numbers less than max_parm_reg are mapped here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|parmdecl_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map pseudo reg number to equivalent constant.  We cannot in general    substitute constants into parameter pseudo registers, since a    machine descriptions (the Sparc md, maybe others) won't always handle    the resulting insns.  So if an incoming parameter has a constant    equivalent, we record it here, and if the resulting insn is    recognizable, we go with it.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|const_equiv_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should try using a constant equivalent.    Set to zero if constant equivalent resulted in insn which could    not be recognized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|try_use_const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use "iteration numbering" to speedily pull constant values    from registers when testing conditionals.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|const_age_map
decl_stmt|,
name|const_age
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleared before attempting to inline any functions.    Set when const equiv is used.  Used to test whether insn    is safe for md or not.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|used_const_equiv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of first pseudo-register beyond those that are parms.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_parm_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset from arg ptr to the first parm of this inline function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_parm_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On machines that perform a function return with a single    instruction, such as the VAX, these return insns must be    mapped into branch statements.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save any constant pool constants in an insn.  */
end_comment

begin_function_decl
specifier|static
name|void
name|save_constants
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Note when parameter registers are the destination of a SET.  */
end_comment

begin_function_decl
specifier|static
name|void
name|note_modified_parmregs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Copy an rtx for save_for_inline.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|copy_for_inline
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.  */
end_comment

begin_function
name|void
name|save_for_inline
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|extern
name|rtx
modifier|*
name|regno_reg_rtx
decl_stmt|;
comment|/* in emit-rtl.c.  */
extern|extern current_function_args_size;
name|rtx
name|first_insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|copy
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|max_labelno
decl_stmt|,
name|min_labelno
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
comment|/* Make and emit a return-label if we have not already done so.  */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Get some bounds on the labels and registers used.  */
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|max_parm_reg
operator|=
name|max_parm_reg_num
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.       Set TREE_VOLATILE to 0 if the parm is in a register, otherwise 1.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.  */
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parmdecl_map
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|rtx
name|p
init|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|REG
condition|)
block|{
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|p
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|parms
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_VOLATILE
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Replace any constant pool references with the actual constant.  We will      put the constant back in the copy made below.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|save_constants
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The list of DECL_SAVED_INSNS, starts off with a header which      contains the following information:       the first insn of the function (not including the insns that copy      parameters into registers).      the first parameter insn of the function,      the first label used by that function,      the last label used by that function,      the highest register number used for parameters,      the total number of registers used,      the stack slot list,      @@ not yet: and some flags that are used to restore compiler globals.  */
name|head
operator|=
name|gen_inline_header_rtx
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|min_labelno
argument_list|,
name|max_labelno
argument_list|,
name|max_parm_reg
argument_list|,
name|max_reg
argument_list|,
name|current_function_args_size
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* We have now allocated all that needs to be allocated permanently      on the rtx obstack.  Set our high-water mark, so that we      can free the rest of this when the time comes.  */
name|preserve_data
argument_list|()
expr_stmt|;
comment|/* Copy the chain insns of this function.      Install the copied chain as the insns of this function,      for continued compilation;      the original chain is recorded as the DECL_SAVED_INSNS      for inlining future calls.  */
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_insn
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|first_insn
expr_stmt|;
comment|/* Each pseudo-reg in the old insn chain must have a unique rtx in the copy.      Make these new rtx's now, and install them in regno_reg_rtx, so they      will be the official pseudo-reg rtx's for the rest of compilation.  */
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_reg
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|+
operator|(
name|GET_RTX_LENGTH
argument_list|(
name|REG
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|max_reg
operator|-
literal|1
init|;
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|--
control|)
name|reg_map
index|[
name|i
index|]
operator|=
operator|(
name|rtx
operator|)
name|obstack_copy
argument_list|(
operator|&
name|maybepermanent_obstack
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|reg_map
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|regno_reg_rtx
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
operator|(
name|max_reg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Likewise each label rtx must have a unique rtx as its copy.  */
name|label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_map
operator|-=
name|min_labelno
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_labelno
init|;
name|i
operator|<
name|max_labelno
condition|;
name|i
operator|++
control|)
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Record the mapping of old insns to copied insns.  */
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_map
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|in_nonparm_insns
operator|=
literal|0
expr_stmt|;
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Now copy the chain of insns.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_operands_vector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
comment|/* No need to keep these.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
continue|continue;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|JUMP_INSN
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|copy
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|copy
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|copy
operator|=
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|INSN_UID
argument_list|(
name|copy
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|copy
expr_stmt|;
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|last_insn
operator|=
name|copy
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|head
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|parmdecl_map
operator|=
literal|0
expr_stmt|;
name|label_map
operator|=
literal|0
expr_stmt|;
name|reg_map
operator|=
literal|0
expr_stmt|;
name|return_label
operator|=
literal|0
expr_stmt|;
name|set_new_first_and_last_insn
argument_list|(
name|first_insn
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
name|output_constant_pool
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.     Other version.  */
end_comment

begin_function
name|void
name|save_for_outline
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|extern
name|rtx
modifier|*
name|regno_reg_rtx
decl_stmt|;
comment|/* in emit-rtl.c.  */
extern|extern current_function_args_size;
name|rtx
name|first_insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|copy
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|max_labelno
decl_stmt|,
name|min_labelno
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
comment|/* Make and emit a return-label if we have not already done so.  */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Get some bounds on the labels and registers used.  */
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|max_parm_reg
operator|=
name|max_parm_reg_num
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.       Set TREE_VOLATILE to 0 if the parm is in a register, otherwise 1.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.  */
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parmdecl_map
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|rtx
name|p
init|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|REG
condition|)
block|{
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|p
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|parms
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_VOLATILE
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The list of DECL_SAVED_INSNS, starts off with a header which      contains the following information:       the first insn of the function (not including the insns that copy      parameters into registers).      the first parameter insn of the function,      the first label used by that function,      the last label used by that function,      the highest register number used for parameters,      the total number of registers used,      the stack slot list,      @@ not yet: and some flags that are used to restore compiler globals.  */
name|head
operator|=
name|gen_inline_header_rtx
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|min_labelno
argument_list|,
name|max_labelno
argument_list|,
name|max_parm_reg
argument_list|,
name|max_reg
argument_list|,
name|current_function_args_size
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
comment|/* We have now allocated all that needs to be allocated permanently      on the rtx obstack.  Set our high-water mark, so that we      can free the rest of this when the time comes.  */
name|preserve_data
argument_list|()
expr_stmt|;
comment|/* Copy the chain insns of this function.      Install the copied chain as the insns of this function,      for continued compilation;      the original chain is recorded as the DECL_SAVED_INSNS      for inlining future calls.  */
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_insn
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|first_insn
expr_stmt|;
name|in_nonparm_insns
operator|=
literal|0
expr_stmt|;
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Now copy the chain of insns.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_operands_vector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|JUMP_INSN
case|:
name|note_modified_parmregs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|head
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Have to output these, since other functions may refer to them.  */
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
name|output_constant_pool
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* References to the constant pool are replaced by the actual constant     encapsulated with a CONST giving the mode and with RTX_INTEGRATED_P set.     *** Note that the above only works if the address was not manipulated.        If the address was not valid and had to be loaded into a register,        we lose track of the fact that it was in the constant pool, which will        result in either an abort or generating a reference to an undefined        label in the assembler code.  No current machine will run into this, but        this should probably be fixed someday.  */
end_comment

begin_function
specifier|static
name|void
name|save_constants
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|save_constants
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|save_constants
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note (recursively) whether a parameter is modified or not.  */
end_comment

begin_function
specifier|static
name|void
name|note_modified_parmregs
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|again
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|in_nonparm_insns
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Now scan the subexpressions recursively.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|format_ptr
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|note_modified_parmregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format_ptr
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
goto|goto
name|hard
goto|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
if|if
condition|(
name|format_ptr
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
name|note_modified_parmregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format_ptr
index|[
name|i
operator|=
literal|1
index|]
operator|==
literal|'E'
condition|)
goto|goto
name|hard
goto|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
if|if
condition|(
name|format_ptr
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|format_ptr
index|[
name|i
operator|=
literal|0
index|]
operator|==
literal|'E'
condition|)
goto|goto
name|hard
goto|;
return|return;
name|i
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|hard
label|:
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|note_modified_parmregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|note_modified_parmregs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|i
operator|-=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the rtx ORIG recursively, replacing pseudo-regs and labels    according to `reg_map' and `label_map'.     If we find a saved constant pool entry, replace it with the constant.    Since the pool wasn't touched, this should simply restore the old    address.     All other kinds of rtx are copied except those that can never be    changed during compilation.  */
end_comment

begin_function
specifier|static
name|rtx
name|copy_for_inline
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
return|;
case|case
name|CONST
case|:
comment|/* Get constant pool entry for constant in the pool.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands 	 then it contains multiple ASM_OPERANDS rtx's that share operand 3. 	 We must make sure that the copied insn continues to share it.  */
if|if
condition|(
name|orig_asm_operands_vector
operator|==
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|x
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
operator|=
name|copy_asm_operands_vector
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
operator|=
name|copy_asm_constraints_vector
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|5
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|x
argument_list|,
literal|6
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
break|break;
case|case
name|MEM
case|:
comment|/* A MEM is allowed to be shared if its address is constant 	 or is a constant plus one of the special registers.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
if|#
directive|if
literal|0
comment|/* This is turned off because it is possible for 	 unshare_all_rtl to copy the address, into memory that won't be saved. 	 Although the MEM can safely be shared, and won't be copied there, 	 the address itself cannot be shared, and may need to be copied.  */
block|if (GET_CODE (XEXP (x, 0)) == PLUS&& GET_CODE (XEXP (XEXP (x, 0), 0)) == REG&& (REGNO (XEXP (XEXP (x, 0), 0)) == FRAME_POINTER_REGNUM 	      || REGNO (XEXP (XEXP (x, 0), 0)) == ARG_POINTER_REGNUM)&& CONSTANT_ADDRESS_P (XEXP (XEXP (x, 0), 1)))
if|#
directive|if
literal|0
comment|/* This statement was accidentally deleted in the remote past. 	   Reinsert it for 1.37.  Don't take the risk now.  */
block|return x;
endif|#
directive|endif
block|if (GET_CODE (XEXP (x, 0)) == REG&& (REGNO (XEXP (x, 0)) == FRAME_POINTER_REGNUM 		|| REGNO (XEXP (x, 0)) == ARG_POINTER_REGNUM)&& CONSTANT_ADDRESS_P (XEXP (x, 1))) 	return x;
endif|#
directive|endif
comment|/* 0 */
break|break;
case|case
name|LABEL_REF
case|:
block|{
comment|/* Must point to the new insn.  */
return|return
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
return|;
block|}
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
else|else
return|return
name|x
return|;
comment|/* If a parm that gets modified lives in a pseudo-reg, 	 set its TREE_VOLATILE to prevent certain optimizations.  */
case|case
name|SET
case|:
if|if
condition|(
name|in_nonparm_insns
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The insn to load an arg pseudo from a stack slot 	 does not count as modifying it.  */
break|break;
comment|/* Arrange that CONST_INTs always appear as the second operand 	 if they appear, and that `frame_pointer_rtx' or `arg_pointer_rtx' 	 always appear as the first.  */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|)
condition|)
block|{
name|rtx
name|t
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
comment|/* Replace this rtx with a copy of itself.  */
name|x
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|orig
argument_list|,
name|x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|x
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
return|return
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
return|;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_v
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|orig_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
name|XVEC
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function to deal with using constants for kinds of INSNs.    Return zero if trouble arose by using constants.    Return one if not.  Caller must know what to do in either case.  */
end_comment

begin_function
specifier|static
name|int
name|note_integrated
parameter_list|(
name|copy
parameter_list|)
name|rtx
name|copy
decl_stmt|;
block|{
if|if
condition|(
name|used_const_equiv
condition|)
block|{
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|old_optimize
init|=
name|optimize
decl_stmt|;
name|optimize
operator|=
literal|1
expr_stmt|;
name|delete_insn
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|optimize
operator|=
name|old_optimize
expr_stmt|;
name|try_use_const
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|try_use_const
operator|=
literal|1
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Non-zero if we are trying to reduce the amount of debug information output */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_inline_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Integrate the procedure defined by FNDECL.  Note that this function    may wind up calling itself.  Since the static variables are not    reentrant, we do not assign them until after the possibility    or recursion is eliminated.     If IGNORE is nonzero, do not produce a value.    Otherwise store the value in TARGET if it is nonzero and that is convenient.     Value is:    (rtx)-1 if we could not substitute the function    0 if we substituted it and it does not produce a value    else an rtx for where the value is stored.  */
end_comment

begin_function
name|rtx
name|expand_inline_function
parameter_list|(
name|fndecl
parameter_list|,
name|parms
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|,
name|type
parameter_list|,
name|structure_value_addr
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|parms
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|structure_value_addr
decl_stmt|;
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|tree
name|formal
decl_stmt|,
name|actual
decl_stmt|;
name|rtx
name|header
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|insns
init|=
name|FIRST_FUNCTION_INSN
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|max_regno
init|=
name|MAX_REGNUM
argument_list|(
name|header
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|min_labelno
init|=
name|FIRST_LABELNO
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|max_labelno
init|=
name|LAST_LABELNO
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|rtx
modifier|*
name|arg_vec
decl_stmt|;
name|rtx
name|local_return_label
init|=
literal|0
decl_stmt|;
name|rtx
name|follows_call
init|=
literal|0
decl_stmt|;
name|rtx
name|this_struct_value_rtx
init|=
literal|0
decl_stmt|;
comment|/* Hack around non-reentrancy of static variables.  */
name|rtx
modifier|*
name|old_const_equiv_map
init|=
name|const_equiv_map
decl_stmt|;
name|unsigned
modifier|*
name|old_const_age_map
init|=
name|const_age_map
decl_stmt|;
name|unsigned
name|old_const_age
init|=
name|const_age
decl_stmt|;
comment|/* If we need INLINE_FP_RTX, set it up immediately      following this insn.  */
if|if
condition|(
name|max_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nargs
operator|=
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We expect PARMS to have the right length; don't crash if not.  */
if|if
condition|(
name|list_length
argument_list|(
name|parms
argument_list|)
operator|!=
name|nargs
condition|)
return|return
operator|(
name|rtx
operator|)
operator|-
literal|1
return|;
comment|/* Also check that the parms type match.  Since the appropriate      conversions or default promotions have already been applied,      the machine modes should match exactly.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|rtx
operator|)
operator|-
literal|1
return|;
comment|/* If they are block mode, the types should match exactly.          They don't match exactly if TREE_TYPE (FORMAL) == ERROR_MARK_NODE, 	 which could happen if the parameter has incomplete type.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
condition|)
return|return
operator|(
name|rtx
operator|)
operator|-
literal|1
return|;
block|}
name|const_equiv_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|const_equiv_map
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|const_age_map
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|const_age_map
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|try_use_const
operator|=
literal|1
expr_stmt|;
comment|/* Trick: set to large number so that variables set in first      basic block keep their values.  After first label is seen,      we wrap.  */
name|const_age
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Make a binding contour to keep inline cleanups called at      outer function-scope level from looking like they are shadowing      parameter declarations.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a fresh binding contour that we can easily remove.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Get all the actual args as RTL, and store them in ARG_VEC.  */
name|arg_vec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_inline_debug
condition|)
comment|/* Say where this function starts.  */
name|emit_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Actual parameter, already converted to DECL_ARG_TYPE (formal).  */
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
decl_stmt|;
comment|/* Mode of the value supplied.  */
name|enum
name|machine_mode
name|tmode
init|=
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Mode of the variable used within the function.  */
name|enum
name|machine_mode
name|imode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|copy
decl_stmt|;
if|#
directive|if
literal|0
comment|/* PARM_DECL nodes no longer have this.  */
block|emit_note (DECL_SOURCE_FILE (formal), DECL_SOURCE_LINE (formal));
endif|#
directive|endif
comment|/* Make a place to hold the argument value, still in mode TMODE, 	 and put it in COPY.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|formal
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|copy
operator|=
name|assign_stack_local
argument_list|(
name|tmode
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|DECL_MODE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|copy
operator|=
name|change_address
argument_list|(
name|copy
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|arg
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|formal
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|formal
argument_list|)
condition|)
block|{
comment|/* If parm is modified or if it hasn't a pseudo reg, 	     we may not simply substitute the actual value; 	     copy it through a register.  */
name|copy
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|arg
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|tmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We do not use CONSTANT_ADDRESS_P here because 	     the set of cases where that might make a difference 	     are a subset of the cases that arise even when 	     it is a CONSTANT_ADDRESS_P (i.e., fp_delta 	     gets into the act.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
condition|)
block|{
if|#
directive|if
literal|0
block|if (! CONSTANT_P (copy)) 		copy = copy_to_reg (copy); 	      else if (! optimize) 		copy = copy_to_mode_reg (imode, copy);
else|#
directive|else
comment|/*   Sigh.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
condition|)
name|copy
operator|=
name|copy_to_reg
argument_list|(
name|copy
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|formal
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
name|const_equiv_map
index|[
name|regno
index|]
operator|=
name|copy
expr_stmt|;
name|const_age_map
index|[
name|regno
index|]
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|2
expr_stmt|;
block|}
name|copy
operator|=
name|copy_to_mode_reg
argument_list|(
name|imode
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* If passed mode != nominal mode, COPY is now the passed mode. 	 Convert it to the nominal mode (i.e. truncate it).  */
if|if
condition|(
name|tmode
operator|!=
name|imode
condition|)
name|copy
operator|=
name|convert_to_mode
argument_list|(
name|imode
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_vec
index|[
name|i
index|]
operator|=
name|copy
expr_stmt|;
block|}
name|copy_parm_decls
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|arg_vec
argument_list|)
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* clean up stack so that variables might have smaller offsets.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Pass the function the address in which to return a structure value.      Note that a constructor can cause someone to call us with      STRUCTURE_VALUE_ADDR, but the initialization takes place      via the first parameter, rather than the struct return address.  */
if|if
condition|(
name|structure_value_addr
operator|&&
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|struct_value_rtx
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|this_struct_value_rtx
operator|=
name|structure_value_addr
expr_stmt|;
else|else
name|this_struct_value_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Now prepare for copying the insns.      Set up reg_map, parm_map and label_map saying how to translate      the pseudo-registers, stack-parm references and labels when copying.  */
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_map
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|FUNCTION_ARGS_SIZE
argument_list|(
name|header
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parm_map
argument_list|,
operator|(
operator|(
name|FUNCTION_ARGS_SIZE
argument_list|(
name|header
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Note that expand_expr (called above) can clobber first_parm_offset.  */
name|first_parm_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|parm_map
operator|-=
name|first_parm_offset
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
for|for
control|(
name|formal
operator|=
name|decl
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Create an entry in PARM_MAP that says what pseudo register 	     is associated with an address we might compute.  */
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|formal
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* This parameter has a home in the stack.  */
name|parm_map
index|[
name|DECL_OFFSET
argument_list|(
name|formal
argument_list|)
operator|/
name|BITS_PER_WORD
index|]
operator|=
name|arg_vec
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Parameter that was passed in a register; 		 does it have a home on the stack (as a local)?  */
name|rtx
name|frtx
init|=
name|DECL_RTL
argument_list|(
name|formal
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|frtx
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|frtx
operator|=
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|frtx
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|1
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* If there is a separate arg pointer 			 and REG_PARM_STACK_SPACE is defined, 			 parms passed in regs can be copied 			 to slots reached via the arg pointer.  */
if|if
condition|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|1
argument_list|)
operator|==
name|arg_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|frtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|offset
condition|)
name|parm_map
index|[
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|/
name|UNITS_PER_WORD
index|]
operator|=
name|arg_vec
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|frtx
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Create an entry in REG_MAP that says what rtx is associated 	     with a pseudo register from the function being inlined.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|formal
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg_map
index|[
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|formal
argument_list|)
argument_list|)
index|]
operator|=
name|arg_vec
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Make certain that we can accept struct_value_{incoming_rtx,rtx},      and map it.  */
if|if
condition|(
name|this_struct_value_rtx
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
operator|==
name|REG
condition|)
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|this_struct_value_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|struct_value_incoming_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|struct_value_incoming_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
if|#
directive|if
literal|1
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|this_struct_value_rtx
expr_stmt|;
else|#
directive|else
name|parm_map
index|[
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|struct_value_incoming_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
index|]
operator|=
name|this_struct_value_rtx
expr_stmt|;
endif|#
directive|endif
else|else
name|abort
argument_list|()
expr_stmt|;
name|label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_map
operator|-=
name|min_labelno
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_labelno
init|;
name|i
operator|<
name|max_labelno
condition|;
name|i
operator|++
control|)
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* As we copy insns, record the correspondence, so that inter-insn      references can be copied into isomorphic structure.  */
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|INSN_UID
argument_list|(
name|header
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_map
argument_list|,
name|INSN_UID
argument_list|(
name|header
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up a target to translate the inline function's value-register.  */
if|if
condition|(
name|structure_value_addr
operator|!=
literal|0
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
name|inline_target
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Machine mode function was declared to return.   */
name|enum
name|machine_mode
name|departing_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* (Possibly wider) machine mode it actually computes 	 (for the sake of callers that fail to declare it right).  */
name|enum
name|machine_mode
name|arriving_mode
init|=
name|TYPE_MODE
argument_list|(
name|DECL_RESULT_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Don't use MEMs as direct targets because on some machines 	 substituting a MEM for a REG makes invalid insns. 	 Let the combiner substitute the MEM if that is valid.  */
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|departing_mode
condition|)
name|inline_target
operator|=
name|target
expr_stmt|;
else|else
block|{
name|inline_target
operator|=
name|gen_reg_rtx
argument_list|(
name|departing_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|inline_target
expr_stmt|;
block|}
comment|/* If function's value was promoted before return, 	 avoid machine mode mismatch when we substitute INLINE_TARGET. 	 But TARGET is what we will return to the caller.  */
if|if
condition|(
name|arriving_mode
operator|!=
name|departing_mode
condition|)
name|inline_target
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|arriving_mode
argument_list|,
name|inline_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Make space in current function's stack frame      for the stack frame of the inline function.      Adjust all frame-pointer references by the difference      between the offset to this space      and the offset to the equivalent space in the inline      function's frame.      This difference equals the size of preexisting locals.  */
name|fp_delta
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|fp_delta
operator|=
operator|-
name|fp_delta
expr_stmt|;
endif|#
directive|endif
name|before_inline_fp_rtx
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|inline_fp_rtx
operator|=
literal|0
expr_stmt|;
comment|/* Now allocate the space for that to point at.  */
name|assign_stack_local
argument_list|(
name|VOIDmode
argument_list|,
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the insns one by one.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|copy
decl_stmt|,
name|pattern
decl_stmt|,
name|next
init|=
literal|0
decl_stmt|;
name|retry
label|:
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
name|copy_asm_operands_vector
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Special handling for the insn immediately after a CALL_INSN 	     that returned a value: 	     If it does copy the value, we must avoid the usual translation 	     of the return-register into INLINE_TARGET. 	     If it just USEs the value, the inline function expects it to 	     stay in the return-register and be returned, 	     so copy it into INLINE_TARGET.  */
if|if
condition|(
name|follows_call
comment|/* Allow a stack-adjust, handled normally, to come in between 		 the call and the value-copying insn.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|follows_call
argument_list|)
condition|)
comment|/* This insn copies the value: take special care to copy 		   that value to this insn's destination.  */
block|{
name|copy
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
argument_list|,
name|follows_call
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_integrated
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|follows_call
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|USE
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
name|follows_call
argument_list|)
condition|)
comment|/* This insn does nothing but says the value is expected 		   to flow through to the inline function's return-value. 		   Make that happen, then ignore this insn.  */
block|{
name|copy
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|inline_target
argument_list|,
name|follows_call
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_integrated
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|follows_call
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If it does neither, this value must be ignored.  */
name|follows_call
operator|=
literal|0
expr_stmt|;
block|}
name|copy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* The (USE (REG n)) at return from the function should 		 be ignored since we are changing (REG n) into 		 inline_target.  */
if|if
condition|(
operator|!
name|ignore
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Don't emit a (USE (REG n)) of something which 		 is now constant.  */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|const_age
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
operator|||
name|const_age_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|>=
name|const_age
operator|)
condition|)
break|break;
block|}
comment|/* Ignore setting a function value that we don't want to use.  */
if|if
condition|(
name|inline_target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Try to do some quick constant folding here. 	     This will save save execution time of the compiler, 	     as well time and space of the program if done here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
operator|==
name|cc0_rtx
condition|)
name|next
operator|=
name|try_fold_cc0
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
block|{
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_integrated
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* If we are copying an insn that loads a constant, 		 record the constantness.  */
if|if
condition|(
name|note
condition|)
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|&&
operator|(
name|const_equiv_map
index|[
name|regno
index|]
operator|==
literal|0
comment|/* Following clause is a hack to make 				 case work where GNU C++ reassigns 				 a variable to make cse work right.  */
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|const_equiv_map
index|[
name|regno
index|]
argument_list|,
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|const_equiv_map
index|[
name|regno
index|]
operator|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|const_age_map
index|[
name|regno
index|]
operator|=
name|const_age
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Forget everything we thought we knew.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|const_equiv_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|JUMP_INSN
case|:
name|follows_call
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
if|if
condition|(
name|local_return_label
operator|==
literal|0
condition|)
name|local_return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|local_return_label
argument_list|)
expr_stmt|;
break|break;
block|}
name|copy
operator|=
name|emit_jump_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_integrated
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
break|break;
case|case
name|CALL_INSN
case|:
name|copy
operator|=
name|emit_call_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note_integrated
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* Special handling needed for the following INSN depending on 	     whether it copies the value from the fcn return reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|follows_call
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|follows_call
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|const_age
operator|+=
literal|2
expr_stmt|;
name|copy
operator|=
name|emit_label
argument_list|(
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|follows_call
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|const_age
operator|&
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|const_age
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|max_regno
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|const_age_map
index|[
name|i
index|]
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
name|const_age_map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BARRIER
case|:
name|const_age
operator|+=
literal|2
expr_stmt|;
name|copy
operator|=
name|emit_barrier
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
comment|/* It is important to discard function-end and function-beg notes, 	     so we have only one of each in the current function.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_BEG
operator|&&
operator|(
name|flag_inline_debug
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|copy
operator|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|copy
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|used_const_equiv
operator|==
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
if|if
condition|(
name|local_return_label
condition|)
name|emit_label
argument_list|(
name|local_return_label
argument_list|)
expr_stmt|;
comment|/* Don't try substituting constants when making up a DECLs rtl.      That would probably only confuse the debugger, but I don't      know for sure.  */
name|try_use_const
operator|=
literal|0
expr_stmt|;
comment|/* Make copies of the decls of the symbols in the inline function, so that      the copies of the variables get declared in the current function.  */
name|copy_decl_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For safety.  */
if|if
condition|(
name|try_use_const
condition|)
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
comment|/* End the scope containing the copied formal parameter variables.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|reg_map
operator|=
name|NULL
expr_stmt|;
name|label_map
operator|=
name|NULL
expr_stmt|;
name|const_equiv_map
operator|=
name|old_const_equiv_map
expr_stmt|;
name|const_age_map
operator|=
name|old_const_age_map
expr_stmt|;
name|const_age
operator|=
name|old_const_age
expr_stmt|;
if|if
condition|(
name|ignore
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|target
operator|&&
name|target
operator|!=
name|inline_target
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|inline_target
argument_list|)
operator|!=
name|SUBREG
operator|||
name|SUBREG_REG
argument_list|(
name|inline_target
argument_list|)
operator|!=
name|target
operator|)
condition|)
block|{
comment|/* Copy result back to TARGET if TARGET is not INLINE_TARGET.          In general, these should always wind up being the same mode, 	 after SUBREGs, if any, are stripped.  */
name|convert_move
argument_list|(
name|target
argument_list|,
name|inline_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of PARM_DECLs, ARGS, and a vector of RTL homes VEC,    copy each decl into a VAR_DECL, push all of those decls    and give each one the corresponding home.  */
end_comment

begin_function
specifier|static
name|void
name|copy_parm_decls
parameter_list|(
name|args
parameter_list|,
name|vec
parameter_list|)
name|tree
name|args
decl_stmt|;
name|rtx
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|args
operator|,
name|i
operator|=
literal|0
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Prevent warning for shadowing with these.  */
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a LET_STMT node, push decls and levels    so as to construct in the current function a tree of contexts    isomorphic to the one that is given.  */
end_comment

begin_function
specifier|static
name|void
name|copy_decl_tree
parameter_list|(
name|let
parameter_list|,
name|level
parameter_list|)
name|tree
name|let
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|node
decl_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|STMT_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* copy_rtx_and_substitute would call memory_address 	       which would copy the address into a register. 	       Then debugging-output wouldn't know how to handle it.  */
name|DECL_RTL
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|DECL_RTL
argument_list|(
name|d
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TREE_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_EXTERNAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Prevent warning for shadowing with these.  */
name|TREE_INLINE
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|STMT_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|copy_decl_tree
argument_list|(
name|t
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|node
operator|=
name|poplevel
argument_list|(
name|level
operator|>
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|TREE_USED
argument_list|(
name|node
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|let
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.     Handle constants that need to be placed in the constant pool by    calling `force_const_mem'.  */
end_comment

begin_function
specifier|static
name|rtx
name|copy_rtx_and_substitute
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|orig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If a frame-pointer register shows up, then we 	 must `fix' the reference.  If the stack pointer 	 register shows up, it must be part of stack-adjustments 	 (*not* because we eliminated the frame pointer!). 	 Small hard registers are returned as-is.  Pseudo-registers 	 go through their `reg_map'.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Some hard registers are also mapped, 	     but others are not translated.  */
if|if
condition|(
name|reg_map
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
return|return
name|reg_map
index|[
name|regno
index|]
return|;
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
comment|/* This is a reference to the function return value.  If 		 the function doesn't have a return value, error. 		 If it does, it may not be the same mode as `inline_target' 		 because SUBREG is not required for hard regs. 		 If not, adjust mode of inline_target to fit the context.  */
if|if
condition|(
name|inline_target
operator|==
literal|0
condition|)
block|{
comment|/* If there isn't an inline target, so be it. 		     Just fake up a reg--it won't get used 		     for anything important anyway.  */
name|inline_target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|inline_target
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|inline_target
argument_list|)
condition|)
return|return
name|inline_target
return|;
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|inline_target
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
return|return
name|plus_constant
argument_list|(
name|orig
argument_list|,
name|fp_delta
argument_list|)
return|;
return|return
name|orig
return|;
block|}
if|if
condition|(
name|try_use_const
operator|&&
name|const_equiv_map
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|const_age_map
index|[
name|regno
index|]
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|2
condition|)
block|{
name|used_const_equiv
operator|=
literal|1
expr_stmt|;
return|return
name|const_equiv_map
index|[
name|regno
index|]
return|;
block|}
if|if
condition|(
name|reg_map
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
name|reg_map
index|[
name|regno
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|reg_map
index|[
name|regno
index|]
return|;
case|case
name|SUBREG
case|:
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SUBREG is ordinary, but don't make nested SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|copy
argument_list|)
argument_list|)
return|;
comment|/* Don't build a SUBREG of a CONST_INT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|copy
return|;
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy
argument_list|,
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
return|return
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
index|]
return|;
case|case
name|LABEL_REF
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|LABEL_REF
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
return|return
name|copy
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
return|return
name|orig
return|;
case|case
name|CONST
case|:
comment|/* Make new constant pool entry for a constant 	 that was in the pool of the inline function.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands 	 then it contains multiple ASM_OPERANDS rtx's that share operand 3. 	 We must make sure that the copied insn continues to share it.  */
if|if
condition|(
name|orig_asm_operands_vector
operator|==
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|copy
argument_list|,
literal|2
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|3
argument_list|)
operator|=
name|copy_asm_operands_vector
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|4
argument_list|)
operator|=
name|copy_asm_constraints_vector
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|5
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|copy
argument_list|,
literal|6
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
break|break;
case|case
name|CALL
case|:
comment|/* This is given special treatment because the first 	 operand of a CALL is a (MEM ...) which may get 	 forced into a register for cse.  This is undesirable 	 if function-address cse isn't wanted or if we won't do cse.  */
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
operator|!
operator|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
operator|)
condition|)
endif|#
directive|endif
return|return
name|gen_rtx
argument_list|(
name|CALL
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|PLUS
case|:
comment|/* Note: treat the PLUS case as though it might be needed          to be part of an address.  If it turns out that the machine's 	 PLUS insns can handle something more exciting than a ``load 	 effective address'', the optimizer will discover this fact.  */
comment|/* Take care of the easy case quickly.  */
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|copy
init|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|c
init|=
name|INTVAL
argument_list|(
name|copy
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|arg_pointer_rtx
operator|&&
name|c
operator|>=
name|first_parm_offset
condition|)
block|{
name|copy
operator|=
name|access_parm_map
argument_list|(
name|c
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|MEM
condition|)
comment|/* Should not happen, because a parm we need to address 		       should not be living in a register. 		       (expand_inline_function copied it to a stack slot.)  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|SImode
argument_list|,
name|c
operator|+
name|fp_delta
argument_list|)
argument_list|)
return|;
block|}
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|copy
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|fp_delta
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|orig
argument_list|)
operator|||
operator|(
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|orig
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|plus_constant
argument_list|(
name|copy
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|orig
argument_list|)
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|old_used_const_equiv
init|=
name|used_const_equiv
decl_stmt|;
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_const_equiv
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|orig
argument_list|)
condition|)
block|{
name|try_use_const
operator|=
literal|0
expr_stmt|;
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|orig
argument_list|)
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|used_const_equiv
operator||=
name|old_used_const_equiv
expr_stmt|;
block|}
return|return
name|temp
return|;
case|case
name|MULT
case|:
block|{
name|int
name|old_used_const_equiv
init|=
name|used_const_equiv
decl_stmt|;
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_const_equiv
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|try_use_const
operator|=
literal|0
expr_stmt|;
name|used_const_equiv
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|used_const_equiv
operator||=
name|old_used_const_equiv
expr_stmt|;
block|}
return|return
name|temp
return|;
case|case
name|MEM
case|:
comment|/* Take care of easiest case here.  */
name|copy
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|frame_pointer_rtx
operator|||
name|copy
operator|==
name|arg_pointer_rtx
condition|)
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|fp_delta
argument_list|)
argument_list|)
return|;
comment|/* Allow a pushing-address even if that is not valid as an 	 ordinary memory address.  It indicates we are inlining a special 	 push-insn.  These must be copied; otherwise unshare_all_rtl 	 might clobber them to point at temporary rtl of this function.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|PRE_DEC
operator|&&
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|copy
argument_list|)
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|PRE_INC
operator|&&
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|copy
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* If this is some other sort of address that isn't generally valid, 	 break out all the registers referred to.  */
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|copy
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|copy_address
argument_list|(
name|copy
argument_list|)
argument_list|)
return|;
comment|/* There is no easy way to get our mode to `access_parm_map', which 	 may need to know it, so here is most of the PLUS code duplicated.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|,
name|copy
operator|=
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|c
init|=
name|INTVAL
argument_list|(
name|copy
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|arg_pointer_rtx
operator|&&
name|c
operator|>=
name|first_parm_offset
condition|)
return|return
name|access_parm_map
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
return|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|SImode
argument_list|,
name|c
operator|+
name|fp_delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|inline_fp_rtx
operator|==
literal|0
condition|)
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|inline_fp_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|fp_delta
argument_list|)
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|before_inline_fp_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|inline_fp_rtx
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
block|}
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|fp_delta
argument_list|)
expr_stmt|;
name|temp
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|copy
argument_list|)
operator|||
operator|(
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|copy
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|left
init|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|right
init|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|copy
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|temp
operator|=
name|change_address
argument_list|(
name|orig
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Deals with GCC bug for now.  */
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|temp
return|;
case|case
name|RETURN
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|orig_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the value corresponding to an address relative to the arg pointer    at index RELADDRESS.  MODE is the machine mode of the reference.    MODE is used only when the value is a REG.    Pass VOIDmode for MODE when the mode is not known;    in such cases, you should make sure the value is a MEM.  */
end_comment

begin_function
specifier|static
name|rtx
name|access_parm_map
parameter_list|(
name|reladdress
parameter_list|,
name|mode
parameter_list|)
name|int
name|reladdress
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Index in parm_map.  */
name|int
name|index
init|=
name|reladdress
operator|/
name|UNITS_PER_WORD
decl_stmt|;
comment|/* Offset of the data being referenced      from the beginning of the value for that parm.  */
name|int
name|offset
init|=
name|reladdress
operator|%
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|copy
decl_stmt|;
comment|/* If we are referring to the middle of a multiword parm,      find the beginning of that parm.      OFFSET gets the offset of the reference from      the beginning of the parm.  */
while|while
condition|(
name|parm_map
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|first_parm_offset
operator|/
name|UNITS_PER_WORD
condition|)
comment|/* If this abort happens, it means we need 	   to handle "decrementing" INDEX back far 	   enough to start looking among the reg parms 	   instead of the stack parms.  What a mess!  */
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
name|copy
operator|=
name|parm_map
index|[
name|index
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Subtract from OFFSET the offset of where      the actual (non-BLKmode) parm value would start.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|offset
operator|-=
operator|(
name|UNITS_PER_WORD
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* For memory ref, adjust it by the desired offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|change_address
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
return|return
name|copy
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|SUBREG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* A REG cannot be offset by bytes, so use a subreg      (which is possible only in certain cases).  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|word
decl_stmt|;
comment|/* Crash if the portion of the arg wanted 	 is not the least significant. 	 Functions with refs to other parts of a 	 parameter should not be inline-- 	 see function_cannot_inline_p. */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|offset
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|word
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
condition|)
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|copy
argument_list|)
operator|,
name|copy
operator|=
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
condition|)
name|copy
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|copy
argument_list|,
name|word
argument_list|)
return|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like copy_rtx_and_substitute but produces different output, suitable    for an ideosyncractic address that isn't memory_address_p.    The output resembles the input except that REGs and MEMs are replaced    with new psuedo registers.  All the "real work" is done in separate    insns which set up the values of these new registers.  */
end_comment

begin_function
specifier|static
name|rtx
name|copy_address
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|orig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|orig
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|orig
argument_list|)
return|;
return|return
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|fp_delta
argument_list|)
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
condition|)
return|return
name|plus_constant
argument_list|(
name|orig
argument_list|,
name|fp_delta
argument_list|)
return|;
break|break;
case|case
name|MEM
case|:
return|return
name|copy_to_reg
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
case|case
name|LABEL_REF
case|:
return|return
name|copy_rtx_and_substitute
argument_list|(
name|orig
argument_list|)
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
return|return
name|orig
return|;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the constant equivalent of X.  If X is a manifest    constant, it is returned.  If X is a register, we check    to see if we happen to know its value as a constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|const_equiv
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|const_equiv_map
index|[
name|regno
index|]
operator|&&
name|const_age_map
index|[
name|regno
index|]
operator|>=
name|const_age
condition|)
return|return
name|const_equiv_map
index|[
name|regno
index|]
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Attempt to simplify INSN while copying it from an inline fn,    assuming it is a SET that sets CC0.     If we simplify it, we emit the appropriate insns and return    the last insn that we have handled (since we may handle the insn    that follows INSN as well as INSN itself).     Otherwise we do nothing and return zero.  */
end_comment

begin_function
specifier|static
name|rtx
name|try_fold_cc0
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|cnst
init|=
name|copy_rtx_and_substitute
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|copy
decl_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|cnst
argument_list|)
condition|)
comment|/* Constant equivlancies are with old, not new rtl.  */
name|cnst
operator|=
name|const_equiv
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnst
comment|/* @@ Cautious: Don't know how many of these tests we need.  */
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
operator|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|pat
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|2
condition|)
block|{
name|rtx
name|cnst2
decl_stmt|;
name|rtx
name|cond
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|(
name|cnst2
operator|=
name|const_equiv
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|(
name|cnst2
operator|=
name|const_equiv
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|copy
operator|=
name|fold_out_const_cc0
argument_list|(
name|cond
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cnst
argument_list|,
name|cnst2
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
comment|/* We will branch unconditionally to 		     the label specified by COPY. 		     Eliminate dead code by running down the 		     list of insn until we see a CODE_LABEL. 		     If the CODE_LABEL is the one specified 		     by COPY, we win, and can delete all code 		     up to (but not necessarily including) 		     that label.  Otherwise only win a little: 		     emit the branch insn, and continue expanding.  */
name|rtx
name|tmp
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|tmp
argument_list|)
index|]
operator|==
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Big win.  */
return|return
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Small win.  Emit the unconditional branch, 			 followed by a BARRIER, so that jump optimization 			 will know what to do.  */
name|emit_jump
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|copy
operator|==
name|pc_rtx
condition|)
block|{
comment|/* Do not take the branch, just fall through. 		     Jump optimize should handle the elimination of 		     dead code if appropriate.  */
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If (COND_RTX CNST1 CNST2) yield a result we can treat    as being constant, return THEN_RTX if the result is always    non-zero, and return ELSE_RTX otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|fold_out_const_cc0
parameter_list|(
name|cond_rtx
parameter_list|,
name|then_rtx
parameter_list|,
name|else_rtx
parameter_list|,
name|cnst1
parameter_list|,
name|cnst2
parameter_list|)
name|rtx
name|cond_rtx
decl_stmt|,
name|then_rtx
decl_stmt|,
name|else_rtx
decl_stmt|;
name|rtx
name|cnst1
decl_stmt|,
name|cnst2
decl_stmt|;
block|{
name|int
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|int
name|int1
init|=
name|GET_CODE
argument_list|(
name|cnst1
argument_list|)
operator|==
name|CONST_INT
decl_stmt|;
name|int
name|int2
init|=
name|GET_CODE
argument_list|(
name|cnst2
argument_list|)
operator|==
name|CONST_INT
decl_stmt|;
if|if
condition|(
name|int1
condition|)
name|value1
operator|=
name|INTVAL
argument_list|(
name|cnst1
argument_list|)
expr_stmt|;
else|else
name|value1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|int2
condition|)
name|value2
operator|=
name|INTVAL
argument_list|(
name|cnst2
argument_list|)
expr_stmt|;
else|else
name|value2
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond_rtx
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
name|value1
operator|!=
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
operator|||
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
if|if
condition|(
name|int1
operator|==
literal|0
operator|&&
name|int2
operator|==
literal|0
condition|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|cnst1
argument_list|,
name|cnst2
argument_list|)
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
break|break;
case|case
name|EQ
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
name|value1
operator|==
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
operator|||
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|int1
operator|==
literal|0
operator|&&
name|int2
operator|==
literal|0
condition|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|cnst1
argument_list|,
name|cnst2
argument_list|)
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
name|value1
operator|>=
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
name|value1
operator|>
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
name|value1
operator|<=
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
name|value1
operator|<
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|value1
operator|>=
operator|(
name|unsigned
operator|)
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|value1
operator|>
operator|(
name|unsigned
operator|)
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|value1
operator|<=
operator|(
name|unsigned
operator|)
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|int1
operator|&&
name|int2
condition|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|value1
operator|<
operator|(
name|unsigned
operator|)
name|value2
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
else|else
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|then_rtx
argument_list|)
return|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
return|return
name|copy_rtx_and_substitute
argument_list|(
name|else_rtx
argument_list|)
return|;
break|break;
block|}
comment|/* Could not hack it.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any CONST expressions with RTX_INTEGRATED_P are present in X,    they should be in the constant pool.    Run force_const_mem to put them there.  */
end_comment

begin_function
specifier|static
name|void
name|restore_constants
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|restore_constants
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|restore_constants
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the assembly language code for the function FNDECL    from its DECL_SAVED_INSNS.  Used for inline functions that are output    at end of compilation instead of where they came in the source.  */
end_comment

begin_function
name|void
name|output_inline_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|head
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|last
decl_stmt|;
specifier|extern
name|rtx
name|stack_slot_list
decl_stmt|;
name|temporary_allocation
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
comment|/* This call is only used to initialize global variables.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Set stack frame size.  */
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|restore_reg_data
argument_list|(
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|XEXP
argument_list|(
name|head
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* There is no need to output a return label again.  */
name|return_label
operator|=
literal|0
expr_stmt|;
name|expand_function_end
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find last insn and rebuild the constant pool.  */
for|for
control|(
name|last
operator|=
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
comment|/* No need to restore these constants again.  */
block|if (GET_CODE (last) == INSN || GET_CODE (last) == JUMP_INSN 	  || GET_CODE (last) == CALL_INSN) 	restore_constants (PATTERN (last));
endif|#
directive|endif
block|}
name|set_new_first_and_last_insn
argument_list|(
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Compile this function all the way down to assembly code.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
name|permanent_allocation
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_escape
end_escape

begin_comment
comment|/* Hashing of rtxs so that we don't make duplicates.    The entry point is `rtx_hash_canon'.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain    of these structures.  */
end_comment

begin_comment
unit|struct rtx_hash {   struct rtx_hash *next;
comment|/* Next structure in the bucket.  */
end_comment

begin_comment
unit|int hashcode;
comment|/* Hash code of this type.  */
end_comment

begin_comment
unit|rtx x;
comment|/* The rtx recorded here.  */
end_comment

begin_comment
unit|};
comment|/* Now here is the hash table.  This works exactly the same way    that types are hashed in tree.c, except this is for rtxs.  */
end_comment

begin_define
define|#
directive|define
name|RTX_HASH_SIZE
value|199
end_define

begin_comment
unit|struct rtx_hash *rtx_hash_table[RTX_HASH_SIZE];
comment|/* Here is how primitive or already-canonicalized types' hash    codes are made.  */
end_comment

begin_define
define|#
directive|define
name|RTX_HASH
parameter_list|(
name|RTX
parameter_list|)
value|(RTX)
end_define

begin_comment
comment|/* Look in the type hash table for a type isomorphic to RTX.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_if
unit|tree rtx_hash_lookup (hashcode, x)      int hashcode;      tree x; {   register struct rtx_hash *h;   for (h = rtx_hash_table[hashcode % RTX_HASH_SIZE]; h; h = h->next)     if (h->hashcode == hashcode&& GET_CODE (h->x) == GET_CODE (x)&& GET_MODE (h->x) == GET_MODE (x)
if|#
directive|if
literal|0
end_if

begin_endif
unit|&& h->x->jump == x->jump&& h->x->call == x->call&& h->x->unchanging == x->unchanging&& h->x->volatil == x->volatil&& h->x->in_struct == x->in_struct&& h->x->used == x->used&& h->x->integrated == x->integrated
endif|#
directive|endif
end_endif

begin_comment
unit|)       { 	int i, j; 	int len = GET_RTX_LENGTH (GET_CODE (x)); 	char *fmt = GET_RTX_FORMAT (GET_CODE (x));  	for (i = 0; i< len; i++) 	  switch (fmt[i]) 	    { 	    case '0': 	      break;  	    case 'e': 	    case 'u': 	    case 's': 	    case 'S': 	      if (XEXP (h->x, i) != XEXP (x, i)) 		goto no_dice; 	      break;  	    case 'E': 	      if (XVECLEN (h->x, i) != XVECLEN (x, i)) 		goto no_dice; 	      for (j = 0; j< XVECLEN (x, i); j++) 		if (XVECEXP (h->x, i, j) != XVECEXP (x, i, j)) 		  goto no_dice; 	      break;  	    case 'i': 	    case 'n': 	      if (INTVAL (XEXP (h->x, i)) != INTVAL (XEXP (x, i))) 		goto no_dice;  	    default: 	      abort (); 	    }
comment|/* Everything matched.  */
end_comment

begin_comment
unit|return h->x;
comment|/* Try more.  */
end_comment

begin_comment
unit|no_dice: 	;       }
comment|/* Nothing matched.  */
end_comment

begin_comment
unit|return 0; }
comment|/* Add an entry to the rtx-hash-table    for a type RTX whose hash code is HASHCODE.  */
end_comment

begin_comment
unit|void rtx_hash_add (hashcode, x)      int hashcode;      tree x; {   register struct rtx_hash *h;    h = (struct rtx_hash *) oballoc (sizeof (struct rtx_hash));   h->hashcode = hashcode;   h->x = x;   h->next = rtx_hash_table[hashcode % RTX_HASH_SIZE];   rtx_hash_table[hashcode % RTX_HASH_SIZE] = h; }
comment|/* Given RTX, and HASHCODE its hash code, return the canonical    object for an identical rtx if one already exists.    Otherwise, return RTX, and record it as the canonical object    if it is a permanent object.     To use this function, first create a rtx of the sort you want.    Then compute its hash code from the fields of the rtx that    make it different from other similar rtxs.    Then call this function and use the value.    This function frees the rtx you pass in if it is a duplicate.  */
end_comment

begin_comment
comment|/* Set to 1 to debug without canonicalization.  Never set by program.  */
end_comment

begin_comment
unit|int debug_no_rtx_hash = 0;  tree rtx_hash_canon (hashcode, x)      int hashcode;      tree x; {   tree x1;    if (debug_no_rtx_hash)     return x;    x1 = rtx_hash_lookup (hashcode, x);   if (x1 != 0)     {       struct obstack *o = maybepermanent_obstack;       obstack_free (o, x);       return x1;     }
comment|/* If this is a new type, record it for later reuse.  */
end_comment

begin_endif
unit|rtx_hash_add (hashcode, x);    return x; }
endif|#
directive|endif
end_endif

end_unit

