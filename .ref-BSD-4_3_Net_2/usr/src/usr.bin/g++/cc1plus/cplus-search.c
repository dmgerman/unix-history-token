begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* For expand_asm_operands.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_search
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack used to bridge from one function context to another.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|bridge_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|obstack
parameter_list|,
name|tp
parameter_list|,
name|size
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|void
modifier|*
name|tp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|lookup_field_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_define
define|#
directive|define
name|pop_search_level
value|pop_stack_level
end_define

begin_escape
end_escape

begin_comment
comment|/* Search memoization.  */
end_comment

begin_struct
struct|struct
name|type_level
block|{
name|struct
name|stack_level
name|base
decl_stmt|;
comment|/* First object allocated in obstack of entries.  */
name|char
modifier|*
name|entries
decl_stmt|;
comment|/* Number of types memoized in this context.  */
name|int
name|len
decl_stmt|;
comment|/* Type being memoized; save this if we are saving      memoized contexts.  */
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack used for memoizing member and member function lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|type_obstack
decl_stmt|,
name|type_obstack_entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|type_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_vptr_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make things that look like tree nodes, but allocate them    on type_obstack_entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_tree_node_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|my_tree_cons
argument_list|()
decl_stmt|,
name|my_build_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_memoize_lookups
decl_stmt|,
name|flag_save_memoized_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_memoized_entry_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fast_finds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_adds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_fast_rejects
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fields_searched
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables to help save memoization contexts.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|prev_type_memoized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|prev_type_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of type memoziation context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|push_type_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|type_level
name|tem
decl_stmt|;
name|tem
operator|.
name|base
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|entries
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|tem
operator|.
name|type
operator|=
name|NULL_TREE
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of type memoziation context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|pop_type_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|type_level
modifier|*
name|stack
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
name|stack
operator|->
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|pop_stack_level
argument_list|(
name|stack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make something that looks like a TREE_LIST, but    do it on the type_obstack_entries obstack.  */
end_comment

begin_function
specifier|static
name|tree
name|my_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_UID
argument_list|(
name|p
argument_list|)
operator|=
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|TREE_LIST
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
operator|=
name|purpose
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_string
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_UID
argument_list|(
name|p
argument_list|)
operator|=
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|p
argument_list|)
operator|=
name|str
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|p
argument_list|)
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|my_copy_node
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|type_obstack_entries
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|TREE_UID
argument_list|(
name|t
argument_list|)
operator|=
operator|++
name|my_tree_node_counter
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memoizing machinery to make searches for multiple inheritance    reasonably efficient.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZE_HASHSIZE
value|8
end_define

begin_typedef
typedef|typedef
struct|struct
name|memoized_entry
block|{
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|tree
name|data_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
name|tree
name|function_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
block|}
typedef|*
name|ME
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MEMOIZED_CHAIN
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->chain)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_UID
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->uid)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->data_members[INDEX])
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FNFIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->function_members[INDEX])
end_define

begin_define
define|#
directive|define
name|MEMOIZED_HASH_FN
parameter_list|(
name|NODE
parameter_list|)
value|(TREE_UID (NODE)&(MEMOIZE_HASHSIZE - 1))
end_define

begin_function
specifier|static
name|struct
name|memoized_entry
modifier|*
name|my_new_memoized_entry
parameter_list|(
name|chain
parameter_list|)
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
block|{
name|struct
name|memoized_entry
modifier|*
name|p
init|=
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
expr_stmt|;
name|MEMOIZED_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
name|MEMOIZED_UID
argument_list|(
name|p
argument_list|)
operator|=
operator|++
name|my_memoized_entry_counter
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* When a new function or class context is entered, we build    a table of types which have been searched for members.    The table is an array (obstack) of types.  When a type is    entered into the obstack, its CLASSTYPE_MTABLE_ENTRY    field is set to point to a new record, of type struct memoized_entry.     A non-NULL TREE_TYPE of the entry contains a visibility error message.     The slots for the data members are arrays of tree nodes.    These tree nodes are lists, with the TREE_PURPOSE    of this list the known member name, and the TREE_VALUE    as the FIELD_DECL for the member.     For member functions, the TREE_PURPOSE is again the    name of the member functions for that class,    and the TREE_VALUE of the list is a pairs    whose TREE_PURPOSE is a member functions of this name,    and whose TREE_VALUE is a list of known argument lists this    member function has been called with.  The TREE_TYPE of the pair,    if non-NULL, is an error message to print.  */
end_comment

begin_comment
comment|/* Tell search machinery that we are entering a new context, and    to update tables appropriately.     TYPE is the type of the context we are entering, which can    be NULL_TREE if we are not in a class's scope.     USE_OLD, if nonzero tries to use previous context.  */
end_comment

begin_function
name|void
name|push_memoized_context
parameter_list|(
name|type
parameter_list|,
name|use_old
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|prev_type_stack
condition|)
block|{
if|if
condition|(
name|use_old
operator|&&
name|prev_type_memoized
operator|==
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_contexts_saved
operator|++
expr_stmt|;
endif|#
directive|endif
name|type_stack
operator|=
name|prev_type_stack
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, need to pop old stack here.  */
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|prev_type_stack
argument_list|)
expr_stmt|;
name|prev_type_memoized
operator|=
literal|0
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
block|}
name|type_stack
operator|=
name|push_type_level
argument_list|(
name|type_stack
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell search machinery that we have left a context.    We do not currently save these contexts for later use.    If we wanted to, we could not use pop_search_level, since    poping that level allows the data we have collected to    be clobbered; a stack of obstacks would be needed.  */
end_comment

begin_macro
name|pop_memoized_context
argument_list|(
argument|use_old
argument_list|)
end_macro

begin_decl_stmt
name|int
name|use_old
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
init|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_save_memoized_contexts
condition|)
name|use_old
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|use_old
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|prev_type_stack
operator|=
name|type_stack
expr_stmt|;
name|prev_type_memoized
operator|=
name|type_stack
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
name|MEMOIZED_CHAIN
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_old
condition|)
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|type_stack
argument_list|)
expr_stmt|;
else|else
name|type_stack
operator|=
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|type_stack
operator|->
name|base
operator|.
name|prev
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Some simple list processing predicates.  */
end_comment

begin_comment
comment|/* Check whether TYPE is immediately derived from PARENT.    Return actual base information if so.  Otherwise, return 0.  */
end_comment

begin_function
name|tree
name|get_base_type_1
parameter_list|(
name|parent
parameter_list|,
name|type
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|parent
condition|)
return|return
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is derived from PARENT.    Return the actual base information if so.  Otherwise return 0.    If PROTECT is 1, then emit an error message if access to    a public field of PARENT would be private.    If PROTECT is 2, then emit an error message if    TYPE is derived from PARENT via private visibility rules.    If PROTECT is 3, then immediately private baseclass is ok,    but deeper than that, if private, emit error message.  */
end_comment

begin_function
name|tree
name|get_base_type
parameter_list|(
name|parent
parameter_list|,
name|type
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|xtype
init|=
name|type
decl_stmt|;
name|tree
name|otype
decl_stmt|;
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|is_private
init|=
literal|0
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|friends
init|=
name|current_class_type
condition|?
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_get_base_type
operator|++
expr_stmt|;
endif|#
directive|endif
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CLASSTYPE_MARKED5
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|via_private
init|=
name|is_private
operator|||
operator|!
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|via_private
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|protect
operator|==
literal|0
condition|)
name|via_private
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|protect
operator|==
literal|1
operator|&&
name|type
operator|==
name|current_class_type
condition|)
comment|/* The immediate base class of the class we are in 		 does let its public members through.  */
name|via_private
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NOJJG
elseif|else
if|if
condition|(
name|protect
operator|&&
name|friends
operator|!=
name|NULL_TREE
operator|&&
name|type
operator|==
name|xtype
operator|&&
name|value_member
argument_list|(
name|current_class_type
argument_list|,
name|friends
argument_list|)
condition|)
comment|/* Friend types of the most derived type have access 		 to its baseclass pointers.  */
name|via_private
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|CLASSTYPE_MARKED5
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|otype
operator|=
name|type
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|via_private
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|protect
operator|&&
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|parent
argument_list|,
literal|"type `%s' is ambiguous base class for type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|xtype
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"(base class for types `%s' and `%s')"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|otype
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|dont_queue
label|:
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|type
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|is_private
operator|=
operator|(
name|int
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|parent
condition|)
block|{
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|type
expr_stmt|;
name|rval_private
operator|=
name|is_private
expr_stmt|;
block|}
goto|goto
name|dont_queue
goto|;
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLASSTYPE_MARKED5
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
block|{
if|if
condition|(
name|protect
operator|==
literal|3
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|xtype
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|parent
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|xtype
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
comment|/* It's ok, since it's immedate.  */
return|return
name|rval
return|;
block|}
name|error
argument_list|(
literal|"type `%s' is derived from private `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|xtype
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Return the number of levels between type PARENT and type TYPE,    following the leftmost path to PARENT.  If PARENT is its own main    type variant, then if PARENT appears in different places from TYPE's    point of view, the leftmost PARENT will be the one chosen.     Return -1 if TYPE is not derived from PARENT.    Return -2 if PARENT is an ambiguous base class of TYPE.    Return -3 if PARENT is private to TYPE, and protect is non-zero.     If PATH_PTR is non-NULL, then also build the list of types    from PARENT to TYPE, with TREE_VIA_VIRUAL and TREE_VIA_PUBLIC    set.  */
end_comment

begin_expr_stmt
name|get_base_distance
argument_list|(
name|parent
argument_list|,
name|type
argument_list|,
name|protect
argument_list|,
name|path_ptr
argument_list|)
specifier|register
name|tree
name|parent
operator|,
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|protect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|path_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|is_private
init|=
literal|0
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|basetypes
decl_stmt|;
name|tree
name|friends
init|=
name|current_class_type
condition|?
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|int
name|use_leftmost
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parent
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|parent
argument_list|)
condition|)
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|use_leftmost
operator|=
operator|(
name|parent
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|basetypes
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
operator|==
name|type
condition|)
block|{
comment|/* If the distance is 0, then we don't really need 	 a path pointer, but we shouldn't let garbage go back.  */
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|basetypes
expr_stmt|;
return|return
literal|0
return|;
block|}
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CLASSTYPE_MARKED5
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|int
name|via_private
init|=
name|is_private
operator|||
operator|!
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|via_private
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|protect
operator|==
literal|0
condition|)
name|via_private
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 13 Jan, 1990: I guess this is turned off because 	       `get_base_type' will emit a more eloquent message 	       if a message desired [--Michael].  */
comment|/* The immediate base class of the class we are in 	       does let its public members through.  */
block|else if (type == current_class_type) 	      via_private = 0; 	    else if (protect&& friends != NULL_TREE&& type == xtype&& value_member (current_class_type, friends))
comment|/* Friend types of the most derived type have access 		 to its baseclass pointers.  */
block|via_private = 0;
endif|#
directive|endif
name|CLASSTYPE_MARKED5
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|via_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
block|{
name|btypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
block|}
name|tail
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|depth
operator|=
operator|(
name|int
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
operator|+
literal|1
expr_stmt|;
name|is_private
operator|=
operator|(
name|int
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|parent
operator|||
operator|(
name|use_leftmost
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|parent
operator|)
condition|)
block|{
name|rval
operator|=
name|depth
expr_stmt|;
name|rval_private
operator|=
name|is_private
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
name|int
name|increment
init|=
name|path_ptr
condition|?
literal|4
else|:
literal|3
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLASSTYPE_MARKED5
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tp
operator|+=
name|increment
expr_stmt|;
block|}
comment|/* Now, guarantee that we are following the leftmost        path in the chain.  */
if|if
condition|(
name|use_leftmost
operator|&&
name|rval
operator|>
literal|0
operator|&&
operator|(
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
comment|/* Reduce all types yet to be fully processed into 	   the base type we are looking for, or NULL_TREE.  */
for|for
control|(
name|tp
operator|=
name|search_stack
operator|->
name|first
init|;
name|tp
operator|<
name|search_tail
condition|;
name|tp
operator|+=
name|increment
control|)
block|{
name|tree
modifier|*
name|sub_tp
decl_stmt|,
name|sub_path_ptr
decl_stmt|;
name|int
name|sub_rval
decl_stmt|;
comment|/* Don't chase down more right-most paths.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
operator|*
name|tp
argument_list|)
operator|||
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
operator|>
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
comment|/* Don't hassle with duplicates.  */
if|if
condition|(
operator|*
name|tp
operator|==
name|type
condition|)
goto|goto
name|skip
goto|;
for|for
control|(
name|sub_tp
operator|=
name|search_stack
operator|->
name|first
init|;
name|sub_tp
operator|<
name|tp
condition|;
name|sub_tp
operator|+=
name|increment
control|)
if|if
condition|(
operator|*
name|tp
operator|==
operator|*
name|sub_tp
condition|)
goto|goto
name|skip
goto|;
comment|/* Find this type's TYPE basetype, if it has one.  */
name|sub_rval
operator|=
name|get_base_distance
argument_list|(
name|parent
argument_list|,
operator|*
name|tp
argument_list|,
literal|0
argument_list|,
operator|&
name|sub_path_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_rval
operator|==
operator|-
literal|1
condition|)
operator|*
name|tp
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|path_ptr
operator|&&
name|TREE_CHAIN
argument_list|(
name|tp
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|tree
name|last
decl_stmt|;
name|tree
name|next_to_last
init|=
name|sub_path_ptr
decl_stmt|;
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|next_to_last
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|next_to_last
argument_list|)
argument_list|)
condition|)
name|next_to_last
operator|=
name|TREE_CHAIN
argument_list|(
name|next_to_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_to_last
operator|==
name|sub_path_ptr
condition|)
block|{
name|sub_path_ptr
operator|=
name|copy_node
argument_list|(
name|sub_path_ptr
argument_list|)
expr_stmt|;
name|last
operator|=
name|sub_path_ptr
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|copy_node
argument_list|(
name|TREE_CHAIN
argument_list|(
name|next_to_last
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|next_to_last
argument_list|)
operator|=
name|last
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|tp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|TREE_VALUE
argument_list|(
name|sub_path_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|tp
index|[
literal|3
index|]
operator|=
name|sub_path_ptr
expr_stmt|;
block|}
name|skip
label|:
block|{}
block|}
comment|/* For all the types which reduce to TYPE, choose 	   the leftmost non-virtual one of them.  */
for|for
control|(
name|tp
operator|=
name|search_stack
operator|->
name|first
init|;
name|tp
operator|<
name|search_tail
condition|;
name|tp
operator|+=
name|increment
control|)
block|{
if|if
condition|(
operator|*
name|tp
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
operator|<
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
name|type
operator|=
operator|*
name|tp
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|basetypes
operator|=
name|tp
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
condition|)
name|rval_private
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
return|return
operator|-
literal|3
return|;
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|basetypes
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance lattice    specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return the FIELD_DECL.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller    must figure out whether it has a visible path to this field.    (Since it is only one level, this is reasonable.)  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_ANON_UNION_ELEM
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
return|return
name|field
return|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|_vptr_name
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Compute the visibility of FIELD.  This is done by computing    the visibility available to each type in BASETYPES (which comes    as a list of [via_public/basetype] in reverse order, namely base    class before derived class).  The first one which defines a    visibility defines the visibility for the field.  Otherwise, the    visibility of the field is that which occurs normally.     Uses global variables CURRENT_CLASS_TYPE and    CURRENT_FUNCTION_DECL to use friend relationships    if necessary.     This will be static when lookup_fnfield comes into this file.  */
end_comment

begin_define
define|#
directive|define
name|PUBLIC_RETURN
value|do { TREE_FIELD_PUBLIC (field) = 1; return visibility_public; } while (0)
end_define

begin_define
define|#
directive|define
name|PROTECTED_RETURN
value|do { TREE_FIELD_PROTECTED (field) = 1; return visibility_protected; } while (0)
end_define

begin_define
define|#
directive|define
name|PRIVATE_RETURN
value|do { TREE_FIELD_PRIVATE (field) = 1; return visibility_private; } while (0)
end_define

begin_function
name|enum
name|visibility_type
name|compute_visibility
parameter_list|(
name|basetypes
parameter_list|,
name|field
parameter_list|)
name|tree
name|basetypes
decl_stmt|,
name|field
decl_stmt|;
block|{
name|enum
name|visibility_type
name|visibility
init|=
name|visibility_public
decl_stmt|;
name|tree
name|types
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|context
init|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* Virtual function tables are never private.      But we should know that we are looking for this,      and not even try to hide it.  */
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
return|return
name|visibility_public
return|;
comment|/* Make these special cases fast.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
if|if
condition|(
name|TREE_FIELD_PUBLIC
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|visibility_public
return|;
if|if
condition|(
name|TREE_FIELD_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|visibility_protected
return|;
if|if
condition|(
name|TREE_FIELD_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|visibility_private
return|;
block|}
comment|/* Member function manipulating its own members.  */
if|if
condition|(
name|current_class_type
operator|==
name|context
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Member found immediately within object.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetypes
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* At object's top level, public members are public.  */
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Friend function manipulating members it gets (for being a friend).  */
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|current_function_decl
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Inner than that, without special visibility,  	   protected members are ok if type of object is current_class_type 	   is derived therefrom.  This means that if the type of the object 	   is a base type for our current class type, we cannot access 	   protected members.  	   private members are not ok.  */
if|if
condition|(
name|current_class_type
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|current_class_type
operator|||
operator|(
name|type
operator|=
name|get_base_type
argument_list|(
name|current_class_type
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
else|else
name|PROTECTED_RETURN
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Friend function manipulating members it gets (for being a friend).  */
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|current_function_decl
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* must reverse more than one element */
name|basetypes
operator|=
name|nreverse
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|types
operator|=
name|basetypes
expr_stmt|;
while|while
condition|(
name|types
condition|)
block|{
name|tree
name|member
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
expr_stmt|;
name|member
operator|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
name|visibility
operator|=
operator|(
expr|enum
name|visibility_type
operator|)
name|TREE_VALUE
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_public
operator|||
name|is_friend
argument_list|(
name|type
argument_list|,
name|current_function_decl
argument_list|)
operator|||
operator|(
name|visibility
operator|==
name|visibility_protected
operator|&&
name|current_class_type
operator|&&
name|get_base_type
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Friends inherit the visibility of the class they inherit from.  */
if|if
condition|(
name|is_friend
argument_list|(
name|type
argument_list|,
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|context
condition|)
block|{
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|#
directive|if
literal|0
comment|/* This short-cut is too short.  */
block|if (visibility == visibility_public) 	    goto ret;
endif|#
directive|endif
comment|/* else, may be a friend of a deeper base class */
block|}
if|if
condition|(
name|type
operator|==
name|context
condition|)
break|break;
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* If the next type was not VIA_PUBLIC, then fields of all 	 remaining class past that one are private.  */
if|if
condition|(
name|types
operator|&&
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|types
argument_list|)
condition|)
name|visibility
operator|=
name|visibility_private
expr_stmt|;
block|}
comment|/* No special visibilities apply.  Use normal rules.      No assignment needed for BASETYPEs here from the nreverse.      This is because we use it only for information about the      path to the base.  The code earlier dealt with what      happens when we are at the base level.  */
if|if
condition|(
name|visibility
operator|==
name|visibility_public
condition|)
block|{
name|basetypes
operator|=
name|nreverse
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* Used to check if the current class type was derived from 	     the type that contains the field.  This is wrong for 	     multiple inheritance because is gives one class reference 	     to protected members via another classes protected path. 	     I.e., if A; B1 : A; B2 : A;  Then B1 and B2 can access 	     their own members which are protected in A, but not 	     those same members in one another.  */
if|if
condition|(
if|#
directive|if
literal|1
name|current_class_type
operator|&&
name|get_base_type
argument_list|(
argument|context
argument_list|,
argument|current_class_type
argument_list|,
literal|0
argument_list|)
else|#
directive|else
name|current_class_type
operator|&&
name|value_member
argument_list|(
name|current_class_type
argument_list|,
name|basetypes
argument_list|)
endif|#
directive|endif
condition|)
name|PUBLIC_RETURN
expr_stmt|;
name|PROTECTED_RETURN
expr_stmt|;
block|}
name|PUBLIC_RETURN
expr_stmt|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_private
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|nreverse
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|PRIVATE_RETURN
expr_stmt|;
block|}
comment|/* See if the field isn't protected.  */
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|tree
name|test
decl_stmt|;
if|#
directive|if
literal|0
block|test = get_base_type (type, current_class_type, 0);
else|#
directive|else
name|test
operator|=
name|value_member
argument_list|(
name|current_class_type
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nreverse
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
condition|)
name|PUBLIC_RETURN
expr_stmt|;
name|PROTECTED_RETURN
expr_stmt|;
block|}
comment|/* See if the field isn't a public member of 	 a private base class.  */
name|visibility
operator|=
name|visibility_public
expr_stmt|;
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
while|while
condition|(
name|types
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
name|visibility
operator|=
name|visibility_private
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|visibility
operator|=
name|visibility_private
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
operator|==
name|context
condition|)
block|{
name|visibility
operator|=
name|visibility_public
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
label|:
name|nreverse
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_public
condition|)
name|TREE_FIELD_PUBLIC
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
name|TREE_FIELD_PROTECTED
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|TREE_FIELD_PRIVATE
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|visibility
return|;
block|}
end_function

begin_comment
comment|/* Make an entry in the memoized table for type TYPE    that the entry for NAME is FIELD.  */
end_comment

begin_function
name|tree
name|make_memoized_table_entry
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|function_p
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
name|int
name|function_p
decl_stmt|;
block|{
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|entry
decl_stmt|,
modifier|*
name|prev_entry
decl_stmt|;
name|memoized_adds
index|[
name|function_p
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|type_obstack
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|=
name|my_new_memoized_entry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|type_stack
operator|->
name|len
operator|*
literal|2
operator|>=
name|type_stack
operator|->
name|base
operator|.
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|function_p
condition|)
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|entry
operator|=
name|my_tree_cons
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
operator|*
name|prev_entry
argument_list|)
expr_stmt|;
operator|*
name|prev_entry
operator|=
name|entry
expr_stmt|;
comment|/* Don't know the error message to give yet.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
name|tree
name|lookup_field
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|basetypes
decl_stmt|;
name|enum
name|visibility_type
name|this_v
init|=
name|visibility_default
decl_stmt|;
name|tree
name|entry
decl_stmt|;
name|enum
name|visibility_type
name|own_visibility
init|=
name|visibility_default
decl_stmt|;
name|int
name|vbase_name_p
init|=
name|VBASE_NAME_P
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* Things for memoization.  */
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for visibility.  */
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|basetypes
operator|=
name|xbasetype
operator|,
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
else|else
name|basetypes
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|xbasetype
argument_list|)
operator|,
name|basetype
operator|=
name|xbasetype
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
else|else
name|memoized_fast_finds
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_memoize_lookups
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|lookup_field_1
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|flag_memoize_lookups
operator|||
name|protect
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
operator||
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|)
name|this_v
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
literal|"enum `%s' is a private value of class `%s'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"enum `%s' is a protected value of class `%s'"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
literal|"member `%s' is a private member of class `%s'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"member `%s' is a protected member of class `%s'"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
comment|/* This depends on behavior of lookup_field_1!  */
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Let entry know there is no problem with this access.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* And since everything is ok, bear the 		 cost of generating correct code.  */
block|if (DECL_OFFSET (TYPE_NAME (basetype)) != 0 		  || TREE_VIA_VIRTUAL (basetype)) 		{ 		  rval = my_copy_node (rval); 		  DECL_FIELD_CONTEXT (rval) = basetype; 		}
endif|#
directive|endif
block|}
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if ((DECL_OFFSET (TYPE_NAME (basetype)) != 0 		|| TREE_VIA_VIRTUAL (basetype))&& ! (errstr&& protect)) 	{ 	  rval = my_copy_node (rval); 	  DECL_FIELD_CONTEXT (rval) = basetype; 	}
endif|#
directive|endif
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetypes
argument_list|)
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CLASSTYPE_MARKED2
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|type
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact legal.  */
if|if
condition|(
name|rval
condition|)
block|{
comment|/* Just another way of finding the same member.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|rval
argument_list|)
operator|==
name|type
condition|)
block|{
name|enum
name|visibility_type
name|new_v
init|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|rval
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|new_v
condition|)
name|errstr
operator|=
literal|"conflicting visibilities to member `%s'"
expr_stmt|;
block|}
comment|/* Same baseclass, different places in the lattice.  */
elseif|else
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|rval
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|errstr
operator|=
literal|"member `%s' belongs to distinct base classes `%s'"
expr_stmt|;
else|else
block|{
name|tree
name|nval
init|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nval
operator|&&
name|get_base_type
argument_list|(
name|type
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|rval
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We found it in other than a baseclass of RVAL's.  */
name|errstr
operator|=
literal|"request for member `%s' is ambiguous"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|entry
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
break|break;
block|}
else|else
block|{
name|rval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|#
directive|if
literal|0
block|if (DECL_OFFSET (TYPE_NAME (type)) != 0 		  || TREE_VIA_VIRTUAL (type)) 		{ 		  rval = my_copy_node (rval); 		  DECL_FIELD_CONTEXT (rval) = type; 		}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|||
name|protect
condition|)
name|this_v
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
comment|/* These may look ambiguous, but they really are not.  */
if|if
condition|(
name|vbase_name_p
condition|)
break|break;
block|}
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
comment|/* If this FIELD_DECL defines its own visibility, deal with that.  */
if|if
condition|(
name|rval
operator|&&
name|errstr
operator|==
literal|0
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|rval
argument_list|)
operator|&&
operator|(
name|protect
operator|||
name|entry
operator|)
condition|)
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
comment|/* If is possible for one of the derived types on the 	       path to have defined special visibility for this 	       field.  Look for such declarations and report an 	       error if a conflict is found.  */
name|enum
name|visibility_type
name|new_v
decl_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|visibility_default
condition|)
name|new_v
operator|=
name|compute_visibility
argument_list|(
operator|*
name|tp
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|visibility_default
operator|&&
name|new_v
operator|!=
name|this_v
condition|)
block|{
name|errstr
operator|=
literal|"conflicting visibilities to member `%s'"
expr_stmt|;
name|this_v
operator|=
name|visibility_default
expr_stmt|;
block|}
name|own_visibility
operator|=
name|new_v
expr_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
name|CLASSTYPE_MARKED2
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|own_visibility
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
literal|"member `%s' declared private"
expr_stmt|;
elseif|else
if|if
condition|(
name|own_visibility
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"member `%s' declared protected"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|errstr
operator|=
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%s' is private"
else|:
literal|"member `%s' is from private base class"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
condition|)
name|errstr
operator|=
literal|"member `%s' is protected"
expr_stmt|;
block|}
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|methods
operator|==
literal|0
condition|)
name|methods
operator|++
expr_stmt|;
while|while
condition|(
name|methods
operator|!=
name|end
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
operator|==
name|name
condition|)
break|break;
name|methods
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|!=
name|end
condition|)
return|return
name|methods
operator|-
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a list of member functions FIELDS (which are implicitly    named TREE_PURPOSE (FIELDS), and come from base type    DECL_FIELD_CONTEXT (TREE_VALUE (FIELDS))), attempt to find the    actual method which can accept (using conversions) PARMS.    The types of PARMS are already computed in PARMTYPES.  */
end_comment

begin_function
name|tree
name|lookup_fnfield
parameter_list|(
name|fields
parameter_list|,
name|parms
parameter_list|,
name|parmtypes
parameter_list|)
name|tree
name|fields
decl_stmt|,
name|parms
decl_stmt|,
name|parmtypes
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Starting from BASETYPE, return a TREE_BASELINK-like object    which gives the following information (in a list):     TREE_TYPE: list of basetypes needed to get to...    TREE_VALUE: list of all functions in of given type    which have name NAME.     No visibility information is computed by this function,    other then to adorn the list of basetypes with    TREE_VIA_PUBLIC.     If FIND_AMBIGUOUS is non-zero, then if we find two ways to get    to the same member function, both those ways are found,    and the caller must know what to do about this.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|basetypes
parameter_list|,
name|name
parameter_list|,
name|find_ambiguous
parameter_list|)
name|tree
name|basetypes
decl_stmt|,
name|name
decl_stmt|;
name|int
name|find_ambiguous
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|,
name|rvals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|entry
decl_stmt|;
comment|/* For now, don't try this.  */
name|int
name|protect
init|=
name|find_ambiguous
decl_stmt|;
comment|/* Things for memoization.  */
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for visibility.  */
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
comment|/* Want to return this, but we must make sure 		 that visibility information is consistent.  */
name|tree
name|baselink
init|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|tree
name|memoized_basetypes
init|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|tree
name|these_basetypes
init|=
name|basetypes
decl_stmt|;
while|while
condition|(
name|memoized_basetypes
operator|&&
name|these_basetypes
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|memoized_basetypes
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|these_basetypes
argument_list|)
condition|)
break|break;
name|memoized_basetypes
operator|=
name|TREE_CHAIN
argument_list|(
name|memoized_basetypes
argument_list|)
expr_stmt|;
name|these_basetypes
operator|=
name|TREE_CHAIN
argument_list|(
name|these_basetypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memoized_basetypes
operator|==
name|these_basetypes
condition|)
block|{
name|memoized_fast_finds
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
comment|/* else, we must re-find this field by hand.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|basetypes
argument_list|,
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|baselink
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_memoize_lookups
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|lookup_fnfields_1
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetypes
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|basetype
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rvals
return|;
block|}
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetypes
argument_list|)
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CLASSTYPE_MARKED2
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|type
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact legal.  */
if|if
condition|(
name|rval
condition|)
block|{
name|tree
name|context
init|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|rval
argument_list|)
decl_stmt|;
comment|/* Just another way of finding the same member.  */
if|if
condition|(
name|context
operator|==
name|type
condition|)
empty_stmt|;
comment|/* Same baseclass, maybe different places in the lattice.  */
elseif|else
if|if
condition|(
name|context
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rvals
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetypes
argument_list|)
condition|)
empty_stmt|;
else|else
name|errstr
operator|=
literal|"member `%s' belongs to virtual and non-virtual baseclasses `%s'"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetypes
argument_list|)
condition|)
name|errstr
operator|=
literal|"member `%s' belongs to virtual and non-virtual baseclasses `%s'"
expr_stmt|;
else|else
name|errstr
operator|=
literal|"member `%s' belongs to MI-distinct base classes `%s'"
expr_stmt|;
block|}
else|else
block|{
name|int
name|index
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|get_base_type
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We found it in other than a baseclass of RVAL's.  */
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetypes
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
argument_list|,
name|rvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|entry
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|find_ambiguous
condition|)
block|{
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|index
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetypes
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
name|CLASSTYPE_MARKED2
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rvals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BREADTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Search a multiple inheritance hierarchy by breadth-first search.     TYPE is an aggregate type, possibly in a multiple-inheritance hierarchy.    TESTFN is a function, which, if true, means that our condition has been met,    and its return value should be returned.    QFN, if non-NULL, is a predicate dictating whether the type should    even be queued.  */
end_comment

begin_decl_stmt
name|int
name|breadth_first_search
argument_list|(
name|type
argument_list|,
name|testfn
argument_list|,
name|qfn
argument_list|)
name|tree
name|type
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|testfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qfn
operator|==
literal|0
operator|||
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
condition|)
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|obstack_int_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|rval
operator|=
call|(
modifier|*
name|testfn
call|)
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
break|break;
name|type
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|tree
name|type
init|=
operator|*
name|tp
operator|++
decl_stmt|;
name|int
name|i
init|=
call|(
name|int
call|)
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
decl_stmt|;
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Functions to use in breadth first searches.  */
end_comment

begin_typedef
typedef|typedef
name|tree
function_decl|(
modifier|*
name|pft
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|pfi
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_function
name|int
name|tree_needs_constructor_p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|i
operator|==
literal|0
condition|?
name|type
else|:
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
return|return
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|declarator
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_virtuals_named_this
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|i
operator|==
literal|0
condition|?
name|type
else|:
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|0
operator|||
name|fields
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Get to the function decls, and return the first virtual function      with this name, if there is one.  */
while|while
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
for|for
control|(
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|fields
return|;
name|fields
operator|=
name|next_baselink
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_virtual_destructor
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|type
operator|=
name|i
operator|==
literal|0
condition|?
name|type
else|:
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tree_has_any_destructor_p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
return|;
return|return
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a class type TYPE, and a function decl FNDECL,    look for the first function the TYPE's heirarchy which    FNDECL could match as a virtual function.     DTORP is nonzero if we are looking for a destructor.  Destructors    need special treatment because they do not match by name.  */
end_comment

begin_function
name|tree
name|get_first_matching_virtual
parameter_list|(
name|type
parameter_list|,
name|fndecl
parameter_list|,
name|dtorp
parameter_list|)
name|tree
name|type
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|dtorp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Breadth first search routines start searching basetypes      of TYPE, so we must perform first ply of search here.  */
if|if
condition|(
name|dtorp
condition|)
block|{
if|if
condition|(
name|tree_has_any_destructor_p
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
condition|)
name|tmp
operator|=
name|get_virtual_destructor
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
name|tmp
operator|=
operator|(
name|tree
operator|)
name|breadth_first_search
argument_list|(
name|type
argument_list|,
operator|(
name|pfi
operator|)
name|get_virtual_destructor
argument_list|,
name|tree_has_any_destructor_p
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|tree
name|drettype
decl_stmt|,
name|dtypes
decl_stmt|,
name|btypes
decl_stmt|,
name|instptr_type
decl_stmt|;
name|tree
name|basetype
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|baselink
decl_stmt|,
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|DECL_ORIGINAL_NAME
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|dtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|instptr_type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|instptr_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|dtypes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|baselink
operator|=
name|get_virtuals_named_this
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
for|for
control|(
name|tmp
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
name|btypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instptr_type
operator|==
name|NULL_TREE
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* Caller knows to give error in this case.  */
return|return
name|tmp
return|;
if|if
condition|(
operator|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|btypes
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TREE_READONLY
argument_list|(
name|instptr_type
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|dtypes
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"conflicting return type specified for virtual function `%s'"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* If this is ambiguous, we will warn about it later.  */
if|if
condition|(
name|best
condition|)
block|{
if|if
condition|(
name|get_base_distance
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|best
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|best
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|best
operator|==
name|NULL_TREE
operator|&&
name|warn_overloaded_virtual
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"conficting specification deriving virtual function `%s'"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
return|return
name|best
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type TYPE.    This information is cached, and so must be built on a    non-temporary obstack.  */
end_comment

begin_function
name|tree
name|get_abstract_virtuals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* For each layer of base class (i.e., the first base class, and each      virtual base class from that one), modify the virtual function table      of the derived class to contain the new virtual function.      A class has as many vfields as it has virtual base classes (total).  */
name|tree
name|vfields
decl_stmt|,
name|vbases
decl_stmt|,
name|base
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|fcontext
init|=
name|vfield
condition|?
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|type
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
name|int
name|normal
decl_stmt|;
comment|/* Find the right base class for this derived class, call it BASE.  */
name|base
operator|=
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|type
condition|)
continue|continue;
comment|/* We call this case NORMAL iff this virtual function table 	 pointer field has its storage reserved in this class. 	 This is normally the case without virtual baseclasses 	 or off-center multiple baseclasses.  */
name|normal
operator|=
operator|(
name|base
operator|==
name|fcontext
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|normal
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|assoc
init|=
name|assoc_value
argument_list|(
name|base
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tmp
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ASSOC_VIRTUALS
argument_list|(
name|vbases
argument_list|)
condition|)
empty_stmt|;
continue|continue;
name|base
operator|=
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|abstract_virtuals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For the type TYPE, return a list of member functions available from    base classes with name NAME.  The TREE_VALUE of the list is a chain of    member functions with name NAME.  The TREE_PURPOSE of the list is a    basetype, or a list of base types (in reverse order) which were    traversed to reach the chain of member functions.  If we reach a base    type which provides a member function of name NAME, and which has at    most one base type itself, then we can terminate the search.  */
end_comment

begin_function
name|tree
name|get_baselinks
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|hash_tree_cons
parameter_list|()
function_decl|;
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|,
name|index
decl_stmt|;
name|tree
name|rval
init|=
literal|0
decl_stmt|,
name|nval
init|=
literal|0
decl_stmt|;
name|tree
name|basetypes
init|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|btypes
operator|=
name|hash_tree_cons
argument_list|(
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|dont_queue
label|:
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|type
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|index
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rval
operator|=
name|hash_tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|basetypes
argument_list|,
name|nval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|dont_queue
goto|;
block|}
block|}
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|next_baselink
parameter_list|(
name|baselink
parameter_list|)
name|tree
name|baselink
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|baselink
operator|=
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
comment|/* @@ does not yet add previous base types.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|baselink
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|baselink
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Assign unique numbers to _CLASSTYPE members of the lattice    specified by TYPE.  The root nodes are marked first; the nodes    are marked depth-fisrt, left-right.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Matrix implementing a relation from CLASSTYPE X CLASSTYPE => INT.    Relation yields 1 if C1<= C2, 0 otherwise.  */
end_comment

begin_typedef
typedef|typedef
name|char
name|mi_boolean
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|mi_boolean
modifier|*
name|mi_matrix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type for which this matrix is defined.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|mi_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the matrix for indexing purposes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mi_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return nonzero if class C2 derives from class C1.  */
end_comment

begin_define
define|#
directive|define
name|DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(CLASSTYPE_CID (C1)-1))[CLASSTYPE_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|DERIVES_FROM_STAR
parameter_list|(
name|C
parameter_list|)
define|\
value|(mi_matrix+(CLASSTYPE_CID (C)-1))
end_define

begin_comment
comment|/* The main function which implements depth first search.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
name|tree
name|type
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
if|if
condition|(
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|dfs_walk
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
block|}
name|fn
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Predicate functions which serve for dfs_walk.  */
end_comment

begin_function
specifier|static
name|int
name|numberedp
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_CID
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unnumberedp
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_CID
argument_list|(
name|type
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|markedp
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_markedp
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarkedp
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarkedp
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked2p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED2
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked2p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED2
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked2p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED2
argument_list|(
name|type
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked2p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED2
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked3p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked3p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED3
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked3p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked3p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED3
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked4p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked4p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED4
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked4p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked4p
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|CLASSTYPE_MARKED4
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_search_slot_nonempty_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_comment
comment|/* Assign each type within the lattice a number which is unique    in the lattice.  The first number assigned is 1.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_number
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_CID
argument_list|(
name|type
argument_list|)
operator|=
operator|++
name|cid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unnumber
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_CID
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark2
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED2
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark2
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED2
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark3
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark3
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark4
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark4
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark12
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark34
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|dfs_clear_search_slot
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|tree
name|vbase_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_decl
decl_stmt|,
name|vbase_decl_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_init_result
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dfs_find_vbases
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vbase
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* ??? ASSOC_VALUE and TREE_VALUE must be the same for this to work.  */
name|tree
name|assoc
init|=
name|value_member
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|vbase
argument_list|)
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|vbase_decl_ptr
argument_list|,
name|ASSOC_OFFSET
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_init_vbase_pointers
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|path
decl_stmt|,
name|this_vbase_ptr
decl_stmt|;
name|int
name|distance
decl_stmt|;
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return;
name|distance
operator|=
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|vbase_decl
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
break|break;
name|distance
operator|-=
literal|1
expr_stmt|;
name|path
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|distance
operator|>
literal|0
condition|)
name|this_vbase_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|this_vbase_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|type
argument_list|,
name|vbase_decl_ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
operator|&&
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ref
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|this_vbase_ptr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|vbase_init_result
operator|=
name|tree_cons
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vbase_init_result
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes this needs to clear both 3 and 4.  Other times,    just 4, but optimizer should make both with equal efficiency    (though it does not currently).  */
end_comment

begin_function
specifier|static
name|void
name|dfs_clear_vbase_slots
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|init_vbase_pointers
parameter_list|(
name|type
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl_ptr
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|flag_this_is_variable
operator|=
literal|0
expr_stmt|;
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|decl_ptr
expr_stmt|;
name|vbase_decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbase_init_result
operator|=
name|NULL_TREE
expr_stmt|;
ifdef|#
directive|ifdef
name|sparc
name|expand_asm_operands
argument_list|(
name|build_string
argument_list|(
literal|32
argument_list|,
literal|"! start of vbase initialization"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked3p
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_init_vbase_pointers
argument_list|,
name|marked3p
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked4p
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
return|return
name|vbase_init_result
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build a COMPOUND_EXPR which when expanded will generate the code    needed to initialize all the virtual function table slots of all    the virtual baseclasses.  FOR_TYPE is the type which determines the    virtual baseclasses to use; TYPE is the type of the object to which    the initialization applies.  TRUE_EXP is the true object we are    initializing, and DECL_PTR is the pointer to the sub-object we    are initializing.     CTOR_P is non-zero if the caller of this function is a top-level    constructor.  It is zero when called from a destructor.  When    non-zero, we can use computed offsets to store the vtables.  When    zero, we must store new vtables through virtual baseclass pointers.  */
end_comment

begin_function
name|tree
name|build_vbase_vtables_init
parameter_list|(
name|for_type
parameter_list|,
name|type
parameter_list|,
name|true_exp
parameter_list|,
name|decl_ptr
parameter_list|,
name|ctor_p
parameter_list|)
name|tree
name|for_type
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|decl_ptr
decl_stmt|;
name|int
name|ctor_p
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|vtable_init_result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|for_type
argument_list|)
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|true_exp
condition|?
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|true_exp
argument_list|,
literal|0
argument_list|)
else|:
name|decl_ptr
expr_stmt|;
name|vbase_decl
operator|=
name|true_exp
condition|?
name|true_exp
else|:
name|build_indirect_ref
argument_list|(
name|decl_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sparc
name|expand_asm_operands
argument_list|(
name|build_string
argument_list|(
literal|32
argument_list|,
literal|"! start of vtable initialization"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flag_this_is_variable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctor_p
condition|)
comment|/* This is an object of type IN_TYPE,  */
name|dfs_walk
argument_list|(
name|for_type
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked4p
argument_list|)
expr_stmt|;
comment|/* Initialized with vtables of type TYPE.  */
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|basetype
init|=
name|get_base_type
argument_list|(
name|ASSOC_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* This time through, not every class's vtable 	     is going to be initialized.  That is, we only initialize 	     the "last" vtable pointer.  */
name|assert
argument_list|(
name|basetype
operator|==
name|ASSOC_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|ASSOC_VALUE
argument_list|(
name|vbases
argument_list|)
condition|)
block|{
name|tree
name|addr
decl_stmt|;
name|tree
name|vtbl
init|=
name|ASSOC_VTABLE
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtbl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctor_p
operator|==
literal|0
condition|)
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|vbase_decl_ptr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|tree
name|ref
init|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|basetype
argument_list|)
decl_stmt|;
name|init
operator|=
name|convert_force
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|vtable_init_result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vtable_init_result
argument_list|)
expr_stmt|;
block|}
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked4p
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
if|if
condition|(
name|vtable_init_result
condition|)
return|return
name|build_compound_expr
argument_list|(
name|vtable_init_result
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|clear_search_slots
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_clear_search_slot
argument_list|,
name|dfs_search_slot_nonempty_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|these_vbase_types
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
if|if
condition|(
name|these_vbase_types
condition|)
block|{
while|while
condition|(
name|these_vbase_types
condition|)
block|{
name|basetype
operator|=
name|ASSOC_TYPE
argument_list|(
name|these_vbase_types
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|vbase_types
operator|=
name|make_assoc
argument_list|(
name|integer_zero_node
argument_list|,
name|basetype
argument_list|,
name|CLASS_ASSOC_VTABLE
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
expr_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|these_vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|these_vbase_types
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|vbase_types
operator|=
name|make_assoc
argument_list|(
name|integer_zero_node
argument_list|,
name|basetype
argument_list|,
name|CLASS_ASSOC_VTABLE
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
expr_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|basetype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some virtual baseclasses might be virtual baseclasses for    other virtual baseclasses.  We sort the virtual baseclasses    topologically: in the list returned, the first virtual base    classes have no virtual baseclasses themselves, and any entry    on the list has no dependency on virtual base classes later in the    list.  */
end_comment

begin_function
name|tree
name|get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|ordered_vbase_types
init|=
name|NULL_TREE
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|vbase_types
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_get_vbase_types
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbase_types
condition|)
block|{
comment|/* Now sort these types.  This is essentially a bubble merge.  */
comment|/* Farm out virtual baseclasses which have no marked ancestors.  */
for|for
control|(
name|vbases
operator|=
name|vbase_types
operator|,
name|prev
operator|=
name|NULL_TREE
init|;
name|vbases
condition|;
name|vbases
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
operator|||
name|CLASSTYPE_MARKED2
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
else|else
name|vbase_types
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|ordered_vbase_types
operator|=
name|chainon
argument_list|(
name|ordered_vbase_types
argument_list|,
name|vbases
argument_list|)
expr_stmt|;
name|CLASSTYPE_MARKED2
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|vbases
expr_stmt|;
block|}
comment|/* Now unmark types all of whose ancestors are now on the 	 `ordered_vbase_types' list.  */
for|for
control|(
name|vbases
operator|=
name|vbase_types
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
comment|/* If all our virtual baseclasses are unmarked, ok.  */
name|tree
name|t
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|ASSOC_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|t
operator|&&
operator|(
name|CLASSTYPE_MARKED2
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_MARKED2
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|ordered_vbase_types
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dfs_record_inheritance
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mi_boolean
modifier|*
name|derived_row
init|=
name|DERIVES_FROM_STAR
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|baseclass
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|mi_boolean
modifier|*
name|base_row
init|=
name|DERIVES_FROM_STAR
argument_list|(
name|baseclass
argument_list|)
decl_stmt|;
comment|/* Don't search if there's nothing there!  MI_SIZE can be 	 zero as a result of parse errors.  */
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|baseclass
argument_list|)
operator|&&
name|mi_size
operator|>
literal|0
condition|)
for|for
control|(
name|j
operator|=
name|mi_size
operator|*
operator|(
name|CLASSTYPE_CID
argument_list|(
name|baseclass
argument_list|)
operator|-
literal|1
operator|)
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
name|mi_size
control|)
name|derived_row
index|[
name|j
index|]
operator||=
name|base_row
index|[
name|j
index|]
expr_stmt|;
name|DERIVES_FROM
argument_list|(
name|baseclass
argument_list|,
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a _CLASSTYPE node in a multiple inheritance lattice,    convert the lattice into a simple relation such that,    given to CIDs, C1 and C2, one can determine if C1<= C2    or C2<= C1 or C1<> C2.     Once constructed, we walk the lattice depth fisrt,    applying various functions to elements as they are encountered.     We use malloc here, in case we want to randomly free these tables.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_MI_MATRIX
end_define

begin_function
name|void
name|build_mi_matrix
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|cid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
if|if
condition|(
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|mi_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|mi_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|bzero
argument_list|(
name|mi_matrix
argument_list|,
name|mi_size
operator|*
name|mi_size
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_record_inheritance
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_mi_matrix
parameter_list|()
block|{
name|dfs_walk
argument_list|(
name|mi_type
argument_list|,
name|dfs_unnumber
argument_list|,
name|numberedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|mi_type
argument_list|)
operator|=
name|mi_matrix
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|mi_matrix
argument_list|)
expr_stmt|;
name|mi_size
operator|=
literal|0
expr_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Local variables for detecting ambiguities of virtual functions    when two or more classes are joined at a multiple inheritance    seam.  */
end_comment

begin_typedef
typedef|typedef
name|tree
name|mi_ventry
index|[
literal|3
index|]
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|mi_ventry
modifier|*
name|mi_vmatrix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|mi_vmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mi_vrows
decl_stmt|,
name|mi_vcols
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MI_VMATRIX
parameter_list|(
name|ROW
parameter_list|,
name|COL
parameter_list|)
value|((mi_vmatrix + (ROW)*mi_vcols)[COL])
end_define

begin_comment
comment|/* Build a table of virtual functions for a multiple-inheritance    structure.  Here, there are N base classes, and at most    M entries per class.     This function does nothing if N is 0 or 1.  */
end_comment

begin_function
name|void
name|build_mi_virtuals
parameter_list|(
name|rows
parameter_list|,
name|cols
parameter_list|)
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
block|{
if|if
condition|(
name|rows
operator|<
literal|2
condition|)
return|return;
name|mi_vrows
operator|=
name|rows
expr_stmt|;
name|mi_vcols
operator|=
name|cols
expr_stmt|;
name|mi_vmatrix
operator|=
operator|(
name|mi_ventry
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|rows
operator|+
literal|1
operator|)
operator|*
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|mi_ventry
argument_list|)
argument_list|)
expr_stmt|;
name|mi_vmax
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|rows
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mi_vmax
argument_list|,
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Row indicies start at 1, so adjust this.  */
name|mi_vmatrix
operator|-=
name|cols
expr_stmt|;
name|mi_vmax
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison function for ordering virtual function table entries.  */
end_comment

begin_function
specifier|static
name|int
name|rank_mi_virtuals
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|mi_ventry
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|TREE_UID
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|(
operator|*
name|v1
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|-
name|TREE_UID
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|(
operator|*
name|v2
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
name|p1
operator|=
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|p2
operator|=
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
name|i
operator|=
operator|(
name|TREE_UID
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|-
name|TREE_UID
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
condition|)
return|return
literal|1
return|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
comment|/* When matches of argument lists occur, pick lowest 	     TREE_UID to keep searching time to a minimum on 	     later passes--like hashing, only different. 	     *MUST BE STABLE*.  */
if|if
condition|(
name|TREE_UID
argument_list|(
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
argument_list|)
operator|<
name|TREE_UID
argument_list|(
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
expr_stmt|;
else|else
operator|(
operator|*
name|v2
operator|)
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|v1
operator|)
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Install the virtuals functions got from the initializer VIRTUALS to    the table at index ROW.  */
end_comment

begin_function
name|void
name|add_mi_virtuals
parameter_list|(
name|row
parameter_list|,
name|virtuals
parameter_list|)
name|int
name|row
decl_stmt|;
name|tree
name|virtuals
decl_stmt|;
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mi_vmatrix
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
operator|=
name|decl
expr_stmt|;
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|1
index|]
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|2
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
name|mi_vmax
index|[
name|row
index|]
operator|=
name|col
expr_stmt|;
name|qsort
argument_list|(
name|mi_vmatrix
operator|+
name|row
operator|*
name|mi_vcols
argument_list|,
name|col
argument_list|,
sizeof|sizeof
argument_list|(
name|mi_ventry
argument_list|)
argument_list|,
name|rank_mi_virtuals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If joining two types results in an ambiguity in the virtual    function table, report such here.  */
end_comment

begin_function
name|void
name|report_ambiguous_mi_virtuals
parameter_list|(
name|rows
parameter_list|,
name|type
parameter_list|)
name|int
name|rows
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
modifier|*
name|mi_vmin
decl_stmt|;
name|int
name|row1
decl_stmt|,
name|col1
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
if|if
condition|(
name|mi_vmatrix
operator|==
literal|0
condition|)
return|return;
comment|/* Now virtuals are all sorted, so we merge to find ambiguous cases.  */
name|mi_vmin
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|rows
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mi_vmin
argument_list|,
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust.  */
name|mi_vmin
operator|-=
literal|1
expr_stmt|;
comment|/* For each base class with virtual functions (and this includes views      of the virtual baseclasses from different base classes), see that      each virtual function in that base class has a unique meet.       When the column loop is finished, THIS_DECL is in fact the meet.      If that value does not appear in the virtual function table for      the row, install it.  This happens when that virtual function comes      from a virtual baseclass, or a non-leftmost baseclass.  */
for|for
control|(
name|row1
operator|=
literal|1
init|;
name|row1
operator|<
name|rows
condition|;
name|row1
operator|++
control|)
block|{
name|tree
name|this_decl
init|=
literal|0
decl_stmt|;
for|for
control|(
name|col1
operator|=
name|mi_vmax
index|[
name|row1
index|]
operator|-
literal|1
init|;
name|col1
operator|>=
name|mi_vmin
index|[
name|row1
index|]
condition|;
name|col1
operator|--
control|)
block|{
name|tree
name|these_args
init|=
name|MI_VMATRIX
argument_list|(
name|row1
argument_list|,
name|col1
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
name|tree
name|this_context
decl_stmt|;
name|this_decl
operator|=
name|MI_VMATRIX
argument_list|(
name|row1
argument_list|,
name|col1
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|this_decl
operator|==
literal|0
condition|)
continue|continue;
name|this_context
operator|=
name|DECL_CONTEXT
argument_list|(
name|this_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_context
operator|!=
name|type
condition|)
name|this_context
operator|=
name|get_base_type
argument_list|(
name|this_context
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|row1
operator|+
literal|1
init|;
name|row
operator|<=
name|rows
condition|;
name|row
operator|++
control|)
for|for
control|(
name|col
operator|=
name|mi_vmax
index|[
name|row
index|]
operator|-
literal|1
init|;
name|col
operator|>=
name|mi_vmin
index|[
name|row
index|]
condition|;
name|col
operator|--
control|)
block|{
name|mi_ventry
name|this_entry
decl_stmt|;
if|if
condition|(
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|this_entry
index|[
literal|0
index|]
operator|=
name|this_decl
expr_stmt|;
name|this_entry
index|[
literal|1
index|]
operator|=
name|these_args
expr_stmt|;
name|this_entry
index|[
literal|2
index|]
operator|=
name|MI_VMATRIX
argument_list|(
name|row1
argument_list|,
name|col1
argument_list|)
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|rank_mi_virtuals
argument_list|(
operator|&
name|this_entry
argument_list|,
operator|&
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* They are equal.  There are four possibilities: 		        		       (1) Derived class is defining this virtual function. 		       (2) Two paths to the same virtual function in the 		       same base class. 		       (3) A path to a virtual function declared in one base 		       class, and another path to a virtual function in a 		       base class of the base class. 		       (4) Two paths to the same virtual function in different 		       base classes. 		        		       The first three cases are ok (non-ambiguous).  */
name|tree
name|that_context
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|this_before_that
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|this_context
condition|)
comment|/* case 1.  */
goto|goto
name|ok
goto|;
name|that_context
operator|=
name|get_base_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|that_context
operator|==
name|this_context
condition|)
comment|/* case 2.  */
goto|goto
name|ok
goto|;
if|if
condition|(
name|that_context
operator|!=
name|NULL_TREE
condition|)
block|{
name|tmp
operator|=
name|get_base_type
argument_list|(
name|that_context
argument_list|,
name|this_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this_before_that
operator|=
operator|(
name|that_context
operator|!=
name|tmp
operator|)
expr_stmt|;
if|if
condition|(
name|this_before_that
operator|==
literal|0
condition|)
comment|/* case 3a.  */
goto|goto
name|ok
goto|;
name|tmp
operator|=
name|get_base_type
argument_list|(
name|this_context
argument_list|,
name|that_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this_before_that
operator|=
operator|(
name|this_context
operator|==
name|tmp
operator|)
expr_stmt|;
if|if
condition|(
name|this_before_that
operator|!=
literal|0
condition|)
comment|/* case 3b.  */
goto|goto
name|ok
goto|;
comment|/* case 4.  */
name|error_with_decl
argument_list|(
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
argument_list|,
literal|"ambiguous virtual function `%s'"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|this_decl
argument_list|,
literal|"ambiguating function `%s' (joined by type `%s')"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ok
label|:
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Let zeros propagate.  */
if|if
condition|(
name|col
operator|==
name|mi_vmax
index|[
name|row
index|]
operator|-
literal|1
condition|)
block|{
name|int
name|i
init|=
name|col
decl_stmt|;
while|while
condition|(
name|i
operator|>=
name|mi_vmin
index|[
name|row
index|]
operator|&&
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|i
operator|--
expr_stmt|;
name|mi_vmax
index|[
name|row
index|]
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|==
name|mi_vmin
index|[
name|row
index|]
condition|)
block|{
name|int
name|i
init|=
name|col
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|mi_vmax
index|[
name|row
index|]
operator|&&
name|MI_VMATRIX
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|mi_vmin
index|[
name|row
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|mi_vmatrix
operator|+
name|mi_vcols
argument_list|)
expr_stmt|;
name|mi_vmatrix
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|mi_vmax
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mi_vmax
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_comment
comment|/* Add the instance variables which this class contributed to the    current class binding contour.  When a redefinition occurs,    if the redefinition is strictly within a single inheritance path,    we just overwrite (in the case of a data field) or    cons (in the case of a member function) the old declaration with    the new.  If the fields are not within a single inheritance path,    we must cons them in either case.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_pushdecls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|,
modifier|*
name|methods
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
comment|/* Unmark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_ANON_UNION_ELEM
argument_list|(
name|fields
argument_list|)
condition|)
block|{
name|dfs_pushdecls
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|TREE_FIELD_PUBLIC
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_FIELD_PROTECTED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_FIELD_PRIVATE
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
comment|/* Possible ambiguity.  If its defining type(s) 		 is (are all) derived from us, no problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|value
argument_list|)
operator|==
name|type
operator|||
name|DERIVES_FROM
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
name|value
operator|=
name|fields
expr_stmt|;
else|else
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fields
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All children may derive from us, in which case 		     there is no problem.  Otherwise, we have to 		     keep lists around of what the ambiguities might be.  */
name|tree
name|values
decl_stmt|;
name|int
name|problem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|values
operator|=
name|value
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
block|{
name|tree
name|sub_values
init|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub_values
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
for|for
control|(
init|;
name|sub_values
condition|;
name|sub_values
operator|=
name|TREE_CHAIN
argument_list|(
name|sub_values
argument_list|)
control|)
if|if
condition|(
operator|!
name|DERIVES_FROM
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|sub_values
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|problem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DERIVES_FROM
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|sub_values
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|values
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|problem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|problem
condition|)
name|value
operator|=
name|fields
expr_stmt|;
block|}
comment|/* Mark this as a potentially ambiguous member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Leaving TREE_TYPE blank is intentional. 		     We cannot use `error_mark_node' (lookup_name) 		     or `unknown_type_node' (all member functions use this).  */
name|TREE_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|fields
expr_stmt|;
block|}
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* This does not work for multiple inheritance yet.  */
while|while
condition|(
name|methods
operator|!=
name|end
condition|)
block|{
comment|/* This will cause lookup_name to return a pointer 	     to the tree_list of possible methods of this name. 	     If the order is a problem, we can nreverse them.  */
name|tree
name|tmp
decl_stmt|;
name|tree
name|old
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|tmp
operator|=
name|tree_cons
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|,
name|old
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only complain if we shadow something we can access.  */
if|if
condition|(
name|old
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|old
argument_list|)
operator|==
name|current_class_type
operator|||
operator|!
name|TREE_PRIVATE
argument_list|(
name|old
argument_list|)
operator|)
condition|)
comment|/* Should figure out visibility more accurately.  */
name|warning
argument_list|(
literal|"shadowing member `%s' with member function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_tree_list
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_OVERLOADED (tmp) = DECL_OVERLOADED (*methods);
endif|#
directive|endif
name|TREE_NONLOCAL
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
operator|*
name|methods
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|TREE_FIELD_PUBLIC
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_FIELD_PROTECTED
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_FIELD_PRIVATE
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|methods
operator|++
expr_stmt|;
block|}
block|}
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consolidate unique (by name) member functions.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_compress_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
block|{
name|tree
name|tmp
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This was replaced in scope by somebody else.  Just leave it 	     alone.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_LIST
condition|)
continue|continue;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
if|#
directive|if
literal|0
block|tree tags = CLASSTYPE_TAGS (type);    while (tags)     {       tree code_type_node;       tree tag;        switch (TREE_CODE (TREE_VALUE (tags))) 	{ 	case ENUMERAL_TYPE: 	  code_type_node = enum_type_node; 	  break; 	case RECORD_TYPE: 	  code_type_node = record_type_node; 	  break; 	case CLASS_TYPE: 	  code_type_node = class_type_node; 	  break; 	case UNION_TYPE: 	  code_type_node = union_type_node; 	  break; 	default: 	  assert (0); 	}       tag = xref_tag (code_type_node, TREE_PURPOSE (tags), 		      CLASSTYPE_BASECLASS (TREE_VALUE (tags), 1));       pushdecl (build_decl (TYPE_DECL, TREE_PURPOSE (tags), TREE_VALUE (tags)));     }
endif|#
directive|endif
name|current_obstack
operator|=
operator|&
name|bridge_obstack
expr_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|bridge_obstack
argument_list|)
expr_stmt|;
comment|/* Push class fields into CLASS_VALUE scope, and mark.  */
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_pushdecls
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
comment|/* Compress fields which have only a single entry      by a given name, and unmark.  */
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_compress_decls
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_popdecls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|DECL_ANON_UNION_ELEM
argument_list|(
name|fields
argument_list|)
condition|)
block|{
name|dfs_popdecls
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|methods
operator|==
literal|0
condition|)
name|methods
operator|+=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|CLASSTYPE_MARKED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* Clear out the IDENTIFIER_CLASS_VALUE which this      class may have occupied, and mark.  */
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_popdecls
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
comment|/* Unmark.  */
name|dfs_walk
argument_list|(
name|type
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a base type PARENT, and a derived type TYPE, build    a name which distinguishes exactly the PARENT member of TYPE's type.     FORMAT is a string which controls how sprintf formats the name    we have generated.     For example, given  	class A; class B; class C : A, B;     it is possible to distinguish "A" from "C's A".  And given  	class L; 	class A : L; class B : L; class C : A, B;     it is possible to distinguish "L" from "A's L", and also from    "C's L from A".  */
end_comment

begin_function
name|tree
name|build_type_pathname
parameter_list|(
name|format
parameter_list|,
name|parent
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|tree
name|parent
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* Remember where to cut the obstack to.  */
name|first
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
comment|/* Put on TYPE+PARENT.  */
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|JOINER
argument_list|)
expr_stmt|;
name|obstack_grow0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|parent
argument_list|)
argument_list|,
name|TYPE_NAME_LENGTH
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|base
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
comment|/* Put on FORMAT+TYPE+PARENT.  */
name|obstack_blank
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|format
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmark_finished_struct
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|type
operator|=
name|i
operator|==
literal|0
condition|?
name|type
else|:
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|assoc
decl_stmt|,
name|decl
decl_stmt|,
name|context
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|current_class_type
condition|)
name|assoc
operator|=
name|CLASSTYPE_ASSOC
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|)
condition|)
name|assoc
operator|=
name|value_member
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assoc
operator|=
name|assoc_value
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|ASSOC_VTABLE
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|unmark_finished_struct
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|bfs_unmark_finished_struct
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|breadth_first_search
argument_list|(
name|type
argument_list|,
name|bfs_unmark_finished_struct
argument_list|,
name|bfs_marked3p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d memoized contexts saved\n"
argument_list|,
name|n_contexts_saved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local tree nodes made\n"
argument_list|,
name|my_tree_node_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local hash nodes made\n"
argument_list|,
name|my_memoized_entry_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|0
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|0
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fnfields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|1
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|1
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|()
block|{
name|obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|bridge_obstack
argument_list|)
expr_stmt|;
comment|/* This gives us room to build our chains of basetypes,      whether or not we decide to memoize them.  */
name|type_stack
operator|=
name|push_type_level
argument_list|(
literal|0
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|_vptr_name
operator|=
name|get_identifier
argument_list|(
literal|"_vptr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|get_wrapper
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|wrap_type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_type
operator|=
name|TYPE_WRAP_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|wrap_type
argument_list|)
operator|+
name|strlen
argument_list|(
name|WRAPPER_NAME_FORMAT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|WRAPPER_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|wrap_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lookup_fnfields
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|wrap_type
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|()
block|{
name|my_memoized_entry_counter
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

