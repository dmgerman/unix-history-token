begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common subexpression elimination for GNU compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* The basic idea of common subexpression elimination is to go    through the code, keeping a record of expressions that would    have the same value at the current scan point, and replacing    expressions encountered with the cheapest equivalent expression.     It is too complicated to keep track of the different possibilities    when control paths merge; so, at each label, we forget all that is    known and start fresh.  This can be described as processing each    basic block separately.  Note, however, that these are not quite    the same as the basic blocks found by a later pass and used for    data flow analysis and register packing.  We do not need to start fresh    after a conditional jump instruction if there is no label there.     We use two data structures to record the equivalent expressions:    a hash table for most expressions, and several vectors together    with "quantity numbers" to record equivalent (pseudo) registers.     The use of the special data structure for registers is desirable    because it is faster.  It is possible because registers references    contain a fairly small number, the register number, taken from    a contiguously allocated series, and two register references are    identical if they have the same number.  General expressions    do not have any such thing, so the only way to retrieve the    information recorded on an expression other than a register    is to keep it in a hash table.  Registers and "quantity numbers":        At the start of each basic block, all of the (hardware and pseudo)    registers used in the function are given distinct quantity    numbers to indicate their contents.  During scan, when the code    copies one register into another, we copy the quantity number.    When a register is loaded in any other way, we allocate a new    quantity number to describe the value generated by this operation.    `reg_qty' records what quantity a register is currently thought    of as containing.     We also maintain a bidirectional chain of registers for each    quantity number.  `qty_first_reg', `qty_last_reg',    `reg_next_eqv' and `reg_prev_eqv' hold these chains.     The first register in a chain is the one whose lifespan is least local.    Among equals, it is the one that was seen first.    We replace any equivalent register with that one.  Constants and quantity numbers     When a quantity has a known constant value, that value is stored    in the appropriate element of qty_const.  This is in addition to    putting the constant in the hash table as is usual for non-regs.     Regs are preferred to constants as they are to everything else,    but expressions containing constants can be simplified, by fold_rtx.     When a quantity has a known nearly constant value (such as an address    of a stack slot), that value is stored in the appropriate element    of qty_const.     Integer constants don't have a machine mode.  However, cse    determines the intended machine mode from the destination    of the instruction that moves the constant.  The machine mode    is recorded in the hash table along with the actual RTL    constant expression so that different modes are kept separate.  Other expressions:     To record known equivalences among expressions in general    we use a hash table called `table'.  It has a fixed number of buckets    that contain chains of `struct table_elt' elements for expressions.    These chains connect the elements whose expressions have the same    hash codes.     Other chains through the same elements connect the elements which    currently have equivalent values.     Register references in an expression are canonicalized before hashing    the expression.  This is done using `reg_qty' and `qty_first_reg'.    The hash code of a register reference is computed using the quantity    number, not the register number.     When the value of an expression changes, it is necessary to remove from the    hash table not just that expression but all expressions whose values    could be different as a result.       1. If the value changing is in memory, except in special cases      ANYTHING referring to memory could be changed.  That is because      nobody knows where a pointer does not point.      The function `invalidate_memory' removes what is necessary.       The special cases are when the address is constant or is      a constant plus a fixed register such as the frame pointer      or a static chain pointer.  When such addresses are stored in,      we can tell exactly which other such addresses must be invalidated      due to overlap.  `invalidate' does this.      All expressions that refer to non-constant      memory addresses are also invalidated.  `invalidate_memory' does this.       2. If the value changing is a register, all expressions      containing references to that register, and only those,      must be removed.     Because searching the entire hash table for expressions that contain    a register is very slow, we try to figure out when it isn't necessary.    Precisely, this is necessary only when expressions have been    entered in the hash table using this register, and then the value has    changed, and then another expression wants to be added to refer to    the register's new value.  This sequence of circumstances is rare    within any one basic block.     The vectors `reg_tick' and `reg_in_table' are used to detect this case.    reg_tick[i] is incremented whenever a value is stored in register i.    reg_in_table[i] holds -1 if no references to register i have been    entered in the table; otherwise, it contains the value reg_tick[i] had    when the references were entered.  If we want to enter a reference    and reg_in_table[i] != reg_tick[i], we must scan and remove old references.    Until we want to enter a new entry, the mere fact that the two vectors    don't match makes the entries be ignored if anyone tries to match them.     Registers themselves are entered in the hash table as well as in    the equivalent-register chains.  However, the vectors `reg_tick'    and `reg_in_table' do not apply to expressions which are simple    register references.  These expressions are removed from the table    immediately when they become invalid, and this can be done even if    we do not immediately search for all the expressions that refer to    the register.     A CLOBBER rtx in an instruction invalidates its operand for further    reuse.  A CLOBBER or SET rtx whose operand is a MEM:BLK    invalidates everything that resides in memory.  Related expressions:     Constant expressions that differ only by an additive integer    are called related.  When a constant expression is put in    the table, the related expression with no constant term    is also entered.  These are made to point at each other    so that it is possible to find out if there exists any    register equivalent to an expression related to a given expression.  */
end_comment

begin_comment
comment|/* One plus largest register number used in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of vectors indexed by quantity number.    We know in advance we will not need a quantity number this big.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next quantity number to be allocated.    This is 1 + the largest number needed so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by quantity number, gives the first (or last) (pseudo) register     in the chain of registers that currently contain this quantity.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_first_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_last_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by quantity number, gives the rtx of the constant value of the    quantity, or zero if it does not have a known value.    A sum of the frame pointer (or arg pointer) plus a constant    can also be entered here.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|qty_const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by qty number, gives the insn that stored the constant value    recorded in `qty_const'.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|qty_const_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value stored in CC0 by previous insn:    0 if previous insn didn't store in CC0.    else 0100 + (M&7)<<3 + (N&7)    where M is 1, 0 or -1 if result was>, == or< as signed number    and N is 1, 0 or -1 if result was>, == or< as unsigned number.    0200 bit may also be set, meaning that only == and != comparisons    have known results.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_insn_cc0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For machines where CC0 is one bit, we may see CC0 assigned a    constant value (after fold_rtx).    Record here the value stored in the previous insn (0 if none).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|prev_insn_explicit_cc0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous actual insn.  0 if at first insn of basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|prev_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn being scanned.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by (pseudo) register number, gives the quantity number    of the register's current contents.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by (pseudo) register number, gives the number of the next    (pseudo) register in the chain of registers sharing the same value.    Or -1 if this register is at the end of the chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_next_eqv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by (pseudo) register number, gives the number of the previous    (pseudo) register in the chain of registers sharing the same value.    Or -1 if this register is at the beginning of the chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_prev_eqv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by (pseudo) register number, gives the latest rtx    to use to insert a ref to that register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by (pseudo) register number, gives the number of times    that register has been altered in the current basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by (pseudo) register number, gives the reg_tick value at which    rtx's containing this register are valid in the hash table.    If this does not equal the current reg_tick value, such expressions    existing in the hash table are invalid.    If this is -1, no expressions containing this register have been    entered in the table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_in_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two vectors of max_reg ints:    one containing all -1's; in the other, element i contains i.    These are used to initialize various other vectors fast.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|all_minus_one
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|consec_ints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero in cse_insn to tell cse_basic_block to skip immediately    to the next basic block and treat it as a continuation of this one.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_skip_to_next_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CUID of insn that starts the basic block currently being cse-processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_basic_block_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CUID of insn that ends the basic block currently being cse-processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_basic_block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector mapping INSN_UIDs to cuids.    The cuids are like uids but increase monononically always.    We use them to see whether a reg is used outside a given basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Nonzero if cse has altered conditional jump insns    in such a way that jump optimization should be redone.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_jumps_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* canon_hash stores 1 in do_not_record    if it notices a reference to CC0, CC1 or PC.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_not_record
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* canon_hash stores 1 in hash_arg_in_memory    if it notices a reference to memory within the expression being hashed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_arg_in_memory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* canon_hash stores 1 in hash_arg_in_struct    if it notices a reference to memory that's part of a structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_arg_in_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The hash table contains buckets which are chains of `struct table_elt's,    each recording one expression's information.    That expression is in the `exp' field.     Those elements with the same hash code are chained in both directions    through the `next_same_hash' and `prev_same_hash' fields.     Each set of expressions with equivalent values    are on a two-way chain through the `next_same_value'    and `prev_same_value' fields, and all point with    the `first_same_value' field at the first element in    that chain.  The chain is in order of increasing cost.    Each element's cost value is in its `cost' field.     The `in_memory' field is nonzero for elements that    involve any reference to memory.  These elements are removed    whenever a write is done to an unidentified location in memory.    To be safe, we assume that a memory address is unidentified unless    the address is either a symbol constant or a constant plus    the frame pointer or argument pointer.     The `in_struct' field is nonzero for elements that    involve any reference to memory inside a structure or array.     The `equivalence_only' field means that this expression came from a    REG_EQUIV or REG_EQUAL note; it is not valid for substitution into an insn.     The `related_value' field is used to connect related expressions    (that differ by adding an integer).    The related expressions are chained in a circular fashion.    `related_value' is zero for expressions for which this    chain is not useful.     The `mode' field is usually the same as GET_MODE (`exp'), but    if `exp' is a CONST_INT and has no machine mode then the `mode'    field is the mode it was being used as.  Each constant is    recorded separately for each mode it is used with.  */
end_comment

begin_struct
struct|struct
name|table_elt
block|{
name|rtx
name|exp
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|prev_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|prev_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|first_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|related_value
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
name|in_memory
decl_stmt|;
name|char
name|in_struct
decl_stmt|;
name|char
name|equivalence_only
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
value|(canon_hash (x, m) % NBUCKETS)
end_define

begin_comment
comment|/* We don't want a lot of buckets, because we rarely have very many    things stored in the hash table, and a lot of buckets slows    down a lot of loops that happen frequently.  */
end_comment

begin_define
define|#
directive|define
name|NBUCKETS
value|31
end_define

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|table
index|[
name|NBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of `struct table_elt's made so far for this function    but currently removed from the table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|free_element_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of `struct table_elt' structures made so far for this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_elements_made
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum value `n_elements_made' has had so far in this compilation    for functions previously processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_elements_made
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bits describing what kind of values in memory must be invalidated    for a particular instruction.  If all three bits are zero,    no memory refs need to be invalidated.  Each bit is more powerful    than the preceding ones, and if a bit is set then the preceding    bits are also set.     Here is how the bits are set.    Writing at a fixed address invalidates only variable addresses,    writing in a structure element at variable address      invalidates all but scalar variables,    and writing in anything else at variable address invalidates everything.  */
end_comment

begin_struct
struct|struct
name|write_data
block|{
name|int
name|var
range|:
literal|1
decl_stmt|;
comment|/* Invalidate variable addresses.  */
name|int
name|nonscalar
range|:
literal|1
decl_stmt|;
comment|/* Invalidate all but scalar variables.  */
name|int
name|all
range|:
literal|1
decl_stmt|;
comment|/* Invalidate all memory refs.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Nonzero if X has the form (PLUS frame-pointer integer).  */
end_comment

begin_define
define|#
directive|define
name|FIXED_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT	\&& (XEXP (X, 0) == frame_pointer_rtx || XEXP (X, 0) == arg_pointer_rtx))
end_define

begin_function_decl
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_element
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_invalid_refs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|exp_equiv_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|refers_to_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|refers_to_mem_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_from_clobbers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_hash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|canon_hash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|equiv_constant
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_integer_term
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_related_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_mem_written
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cse_rtx_addr_varies_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fold_cc0
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return an estimate of the cost of computing rtx X.    The only use of this is to compare the costs of two expressions    to decide whether to replace one with the other.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_cost
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|total
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
return|return
literal|2
return|;
name|CONST_COSTS
argument_list|(
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|total
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
name|total
operator|=
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Sum the costs of the sub-rtx's, plus 2 just put in.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear the hash table and initialize each register with its own quantity,    for a new basic block.  */
end_comment

begin_function
specifier|static
name|void
name|new_basic_block
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|vecsize
init|=
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
decl_stmt|;
name|next_qty
operator|=
name|max_reg
expr_stmt|;
name|bzero
argument_list|(
name|reg_rtx
argument_list|,
name|vecsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_tick
argument_list|,
name|vecsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|all_minus_one
argument_list|,
name|reg_in_table
argument_list|,
name|vecsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|all_minus_one
argument_list|,
name|reg_next_eqv
argument_list|,
name|vecsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|all_minus_one
argument_list|,
name|reg_prev_eqv
argument_list|,
name|vecsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|consec_ints
argument_list|,
name|reg_qty
argument_list|,
name|vecsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_qty
condition|;
name|i
operator|++
control|)
block|{
name|qty_first_reg
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qty_last_reg
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qty_const
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|qty_const_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|table
index|[
name|i
index|]
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|next_same_hash
expr_stmt|;
name|free_element
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
name|table
argument_list|,
sizeof|sizeof
name|table
argument_list|)
expr_stmt|;
name|prev_insn_cc0
operator|=
literal|0
expr_stmt|;
name|prev_insn_explicit_cc0
operator|=
literal|0
expr_stmt|;
name|prev_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Say that register REG contains a quantity not in any register before.  */
end_comment

begin_function
specifier|static
name|void
name|make_new_qty
parameter_list|(
name|reg
parameter_list|)
specifier|register
name|int
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|q
decl_stmt|;
name|q
operator|=
name|reg_qty
index|[
name|reg
index|]
operator|=
name|next_qty
operator|++
expr_stmt|;
name|qty_first_reg
index|[
name|q
index|]
operator|=
name|reg
expr_stmt|;
name|qty_last_reg
index|[
name|q
index|]
operator|=
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make reg NEW equivalent to reg OLD.    OLD is not changing; NEW is.  */
end_comment

begin_function
specifier|static
name|void
name|make_regs_eqv
parameter_list|(
name|new
parameter_list|,
name|old
parameter_list|)
specifier|register
name|int
name|new
decl_stmt|,
name|old
decl_stmt|;
block|{
specifier|register
name|int
name|lastr
decl_stmt|,
name|firstr
decl_stmt|;
specifier|register
name|int
name|q
init|=
name|reg_qty
index|[
name|old
index|]
decl_stmt|;
comment|/* Nothing should become eqv until it has a "non-invalid" qty number.  */
if|if
condition|(
name|q
operator|==
name|old
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg_qty
index|[
name|new
index|]
operator|=
name|q
expr_stmt|;
name|firstr
operator|=
name|qty_first_reg
index|[
name|q
index|]
expr_stmt|;
name|lastr
operator|=
name|qty_last_reg
index|[
name|q
index|]
expr_stmt|;
comment|/* Prefer pseudo regs to hard regs with the same value.      Among pseudos, if NEW will live longer than any other reg of the same qty,      and that is beyond the current basic block,      make it the new canonical replacement for this qty.  */
if|if
condition|(
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|firstr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
operator|(
name|uid_cuid
index|[
name|regno_last_uid
index|[
name|new
index|]
index|]
operator|>
name|cse_basic_block_end
operator|||
name|uid_cuid
index|[
name|regno_first_uid
index|[
name|new
index|]
index|]
operator|<
name|cse_basic_block_start
operator|)
operator|&&
operator|(
name|uid_cuid
index|[
name|regno_last_uid
index|[
name|new
index|]
index|]
operator|>
name|uid_cuid
index|[
name|regno_last_uid
index|[
name|firstr
index|]
index|]
operator|)
operator|)
operator|)
condition|)
block|{
name|reg_prev_eqv
index|[
name|firstr
index|]
operator|=
name|new
expr_stmt|;
name|reg_next_eqv
index|[
name|new
index|]
operator|=
name|firstr
expr_stmt|;
name|reg_prev_eqv
index|[
name|new
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_first_reg
index|[
name|q
index|]
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* If NEW is a hard reg, insert at end. 	 Otherwise, insert before any hard regs that are at the end.  */
while|while
condition|(
name|lastr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|lastr
operator|=
name|reg_prev_eqv
index|[
name|lastr
index|]
expr_stmt|;
name|reg_next_eqv
index|[
name|new
index|]
operator|=
name|reg_next_eqv
index|[
name|lastr
index|]
expr_stmt|;
if|if
condition|(
name|reg_next_eqv
index|[
name|lastr
index|]
operator|>=
literal|0
condition|)
name|reg_prev_eqv
index|[
name|reg_next_eqv
index|[
name|lastr
index|]
index|]
operator|=
name|new
expr_stmt|;
else|else
name|qty_last_reg
index|[
name|q
index|]
operator|=
name|new
expr_stmt|;
name|reg_next_eqv
index|[
name|lastr
index|]
operator|=
name|new
expr_stmt|;
name|reg_prev_eqv
index|[
name|new
index|]
operator|=
name|lastr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Discard the records of what is in register REG.  */
end_comment

begin_function
specifier|static
name|void
name|reg_invalidate
parameter_list|(
name|reg
parameter_list|)
specifier|register
name|int
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
name|reg_next_eqv
index|[
name|reg
index|]
decl_stmt|;
specifier|register
name|int
name|p
init|=
name|reg_prev_eqv
index|[
name|reg
index|]
decl_stmt|;
specifier|register
name|int
name|q
init|=
name|reg_qty
index|[
name|reg
index|]
decl_stmt|;
name|reg_tick
index|[
name|reg
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|reg
condition|)
block|{
comment|/* Save time if already invalid */
comment|/* It shouldn't be linked to anything if it's invalid.  */
if|if
condition|(
name|reg_prev_eqv
index|[
name|q
index|]
operator|!=
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_next_eqv
index|[
name|q
index|]
operator|!=
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
name|reg_prev_eqv
index|[
name|n
index|]
operator|=
name|p
expr_stmt|;
else|else
name|qty_last_reg
index|[
name|q
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|-
literal|1
condition|)
name|reg_next_eqv
index|[
name|p
index|]
operator|=
name|n
expr_stmt|;
else|else
name|qty_first_reg
index|[
name|q
index|]
operator|=
name|n
expr_stmt|;
name|reg_qty
index|[
name|reg
index|]
operator|=
name|reg
expr_stmt|;
name|qty_first_reg
index|[
name|reg
index|]
operator|=
name|reg
expr_stmt|;
name|qty_last_reg
index|[
name|reg
index|]
operator|=
name|reg
expr_stmt|;
name|reg_next_eqv
index|[
name|reg
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_prev_eqv
index|[
name|reg
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove any invalid expressions from the hash table    that refer to any of the registers contained in expression X.     Make sure that newly inserted references to those registers    as subexpressions will be considered valid.     mention_regs is not called when a register itself    is being stored in the table.  */
end_comment

begin_function
specifier|static
name|void
name|mention_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|reg_rtx
index|[
name|regno
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|reg_in_table
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reg_in_table
index|[
name|regno
index|]
operator|!=
name|reg_tick
index|[
name|regno
index|]
condition|)
name|remove_invalid_refs
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|reg_in_table
index|[
name|regno
index|]
operator|=
name|reg_tick
index|[
name|regno
index|]
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mention_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mention_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the register quantities for inserting X into the hash table    with a value equivalent to CLASSP.    (If CLASSP is not a REG or a SUBREG, it is irrelevant.)    If MODIFIED is nonzero, X is a destination; it is being modified.    Note that reg_invalidate should be called on a register    before insert_regs is done on that register with MODIFIED != 0.     Nonzero value means that elements of reg_qty have changed    so X's hash code may be different.  */
end_comment

begin_function
specifier|static
name|int
name|insert_regs
parameter_list|(
name|x
parameter_list|,
name|classp
parameter_list|,
name|modified
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|classp
decl_stmt|;
name|int
name|modified
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|reg_rtx
index|[
name|regno
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|modified
operator|||
name|reg_qty
index|[
name|regno
index|]
operator|==
name|regno
condition|)
block|{
if|if
condition|(
name|classp
operator|&&
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|make_regs_eqv
argument_list|(
name|regno
argument_list|,
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure reg_rtx is set up even for regs 		 not explicitly set (such as function value).  */
name|reg_rtx
index|[
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
index|]
operator|=
name|classp
operator|->
name|exp
expr_stmt|;
block|}
else|else
name|make_new_qty
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Copying a subreg into a subreg makes the regs equivalent,      but only if the entire regs' mode is within one word.      Copying one reg of a DImode into one reg of another DImode      does not make them equivalent.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|modified
operator|||
name|reg_qty
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|classp
operator|&&
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|oregno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|make_regs_eqv
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|oregno
argument_list|)
expr_stmt|;
comment|/* Make sure reg_rtx is set up even for regs 	     not explicitly set (such as function value).  */
name|reg_rtx
index|[
name|oregno
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
name|make_new_qty
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|mention_regs
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look in or update the hash table.  */
end_comment

begin_comment
comment|/* Put the element ELT on the list of free elements.  */
end_comment

begin_function
specifier|static
name|void
name|free_element
parameter_list|(
name|elt
parameter_list|)
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
block|{
name|elt
operator|->
name|next_same_hash
operator|=
name|free_element_chain
expr_stmt|;
name|free_element_chain
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an element that is free for use.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|get_element
parameter_list|()
block|{
name|struct
name|table_elt
modifier|*
name|elt
init|=
name|free_element_chain
decl_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
name|free_element_chain
operator|=
name|elt
operator|->
name|next_same_hash
expr_stmt|;
return|return
name|elt
return|;
block|}
name|n_elements_made
operator|++
expr_stmt|;
return|return
operator|(
expr|struct
name|table_elt
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|table_elt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove table element ELT from use in the table.    HASH is its hash code, made using the HASH macro.    It's an argument because often that is known in advance    and we save much time not recomputing it.  */
end_comment

begin_function
specifier|static
name|void
name|remove
parameter_list|(
name|elt
parameter_list|,
name|hash
parameter_list|)
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return;
comment|/* Mark this element as removed.  See cse_insn.  */
name|elt
operator|->
name|first_same_value
operator|=
literal|0
expr_stmt|;
comment|/* Remove the table element from its equivalence class.  */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|prev
init|=
name|elt
operator|->
name|prev_same_value
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|next
init|=
name|elt
operator|->
name|next_same_value
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_value
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_same_value
operator|=
name|next
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|newfirst
init|=
name|next
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|next
operator|->
name|first_same_value
operator|=
name|newfirst
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next_same_value
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove the table element from its hash bucket.  */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|prev
init|=
name|elt
operator|->
name|prev_same_hash
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|next
init|=
name|elt
operator|->
name|next_same_hash
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_hash
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_same_hash
operator|=
name|next
expr_stmt|;
else|else
name|table
index|[
name|hash
index|]
operator|=
name|next
expr_stmt|;
block|}
comment|/* Remove the table element from its related-value circular chain.  */
if|if
condition|(
name|elt
operator|->
name|related_value
operator|!=
literal|0
operator|&&
name|elt
operator|->
name|related_value
operator|!=
name|elt
condition|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
init|=
name|elt
operator|->
name|related_value
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|related_value
operator|!=
name|elt
condition|)
name|p
operator|=
name|p
operator|->
name|related_value
expr_stmt|;
name|p
operator|->
name|related_value
operator|=
name|elt
operator|->
name|related_value
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|related_value
operator|==
name|p
condition|)
name|p
operator|->
name|related_value
operator|=
literal|0
expr_stmt|;
block|}
name|free_element
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up X in the hash table and return its table element,    or 0 if X is not in the table.     MODE is the machine-mode of X, or if X is an integer constant    with VOIDmode then MODE is the mode with which X will be used.     Here we are satisfied to find an expression whose tree structure    looks like X.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup
parameter_list|(
name|x
parameter_list|,
name|hash
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|&&
operator|(
name|x
operator|==
name|p
operator|->
name|exp
operator|||
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like `lookup' but don't care whether the table element uses invalid regs.    Also ignore discrepancies in the machine mode of a register.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup_for_remove
parameter_list|(
name|x
parameter_list|,
name|hash
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Don't check the machine mode when comparing registers; 	 invalidating (REG:SI 0) also invalidates (REG:DF 0).  */
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|regno
condition|)
return|return
name|p
return|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|&&
operator|(
name|x
operator|==
name|p
operator|->
name|exp
operator|||
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for an expression equivalent to X and with code CODE.    If one is found, return that expression.  */
end_comment

begin_function
specifier|static
name|rtx
name|lookup_as_function
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
init|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|code
comment|/* Make sure this is a valid entry in the table.  */
operator|&&
operator|(
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|p
operator|->
name|exp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert X in the hash table, assuming HASH is its hash code    and CLASSP is the current first element of the class it should go in    (or 0 if a new class should be made).    It is inserted at the proper position to keep the class in    the order cheapest first.     MODE is the machine-mode of X, or if X is an integer constant    with VOIDmode then MODE is the mode with which X will be used.     For elements of equal cheapness, the most recent one    goes in front, except that the first element in the list    remains first unless a cheaper element is added.     The in_memory field in the hash table element is set to 0.    The caller must set it nonzero if appropriate.     You should call insert_regs (X, CLASSP, MODIFY) before calling here,    and if insert_regs returns a nonzero value    you must then recompute its hash code before calling here.     If necessary, update table showing constant values of quantities.  */
end_comment

begin_define
define|#
directive|define
name|CHEAPER
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|(((X)->cost< (Y)->cost) ||						\     ((X)->cost == (Y)->cost						\&& GET_CODE ((X)->exp) == REG&& GET_CODE ((Y)->exp) == REG	\&& (uid_cuid[regno_last_uid[REGNO ((X)->exp)]]> cse_basic_block_end		\ 	 || uid_cuid[regno_first_uid[REGNO ((X)->exp)]]< cse_basic_block_start)	\&& (uid_cuid[regno_last_uid[REGNO ((X)->exp)]]			\> uid_cuid[regno_last_uid[REGNO ((Y)->exp)]])))
end_define

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|insert
parameter_list|(
name|x
parameter_list|,
name|classp
parameter_list|,
name|hash
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|classp
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* Put an element for X into the right hash bucket.  */
name|elt
operator|=
name|get_element
argument_list|()
expr_stmt|;
name|elt
operator|->
name|exp
operator|=
name|x
expr_stmt|;
name|elt
operator|->
name|cost
operator|=
name|rtx_cost
argument_list|(
name|x
argument_list|)
operator|*
literal|2
expr_stmt|;
comment|/* Make pseudo regs a little cheaper than hard regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|elt
operator|->
name|cost
operator|-=
literal|1
expr_stmt|;
name|elt
operator|->
name|next_same_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|prev_same_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|next_same_hash
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|elt
operator|->
name|prev_same_hash
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|related_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|equivalence_only
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|table
index|[
name|hash
index|]
condition|)
name|table
index|[
name|hash
index|]
operator|->
name|prev_same_hash
operator|=
name|elt
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|elt
expr_stmt|;
comment|/* Put it into the proper value-class.  */
if|if
condition|(
name|classp
condition|)
block|{
if|if
condition|(
name|CHEAPER
argument_list|(
name|elt
argument_list|,
name|classp
argument_list|)
condition|)
comment|/** Insert at the head of the class */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|elt
operator|->
name|next_same_value
operator|=
name|classp
expr_stmt|;
name|classp
operator|->
name|prev_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert not at head of the class.  */
comment|/* Put it after the last element cheaper than X.  */
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
operator|(
name|next
operator|=
name|p
operator|->
name|next_same_value
operator|)
operator|&&
name|CHEAPER
argument_list|(
name|next
argument_list|,
name|elt
argument_list|)
condition|;
name|p
operator|=
name|next
control|)
empty_stmt|;
comment|/* Put it after P and before NEXT.  */
name|elt
operator|->
name|next_same_value
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|prev_same_value
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|next_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|first_same_value
operator|=
name|classp
expr_stmt|;
block|}
block|}
else|else
name|elt
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|elt
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
index|]
index|]
operator|=
name|x
expr_stmt|;
name|qty_const_insn
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|elt
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
index|]
index|]
operator|=
name|this_insn
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|next_same_value
operator|!=
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|elt
operator|->
name|next_same_value
operator|->
name|exp
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|elt
operator|->
name|next_same_value
operator|->
name|exp
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|elt
operator|->
name|next_same_value
operator|->
name|exp
argument_list|)
operator|)
condition|)
block|{
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|]
operator|=
name|elt
operator|->
name|next_same_value
operator|->
name|exp
expr_stmt|;
name|qty_const_insn
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|]
operator|=
name|this_insn
expr_stmt|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|elt
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|elt
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|elt
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
condition|)
block|{
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|]
operator|=
name|elt
operator|->
name|first_same_value
operator|->
name|exp
expr_stmt|;
name|qty_const_insn
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|]
operator|=
name|this_insn
expr_stmt|;
block|}
block|}
comment|/* If this is a constant with symbolic value,      and it has a term with an explicit integer value,      link it up with related expressions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|subexp
init|=
name|get_related_value
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|subhash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|subelt
decl_stmt|,
modifier|*
name|subelt_prev
decl_stmt|;
if|if
condition|(
name|subexp
operator|!=
literal|0
condition|)
block|{
comment|/* Get the integer-free subexpression in the hash table.  */
name|subhash
operator|=
name|safe_hash
argument_list|(
name|subexp
argument_list|,
name|mode
argument_list|)
operator|%
name|NBUCKETS
expr_stmt|;
name|subelt
operator|=
name|lookup
argument_list|(
name|subexp
argument_list|,
name|subhash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subelt
operator|==
literal|0
condition|)
name|subelt
operator|=
name|insert
argument_list|(
name|subexp
argument_list|,
literal|0
argument_list|,
name|subhash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Initialize SUBELT's circular chain if it has none.  */
if|if
condition|(
name|subelt
operator|->
name|related_value
operator|==
literal|0
condition|)
name|subelt
operator|->
name|related_value
operator|=
name|subelt
expr_stmt|;
comment|/* Find the element in the circular chain that precedes SUBELT.  */
name|subelt_prev
operator|=
name|subelt
expr_stmt|;
while|while
condition|(
name|subelt_prev
operator|->
name|related_value
operator|!=
name|subelt
condition|)
name|subelt_prev
operator|=
name|subelt_prev
operator|->
name|related_value
expr_stmt|;
comment|/* Put new ELT into SUBELT's circular chain just before SUBELT. 	     This way the element that follows SUBELT is the oldest one.  */
name|elt
operator|->
name|related_value
operator|=
name|subelt_prev
operator|->
name|related_value
expr_stmt|;
name|subelt_prev
operator|->
name|related_value
operator|=
name|elt
expr_stmt|;
block|}
block|}
return|return
name|elt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table, or mark as invalid,    all expressions whose values could be altered by storing in X.    X is a register, a subreg, or a memory reference with nonvarying address    (because, when a memory reference with a varying address is stored in,    all memory references are removed by invalidate_memory    so specific invalidation is superfluous).     A nonvarying address may be just a register or just    a symbol reference, or it may be either of those plus    a numeric offset.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
specifier|register
name|rtx
name|base
decl_stmt|;
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* If X is a register, dependencies on its contents      are recorded through the qty number mechanism.      Just change the qty number of the register,      mark it as invalid for expressions that refer to it,      and remove it itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|hash
init|=
name|HASH
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|reg_invalidate
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|lookup_for_remove
argument_list|(
name|x
argument_list|,
name|hash
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|invalidate
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* X is not a register; it must be a memory reference with      a nonvarying address.  Remove all hash table elements      that refer to overlapping pieces of memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
comment|/* Registers with nonvarying addresses usually have constant equivalents;      but the frame pointer register is also possible.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
index|]
operator|!=
literal|0
condition|)
name|base
operator|=
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|start
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|start
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|refers_to_mem_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|base
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
name|remove
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove all expressions that refer to register REGNO,    since they are already invalid, and we are about to    mark that register valid again and don't want the old    expressions to reappear as valid.  */
end_comment

begin_function
specifier|static
name|void
name|remove_invalid_refs
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|rtx
name|x
init|=
name|reg_rtx
index|[
name|regno
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|x
argument_list|)
condition|)
name|remove
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table all expressions that reference memory,    or some of them as specified by *WRITES.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_memory
parameter_list|(
name|writes
parameter_list|)
name|struct
name|write_data
modifier|*
name|writes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|all
init|=
name|writes
operator|->
name|all
decl_stmt|;
name|int
name|nonscalar
init|=
name|writes
operator|->
name|nonscalar
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in_memory
operator|&&
operator|(
name|all
operator|||
operator|(
name|nonscalar
operator|&&
name|p
operator|->
name|in_struct
operator|)
operator|||
name|cse_rtx_addr_varies_p
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|)
condition|)
name|remove
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of the integer term in X, if one is apparent;    otherwise return 0.    We do not check extremely carefully for the presence of integer terms    but rather consider only the cases that `insert' notices    for the `related_value' field.  */
end_comment

begin_function
specifier|static
name|int
name|get_integer_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|get_related_value
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an expression X of type CONST,    and ELT which is its table entry (or 0 if it    is not in the hash table),    return an alternate expression for X as a register plus integer.    If none can be found or it would not be a valid address, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|use_related_value
parameter_list|(
name|x
parameter_list|,
name|elt
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|relt
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* First, is there anything related known?      If we have a table element, we can tell from that.      Otherwise, must look it up.  */
if|if
condition|(
name|elt
operator|!=
literal|0
operator|&&
name|elt
operator|->
name|related_value
operator|!=
literal|0
condition|)
name|relt
operator|=
name|elt
expr_stmt|;
elseif|else
if|if
condition|(
name|elt
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|subexp
init|=
name|get_related_value
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|subexp
operator|!=
literal|0
condition|)
name|relt
operator|=
name|lookup
argument_list|(
name|subexp
argument_list|,
name|safe_hash
argument_list|(
name|subexp
argument_list|,
name|GET_MODE
argument_list|(
name|subexp
argument_list|)
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|GET_MODE
argument_list|(
name|subexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relt
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Search all related table entries for one that has an      equivalent register.  */
name|p
operator|=
name|relt
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|first_same_value
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|p
operator|->
name|first_same_value
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
break|break;
name|p
operator|=
name|p
operator|->
name|related_value
expr_stmt|;
comment|/* We went all the way around, so there is nothing to be found. 	 Return failure.  */
if|if
condition|(
name|p
operator|==
name|relt
condition|)
return|return
literal|0
return|;
comment|/* Perhaps RELT was in the table for some other reason and 	 it has no related values recorded.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Note: OFFSET may be 0 if P->xexp and X are related by commutativity.  */
name|offset
operator|=
operator|(
name|get_integer_term
argument_list|(
name|x
argument_list|)
operator|-
name|get_integer_term
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|p
operator|->
name|first_same_value
operator|->
name|exp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|addr
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash an rtx.  We are careful to make sure the value is never negative.    Equivalent registers hash identically.    MODE is used in hashing for CONST_INTs only;    otherwise the mode of X is used.     Store 1 in do_not_record if any subexpression is volatile.     Store 1 in hash_arg_in_memory if X contains a MEM rtx    which does not have the RTX_UNCHANGING_P bit set.    In this case, also store 1 in hash_arg_in_struct    if there is a MEM rtx which has the MEM_IN_STRUCT_P bit set.     Note that cse_insn knows that the hash code of a MEM expression    is just (int) MEM plus the hash code of the address.    It also knows it can use HASHREG to get the hash code of (REG n).  */
end_comment

begin_define
define|#
directive|define
name|HASHBITS
value|16
end_define

begin_define
define|#
directive|define
name|HASHREG
parameter_list|(
name|RTX
parameter_list|)
define|\
value|((((int) REG<< 7) + reg_qty[REGNO (RTX)]) % NBUCKETS)
end_define

begin_function
specifier|static
name|int
name|canon_hash
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|hash
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
comment|/* We do not invalidate anything on pushing or popping 	   because they cannot change anything but the stack pointer; 	   but that means we must consider the stack pointer volatile 	   since it can be changed "mysteriously".  */
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|hash
operator|+
operator|(
operator|(
name|int
operator|)
name|REG
operator|<<
literal|7
operator|)
operator|+
name|reg_qty
index|[
name|regno
index|]
return|;
block|}
case|case
name|CONST_INT
case|:
name|hash
operator|+=
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
operator|(
operator|(
name|int
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
name|HASHBITS
operator|)
operator|)
expr_stmt|;
return|return
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|&
name|hash
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the first two elements.  */
name|hash
operator|+=
operator|(
name|int
operator|)
name|code
operator|+
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
name|tem
operator|+
operator|(
name|tem
operator|>>
name|HASHBITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|hash
return|;
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
comment|/* Use `and' to ensure a positive number.  */
return|return
operator|(
name|hash
operator|+
operator|(
operator|(
name|int
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|int
operator|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
operator|(
name|hash
operator|+
operator|(
operator|(
name|int
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|int
operator|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|hash_arg_in_memory
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
condition|)
name|hash_arg_in_struct
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now that we have already found this special case, 	 might as well speed it up as much as possible.  */
name|hash
operator|+=
operator|(
name|int
operator|)
name|MEM
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|+=
operator|(
name|int
operator|)
name|code
operator|+
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function  is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|hash
operator|+=
name|canon_hash
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|hash
operator|+=
name|canon_hash
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
block|{
specifier|register
name|int
name|tem
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
name|tem
operator|+
operator|(
name|tem
operator|>>
name|HASHBITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|int
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
name|tem
operator|+
operator|(
name|tem
operator|>>
name|HASHBITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Like canon_hash but with no side effects.  */
end_comment

begin_function
specifier|static
name|int
name|safe_hash
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|save_do_not_record
init|=
name|do_not_record
decl_stmt|;
name|int
name|save_hash_arg_in_memory
init|=
name|hash_arg_in_memory
decl_stmt|;
name|int
name|save_hash_arg_in_struct
init|=
name|hash_arg_in_struct
decl_stmt|;
name|int
name|hash
init|=
name|canon_hash
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
name|hash_arg_in_struct
operator|=
name|save_hash_arg_in_struct
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff X and Y would canonicalize into the same thing,    without actually constructing the canonicalization of either one.    If VALIDATE is nonzero,    we assume X is an expression being processed from the rtl    and Y was found in the hash table.  We check register refs    in Y for being marked as valid.  */
end_comment

begin_function
specifier|static
name|int
name|exp_equiv_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|validate
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|validate
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Note: it is incorrect to assume an expression is equivalent to itself      if VALIDATE is nonzero.  */
if|if
condition|(
name|x
operator|==
name|y
operator|&&
operator|!
name|validate
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
name|y
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
operator|==
name|y
return|;
case|case
name|CONST_INT
case|:
return|return
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XINT
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REG
case|:
return|return
operator|(
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|reg_qty
index|[
name|REGNO
argument_list|(
name|y
argument_list|)
index|]
operator|&&
operator|(
operator|!
name|validate
operator|||
name|reg_in_table
index|[
name|REGNO
argument_list|(
name|y
argument_list|)
index|]
operator|==
name|reg_tick
index|[
name|REGNO
argument_list|(
name|y
argument_list|)
index|]
operator|)
operator|)
return|;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|validate
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|validate
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff any subexpression of X matches Y.    Here we do not require that X or Y be valid (for registers referred to)    for being in the hash table.  */
end_comment

begin_function
name|int
name|refers_to_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X as a whole has the same code as Y, they may match.      If so, return 1.  */
if|if
condition|(
name|code
operator|==
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|refers_to_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff any subexpression of X refers to memory    at an address of REG plus some offset    such that any of the bytes' offsets fall between START (inclusive)    and END (exclusive).     The value is undefined if X is a varying address.    This function is not used in such cases.     When used in the cse pass, `qty_const' is nonzero, and it is used    to treat an address that is a register with a known constant value    as if it were that constant value.    In the loop pass, `qty_const' is zero, so this is not done.  */
end_comment

begin_function
name|int
name|refers_to_mem_p
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Get the address.  */
name|int
name|myend
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
comment|/* qty_const is 0 when outside the cse pass; 	     at such times, this info is not available.  */
operator|&&
name|qty_const
operator|!=
literal|0
operator|&&
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
index|]
operator|!=
literal|0
condition|)
name|addr
operator|=
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If ADDR is BASE, or BASE plus an integer, put 	 the integer in I.  */
if|if
condition|(
name|addr
operator|==
name|reg
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|i
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
name|myend
operator|=
name|i
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|myend
operator|>
name|start
operator|&&
name|i
operator|<
name|end
return|;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_mem_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|refers_to_mem_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if X refers to memory at a varying address;    except that a register which has at the moment a known constant value    isn't considered variable.  */
end_comment

begin_function
specifier|static
name|int
name|cse_rtx_addr_varies_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Canonicalize an expression:    replace each register reference inside it    with the "oldest" equivalent register.  */
end_comment

begin_function
specifier|static
name|rtx
name|canon_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
block|{
specifier|register
name|rtx
name|new
decl_stmt|;
comment|/* Never replace a hard reg, because hard regs can appear 	   in more than one machine mode, and we must preserve the mode 	   of each occurrence.  Also, some hard regs appear in 	   MEMs that are shared and mustn't be altered.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|x
return|;
name|new
operator|=
name|reg_rtx
index|[
name|qty_first_reg
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|]
index|]
expr_stmt|;
return|return
name|new
condition|?
name|new
else|:
name|x
return|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a nontrivial arithmetic operation on an argument    for which a constant value can be determined, return    the result of operating on that value, as a constant.    Otherwise, return X, possibly with one or more operands    modified by recursive calls to this function.     If X is a register whose contents are known, we do NOT    return those contents.  This is because an instruction that    uses a register is usually faster than one that uses a constant.     COPYFLAG is nonzero for memory addresses and subexpressions thereof.    If COPYFLAG is nonzero, we avoid altering X itself    by creating new structure when necessary.  In this case we    can risk creating invalid structure because it will be tested.    If COPYFLAG is zero, be careful not to substitute constants    into expressions that cannot be simplified.  */
end_comment

begin_function
specifier|static
name|rtx
name|fold_rtx
parameter_list|(
name|x
parameter_list|,
name|copyflag
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|copyflag
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|int
name|copied
init|=
operator|!
name|copyflag
decl_stmt|;
name|int
name|width
decl_stmt|;
comment|/* Constant equivalents of first three operands of X;      0 when no such equivalent is known.  */
name|rtx
name|const_arg0
decl_stmt|;
name|rtx
name|const_arg1
decl_stmt|;
name|rtx
name|const_arg2
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
comment|/* No use simplifying an EXPR_LIST 	 since they are used only for lists of args 	 in a function call's REG_EQUAL note.  */
case|case
name|EXPR_LIST
case|:
return|return
name|x
return|;
comment|/* We must be careful when folding a memory address      to avoid making it invalid.  So fold nondestructively      and use the result only if it's valid.  */
case|case
name|MEM
case|:
block|{
name|rtx
name|newaddr
init|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Save time if no change was made.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|newaddr
condition|)
return|return
name|x
return|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|newaddr
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* Don't replace a value with a more expensive one.  */
if|if
condition|(
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|newaddr
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|copyflag
condition|)
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|newaddr
argument_list|)
return|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|newaddr
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
name|const_arg0
operator|=
literal|0
expr_stmt|;
name|const_arg1
operator|=
literal|0
expr_stmt|;
name|const_arg2
operator|=
literal|0
expr_stmt|;
comment|/* Try folding our operands.      Then see which ones have constant values known.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
specifier|register
name|rtx
name|tem
init|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|copyflag
argument_list|)
decl_stmt|;
comment|/* If an operand has changed under folding, and we are not supposed to 	   alter the original structure, copy X if we haven't yet done so.  */
if|if
condition|(
operator|!
name|copied
operator|&&
name|tem
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|rtx
name|new
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|j
operator|++
control|)
name|XINT
argument_list|(
name|new
argument_list|,
name|j
argument_list|)
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|x
operator|=
name|new
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Install the possibly altered folded operand.  */
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|tem
expr_stmt|;
comment|/* For the first three operands, see if the operand 	   is constant or equivalent to a constant.  */
if|if
condition|(
name|i
operator|<
literal|3
condition|)
block|{
name|rtx
name|const_arg
init|=
name|equiv_constant
argument_list|(
name|tem
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|const_arg0
operator|=
name|const_arg
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|const_arg1
operator|=
name|const_arg
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|const_arg2
operator|=
name|const_arg
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
comment|/* Don't try to fold inside of a vector of expressions. 	 Doing nothing is is harmless.  */
empty_stmt|;
comment|/* If a commutative operation, place a constant integer as the second      operand unless the first operand is also a constant integer.  Otherwise,      place any constant second unless the first operand is also a constant.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|UMULT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
if|if
condition|(
name|const_arg0
operator|&&
name|const_arg0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|const_arg1
operator|&&
name|const_arg1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|)
condition|)
block|{
specifier|register
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|copied
condition|)
name|copied
operator|=
literal|1
operator|,
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|const_arg0
expr_stmt|;
name|const_arg0
operator|=
name|const_arg1
expr_stmt|;
name|const_arg1
operator|=
name|tem
expr_stmt|;
block|}
break|break;
block|}
comment|/* Now decode the kind of rtx X is      and then return X (if nothing can be done)      or return a folded rtx      or store a value in VAL and drop through      (to return a CONST_INT for the integer VAL).  */
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|const_arg0
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|int
name|arg0
init|=
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|NOT
case|:
name|val
operator|=
operator|~
name|arg0
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|val
operator|=
operator|-
name|arg0
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|val
operator|=
name|arg0
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|HOST_BITS_PER_INT
condition|)
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
else|else
return|return
name|x
return|;
break|break;
block|}
case|case
name|SIGN_EXTEND
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|HOST_BITS_PER_INT
condition|)
block|{
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|-=
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|x
return|;
break|break;
block|}
default|default:
return|return
name|x
return|;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|union
name|real_extract
name|u
decl_stmt|;
specifier|register
name|REAL_VALUE_TYPE
name|arg0
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"floating point trap in constant folding"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|const_arg0
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|u
operator|.
name|d
expr_stmt|;
name|u
operator|.
name|d
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|x
operator|=
name|immed_real_const_1
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
endif|#
directive|endif
else|else
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|2
condition|)
block|{
specifier|register
name|int
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg0s
decl_stmt|,
name|arg1s
decl_stmt|;
name|int
name|arithwidth
init|=
name|width
decl_stmt|;
comment|/* If 1st arg is the condition codes, 2nd must be zero 	 and this must be a comparison. 	 Decode the info on how the previous insn set the cc0 	 and use that to deduce result of comparison.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
condition|)
name|arg0
operator|=
name|prev_insn_cc0
expr_stmt|;
else|else
name|arg0
operator|=
name|fold_cc0
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|const_arg1
operator|!=
name|const0_rtx
comment|/* 0200 bit in arg0 means only zeroness is known, 		 and sign is not known.  */
operator|||
operator|(
operator|(
name|arg0
operator|&
literal|0200
operator|)
operator|!=
literal|0
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
operator|)
condition|)
return|return
name|x
return|;
comment|/* Extract either the signed or the unsigned digit from ARG0.  */
if|if
condition|(
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|GTU
condition|)
name|arg0
operator|=
name|arg0
operator|&
literal|7
expr_stmt|;
else|else
name|arg0
operator|=
operator|(
name|arg0
operator|>>
literal|3
operator|)
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|7
condition|)
name|arg0
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
return|return
operator|(
name|arg0
operator|<=
literal|0
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
return|return
operator|(
name|arg0
operator|<
literal|0
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
operator|(
name|arg0
operator|>=
literal|0
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
return|return
operator|(
name|arg0
operator|>
literal|0
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
case|case
name|NE
case|:
return|return
operator|(
name|arg0
operator|!=
literal|0
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
case|case
name|EQ
case|:
return|return
operator|(
name|arg0
operator|==
literal|0
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|const_arg0
operator|==
literal|0
operator|||
name|const_arg1
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* Even if we can't compute a constant result, 	     there are some cases worth simplifying.  */
comment|/* Note that we cannot rely on constant args to come last, 	     even for commutative operators, 	     because that happens only when the constant is explicit.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
operator|||
name|const_arg0
operator|==
name|fconst0_rtx
operator|||
name|const_arg0
operator|==
name|dconst0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
operator|||
name|const_arg1
operator|==
name|fconst0_rtx
operator|||
name|const_arg1
operator|==
name|dconst0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Handle both-operands-constant cases.  */
if|if
condition|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|const_arg0
argument_list|,
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|const_arg0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST
condition|)
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
operator|=
name|const_arg1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST
condition|)
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|const_arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* constant + (variable + constant) 		   can result if an index register is made constant. 		   We simplify this by adding the constants. 		   If we did not, it would become an invalid address.  */
name|new
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|const_arg0
operator|==
name|const_arg1
operator|)
condition|)
block|{
comment|/* We can't assume x-x is 0 with IEEE floating point.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|const0_rtx
return|;
block|}
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
operator|||
name|const_arg1
operator|==
name|fconst0_rtx
operator|||
name|const_arg1
operator|==
name|dconst0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|const_arg0
operator|==
name|const_arg1
operator|)
condition|)
block|{
comment|/* We can't assume x-x is 0 with IEEE floating point.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|const0_rtx
return|;
block|}
comment|/* Change subtraction from zero into negation.  */
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
condition|)
return|return
name|gen_rtx
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Don't let a relocatable value get a negative coeff.  */
if|if
condition|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|const_arg0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
case|case
name|UMULT
case|:
if|if
condition|(
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|==
operator|-
literal|1
comment|/* Don't do this in the case of widening multiplication.  */
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
operator|||
name|const_arg0
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|const_arg1
operator|==
name|fconst0_rtx
operator|||
name|const_arg0
operator|==
name|fconst0_rtx
condition|)
name|new
operator|=
name|fconst0_rtx
expr_stmt|;
if|if
condition|(
name|const_arg1
operator|==
name|dconst0_rtx
operator|||
name|const_arg0
operator|==
name|dconst0_rtx
condition|)
name|new
operator|=
name|dconst0_rtx
expr_stmt|;
if|if
condition|(
name|const_arg1
operator|==
name|const1_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|==
name|const1_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|new
operator|=
name|const_arg1
expr_stmt|;
if|if
condition|(
name|const_arg0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|new
operator|=
name|const_arg0
expr_stmt|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|NOT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|NOT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
operator|||
name|const_arg0
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
break|break;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const1_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
operator|||
name|const_arg1
operator|==
name|const1_rtx
condition|)
name|new
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|const_arg0
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|const_arg0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|new
argument_list|)
condition|)
return|return
name|new
return|;
return|return
name|x
return|;
block|}
if|if
condition|(
name|arithwidth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|arithwidth
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|arithwidth
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the integer argument values in two forms: 	 zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */
name|arg0
operator|=
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arithwidth
operator|<
name|HOST_BITS_PER_INT
operator|&&
name|arithwidth
operator|>
literal|0
condition|)
block|{
name|arg0
operator|&=
operator|(
literal|1
operator|<<
name|arithwidth
operator|)
operator|-
literal|1
expr_stmt|;
name|arg1
operator|&=
operator|(
literal|1
operator|<<
name|arithwidth
operator|)
operator|-
literal|1
expr_stmt|;
name|arg0s
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|arg0s
operator|&
operator|(
literal|1
operator|<<
operator|(
name|arithwidth
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg0s
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|arithwidth
operator|)
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|arg1s
operator|&
operator|(
literal|1
operator|<<
operator|(
name|arithwidth
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg1s
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|arithwidth
operator|)
expr_stmt|;
block|}
else|else
block|{
name|arg0s
operator|=
name|arg0
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
block|}
comment|/* Compute the value of the arithmetic.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|val
operator|=
name|arg0
operator|+
name|arg1
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|val
operator|=
name|arg0
operator|-
name|arg1
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|val
operator|=
name|arg0s
operator|*
name|arg1s
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|val
operator|=
name|arg0s
operator|/
name|arg1s
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|val
operator|=
name|arg0s
operator|%
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMULT
case|:
name|val
operator|=
operator|(
name|unsigned
operator|)
name|arg0
operator|*
name|arg1
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|val
operator|=
operator|(
name|unsigned
operator|)
name|arg0
operator|/
name|arg1
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|val
operator|=
operator|(
name|unsigned
operator|)
name|arg0
operator|%
name|arg1
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|val
operator|=
name|arg0
operator|&
name|arg1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|val
operator|=
name|arg0
operator||
name|arg1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|val
operator|=
name|arg0
operator|^
name|arg1
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|val
operator|=
name|arg0
operator|!=
name|arg1
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|val
operator|=
name|arg0
operator|==
name|arg1
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|val
operator|=
name|arg0s
operator|<=
name|arg1s
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|val
operator|=
name|arg0s
operator|<
name|arg1s
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|val
operator|=
name|arg0s
operator|>=
name|arg1s
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|val
operator|=
name|arg0s
operator|>
name|arg1s
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|<=
operator|(
operator|(
name|unsigned
operator|)
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|<
operator|(
operator|(
name|unsigned
operator|)
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|>=
operator|(
operator|(
name|unsigned
operator|)
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|>
operator|(
operator|(
name|unsigned
operator|)
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
comment|/* If target machine uses negative shift counts 	     but host machine does not, simulate them.  */
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|>>
operator|-
name|arg1
expr_stmt|;
else|else
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|<<
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
name|val
operator|=
name|arg0s
operator|>>
operator|-
name|arg1
expr_stmt|;
else|else
name|val
operator|=
name|arg0s
operator|<<
name|arg1
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
name|arg1
operator|=
operator|-
name|arg1
expr_stmt|;
case|case
name|ROTATE
case|:
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|arg1
operator|>
literal|0
condition|)
block|{
name|arg1
operator|%=
name|size
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|<<
name|arg1
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|>>
operator|(
name|size
operator|-
name|arg1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
block|{
name|arg1
operator|=
operator|(
operator|-
name|arg1
operator|)
operator|%
name|size
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|>>
name|arg1
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|<<
operator|(
name|size
operator|-
name|arg1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|arg0
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFTRT
case|:
comment|/* If target machine uses negative shift counts 	     but host machine does not, simulate them.  */
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|<<
operator|-
name|arg1
expr_stmt|;
else|else
name|val
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arg0
operator|)
operator|>>
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
name|val
operator|=
name|arg0s
operator|<<
operator|-
name|arg1
expr_stmt|;
else|else
name|val
operator|=
name|arg0s
operator|>>
name|arg1
expr_stmt|;
break|break;
default|default:
return|return
name|x
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
operator|&&
name|const_arg0
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|prev_insn_explicit_cc0
operator|!=
literal|0
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|prev_insn_explicit_cc0
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
if|if
condition|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|const_arg1
operator|!=
literal|0
operator|&&
name|const_arg2
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|const_arg2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Extracting a bit-field from a constant */
name|val
operator|=
name|INTVAL
argument_list|(
name|const_arg0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
name|val
operator|>>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|const_arg2
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|val
operator|>>=
name|INTVAL
argument_list|(
name|const_arg2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|HOST_BITS_PER_INT
operator|!=
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
condition|)
block|{
comment|/* First zero-extend.  */
name|val
operator|&=
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If desired, propagate sign bit.  */
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|&&
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|~
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|x
return|;
block|}
else|else
return|return
name|x
return|;
comment|/* Clear the bits that don't belong in our mode,      unless they and our sign bit are all one.      So we get either a reasonable negative value or a reasonable      unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Now make the new constant.  */
block|{
name|rtx
name|new
init|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
decl_stmt|;
return|return
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|new
argument_list|)
condition|?
name|new
else|:
name|x
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a constant value currently equivalent to X.    Return 0 if we don't know one.  */
end_comment

begin_function
specifier|static
name|rtx
name|equiv_constant
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|tem1
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|tem1
operator|=
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|]
operator|)
operator|!=
literal|0
comment|/* Make sure it is really a constant */
operator|&&
name|GET_CODE
argument_list|(
name|tem1
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|tem1
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|tem1
return|;
comment|/* If integer truncation is being done with SUBREG,      we can compute the result.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|tem1
operator|=
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
index|]
operator|)
operator|!=
literal|0
comment|/* Make sure it is a known integer.  */
operator|&&
name|GET_CODE
argument_list|(
name|tem1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
comment|/* Make sure this SUBREG is truncation.  */
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|value
init|=
name|INTVAL
argument_list|(
name|tem1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|HOST_BITS_PER_INT
condition|)
name|value
operator|&=
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|INTVAL
argument_list|(
name|tem1
argument_list|)
condition|)
return|return
name|tem1
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|value
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression X which is used to set CC0,    return an integer recording (in the encoding used for prev_insn_cc0)    how the condition codes would be set by that expression.    Return 0 if the value is not constant    or if there is any doubt what condition codes result from it.     MODE is the machine mode to use to interpret X if it is a CONST_INT.  */
end_comment

begin_function
specifier|static
name|int
name|fold_cc0
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|rtx
name|y0
init|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|u0
decl_stmt|,
name|u1
decl_stmt|,
name|s0
decl_stmt|,
name|s1
decl_stmt|;
name|enum
name|machine_mode
name|m
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|m
operator|=
name|GET_MODE
argument_list|(
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|VOIDmode
condition|)
name|m
operator|=
name|GET_MODE
argument_list|(
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|equiv_constant
argument_list|(
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|y0
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|y0
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|equiv_constant
argument_list|(
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|y1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|y1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compare floats; report the result only for signed compares 	 since that's all there are for floats.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|y0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|union
name|real_extract
name|u0
decl_stmt|,
name|u1
decl_stmt|;
name|int
name|value
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"floating point trap in constant folding"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|y0
argument_list|)
argument_list|,
operator|&
name|u0
argument_list|,
sizeof|sizeof
name|u0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|y1
argument_list|)
argument_list|,
operator|&
name|u1
argument_list|,
sizeof|sizeof
name|u1
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0100
operator|+
operator|(
name|REAL_VALUES_LESS
argument_list|(
name|u0
operator|.
name|d
argument_list|,
name|u1
operator|.
name|d
argument_list|)
condition|?
literal|7
operator|<<
literal|3
else|:
name|REAL_VALUES_LESS
argument_list|(
name|u1
operator|.
name|d
argument_list|,
name|u0
operator|.
name|d
argument_list|)
condition|?
literal|1
operator|<<
literal|3
else|:
literal|0
operator|)
expr_stmt|;
name|set_float_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* Aside from that, demand explicit integers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|s0
operator|=
name|u0
operator|=
name|INTVAL
argument_list|(
name|y0
argument_list|)
expr_stmt|;
name|s1
operator|=
name|u1
operator|=
name|INTVAL
argument_list|(
name|y1
argument_list|)
expr_stmt|;
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
block|{
name|s0
operator|=
name|u0
operator|&=
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|width
operator|)
expr_stmt|;
name|s1
operator|=
name|u1
operator|&=
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|u0
operator|&
operator|(
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|s0
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|u1
operator|&
operator|(
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|s1
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
block|}
return|return
literal|0100
operator|+
operator|(
operator|(
name|s0
operator|<
name|s1
condition|?
literal|7
else|:
name|s0
operator|>
name|s1
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|u0
operator|<
operator|(
name|unsigned
operator|)
name|u1
operator|)
condition|?
literal|7
else|:
operator|(
operator|(
name|unsigned
operator|)
name|u0
operator|>
operator|(
name|unsigned
operator|)
name|u1
operator|)
operator|)
return|;
block|}
block|{
name|rtx
name|y0
decl_stmt|;
name|int
name|u0
decl_stmt|,
name|s0
decl_stmt|;
name|enum
name|machine_mode
name|m
decl_stmt|;
name|y0
operator|=
name|fold_rtx
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|=
name|GET_MODE
argument_list|(
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|VOIDmode
condition|)
name|m
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|==
name|REG
condition|)
name|y0
operator|=
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|y0
argument_list|)
index|]
index|]
expr_stmt|;
comment|/* Register had no constant equivalent?  We can't do anything.  */
if|if
condition|(
name|y0
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we don't know the mode, we can't test the sign.  */
if|if
condition|(
name|m
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Value is frame-pointer plus a constant?  Or non-explicit constant?        That isn't zero, but we don't know its sign.  */
if|if
condition|(
name|FIXED_BASE_PLUS_P
argument_list|(
name|y0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|0300
operator|+
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|+
literal|1
return|;
comment|/* Otherwise, only integers enable us to optimize.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y0
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|s0
operator|=
name|u0
operator|=
name|INTVAL
argument_list|(
name|y0
argument_list|)
expr_stmt|;
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
block|{
name|s0
operator|=
name|u0
operator|&=
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|u0
operator|&
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|m
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|s0
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
return|return
literal|0100
operator|+
operator|(
operator|(
name|s0
operator|<
literal|0
condition|?
literal|7
else|:
name|s0
operator|>
literal|0
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
name|u0
operator|!=
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to prove that a loop will be executed>= 1 times,    or prove it will be executed 0 times.    If either can be proved, delete some of the code.  */
end_comment

begin_function
specifier|static
name|void
name|predecide_loop_entry
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|jump
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
specifier|register
name|rtx
name|loop_top_label
init|=
name|NEXT_INSN
argument_list|(
name|jump
argument_list|)
decl_stmt|;
enum|enum
name|anon1
block|{
name|UNK
block|,
name|DELETE_LOOP
block|,
name|DELETE_JUMP
block|}
name|disposition
init|=
name|UNK
enum|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Give up if we don't find a jump that enters the loop.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return;
comment|/* Find the label at the top of the loop.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|loop_top_label
argument_list|)
operator|==
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|loop_top_label
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|loop_top_label
operator|=
name|NEXT_INSN
argument_list|(
name|loop_top_label
argument_list|)
expr_stmt|;
comment|/* No label?  Give up.  */
if|if
condition|(
name|loop_top_label
operator|==
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|loop_top_label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the label at which the loop is entered.  */
name|p
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Trace the flow of control through the end test,      propagating constants, to see if result is determined.  */
name|prev_insn_cc0
operator|=
literal|0
expr_stmt|;
name|prev_insn_explicit_cc0
operator|=
literal|0
expr_stmt|;
comment|/* Avoid infinite loop if we find a cycle of jumps.  */
while|while
condition|(
name|count
operator|<
literal|10
condition|)
block|{
comment|/* At end of function?  Means rtl is inconsistent, 	 but this can happen when stmt.c gets confused 	 by a syntax error.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
break|break;
comment|/* Arriving at end of loop means endtest will drop out.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
block|{
name|disposition
operator|=
name|DELETE_LOOP
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
empty_stmt|;
comment|/* We only know how to handle two kinds of insns: 	 conditional jumps, and those that set the condition codes. */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|prev_insn_cc0
operator|=
name|fold_cc0
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|prev_insn_explicit_cc0
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
specifier|register
name|rtx
name|target
init|=
name|fold_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|!=
name|pc_rtx
condition|)
comment|/* If destination of jump is not fixed, give up.  */
break|break;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Any other kind of insn means we don't know 	 what result the test will have.  */
else|else
break|break;
comment|/* Arriving at top of loop means we can drop straight in. 	 Check here because we can arrive only via a jump insn 	 which would have changed P above.  */
if|if
condition|(
name|p
operator|==
name|loop_top_label
condition|)
block|{
name|disposition
operator|=
name|DELETE_JUMP
expr_stmt|;
break|break;
block|}
comment|/* We went past one insn; consider the next.  */
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disposition
operator|==
name|DELETE_JUMP
condition|)
block|{
comment|/* We know the loop test will succeed the first time, 	 so delete the jump to the test; drop right into loop. 	 Note that one call to delete_insn gets the BARRIER as well.  */
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disposition
operator|==
name|DELETE_LOOP
condition|)
block|{
comment|/* We know the endtest will fail and drop right out of the loop, 	 but it isn't safe to delete the loop here. 	 There could be jumps into it from outside. 	 So make the entry-jump jump around the loop. 	 This will cause find_basic_blocks to delete it if appropriate.  */
specifier|register
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|redirect_jump
argument_list|(
name|jump
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* CSE processing for one instruction.    First simplify sources and addresses of all assignments    in the instruction, using previously-computed equivalents values.    Then install the new sources and destinations in the table    of available values.  */
end_comment

begin_comment
comment|/* Data on one SET contained in the instruction.  */
end_comment

begin_struct
struct|struct
name|set
block|{
comment|/* The SET rtx itself.  */
name|rtx
name|rtl
decl_stmt|;
comment|/* The hash-table element for the SET_SRC of the SET.  */
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
comment|/* Hash code for the SET_SRC.  */
name|int
name|src_hash_code
decl_stmt|;
comment|/* Hash code for the SET_DEST.  */
name|int
name|dest_hash_code
decl_stmt|;
comment|/* The SET_DEST, with SUBREG, etc., stripped.  */
name|rtx
name|inner_dest
decl_stmt|;
comment|/* Place where the pointer to the INNER_DEST was found.  */
name|rtx
modifier|*
name|inner_dest_loc
decl_stmt|;
comment|/* Nonzero if the SET_SRC is in memory.  */
name|char
name|src_in_memory
decl_stmt|;
comment|/* Nonzero if the SET_SRC is in a structure.  */
name|char
name|src_in_struct
decl_stmt|;
comment|/* Nonzero if the SET_SRC contains something      whose value cannot be predicted and understood.  */
name|char
name|src_volatile
decl_stmt|;
comment|/* Original machine mode, in case it becomes a CONST_INT.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cse_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|n_sets
init|=
literal|0
decl_stmt|;
comment|/* Records what this insn does to set CC0,      using same encoding used for prev_insn_cc0.  */
name|int
name|this_insn_cc0
init|=
literal|0
decl_stmt|;
comment|/* Likewise, what to store in prev_insn_explicit_cc0.  */
name|rtx
name|this_insn_explicit_cc0
init|=
literal|0
decl_stmt|;
name|struct
name|write_data
name|writes_memory
decl_stmt|;
specifier|static
name|struct
name|write_data
name|init
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|rtx
name|src_eqv
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_eqv_elt
init|=
literal|0
decl_stmt|;
name|int
name|src_eqv_in_memory
decl_stmt|;
name|int
name|src_eqv_in_struct
decl_stmt|;
name|int
name|src_eqv_hash_code
decl_stmt|;
name|struct
name|set
modifier|*
name|sets
decl_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
name|writes_memory
operator|=
name|init
expr_stmt|;
comment|/* Find all the SETs and CLOBBERs in this instruction.      Record all the SETs in the array `set' and count them.      Also determine whether there is a CLOBBER that invalidates      all memory references, or all references at varying addresses.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|n_sets
operator|=
literal|1
expr_stmt|;
name|sets
operator|=
operator|(
expr|struct
name|set
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Store the equivalent value (re REG_EQUAL or REG_EQUIV) in SRC_EQV.  */
name|tem
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|tem
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|src_eqv
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ignore the REG_EQUAL or REG_EQUIV note if its contents 	     are the same as the source.  */
if|if
condition|(
name|src_eqv
operator|&&
name|rtx_equal_p
argument_list|(
name|src_eqv
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|src_eqv
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Return now for unconditional jumps. 	 They never need cse processing, so this does not hurt. 	 The reason is not efficiency but rather 	 so that we can test at the end for instructions 	 that have been simplified to unconditional jumps 	 and not be misled by unchanged instructions 	 that were unconditional jumps to begin with.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return;
comment|/* Return now for call-insns, (set (reg 0) (call ...)). 	 The hard function value register is used only once, to copy to 	 someplace else, so it isn't worth cse'ing (and on 80386 is unsafe)! */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|lim
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sets
operator|=
operator|(
expr|struct
name|set
operator|*
operator|)
name|alloca
argument_list|(
name|lim
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find all regs explicitly clobbered in this insn, 	 and ensure they are not replaced with any other regs 	 elsewhere in this insn. 	 When a reg that is clobbered is also used for input, 	 we should presume that that is for a reason, 	 and we should not substitute some other register 	 which is not supposed to be clobbered.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SET
condition|)
name|sets
index|[
name|n_sets
operator|++
index|]
operator|.
name|rtl
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
comment|/* If we clobber memory, take note of that, 		 and canon the address. 		 This does nothing when a register is clobbered 		 because we have already invalidated the reg.  */
name|canon_reg
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|note_mem_written
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|writes_memory
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|USE
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|canon_reg
argument_list|(
name|y
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CALL
condition|)
name|canon_reg
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|note_mem_written
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|writes_memory
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|canon_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_sets
operator|==
literal|0
condition|)
block|{
name|invalidate_from_clobbers
argument_list|(
operator|&
name|writes_memory
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Canonicalize sources and addresses of destinations.      set sets[i].src_elt to the class each source belongs to.      Detect assignments from or to volatile things      and set set[i] to zero so they will be ignored      in the rest of this function.       Nothing in this loop changes the hash table or the register chains.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* If SRC is a constant that has no machine mode, 	 hash it with the destination's machine mode. 	 This way we can keep different modes separate.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|dest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
comment|/* Replace each registers in SRC with oldest equivalent register, 	 but if DEST is a register do not replace it if it appears in SRC.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|tem
init|=
name|reg_qty
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
decl_stmt|;
name|reg_qty
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|src
operator|=
name|canon_reg
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_eqv
condition|)
name|src_eqv
operator|=
name|canon_reg
argument_list|(
name|src_eqv
argument_list|)
expr_stmt|;
name|reg_qty
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|tem
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|canon_reg
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_eqv
condition|)
name|src_eqv
operator|=
name|canon_reg
argument_list|(
name|src_eqv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_eqv
condition|)
block|{
name|enum
name|machine_mode
name|eqvmode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|eqvmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|src_eqv
operator|=
name|fold_rtx
argument_list|(
name|src_eqv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src_eqv_hash_code
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
comment|/* Replace the src_eqv with its cheapest equivalent.  */
if|if
condition|(
operator|!
name|do_not_record
condition|)
block|{
name|elt
operator|=
name|lookup
argument_list|(
name|src_eqv
argument_list|,
name|src_eqv_hash_code
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|elt
operator|!=
name|elt
operator|->
name|first_same_value
condition|)
block|{
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
comment|/* Find the cheapest one that is still valid.  */
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
name|elt
operator|->
name|equivalence_only
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|src_eqv
operator|=
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|src_eqv_hash_code
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
name|src_eqv_elt
operator|=
name|elt
expr_stmt|;
block|}
else|else
name|src_eqv
operator|=
literal|0
expr_stmt|;
name|src_eqv_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|src_eqv_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
block|}
comment|/* Compute SRC's hash code, and also notice if it 	 should not be recorded at all.  In that case, 	 prevent any further processing of this assignment.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|src
operator|=
name|fold_rtx
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If SRC is a subreg of a reg with a known value, 	 perform the truncation now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|temp
init|=
name|equiv_constant
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|src
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If we have (NOT Y), see if Y is known to be (NOT Z). 	 If so, (NOT Y) simplifies to Z.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|NOT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
name|src
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If storing a constant value in a register that 	 previously held the constant value 0, 	 record this fact with a REG_WAS_0 note on this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
index|]
operator|==
name|const0_rtx
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_WAS_0
argument_list|,
name|qty_const_insn
index|[
name|reg_qty
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
name|do_not_record
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code caused multiple hash-table entries 	 to be created for registers.  Invalidation 	 would only get one, leaving others that didn't belong. 	 I don't know what good this ever did.  */
block|if (GET_CODE (src) == REG) 	{ 	  sets[i].src_in_memory = 0; 	  sets[i].src_elt = 0; 	}       else ...;
endif|#
directive|endif
comment|/* If source is a perverse subreg (such as QI treated as an SI), 	 treat it as volatile.  It may do the work of an SI in one context 	 where the extra bits are not being used, but cannot replace an SI 	 in general.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
condition|)
block|{
comment|/* Replace the source with its cheapest equivalent.  */
name|elt
operator|=
name|lookup
argument_list|(
name|src
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|elt
operator|!=
name|elt
operator|->
name|first_same_value
condition|)
block|{
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
comment|/* Find the cheapest one that is still valid.  */
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
name|elt
operator|->
name|equivalence_only
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
comment|/* Don't replace with things that are not likely to be valid, 		 such as arithmetic expressions, unless the destination is 		 a register.  */
if|if
condition|(
name|general_operand
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|VOIDmode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src
operator|=
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If ELT is a constant, is there a register 	     linearly related to it?  If so, replace it 	     with the sum of that register plus an offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
operator|&&
name|n_sets
operator|==
literal|1
operator|&&
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|!=
name|cc0_rtx
condition|)
block|{
name|rtx
name|newsrc
init|=
name|use_related_value
argument_list|(
name|src
argument_list|,
name|elt
argument_list|)
decl_stmt|;
if|if
condition|(
name|newsrc
operator|==
literal|0
operator|&&
name|src_eqv
operator|!=
literal|0
condition|)
name|newsrc
operator|=
name|use_related_value
argument_list|(
name|src_eqv
argument_list|,
name|src_eqv_elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsrc
condition|)
block|{
name|rtx
name|oldsrc
init|=
name|src
decl_stmt|;
name|src
operator|=
name|newsrc
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The new expression for the SRC has the same value 		     as the previous one; so if the previous one is in 		     the hash table, put the new one in as equivalent.  */
if|if
condition|(
name|elt
operator|!=
literal|0
condition|)
name|elt
operator|=
name|insert
argument_list|(
name|src
argument_list|,
name|elt
operator|->
name|first_same_value
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Maybe the new expression is in the table already.  */
name|elt
operator|=
name|lookup
argument_list|(
name|src
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* And maybe a register contains the same value.  */
if|if
condition|(
name|elt
operator|&&
name|elt
operator|!=
name|elt
operator|->
name|first_same_value
condition|)
block|{
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
comment|/* Find the cheapest one that is still valid.  */
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
name|elt
operator|->
name|equivalence_only
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|src
operator|=
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This would normally be inhibited by the REG_EQUIV 		     note we are about to make.  */
if|#
directive|if
literal|0
comment|/* Deleted because the inhibition was deleted.  */
block|SET_SRC (sets[i].rtl) = src;
endif|#
directive|endif
comment|/* Record the actual constant value 		     in a REG_EQUIV or REG_EQUAL note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* A REG_EQUIV note means the dest never changes. 			 Don't put one on unless there is already one.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|oldsrc
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|oldsrc
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
block|}
comment|/* Either canon_reg or the copy_rtx may have changed this.  */
comment|/* Note it is not safe to replace the sources if there 	 is more than one set.  We could get an insn 	 [(set (reg) (reg)) (set (reg) (reg))], which is probably 	 not in the machine description. 	 This case we could handle by breaking into several insns. 	 Cases of partial substitution cannot win at all.  */
comment|/* Also, if this insn is setting a "constant" register, 	 we may not replace the value that is given to it.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
condition|)
if|#
directive|if
literal|0
comment|/* Now that the REG_EQUIV contains the constant instead of the reg, 	   it should be ok to modify the insn's actual source.  */
then|if (REG_NOTES (insn) == 0 	    || REG_NOTE_KIND (REG_NOTES (insn)) != REG_EQUIV)
endif|#
directive|endif
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|src
expr_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest_loc
operator|=
operator|&
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* Look within any SIGN_EXTRACT or ZERO_EXTRACT 	 to the MEM or REG within it.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest_loc
operator|=
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest_loc
operator|=
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
operator|=
name|dest
expr_stmt|;
comment|/* If storing into memory, do cse on the memory address. 	 Also compute the hash code of the destination now, 	 before the effects of this instruction are recorded, 	 since the register values used in the address computation 	 are those before this instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|addr
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
name|canon_reg
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|=
name|fold_rtx
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pushing or popping does not invalidate anything.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
empty_stmt|;
else|else
comment|/* Otherwise, decide whether we invalidate 	       everything in memory, or just things at non-fixed places. 	       Writing a large aggregate must invalidate everything 	       because we don't know how long it is.  */
name|note_mem_written
argument_list|(
name|dest
argument_list|,
operator|&
name|writes_memory
argument_list|)
expr_stmt|;
comment|/* Do not try to replace addresses of local and argument slots. 	     The MEM expressions for args and non-register local variables 	     are made only once and inserted in many instructions, 	     as well as being used to control symbol table output. 	     It is not safe to clobber them.  It also doesn't do any good!  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|hash
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|hash
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|hash
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|hash
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|,
name|hash
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|hash
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash_code
operator|=
operator|(
operator|(
name|int
operator|)
name|MEM
operator|+
name|canon_hash
argument_list|(
name|addr
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
operator|%
name|NBUCKETS
expr_stmt|;
else|else
block|{
comment|/* Look for a simpler equivalent for the destination address.  */
name|hash
operator|=
name|HASH
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_not_record
condition|)
block|{
name|elt
operator|=
name|lookup
argument_list|(
name|addr
argument_list|,
name|hash
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash_code
operator|=
operator|(
operator|(
name|int
operator|)
name|MEM
operator|+
name|hash
operator|)
operator|%
name|NBUCKETS
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|elt
operator|!=
name|elt
operator|->
name|first_same_value
condition|)
block|{
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
comment|/* Find the cheapest one that is still valid.  */
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
name|elt
operator|->
name|equivalence_only
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|addr
operator|=
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
comment|/* Create a new MEM rtx, in case the old one 			 is shared somewhere else.  */
name|dest
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|dest
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|dest
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
expr_stmt|;
operator|*
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest_loc
operator|=
name|dest
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
operator|=
name|dest
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Don't enter a bit-field in the hash table 	 because the value in it after the store 	 may not equal what was stored, due to truncation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|rtx
name|width
init|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|value
init|=
name|equiv_constant
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|width
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|width
argument_list|)
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|!
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|&
operator|(
operator|-
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|width
argument_list|)
operator|)
condition|)
comment|/* Exception: if the value is constant, 	       we can tell whether truncation would change it.  */
empty_stmt|;
else|else
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
literal|1
operator|,
name|src_eqv
operator|=
literal|0
expr_stmt|;
block|}
comment|/* No further processing for this assignment 	 if destination is volatile or if the source and destination 	 are the same.  */
elseif|else
if|if
condition|(
name|do_not_record
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
else|:
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|!=
literal|0
operator|&&
name|dest
operator|!=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash_code
operator|=
name|HASH
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
operator|||
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|)
condition|)
name|this_insn_cc0
operator|=
name|fold_cc0
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
name|this_insn_explicit_cc0
operator|=
name|src
expr_stmt|;
block|}
comment|/* Now enter all non-volatile source expressions in the hash table      if they are not already present.      Record in src_elt the heads of their equivalence classes.      This way we can insert the corresponding destinations into      the same classes even if the actual sources are no longer in them      (having been invalidated).  */
if|if
condition|(
name|src_eqv
operator|&&
name|src_eqv_elt
operator|==
literal|0
operator|&&
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|!=
literal|0
condition|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|eqvmode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|eqvmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_regs
argument_list|(
name|src_eqv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|src_eqv_hash_code
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
name|elt
operator|=
name|insert
argument_list|(
name|src_eqv
argument_list|,
literal|0
argument_list|,
name|src_eqv_hash_code
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|src_eqv_in_memory
expr_stmt|;
name|elt
operator|->
name|in_struct
operator|=
name|src_eqv_in_struct
expr_stmt|;
name|elt
operator|->
name|equivalence_only
operator|=
literal|1
expr_stmt|;
name|src_eqv_elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|&&
operator|!
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
comment|/* REG_EQUAL in setting a STRICT_LOW_PART 	       gives an equivalent for the entire destination register, 	       not just for the subreg being stored in now. 	       This is a more interesting equivalent, so we arrange later 	       to treat the entire reg as the destination.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
operator|=
name|src_eqv_hash_code
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|dest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* Note that these insert_regs calls cannot remove 	       any of the src_elt's, because they would have failed to match 	       if not still valid.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|elt
operator|=
name|insert
argument_list|(
name|src
argument_list|,
name|src_eqv_elt
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash_code
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
expr_stmt|;
name|elt
operator|->
name|in_struct
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_in_struct
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
block|}
block|}
name|invalidate_from_clobbers
argument_list|(
operator|&
name|writes_memory
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Now invalidate everything set by this instruction.      If a SUBREG or other funny destination is being set,      sets[i].rtl is still nonzero, so here we invalidate the reg      a part of which is being set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
decl_stmt|;
comment|/* Needed for registers to remove the register from its 	   previous quantity's chain. 	   Needed for memory if this is a nonvarying address, unless 	   we have just done an invalidate_memory that covers even those.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
operator|!
name|writes_memory
operator|.
name|all
operator|&&
operator|!
name|cse_rtx_addr_varies_p
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure registers mentioned in destinations      are safe for use in an expression to be inserted.      This removes from the hash table      any invalid entry that refers to one of these registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|mention_regs
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We may have just removed some of the src_elt's from the hash table.      So replace each one with the current head of the same class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
comment|/* If the source is volatile, its destination goes in 	   a class of its own.  */
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|->
name|first_same_value
operator|==
literal|0
condition|)
comment|/* If elt was removed, find current head of same class, 	     or 0 if nothing remains of that class.  */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
init|=
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
decl_stmt|;
while|while
condition|(
name|elt
operator|&&
name|elt
operator|->
name|first_same_value
operator|==
literal|0
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
condition|?
name|elt
operator|->
name|first_same_value
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now insert the destinations into their equivalence classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|flag_float_store
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|DFmode
operator|)
condition|)
continue|continue;
comment|/* STRICT_LOW_PART isn't part of the value BEING set, 	   and neither is the SUBREG inside it. 	   Note that in this case SETS[I].SRC_ELT is really SRC_EQV_ELT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
comment|/* Registers must also be inserted into chains for quantities.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* If `insert_regs' changes something, the hash code must be 	       recalculated.  */
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash_code
operator|=
name|HASHREG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
comment|/* Registers must also be inserted into chains for quantities.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* If `insert_regs' changes something, the hash code must be 	       recalculated.  */
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash_code
operator|=
name|canon_hash
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|%
name|NBUCKETS
expr_stmt|;
name|elt
operator|=
name|insert
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash_code
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|==
name|MEM
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|in_memory
condition|)
block|{
name|elt
operator|->
name|in_struct
operator|=
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|||
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
operator|!=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* Special handling for (set REG0 REG1)      where REG0 is the "cheapest", cheaper than REG1.      After cse, REG1 will probably not be used in the sequel,       so (if easily done) change this insn to (set REG1 REG0) and      replace REG1 with REG0 in the previous insn that computed their value.      Then REG1 will become a dead store and won't cloud the situation      for later optimizations.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|prev
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|=
name|dest
expr_stmt|;
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|dest
expr_stmt|;
comment|/* If REG1 was equivalent to a constant, REG0 is not.  */
if|if
condition|(
name|note
condition|)
name|PUT_MODE
argument_list|(
name|note
argument_list|,
name|REG_EQUAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Did this insn become an unconditional branch or become a no-op?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
comment|/* If previous insn just set CC0 for us, delete it too.  */
if|if
condition|(
name|prev_insn_cc0
operator|!=
literal|0
operator|||
name|prev_insn_explicit_cc0
operator|!=
literal|0
condition|)
block|{
name|PUT_CODE
argument_list|(
name|prev_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* One less use of the label this insn used to jump to.  */
operator|--
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
comment|/* If previous insn just set CC0 for us, delete it too.  */
if|if
condition|(
name|prev_insn_cc0
operator|!=
literal|0
operator|||
name|prev_insn_explicit_cc0
operator|!=
literal|0
condition|)
block|{
name|PUT_CODE
argument_list|(
name|prev_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If jump target is the following label, and this is only use of it, 	     skip direct to that label and continue optimizing there.  */
name|label
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|label
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|label
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|==
literal|1
condition|)
name|cse_skip_to_next_block
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this insn used to store a value based on CC0 but now value is constant,      and the previous insn just set CC0 for us, delete previous insn.      Here we use the fact that nothing expects CC0 to be valid over an insn,      which is true until the final pass.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|prev_insn_cc0
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|prev_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|prev_insn_explicit_cc0
operator|=
name|this_insn_explicit_cc0
expr_stmt|;
name|prev_insn_cc0
operator|=
name|this_insn_cc0
expr_stmt|;
name|prev_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store 1 in *WRITES_PTR for those categories of memory ref    that must be invalidated when the expression WRITTEN is stored in.    If WRITTEN is null, say everything must be invalidated.  */
end_comment

begin_function
specifier|static
name|void
name|note_mem_written
parameter_list|(
name|written
parameter_list|,
name|writes_ptr
parameter_list|)
name|rtx
name|written
decl_stmt|;
name|struct
name|write_data
modifier|*
name|writes_ptr
decl_stmt|;
block|{
specifier|static
name|struct
name|write_data
name|everything
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
operator|*
name|writes_ptr
operator|=
name|everything
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|written
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Pushing or popping the stack invalidates nothing.  */
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|written
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
if|if
condition|(
name|GET_MODE
argument_list|(
name|written
argument_list|)
operator|==
name|BLKmode
condition|)
operator|*
name|writes_ptr
operator|=
name|everything
expr_stmt|;
elseif|else
if|if
condition|(
name|cse_rtx_addr_varies_p
argument_list|(
name|written
argument_list|)
condition|)
block|{
comment|/* A varying address that is a sum indicates an array element, 	     and that's just as good as a structure element 	     in implying that we need not invalidate scalar variables.  */
if|if
condition|(
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|written
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|written
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
name|writes_ptr
operator|->
name|all
operator|=
literal|1
expr_stmt|;
name|writes_ptr
operator|->
name|nonscalar
operator|=
literal|1
expr_stmt|;
block|}
name|writes_ptr
operator|->
name|var
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform invalidation on the basis of everything about an insn    except for invalidating the actual places that are SET in it.    This includes the places CLOBBERed, and anything that might    alias with something that is SET or CLOBBERed.     W points to the writes_memory for this insn, a struct write_data    saying which kinds of memory references must be invalidated.    X is the pattern of the insn.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_from_clobbers
parameter_list|(
name|w
parameter_list|,
name|x
parameter_list|)
name|struct
name|write_data
modifier|*
name|w
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
comment|/* If W->var is not set, W specifies no action.      If W->all is set, this step gets all memory refs      so they can be ignored in the rest of this function.  */
if|if
condition|(
name|w
operator|->
name|var
condition|)
name|invalidate_memory
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|ref
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|w
operator|->
name|all
operator|)
operator|)
condition|)
name|invalidate
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|ref
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|w
operator|->
name|all
operator|)
operator|)
condition|)
name|invalidate
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the end of INSN's basic block, and return the cuid of its last insn    and the total number of SETs in all the insns of the block.  */
end_comment

begin_struct
struct|struct
name|cse_basic_block_data
block|{
name|int
name|cuid
decl_stmt|,
name|nsets
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|cse_basic_block_data
name|cse_end_of_basic_block
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|p
init|=
name|insn
decl_stmt|;
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
name|int
name|nsets
init|=
literal|0
decl_stmt|;
name|int
name|last_uid
init|=
literal|0
decl_stmt|;
comment|/* Scan to end of this basic block.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Don't cse out the end of a loop.  This makes a difference 	 only for the unusual loops that always execute at least once; 	 all other loops have labels there so we will stop in any case. 	 Cse'ing out the end of the loop is dangerous because it 	 might cause an invariant expression inside the loop 	 to be reused after the end of the loop.  This would make it 	 hard to move the expression out of the loop in loop.c, 	 especially if it is one of several equivalent expressions 	 and loop.c would like to eliminate it. 	 The occasional optimizations lost by this will all come back 	 if loop and cse are made to work alternatingly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
comment|/* Don't cse over a call to setjmp; on some machines (eg vax) 	 the regs restored by the longjmp come from 	 a later time than the setjmp.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
break|break;
comment|/* A PARALLEL can have lots of SETs in it, 	 especially if it is really an ASM_OPERANDS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
name|nsets
operator|+=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|nsets
operator|+=
literal|1
expr_stmt|;
name|last_uid
operator|=
name|INSN_UID
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|cuid
operator|=
name|uid_cuid
index|[
name|last_uid
index|]
expr_stmt|;
name|val
operator|.
name|nsets
operator|=
name|nsets
expr_stmt|;
name|val
operator|.
name|last
operator|=
name|p
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|rtx
name|cse_basic_block
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Perform cse on the instructions of a function.    F is the first instruction.    NREGS is one plus the highest pseudo-reg number used in the instruction.     Returns 1 if jump_optimize should be redone due to simplifications    in conditional jump instructions.  */
end_comment

begin_function
name|int
name|cse_main
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
comment|/* f is the first instruction of a chain of insns for one function */
name|rtx
name|f
decl_stmt|;
comment|/* nregs is the total number of registers used in it */
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cse_jumps_altered
operator|=
literal|0
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|nregs
expr_stmt|;
name|all_minus_one
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|consec_ints
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|all_minus_one
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|consec_ints
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|reg_next_eqv
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_prev_eqv
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_qty
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_rtx
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_in_table
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_tick
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Discard all the free elements of the previous function      since they are allocated in the temporarily obstack.  */
name|bzero
argument_list|(
name|table
argument_list|,
sizeof|sizeof
name|table
argument_list|)
expr_stmt|;
name|free_element_chain
operator|=
literal|0
expr_stmt|;
name|n_elements_made
operator|=
literal|0
expr_stmt|;
comment|/* Find the largest uid.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|i
condition|)
name|i
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|uid_cuid
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|uid_cuid
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to cuids.      CUIDs are numbers assigned to insns, like uids,      except that cuids increase monotonically through the code.      Don't assign cuids to line-number NOTEs, so that the distance in cuids      between two insns is not affected by -g.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same cuid as preceding insn.  */
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
comment|/* Loop over basic blocks.      Compute the maximum number of qty's needed for each basic block      (which is 2 for each SET).  */
name|insn
operator|=
name|f
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
name|val
operator|=
name|cse_end_of_basic_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cse_basic_block_end
operator|=
name|val
operator|.
name|cuid
expr_stmt|;
name|cse_basic_block_start
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|max_qty
operator|=
name|val
operator|.
name|nsets
operator|*
literal|2
expr_stmt|;
comment|/* Make MAX_QTY bigger to give us room to optimize 	 past the end of this basic block, if that should prove useful.  */
if|if
condition|(
name|max_qty
operator|<
literal|500
condition|)
name|max_qty
operator|=
literal|500
expr_stmt|;
name|max_qty
operator|+=
name|max_reg
expr_stmt|;
name|insn
operator|=
name|cse_basic_block
argument_list|(
name|insn
argument_list|,
name|val
operator|.
name|last
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Tell refers_to_mem_p that qty_const info is not available.  */
name|qty_const
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_elements_made
operator|<
name|n_elements_made
condition|)
name|max_elements_made
operator|=
name|n_elements_made
expr_stmt|;
return|return
name|cse_jumps_altered
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|cse_basic_block
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|qv1
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|qv2
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|qv3
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|qty_first_reg
operator|=
name|qv1
expr_stmt|;
name|qty_last_reg
operator|=
name|qv2
expr_stmt|;
name|qty_const
operator|=
name|qv3
expr_stmt|;
name|qty_const_insn
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|new_basic_block
argument_list|()
expr_stmt|;
name|cse_skip_to_next_block
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|to
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
condition|)
name|cse_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Memory, and some registers, are invalidate by subroutine calls.  */
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|write_data
name|everything
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|invalidate_memory
argument_list|(
operator|&
name|everything
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|reg_rtx
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|ARG_POINTER_REGNUM
condition|)
name|invalidate
argument_list|(
name|reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Loop beginnings are often followed by jumps 	 (that enter the loop above the endtest). 	 See if we can prove the loop will be executed at least once; 	 if so, delete the jump.  Also perhaps we can prove loop 	 will never be executed and delete the entire thing.  */
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|predecide_loop_entry
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Whether that jump was deleted or not, 	     it certainly is the end of the basic block. 	     Since the jump is unconditional, 	     it requires no further processing here.  */
break|break;
block|}
comment|/* See if it is ok to keep on going past the label 	 which used to end our basic block.  */
if|if
condition|(
name|cse_skip_to_next_block
operator|||
operator|(
name|to
operator|!=
literal|0
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|to
operator|&&
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
comment|/* Skip the remaining insns in this block.  */
name|cse_skip_to_next_block
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
break|break;
comment|/* Find the end of the following block.  */
name|val
operator|=
name|cse_end_of_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the tables we allocated have enough space left 	     to handle all the SETs in the next basic block, 	     continue through it.  Otherwise, return, 	     and that block will be scanned individually.  */
if|if
condition|(
name|val
operator|.
name|nsets
operator|*
literal|2
operator|+
name|next_qty
operator|>
name|max_qty
condition|)
break|break;
name|cse_basic_block_end
operator|=
name|val
operator|.
name|cuid
expr_stmt|;
name|to
operator|=
name|val
operator|.
name|last
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next_qty
operator|>
name|max_qty
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|to
condition|?
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
else|:
literal|0
return|;
block|}
end_function

end_unit

