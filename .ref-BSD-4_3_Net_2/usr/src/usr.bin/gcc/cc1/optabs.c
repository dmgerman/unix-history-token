begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand the basic unary and binary arithmetic operations, for GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_comment
comment|/* In ANSI C we could write MODE + 1, but traditional C compilers    seem to reject it.  */
end_comment

begin_define
define|#
directive|define
name|INC_MODE
parameter_list|(
name|MODE
parameter_list|)
value|(enum machine_mode) ((int)(MODE) + 1)
end_define

begin_comment
comment|/* Each optab contains info on how this target machine    can perform a particular operation    for all sizes and kinds of operands.     The operation to be performed is often specified    by passing one of these optabs as an argument.     See expr.h for documentation of these optabs.  */
end_comment

begin_decl_stmt
name|optab
name|add_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sub_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smul_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umul_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smul_widen_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umul_widen_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sdiv_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|sdivmod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|udiv_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|udivmod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|smod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|umod_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|flodiv_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ftrunc_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|and_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|andcb_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ior_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|xor_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ashl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|lshr_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|lshl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ashr_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|rotl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|rotr_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|mov_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|movstrict_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|neg_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|abs_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|one_cmpl_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ffs_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|cmp_optab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|optab
name|ucmp_optab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used only for libcalls for unsigned comparisons.  */
end_comment

begin_decl_stmt
name|optab
name|tst_optab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the gen_function to make a branch to test that condition.  */
end_comment

begin_decl_stmt
name|rtxfun
name|bcc_gen_fctn
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the gen_function to make a store-condition insn    to test that condition.  */
end_comment

begin_decl_stmt
name|rtxfun
name|setcc_gen_fctn
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_binop
parameter_list|(
name|mode
parameter_list|,
name|binoptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|binoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We may get better code by generating the result in a register      when the target is not one of the operands.  */
block|if (target&& ! rtx_equal_p (target, op1)&& ! rtx_equal_p (target, op0))     target_is_not_an_operand = 1;
endif|#
directive|endif
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Record where to delete back to if we backtrack.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* If operation is commutative,      try to make the first operand a register.      Even better, try to make it the same as the target.      Also try to make the last operand a constant.  */
if|if
condition|(
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|umul_optab
operator|||
name|binoptab
operator|==
name|smul_widen_optab
operator|||
name|binoptab
operator|==
name|umul_widen_optab
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|)
condition|?
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|)
operator|||
name|target
operator|==
name|op1
operator|)
else|:
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|temp
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* If we can do it with a three-operand insn, do so.  */
if|if
condition|(
name|methods
operator|!=
name|OPTAB_MUST_WIDEN
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* In case the insn wants input operands in modes different from 	 the result, convert the operands.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|mode1
condition|)
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn requires register operands, put operands into regs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|xop1
argument_list|,
name|mode1
argument_list|)
condition|)
name|xop1
operator|=
name|force_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be open-coded in this mode.      Use a library call if one is available and caller says that's ok.  */
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
operator|&&
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|)
condition|)
block|{
name|rtx
name|insn_before
decl_stmt|,
name|insn_first
decl_stmt|,
name|insn_last
decl_stmt|;
name|rtx
name|funexp
init|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
argument_list|)
decl_stmt|;
comment|/* Pass the address through a pseudoreg, if desired, 	 before the "beginning" of the library call. 	 So this insn isn't "part of" the library call, in case that 	 is deleted, or cse'd.  */
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
operator|!
name|flag_no_function_cse
condition|)
name|funexp
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insn_before
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Cannot pass FUNEXP since emit_library_call insists 	 on getting a SYMBOL_REF.  But cse will make this SYMBOL_REF 	 be replaced with the copy we made just above.  */
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
argument_list|)
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
literal|2
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|target
operator|=
name|hard_libcall_value
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_before
operator|==
literal|0
condition|)
name|insn_first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|insn_first
operator|=
name|NEXT_INSN
argument_list|(
name|insn_before
argument_list|)
expr_stmt|;
name|insn_last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn_last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_RETVAL
argument_list|,
name|insn_first
argument_list|,
name|REG_NOTES
argument_list|(
name|insn_last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn_first
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_LIBCALL
argument_list|,
name|insn_last
argument_list|,
name|REG_NOTES
argument_list|(
name|insn_first
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
operator|!
operator|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_MUST_WIDEN
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Caller says, don't even try.  */
comment|/* Compute the value of METHODS to pass to recursive calls.      Don't allow widening to be tried recursively.  */
name|methods
operator|=
operator|(
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|?
name|OPTAB_LIB
else|:
name|OPTAB_DIRECT
operator|)
expr_stmt|;
comment|/* Widening is now independent of specific machine modes.      It is assumed that widening may be performed to any      higher numbered mode in the same mode class.  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|mode
argument_list|)
init|;
operator|(
operator|(
name|int
operator|)
name|wider_mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|wider_mode
argument_list|)
operator|==
name|class
operator|)
condition|;
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|lib_call
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 		 the narrow operands, as long as we will truncate 		 the results to the same narrowness.  */
if|if
condition|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|andcb_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|umul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|||
name|binoptab
operator|==
name|lshl_optab
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|no_extend
condition|)
block|{
name|temp
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|xop0
operator|=
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|no_extend
condition|)
block|{
name|temp
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|xop1
argument_list|)
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|wider_mode
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a binary operator which has both signed and unsigned forms.    UOPTAB is the optab for unsigned operations, and SOPTAB is for    signed operations.     If we widen unsigned operands, we may use a signed wider operation instead    of an unsigned wider operation, since the result would be the same.  */
end_comment

begin_function
name|rtx
name|sign_expand_binop
parameter_list|(
name|mode
parameter_list|,
name|uoptab
parameter_list|,
name|soptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|methods
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|uoptab
decl_stmt|,
name|soptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|optab_methods
name|methods
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|optab
name|direct_optab
init|=
name|unsignedp
condition|?
name|uoptab
else|:
name|soptab
decl_stmt|;
name|struct
name|optab
name|wide_soptab
decl_stmt|;
comment|/* Do it without widening, if possible.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_DIRECT
condition|)
return|return
name|temp
return|;
comment|/* Try widening to a signed int.  Make a fake signed optab that      hides any signed insn for direct use.  */
name|wide_soptab
operator|=
operator|*
name|soptab
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
comment|/* For unsigned operands, try widening to an unsigned int.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|unsignedp
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_WIDEN
condition|)
return|return
name|temp
return|;
comment|/* Use the right width lib call if that exists.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_LIB
condition|)
return|return
name|temp
return|;
comment|/* Must widen and use a lib call, use either signed or unsigned.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with two results to TARG1 and TARG2.    We assume that the order of the operands for the instruction    is TARG0, OP0, OP1, TARG1, which would fit a pattern like    [(set TARG0 (operate OP0 OP1)) (set TARG1 (operate ...))].     Either TARG0 or TARG1 may be zero, but what that means is that    that result is not actually wanted.  We will generate it into    a dummy pseudo-reg and discard it.  They may not both be zero.     Returns 1 if this operation can be performed; 0 if not.  */
end_comment

begin_function
name|int
name|expand_twoval_binop
parameter_list|(
name|binoptab
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|targ0
parameter_list|,
name|targ1
parameter_list|,
name|unsignedp
parameter_list|)
name|optab
name|binoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|targ0
decl_stmt|,
name|targ1
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|targ0
condition|?
name|targ0
else|:
name|targ1
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targ0
condition|)
name|targ0
operator|=
name|protect_from_queue
argument_list|(
name|targ0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|targ0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ1
condition|)
name|targ1
operator|=
name|protect_from_queue
argument_list|(
name|targ1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|targ1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|targ0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|targ1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|mode
argument_list|)
init|;
operator|(
operator|(
name|int
operator|)
name|wider_mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|wider_mode
argument_list|)
operator|==
name|class
operator|)
condition|;
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|expand_twoval_binop_convert
argument_list|(
name|binoptab
argument_list|,
name|wider_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|targ0
argument_list|,
name|targ1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|expand_twoval_binop_convert
parameter_list|(
name|binoptab
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|targ0
parameter_list|,
name|targ1
parameter_list|,
name|unsignedp
parameter_list|)
specifier|register
name|optab
name|binoptab
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|targ0
decl_stmt|,
name|targ1
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|t1
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
name|expand_twoval_binop
argument_list|(
name|binoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|targ0
argument_list|,
name|t0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|targ1
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by UNOPTAB    on operand OP0, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_unop
parameter_list|(
name|mode
parameter_list|,
name|unoptab
parameter_list|,
name|op0
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|optab
name|unoptab
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn requires register operands, put operands into regs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
condition|)
block|{
name|rtx
name|insn_before
decl_stmt|,
name|insn_last
decl_stmt|;
name|rtx
name|funexp
init|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
argument_list|)
decl_stmt|;
comment|/* Pass the address through a pseudoreg, if desired, 	 before the "beginning" of the library call (for deletion).  */
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
operator|!
name|flag_no_function_cse
condition|)
name|funexp
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insn_before
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Cannot pass FUNEXP since  emit_library_call insists 	 on getting a SYMBOL_REF.  But cse will make this SYMBOL_REF 	 be replaced with the copy we made just above.  */
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
argument_list|)
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|target
operator|=
name|hard_libcall_value
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|insn_last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn_last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_RETVAL
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn_before
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn_last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_before
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_LIBCALL
argument_list|,
name|insn_last
argument_list|,
name|REG_NOTES
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_before
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|mode
argument_list|)
init|;
operator|(
operator|(
name|int
operator|)
name|wider_mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|wider_mode
argument_list|)
operator|==
name|class
operator|)
condition|;
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|lib_call
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
block|}
name|target
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an instruction whose insn-code is INSN_CODE,    with two operands: an output TARGET and an input OP0.    TARGET *must* be nonzero, and the output is always stored there.    CODE is an rtx code such that (CODE OP0) is an rtx that describes    the value that is stored into TARGET.  */
end_comment

begin_function
name|void
name|emit_unop_insn
parameter_list|(
name|icode
parameter_list|,
name|target
parameter_list|,
name|op0
parameter_list|,
name|code
parameter_list|)
name|int
name|icode
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
name|temp
operator|=
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Now, if insn requires register operands, put operands into regs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|temp
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we just made a multi-insn sequence,      record in the last insn an equivalent expression for its value      and a pointer to the first insn.  This makes cse possible.  */
if|if
condition|(
name|code
operator|!=
name|UNKNOWN
operator|&&
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|prev_insn
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to store zero in X.  */
end_comment

begin_function
name|void
name|emit_clr_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to store 1 in X    assuming it contains zero beforehand.  */
end_comment

begin_function
name|void
name|emit_0_to_1_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to compare X with Y    so that the condition codes are set.     UNSIGNEDP nonzero says that X and Y are unsigned;    this matters if they need to be widened.     If they have mode BLKmode, then SIZE specifies the size of both X and Y,    and ALIGN specifies the known shared alignment of X and Y.  */
end_comment

begin_function
name|void
name|emit_cmp_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* They could both be VOIDmode if both args are immediate constants,      but we should fold that at an earlier stage.      With no special code here, this will call abort,      reminding the programmer to implement such folding.  */
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|flag_force_mem
condition|)
block|{
name|x
operator|=
name|force_not_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|force_not_mem
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* Handle all BLKmode compares.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpstrqi
if|if
condition|(
name|HAVE_cmpstrqi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_cmpstrqi
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrhi
if|if
condition|(
name|HAVE_cmpstrhi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_cmpstrhi
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
name|emit_insn
argument_list|(
name|gen_cmpstrsi
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcmp"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bcmp"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_cmp_insn
argument_list|(
name|hard_libcall_value
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Handle some compares against zero.  */
if|if
condition|(
name|y
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, if insn requires register operands, put operands into regs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle compares for which there is a directly suitable insn.  */
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, if insn requires register operands, put operands into regs.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|y
argument_list|,
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|y
operator|=
name|force_reg
argument_list|(
name|insn_operand_mode
index|[
name|icode
index|]
index|[
literal|1
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try widening if we can find a direct insn that way.  */
if|if
condition|(
name|class
operator|==
name|MODE_INT
operator|||
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|mode
argument_list|)
init|;
operator|(
operator|(
name|int
operator|)
name|wider_mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|wider_mode
argument_list|)
operator|==
name|class
operator|)
condition|;
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|y
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Handle a lib call just for the mode we are using.  */
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
decl_stmt|;
comment|/* If we want unsigned, and this mode has a distinct unsigned 	 comparison routine, use that.  */
if|if
condition|(
name|unsignedp
operator|&&
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
condition|)
name|string
operator|=
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|lib_call
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|string
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Integer comparison returns a result that must be compared against 1, 	 so that even if we do an unsigned compare afterward, 	 there is still a value that can represent the result "less than".  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
name|emit_cmp_insn
argument_list|(
name|hard_libcall_value
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit_cmp_insn
argument_list|(
name|hard_libcall_value
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try widening and then using a libcall.  */
if|if
condition|(
name|class
operator|==
name|MODE_FLOAT
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|mode
argument_list|)
init|;
operator|(
operator|(
name|int
operator|)
name|wider_mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|wider_mode
argument_list|)
operator|==
name|class
operator|)
condition|;
name|wider_mode
operator|=
name|INC_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|lib_call
operator|!=
literal|0
operator|)
condition|)
block|{
name|x
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|y
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These three functions generate an insn body and return it    rather than emitting the insn.     They do not protect from queued increments,    because they may be used 1) in protect_from_queue itself    and 2) in other passes where there is no queue.  */
end_comment

begin_comment
comment|/* Generate and return an insn body to add Y to X.  */
end_comment

begin_function
name|rtx
name|gen_add2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|GEN_FCN
argument_list|(
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|have_add2_insn
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to subtract Y from X.  */
end_comment

begin_function
name|rtx
name|gen_sub2_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|GEN_FCN
argument_list|(
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|have_sub2_insn
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an instruction to copy Y into X.  */
end_comment

begin_function
name|rtx
name|gen_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Tables of patterns for extending one integer mode to another.  */
end_comment

begin_comment
unit|enum insn_code zero_extend_optab[MAX_MACHINE_MODE][MAX_MACHINE_MODE]; enum insn_code sign_extend_optab[MAX_MACHINE_MODE][MAX_MACHINE_MODE];
comment|/* Generate the body of an insn to extend Y (with mode MFROM)    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */
end_comment

begin_endif
unit|rtx gen_extend_insn (x, y, mto, mfrom, unsignedp)      rtx x, y;      enum machine_mode mto, mfrom;      int unsignedp; {   return (GEN_FCN ((unsignedp ? zero_extend_optab : sign_extend_optab) 		   [(int)mto][(int)mfrom]) 	  (x, y)); }  static void init_extends () {   bzero (sign_extend_optab, sizeof sign_extend_optab);   bzero (zero_extend_optab, sizeof zero_extend_optab);   sign_extend_optab[(int) SImode][(int) HImode] = CODE_FOR_extendhisi2;   sign_extend_optab[(int) SImode][(int) QImode] = CODE_FOR_extendqisi2;   sign_extend_optab[(int) HImode][(int) QImode] = CODE_FOR_extendqihi2;   zero_extend_optab[(int) SImode][(int) HImode] = CODE_FOR_zero_extendhisi2;   zero_extend_optab[(int) SImode][(int) QImode] = CODE_FOR_zero_extendqisi2;   zero_extend_optab[(int) HImode][(int) QImode] = CODE_FOR_zero_extendqihi2; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* can_fix_p and can_float_p say whether the target machine    can directly convert a given fixed point type to    a given floating point type, or vice versa.    The returned value is the CODE_FOR_... value to use,    or CODE_FOR_nothing if these modes cannot be directly converted.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|fixtab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|fixtrunctab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|floattab
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *TRUNCP_PTR is set to 1 if it is necessary to output    an explicit FTRUNC insn before the fix insn; otherwise 0.  */
end_comment

begin_function
specifier|static
name|enum
name|insn_code
name|can_fix_p
parameter_list|(
name|fixmode
parameter_list|,
name|fltmode
parameter_list|,
name|unsignedp
parameter_list|,
name|truncp_ptr
parameter_list|)
name|enum
name|machine_mode
name|fltmode
decl_stmt|,
name|fixmode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
modifier|*
name|truncp_ptr
decl_stmt|;
block|{
operator|*
name|truncp_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixtrunctab
index|[
name|fltmode
operator|!=
name|SFmode
index|]
index|[
name|fixmode
operator|==
name|DImode
index|]
index|[
name|unsignedp
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|fixtrunctab
index|[
name|fltmode
operator|!=
name|SFmode
index|]
index|[
name|fixmode
operator|==
name|DImode
index|]
index|[
name|unsignedp
index|]
return|;
if|if
condition|(
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fltmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
operator|*
name|truncp_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|fixtab
index|[
name|fltmode
operator|!=
name|SFmode
index|]
index|[
name|fixmode
operator|==
name|DImode
index|]
index|[
name|unsignedp
index|]
return|;
block|}
return|return
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|insn_code
name|can_float_p
parameter_list|(
name|fltmode
parameter_list|,
name|fixmode
parameter_list|)
name|enum
name|machine_mode
name|fixmode
decl_stmt|,
name|fltmode
decl_stmt|;
block|{
return|return
name|floattab
index|[
name|fltmode
operator|!=
name|SFmode
index|]
index|[
name|fixmode
operator|==
name|DImode
index|]
return|;
block|}
end_function

begin_function
name|void
name|init_fixtab
parameter_list|()
block|{
name|enum
name|insn_code
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|p
operator|<
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|fixtab
operator|/
sizeof|sizeof
argument_list|(
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|p
operator|<
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|fixtrunctab
operator|/
sizeof|sizeof
argument_list|(
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_fixsfsi2
if|if
condition|(
name|HAVE_fixsfsi2
condition|)
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixsfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixsfdi2
if|if
condition|(
name|HAVE_fixsfdi2
condition|)
name|fixtab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixsfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfsi2
if|if
condition|(
name|HAVE_fixdfsi2
condition|)
name|fixtab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixdfdi2
if|if
condition|(
name|HAVE_fixdfdi2
condition|)
name|fixtab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fixdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunssfsi2
if|if
condition|(
name|HAVE_fixunssfsi2
condition|)
name|fixtab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunssfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunssfdi2
if|if
condition|(
name|HAVE_fixunssfdi2
condition|)
name|fixtab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunssfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfsi2
if|if
condition|(
name|HAVE_fixunsdfsi2
condition|)
name|fixtab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixunsdfdi2
if|if
condition|(
name|HAVE_fixunsdfdi2
condition|)
name|fixtab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixunsdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncsfsi2
if|if
condition|(
name|HAVE_fix_truncsfsi2
condition|)
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncsfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncsfdi2
if|if
condition|(
name|HAVE_fix_truncsfdi2
condition|)
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncsfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfsi2
if|if
condition|(
name|HAVE_fix_truncdfsi2
condition|)
name|fixtrunctab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fix_truncdfdi2
if|if
condition|(
name|HAVE_fix_truncdfdi2
condition|)
name|fixtrunctab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_fix_truncdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncsfsi2
if|if
condition|(
name|HAVE_fixuns_truncsfsi2
condition|)
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncsfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncsfdi2
if|if
condition|(
name|HAVE_fixuns_truncsfdi2
condition|)
name|fixtrunctab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncsfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfsi2
if|if
condition|(
name|HAVE_fixuns_truncdfsi2
condition|)
name|fixtrunctab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_fixuns_truncdfdi2
if|if
condition|(
name|HAVE_fixuns_truncdfdi2
condition|)
name|fixtrunctab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_fixuns_truncdfdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIXUNS_TRUNC_LIKE_FIX_TRUNC
comment|/* This flag says the same insns that convert to a signed fixnum      also convert validly to an unsigned one.  */
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
name|fixtrunctab
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_floattab
parameter_list|()
block|{
name|enum
name|insn_code
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|floattab
index|[
literal|0
index|]
init|;
name|p
operator|<
name|floattab
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|floattab
operator|/
sizeof|sizeof
argument_list|(
name|floattab
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_floatsisf2
if|if
condition|(
name|HAVE_floatsisf2
condition|)
name|floattab
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatsisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatdisf2
if|if
condition|(
name|HAVE_floatdisf2
condition|)
name|floattab
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatdisf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatsidf2
if|if
condition|(
name|HAVE_floatsidf2
condition|)
name|floattab
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|CODE_FOR_floatsidf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_floatdidf2
if|if
condition|(
name|HAVE_floatdidf2
condition|)
name|floattab
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|CODE_FOR_floatdidf2
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to convert FROM to floating point    and store in TO.  FROM must be fixed point.    UNSIGNEDP nonzero means regard FROM as unsigned.    Normally this is done by correcting the final value    if it is negative.  */
end_comment

begin_function
name|void
name|expand_float
parameter_list|(
name|real_to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|real_to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|register
name|rtx
name|to
decl_stmt|;
comment|/* Constants should get converted in `fold'.      We lose here since we don't know the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|to
operator|=
name|real_to
operator|=
name|protect_from_queue
argument_list|(
name|real_to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/* If we are about to do some arithmetic to correct for an      unsigned operand, do it in a pseudo-register.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|to
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|to
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now do the basic conversion.  Do it in the specified modes if possible;      otherwise convert either input, output or both with wider mode;      otherwise use a library call.  */
if|if
condition|(
operator|(
name|icode
operator|=
name|can_float_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SFmode
operator|&&
operator|(
operator|(
name|icode
operator|=
name|can_float_p
argument_list|(
name|DFmode
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|to
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|FLOAT
argument_list|)
expr_stmt|;
block|}
comment|/* If we can't float a SI, maybe we can float a DI.      If so, convert to DI and then float.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|!=
name|DImode
operator|&&
operator|(
name|can_float_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|||
name|can_float_p
argument_list|(
name|DFmode
argument_list|,
name|DImode
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
specifier|register
name|rtx
name|tem
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|convert_move
argument_list|(
name|tem
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from
operator|=
name|tem
expr_stmt|;
comment|/* If we extend FROM then we don't need to correct 	 the final value for unsignedness.  */
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|icode
operator|=
name|can_float_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|icode
operator|=
name|can_float_p
argument_list|(
name|DFmode
argument_list|,
name|DImode
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|to
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|FLOAT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No hardware instruction available; call a library      to convert from SImode or DImode into DFmode.  */
else|else
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
literal|0
expr_stmt|;
block|}
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
operator|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SImode
condition|?
literal|"__floatsidf"
else|:
literal|"__floatdidf"
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DFmode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|=
name|copy_to_reg
argument_list|(
name|hard_libcall_value
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If FROM was unsigned but we treated it as signed,      then in the case where it is negative (and therefore TO is negative),      correct its value by 2**bitwidth.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|to
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|DFmode
condition|?
name|dconst0_rtx
else|:
name|fconst0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|REAL_VALUE_LDEXP
argument_list|(
literal|1.0
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|to
argument_list|,
name|immed_real_const_1
argument_list|(
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|to
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* Copy result to requested destination      if we have been computing in a temp location.  */
if|if
condition|(
name|to
operator|!=
name|real_to
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|real_to
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|real_to
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|real_to
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* expand_fix: generate code to convert FROM to fixed point    and store in TO.  FROM must be floating point.  */
end_comment

begin_function
specifier|static
name|rtx
name|ftruncify
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ftrunc_optab
argument_list|,
name|x
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|expand_fix
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
specifier|register
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|must_trunc
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|icode
operator|=
name|can_fix_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
operator|&
name|must_trunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|must_trunc
condition|)
name|from
operator|=
name|ftruncify
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|FIX
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
comment|/* Turned off.  It fails because the positive numbers 	  that become temporarily negative are rounded up instead of down.  */
comment|/* If no insns for unsigned conversion, 	 we can go via a signed number. 	 But make sure we won't overflow in the compiler.  */
block|if (unsignedp&& GET_MODE_BITSIZE (GET_MODE (to))<= HOST_BITS_PER_INT
comment|/* Make sure we won't lose significant bits doing this.  */
block|&& GET_MODE_BITSIZE (GET_MODE (from))> GET_MODE_BITSIZE (GET_MODE (to))) 	{ 	  icode = can_fix_p (GET_MODE (to), GET_MODE (from), 			     0,&must_trunc);  	  if (icode != CODE_FOR_nothing) 	    { 	      REAL_VALUE_TYPE offset; 	      rtx temp, temp1; 	      int bitsize = GET_MODE_BITSIZE (GET_MODE (to));  	      if (must_trunc) 		from = ftruncify (from);
comment|/* Subtract 2**(N-1), convert to signed number, 		 then add 2**(N-1).  */
block|offset = REAL_VALUE_LDEXP (1.0, bitsize - 1); 	      temp = expand_binop (GET_MODE (from), sub_optab, from, 				   immed_real_const_1 (offset, GET_MODE (from)), 				   0, 0, OPTAB_LIB_WIDEN);  	      temp1 = gen_reg_rtx (GET_MODE (to)); 	      emit_unop_insn (icode, temp1, temp, FIX); 	      temp = expand_binop (GET_MODE (to), add_optab, temp1, 				   gen_rtx (CONST_INT, VOIDmode, 					    1<< (bitsize - 1)), 				   to, 1, OPTAB_LIB_WIDEN); 	      if (temp != to) 		emit_move_insn (to, temp); 	      return; 	    } 	}
endif|#
directive|endif
name|icode
operator|=
name|can_fix_p
argument_list|(
name|DImode
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
operator|&
name|must_trunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|!=
name|DImode
operator|&&
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
if|if
condition|(
name|must_trunc
condition|)
name|from
operator|=
name|ftruncify
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|temp
argument_list|,
name|from
argument_list|,
name|FIX
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|to
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If FROM is not DFmode, convert to DFmode and try again from there.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|DFmode
condition|)
break|break;
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DFmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We can't do it with an insn, so use a library call.      The mode of FROM is known to be DFmode.  */
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|!=
name|DImode
condition|)
block|{
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|unsignedp
condition|?
literal|"__fixunsdfsi"
else|:
literal|"__fixdfsi"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|target
operator|=
name|hard_libcall_value
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|unsignedp
condition|?
literal|"__fixunsdfdi"
else|:
literal|"__fixdfdi"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|target
operator|=
name|hard_libcall_value
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|optab
name|init_optab
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|optab
name|op
init|=
operator|(
name|optab
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|optab
argument_list|)
argument_list|)
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|lib_call
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Call this once to initialize the contents of the optabs    appropriately for the current target machine.  */
end_comment

begin_function
name|void
name|init_optabs
parameter_list|()
block|{
name|init_fixtab
argument_list|()
expr_stmt|;
name|init_floattab
argument_list|()
expr_stmt|;
name|init_comparisons
argument_list|()
expr_stmt|;
comment|/*  init_extends (); */
name|add_optab
operator|=
name|init_optab
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
name|sub_optab
operator|=
name|init_optab
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
name|smul_optab
operator|=
name|init_optab
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|umul_optab
operator|=
name|init_optab
argument_list|(
name|UMULT
argument_list|)
expr_stmt|;
name|smul_widen_optab
operator|=
name|init_optab
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|umul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UMULT
argument_list|)
expr_stmt|;
name|sdiv_optab
operator|=
name|init_optab
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|sdivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|udiv_optab
operator|=
name|init_optab
argument_list|(
name|UDIV
argument_list|)
expr_stmt|;
name|udivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|smod_optab
operator|=
name|init_optab
argument_list|(
name|MOD
argument_list|)
expr_stmt|;
name|umod_optab
operator|=
name|init_optab
argument_list|(
name|UMOD
argument_list|)
expr_stmt|;
name|flodiv_optab
operator|=
name|init_optab
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|ftrunc_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|and_optab
operator|=
name|init_optab
argument_list|(
name|AND
argument_list|)
expr_stmt|;
name|andcb_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ior_optab
operator|=
name|init_optab
argument_list|(
name|IOR
argument_list|)
expr_stmt|;
name|xor_optab
operator|=
name|init_optab
argument_list|(
name|XOR
argument_list|)
expr_stmt|;
name|ashl_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFT
argument_list|)
expr_stmt|;
name|ashr_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFTRT
argument_list|)
expr_stmt|;
name|lshl_optab
operator|=
name|init_optab
argument_list|(
name|LSHIFT
argument_list|)
expr_stmt|;
name|lshr_optab
operator|=
name|init_optab
argument_list|(
name|LSHIFTRT
argument_list|)
expr_stmt|;
name|rotl_optab
operator|=
name|init_optab
argument_list|(
name|ROTATE
argument_list|)
expr_stmt|;
name|rotr_optab
operator|=
name|init_optab
argument_list|(
name|ROTATERT
argument_list|)
expr_stmt|;
name|mov_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|movstrict_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cmp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ucmp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|tst_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|neg_optab
operator|=
name|init_optab
argument_list|(
name|NEG
argument_list|)
expr_stmt|;
name|abs_optab
operator|=
name|init_optab
argument_list|(
name|ABS
argument_list|)
expr_stmt|;
name|one_cmpl_optab
operator|=
name|init_optab
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
name|ffs_optab
operator|=
name|init_optab
argument_list|(
name|FFS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_addqi3
if|if
condition|(
name|HAVE_addqi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addhi3
if|if
condition|(
name|HAVE_addhi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addsi3
if|if
condition|(
name|HAVE_addsi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_adddi3
if|if
condition|(
name|HAVE_adddi3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_adddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_addsf3
if|if
condition|(
name|HAVE_addsf3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_addsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_adddf3
if|if
condition|(
name|HAVE_adddf3
condition|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_adddf3
expr_stmt|;
endif|#
directive|endif
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__adddi3"
expr_stmt|;
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__addsf3"
expr_stmt|;
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__adddf3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_subqi3
if|if
condition|(
name|HAVE_subqi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subhi3
if|if
condition|(
name|HAVE_subhi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subsi3
if|if
condition|(
name|HAVE_subsi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subdi3
if|if
condition|(
name|HAVE_subdi3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subsf3
if|if
condition|(
name|HAVE_subsf3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_subdf3
if|if
condition|(
name|HAVE_subdf3
condition|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_subdf3
expr_stmt|;
endif|#
directive|endif
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__subdi3"
expr_stmt|;
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__subsf3"
expr_stmt|;
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__subdf3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_mulqi3
if|if
condition|(
name|HAVE_mulqi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulhi3
if|if
condition|(
name|HAVE_mulhi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulsi3
if|if
condition|(
name|HAVE_mulsi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_muldi3
if|if
condition|(
name|HAVE_muldi3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_muldi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulsf3
if|if
condition|(
name|HAVE_mulsf3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_muldf3
if|if
condition|(
name|HAVE_muldf3
condition|)
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_muldf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULSI3_LIBCALL
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
name|MULSI3_LIBCALL
expr_stmt|;
else|#
directive|else
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__mulsi3"
expr_stmt|;
endif|#
directive|endif
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__muldi3"
expr_stmt|;
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__mulsf3"
expr_stmt|;
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__muldf3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_mulqihi3
if|if
condition|(
name|HAVE_mulqihi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulqihi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulhisi3
if|if
condition|(
name|HAVE_mulhisi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulhisi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_mulsidi3
if|if
condition|(
name|HAVE_mulsidi3
condition|)
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_mulsidi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulqi3
if|if
condition|(
name|HAVE_umulqi3
condition|)
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulhi3
if|if
condition|(
name|HAVE_umulhi3
condition|)
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulsi3
if|if
condition|(
name|HAVE_umulsi3
condition|)
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umuldi3
if|if
condition|(
name|HAVE_umuldi3
condition|)
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umuldi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulsf3
if|if
condition|(
name|HAVE_umulsf3
condition|)
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umuldf3
if|if
condition|(
name|HAVE_umuldf3
condition|)
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umuldf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMULSI3_LIBCALL
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
name|UMULSI3_LIBCALL
expr_stmt|;
else|#
directive|else
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__umulsi3"
expr_stmt|;
endif|#
directive|endif
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__umuldi3"
expr_stmt|;
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__umulsf3"
expr_stmt|;
name|umul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__umuldf3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_umulqihi3
if|if
condition|(
name|HAVE_umulqihi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulqihi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulhisi3
if|if
condition|(
name|HAVE_umulhisi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulhisi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umulsidi3
if|if
condition|(
name|HAVE_umulsidi3
condition|)
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umulsidi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divqi3
if|if
condition|(
name|HAVE_divqi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divhi3
if|if
condition|(
name|HAVE_divhi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divsi3
if|if
condition|(
name|HAVE_divsi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divdi3
if|if
condition|(
name|HAVE_divdi3
condition|)
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIVSI3_LIBCALL
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
name|DIVSI3_LIBCALL
expr_stmt|;
else|#
directive|else
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__divsi3"
expr_stmt|;
endif|#
directive|endif
name|sdiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__divdi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_udivqi3
if|if
condition|(
name|HAVE_udivqi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivhi3
if|if
condition|(
name|HAVE_udivhi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivsi3
if|if
condition|(
name|HAVE_udivsi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivdi3
if|if
condition|(
name|HAVE_udivdi3
condition|)
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivdi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UDIVSI3_LIBCALL
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
name|UDIVSI3_LIBCALL
expr_stmt|;
else|#
directive|else
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__udivsi3"
expr_stmt|;
endif|#
directive|endif
name|udiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__udivdi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_divmodqi4
if|if
condition|(
name|HAVE_divmodqi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodqi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmodhi4
if|if
condition|(
name|HAVE_divmodhi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodhi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmodsi4
if|if
condition|(
name|HAVE_divmodsi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmodsi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divmoddi4
if|if
condition|(
name|HAVE_divmoddi4
condition|)
name|sdivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divmoddi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmodqi4
if|if
condition|(
name|HAVE_udivmodqi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodqi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmodhi4
if|if
condition|(
name|HAVE_udivmodhi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodhi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmodsi4
if|if
condition|(
name|HAVE_udivmodsi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmodsi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_udivmoddi4
if|if
condition|(
name|HAVE_udivmoddi4
condition|)
name|udivmod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_udivmoddi4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modqi3
if|if
condition|(
name|HAVE_modqi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modhi3
if|if
condition|(
name|HAVE_modhi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_modsi3
if|if
condition|(
name|HAVE_modsi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_modsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_moddi3
if|if
condition|(
name|HAVE_moddi3
condition|)
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_moddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MODSI3_LIBCALL
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
name|MODSI3_LIBCALL
expr_stmt|;
else|#
directive|else
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__modsi3"
expr_stmt|;
endif|#
directive|endif
name|smod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__moddi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_umodqi3
if|if
condition|(
name|HAVE_umodqi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodhi3
if|if
condition|(
name|HAVE_umodhi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umodsi3
if|if
condition|(
name|HAVE_umodsi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umodsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_umoddi3
if|if
condition|(
name|HAVE_umoddi3
condition|)
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_umoddi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMODSI3_LIBCALL
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
name|UMODSI3_LIBCALL
expr_stmt|;
else|#
directive|else
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__umodsi3"
expr_stmt|;
endif|#
directive|endif
name|umod_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__umoddi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_divsf3
if|if
condition|(
name|HAVE_divsf3
condition|)
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divsf3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_divdf3
if|if
condition|(
name|HAVE_divdf3
condition|)
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_divdf3
expr_stmt|;
endif|#
directive|endif
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__divsf3"
expr_stmt|;
name|flodiv_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__divdf3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ftruncsf2
if|if
condition|(
name|HAVE_ftruncsf2
condition|)
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ftruncsf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ftruncdf2
if|if
condition|(
name|HAVE_ftruncdf2
condition|)
name|ftrunc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ftruncdf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andqi3
if|if
condition|(
name|HAVE_andqi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andhi3
if|if
condition|(
name|HAVE_andhi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andsi3
if|if
condition|(
name|HAVE_andsi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_anddi3
if|if
condition|(
name|HAVE_anddi3
condition|)
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_anddi3
expr_stmt|;
endif|#
directive|endif
name|and_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__anddi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_andcbqi3
if|if
condition|(
name|HAVE_andcbqi3
condition|)
name|andcb_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andcbqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andcbhi3
if|if
condition|(
name|HAVE_andcbhi3
condition|)
name|andcb_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andcbhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andcbsi3
if|if
condition|(
name|HAVE_andcbsi3
condition|)
name|andcb_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andcbsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_andcbdi3
if|if
condition|(
name|HAVE_andcbdi3
condition|)
name|andcb_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_andcbdi3
expr_stmt|;
endif|#
directive|endif
name|andcb_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__andcbdi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_iorqi3
if|if
condition|(
name|HAVE_iorqi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iorhi3
if|if
condition|(
name|HAVE_iorhi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iorsi3
if|if
condition|(
name|HAVE_iorsi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iorsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_iordi3
if|if
condition|(
name|HAVE_iordi3
condition|)
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_iordi3
expr_stmt|;
endif|#
directive|endif
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__iordi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_xorqi3
if|if
condition|(
name|HAVE_xorqi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xorhi3
if|if
condition|(
name|HAVE_xorhi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xorsi3
if|if
condition|(
name|HAVE_xorsi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xorsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_xordi3
if|if
condition|(
name|HAVE_xordi3
condition|)
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_xordi3
expr_stmt|;
endif|#
directive|endif
name|xor_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__xordi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ashlqi3
if|if
condition|(
name|HAVE_ashlqi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashlhi3
if|if
condition|(
name|HAVE_ashlhi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashlsi3
if|if
condition|(
name|HAVE_ashlsi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashlsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashldi3
if|if
condition|(
name|HAVE_ashldi3
condition|)
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashldi3
expr_stmt|;
endif|#
directive|endif
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__ashlsi3"
expr_stmt|;
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__ashldi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ashrqi3
if|if
condition|(
name|HAVE_ashrqi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrhi3
if|if
condition|(
name|HAVE_ashrhi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrsi3
if|if
condition|(
name|HAVE_ashrsi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ashrdi3
if|if
condition|(
name|HAVE_ashrdi3
condition|)
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ashrdi3
expr_stmt|;
endif|#
directive|endif
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__ashrsi3"
expr_stmt|;
name|ashr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__ashrdi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_lshlqi3
if|if
condition|(
name|HAVE_lshlqi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshlhi3
if|if
condition|(
name|HAVE_lshlhi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshlsi3
if|if
condition|(
name|HAVE_lshlsi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshlsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshldi3
if|if
condition|(
name|HAVE_lshldi3
condition|)
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshldi3
expr_stmt|;
endif|#
directive|endif
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__lshlsi3"
expr_stmt|;
name|lshl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__lshldi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_lshrqi3
if|if
condition|(
name|HAVE_lshrqi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrhi3
if|if
condition|(
name|HAVE_lshrhi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrsi3
if|if
condition|(
name|HAVE_lshrsi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_lshrdi3
if|if
condition|(
name|HAVE_lshrdi3
condition|)
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_lshrdi3
expr_stmt|;
endif|#
directive|endif
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__lshrsi3"
expr_stmt|;
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__lshrdi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_rotlqi3
if|if
condition|(
name|HAVE_rotlqi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotlhi3
if|if
condition|(
name|HAVE_rotlhi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotlsi3
if|if
condition|(
name|HAVE_rotlsi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotlsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotldi3
if|if
condition|(
name|HAVE_rotldi3
condition|)
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotldi3
expr_stmt|;
endif|#
directive|endif
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__rotlsi3"
expr_stmt|;
name|rotl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__rotldi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_rotrqi3
if|if
condition|(
name|HAVE_rotrqi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrqi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrhi3
if|if
condition|(
name|HAVE_rotrhi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrhi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrsi3
if|if
condition|(
name|HAVE_rotrsi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrsi3
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_rotrdi3
if|if
condition|(
name|HAVE_rotrdi3
condition|)
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_rotrdi3
expr_stmt|;
endif|#
directive|endif
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__rotrsi3"
expr_stmt|;
name|rotr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__rotrdi3"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_negqi2
if|if
condition|(
name|HAVE_negqi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_neghi2
if|if
condition|(
name|HAVE_neghi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_neghi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negsi2
if|if
condition|(
name|HAVE_negsi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negdi2
if|if
condition|(
name|HAVE_negdi2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negsf2
if|if
condition|(
name|HAVE_negsf2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negsf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_negdf2
if|if
condition|(
name|HAVE_negdf2
condition|)
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_negdf2
expr_stmt|;
endif|#
directive|endif
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__negsi2"
expr_stmt|;
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__negdi2"
expr_stmt|;
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__negsf2"
expr_stmt|;
name|neg_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__negdf2"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_absqi2
if|if
condition|(
name|HAVE_absqi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abshi2
if|if
condition|(
name|HAVE_abshi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abshi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abssi2
if|if
condition|(
name|HAVE_abssi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abssi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_absdi2
if|if
condition|(
name|HAVE_absdi2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absdi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_abssf2
if|if
condition|(
name|HAVE_abssf2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_abssf2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_absdf2
if|if
condition|(
name|HAVE_absdf2
condition|)
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_absdf2
expr_stmt|;
endif|#
directive|endif
comment|/* No library calls here!  If there is no abs instruction,      expand_expr will generate a conditional negation.  */
ifdef|#
directive|ifdef
name|HAVE_one_cmplqi2
if|if
condition|(
name|HAVE_one_cmplqi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmplhi2
if|if
condition|(
name|HAVE_one_cmplhi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplhi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmplsi2
if|if
condition|(
name|HAVE_one_cmplsi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmplsi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_one_cmpldi2
if|if
condition|(
name|HAVE_one_cmpldi2
condition|)
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_one_cmpldi2
expr_stmt|;
endif|#
directive|endif
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"__one_cmplsi2"
expr_stmt|;
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__one_cmpldi2"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ffsqi2
if|if
condition|(
name|HAVE_ffsqi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffsqi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffshi2
if|if
condition|(
name|HAVE_ffshi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffshi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffssi2
if|if
condition|(
name|HAVE_ffssi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffssi2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ffsdi2
if|if
condition|(
name|HAVE_ffsdi2
condition|)
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_ffsdi2
expr_stmt|;
endif|#
directive|endif
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|lib_call
operator|=
literal|"ffs"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_movqi
if|if
condition|(
name|HAVE_movqi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movhi
if|if
condition|(
name|HAVE_movhi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movhi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movsi
if|if
condition|(
name|HAVE_movsi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movdi
if|if
condition|(
name|HAVE_movdi
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movti
if|if
condition|(
name|HAVE_movti
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movti
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movsf
if|if
condition|(
name|HAVE_movsf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movsf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movdf
if|if
condition|(
name|HAVE_movdf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movdf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movtf
if|if
condition|(
name|HAVE_movtf
condition|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movtf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictqi
if|if
condition|(
name|HAVE_movstrictqi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstricthi
if|if
condition|(
name|HAVE_movstricthi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstricthi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictsi
if|if
condition|(
name|HAVE_movstrictsi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrictdi
if|if
condition|(
name|HAVE_movstrictdi
condition|)
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_movstrictdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpqi
if|if
condition|(
name|HAVE_cmpqi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmphi
if|if
condition|(
name|HAVE_cmphi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmphi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpsi
if|if
condition|(
name|HAVE_cmpsi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpdi
if|if
condition|(
name|HAVE_cmpdi
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpsf
if|if
condition|(
name|HAVE_cmpsf
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpsf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpdf
if|if
condition|(
name|HAVE_cmpdf
condition|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_cmpdf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstqi
if|if
condition|(
name|HAVE_tstqi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|QImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstqi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tsthi
if|if
condition|(
name|HAVE_tsthi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|HImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tsthi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstsi
if|if
condition|(
name|HAVE_tstsi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstsi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstdi
if|if
condition|(
name|HAVE_tstdi
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstdi
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstsf
if|if
condition|(
name|HAVE_tstsf
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstsf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tstdf
if|if
condition|(
name|HAVE_tstdf
condition|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_tstdf
expr_stmt|;
endif|#
directive|endif
comment|/* Comparison libcalls for integers MUST come in pairs, signed/unsigned.  */
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__cmpdi2"
expr_stmt|;
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DImode
index|]
operator|.
name|lib_call
operator|=
literal|"__ucmpdi2"
expr_stmt|;
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|SFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__cmpsf2"
expr_stmt|;
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
operator|.
name|lib_call
operator|=
literal|"__cmpdf2"
expr_stmt|;
if|#
directive|if
name|HAVE_beq
if|if
condition|(
name|HAVE_beq
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|EQ
index|]
operator|=
name|gen_beq
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bne
if|if
condition|(
name|HAVE_bne
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|NE
index|]
operator|=
name|gen_bne
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bgt
if|if
condition|(
name|HAVE_bgt
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GT
index|]
operator|=
name|gen_bgt
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bge
if|if
condition|(
name|HAVE_bge
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GE
index|]
operator|=
name|gen_bge
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bgtu
if|if
condition|(
name|HAVE_bgtu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GTU
index|]
operator|=
name|gen_bgtu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bgeu
if|if
condition|(
name|HAVE_bgeu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GEU
index|]
operator|=
name|gen_bgeu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_blt
if|if
condition|(
name|HAVE_blt
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LT
index|]
operator|=
name|gen_blt
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_ble
if|if
condition|(
name|HAVE_ble
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LE
index|]
operator|=
name|gen_ble
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bltu
if|if
condition|(
name|HAVE_bltu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LTU
index|]
operator|=
name|gen_bltu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_bleu
if|if
condition|(
name|HAVE_bleu
condition|)
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LEU
index|]
operator|=
name|gen_bleu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_seq
if|if
condition|(
name|HAVE_seq
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|EQ
index|]
operator|=
name|gen_seq
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sne
if|if
condition|(
name|HAVE_sne
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|NE
index|]
operator|=
name|gen_sne
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sgt
if|if
condition|(
name|HAVE_sgt
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GT
index|]
operator|=
name|gen_sgt
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sge
if|if
condition|(
name|HAVE_sge
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GE
index|]
operator|=
name|gen_sge
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sgtu
if|if
condition|(
name|HAVE_sgtu
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GTU
index|]
operator|=
name|gen_sgtu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sgeu
if|if
condition|(
name|HAVE_sgeu
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GEU
index|]
operator|=
name|gen_sgeu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_slt
if|if
condition|(
name|HAVE_slt
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LT
index|]
operator|=
name|gen_slt
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sle
if|if
condition|(
name|HAVE_sle
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LE
index|]
operator|=
name|gen_sle
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sltu
if|if
condition|(
name|HAVE_sltu
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LTU
index|]
operator|=
name|gen_sltu
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_sleu
if|if
condition|(
name|HAVE_sleu
condition|)
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|LEU
index|]
operator|=
name|gen_sleu
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

