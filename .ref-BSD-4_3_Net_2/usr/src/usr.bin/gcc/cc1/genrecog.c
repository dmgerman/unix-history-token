begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to emit insns as rtl.    Copyright (C) 1987,1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This program is used to produce insn-recog.c, which contains    a function called `recog' plus its subroutines.    These functions contain a decision tree    that recognizes whether an rtx, the argument given to recog,    is a valid instruction.     recog returns -1 if the rtx is not valid.    If the rtx is valid, recog returns a nonnegative number    which is the insn code number for the pattern that matched.    This is the same as the order in the machine description of the    entry that matched.  This number can be used as an index into    insn_templates and insn_n_operands (found in insn-output.c)    or as an argument to output_insn_hairy (also in insn-output.c).  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Data structure for decision tree for recognizing    legitimate instructions.  */
end_comment

begin_struct
struct|struct
name|decision
block|{
name|int
name|number
decl_stmt|;
name|char
modifier|*
name|position
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|char
modifier|*
name|exact
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
modifier|*
name|tests
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|struct
name|decision
modifier|*
name|next
decl_stmt|;
name|struct
name|decision
modifier|*
name|success
decl_stmt|;
name|int
name|opno
decl_stmt|;
name|int
name|dupno
decl_stmt|;
name|int
name|dupcount
decl_stmt|;
name|int
name|test_elt_zero_int
decl_stmt|;
name|int
name|elt_zero_int
decl_stmt|;
name|int
name|test_elt_one_int
decl_stmt|;
name|int
name|elt_one_int
decl_stmt|;
name|int
name|ignmode
decl_stmt|;
name|struct
name|decision
modifier|*
name|afterward
decl_stmt|;
name|int
name|label_needed
decl_stmt|;
name|char
modifier|*
name|c_test
decl_stmt|;
name|char
modifier|*
name|reg_class
decl_stmt|;
name|char
name|enforce_mode
decl_stmt|;
name|int
name|veclen
decl_stmt|;
name|int
name|subroutine_number
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SUBROUTINE_THRESHOLD
value|50
end_define

begin_decl_stmt
name|int
name|next_subroutine_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recognize (top) {  staten:   x = XVECEXP (top, 0, 3);   if (test_code (GET_CODE (x))&& test_mode (MODE (x))&& whatever_else)     goto statep;   else if (next one...)     goto statem:   goto stater;   statep:   actions...;   return 1;   statem:   x = stack[depth--];   more tests...;   stateq:   stack[++depth] = x;   x = XEXP (stack[depth], 0);   more tests...;   stater:   x = XEXP (stack[depth], 1); }  */
end_comment

begin_decl_stmt
name|int
name|next_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|next_insn_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of MATCH_DUP's seen so far in this instruction.  */
end_comment

begin_decl_stmt
name|int
name|dupcount
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|decision
modifier|*
name|add_to_sequence
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|decision
modifier|*
name|try_merge_2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_subroutine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_code
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_codes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_modes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|change_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|copystr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mybzero
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_decl_stmt
name|struct
name|decision
modifier|*
name|first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct and return a sequence of decisions    that will recognize INSN.  */
end_comment

begin_function
name|struct
name|decision
modifier|*
name|make_insn_sequence
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|char
modifier|*
name|c_test
init|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|struct
name|decision
modifier|*
name|last
decl_stmt|;
name|dupcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|x
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|x
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|add_to_sequence
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_test
index|[
literal|0
index|]
condition|)
name|last
operator|->
name|c_test
operator|=
name|c_test
expr_stmt|;
name|last
operator|->
name|insn_code_number
operator|=
name|next_insn_code
operator|++
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_function
name|struct
name|decision
modifier|*
name|add_to_sequence
parameter_list|(
name|pattern
parameter_list|,
name|last
parameter_list|,
name|position
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|struct
name|decision
modifier|*
name|last
decl_stmt|;
name|char
modifier|*
name|position
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|struct
name|decision
modifier|*
name|new
init|=
operator|(
expr|struct
name|decision
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decision
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|decision
modifier|*
name|this
decl_stmt|;
name|char
modifier|*
name|newpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|len
decl_stmt|;
name|new
operator|->
name|number
operator|=
name|next_number
operator|++
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|copystr
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|new
operator|->
name|exact
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|success
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|insn_code_number
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|opno
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|dupno
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|dupcount
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|test_elt_zero_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|test_elt_one_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|elt_zero_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|elt_one_int
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|enforce_mode
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|ignmode
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|afterward
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|label_needed
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_test
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|reg_class
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|veclen
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|subroutine_number
operator|=
literal|0
expr_stmt|;
name|this
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|first
operator|=
name|new
expr_stmt|;
else|else
name|last
operator|->
name|success
operator|=
name|new
expr_stmt|;
name|depth
operator|=
name|strlen
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|newpos
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpos
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|newpos
index|[
name|depth
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|pattern
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|exact
operator|=
literal|"0"
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|new
operator|->
name|mode
operator|=
name|VOIDmode
expr_stmt|;
return|return
name|new
return|;
block|}
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|new
operator|->
name|mode
operator|=
name|VOIDmode
expr_stmt|;
break|break;
default|default:
name|new
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
break|break;
block|}
name|new
operator|->
name|code
operator|=
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|new
operator|->
name|opno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|new
operator|->
name|tests
operator|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|new
operator|->
name|tests
operator|==
literal|0
condition|)
name|new
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|reg_class
operator|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|new
operator|->
name|reg_class
operator|==
literal|0
condition|)
name|new
operator|->
name|reg_class
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
case|case
name|MATCH_OPERATOR
case|:
name|new
operator|->
name|opno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|new
operator|->
name|tests
operator|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|new
operator|->
name|tests
operator|==
literal|0
condition|)
name|new
operator|->
name|tests
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
name|i
operator|+
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
block|}
name|this
operator|->
name|success
operator|->
name|enforce_mode
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
case|case
name|MATCH_DUP
case|:
name|new
operator|->
name|dupno
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|dupcount
operator|=
name|dupcount
operator|++
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
return|return
name|new
return|;
case|case
name|ADDRESS
case|:
name|pattern
operator|=
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|PC
case|:
name|new
operator|->
name|exact
operator|=
literal|"pc_rtx"
expr_stmt|;
return|return
name|new
return|;
case|case
name|CC0
case|:
name|new
operator|->
name|exact
operator|=
literal|"cc0_rtx"
expr_stmt|;
return|return
name|new
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|pattern
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|exact
operator|=
literal|"const0_rtx"
expr_stmt|;
return|return
name|new
return|;
block|}
if|if
condition|(
name|INTVAL
argument_list|(
name|pattern
argument_list|)
operator|==
literal|1
condition|)
block|{
name|new
operator|->
name|exact
operator|=
literal|"const1_rtx"
expr_stmt|;
return|return
name|new
return|;
block|}
break|break;
case|case
name|SET
case|:
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'1'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
return|return
name|new
return|;
case|case
name|STRICT_LOW_PART
case|:
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
return|return
name|new
return|;
case|case
name|SUBREG
case|:
name|this
operator|->
name|test_elt_one_int
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_one_int
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
return|return
name|new
return|;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|this
operator|->
name|success
operator|->
name|enforce_mode
operator|=
literal|1
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'1'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
name|newpos
index|[
name|depth
index|]
operator|=
literal|'2'
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|this
operator|->
name|test_elt_zero_int
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_zero_int
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
operator|&&
name|i
operator|==
literal|1
condition|)
block|{
name|this
operator|->
name|test_elt_one_int
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|elt_one_int
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
comment|/* We do not handle a vector appearing as other than 	     the first item, just because nothing uses them 	     and by handling only the special case 	     we can use one element in newpos for either 	     the item number of a subexpression 	     or the element number in a vector.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|this
operator|->
name|veclen
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|newpos
index|[
name|depth
index|]
operator|=
literal|'a'
operator|+
name|j
expr_stmt|;
name|new
operator|=
name|add_to_sequence
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|new
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|!=
literal|'0'
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Merge two decision trees OLD and ADD,    modifying OLD destructively,    and return the merged tree.  */
end_comment

begin_function
name|struct
name|decision
modifier|*
name|merge_trees
parameter_list|(
name|old
parameter_list|,
name|add
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|old
decl_stmt|,
decl|*
name|add
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|add
condition|)
block|{
specifier|register
name|struct
name|decision
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
name|add
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|try_merge_1
argument_list|(
name|old
argument_list|,
name|add
argument_list|)
condition|)
name|old
operator|=
name|try_merge_2
argument_list|(
name|old
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|add
operator|=
name|next
expr_stmt|;
block|}
return|return
name|old
return|;
block|}
end_block

begin_comment
comment|/* Merge ADD into the next-chain starting with OLD    only if it overlaps a condition already tested in OLD.    Returns 1 if successful (OLD is modified),    0 if nothing has been done.  */
end_comment

begin_function
name|int
name|try_merge_1
parameter_list|(
name|old
parameter_list|,
name|add
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|old
decl_stmt|,
decl|*
name|add
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|old
condition|)
block|{
if|if
condition|(
operator|(
name|old
operator|->
name|position
operator|==
name|add
operator|->
name|position
operator|||
operator|(
name|old
operator|->
name|position
operator|&&
name|add
operator|->
name|position
operator|&&
operator|!
name|strcmp
argument_list|(
name|old
operator|->
name|position
argument_list|,
name|add
operator|->
name|position
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|old
operator|->
name|tests
operator|==
name|add
operator|->
name|tests
operator|||
operator|(
name|old
operator|->
name|tests
operator|&&
name|add
operator|->
name|tests
operator|&&
operator|!
name|strcmp
argument_list|(
name|old
operator|->
name|tests
argument_list|,
name|add
operator|->
name|tests
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|old
operator|->
name|c_test
operator|==
name|add
operator|->
name|c_test
operator|||
operator|(
name|old
operator|->
name|c_test
operator|&&
name|add
operator|->
name|c_test
operator|&&
operator|!
name|strcmp
argument_list|(
name|old
operator|->
name|c_test
argument_list|,
name|add
operator|->
name|c_test
argument_list|)
operator|)
operator|)
operator|&&
name|old
operator|->
name|test_elt_zero_int
operator|==
name|add
operator|->
name|test_elt_zero_int
operator|&&
name|old
operator|->
name|elt_zero_int
operator|==
name|add
operator|->
name|elt_zero_int
operator|&&
name|old
operator|->
name|test_elt_one_int
operator|==
name|add
operator|->
name|test_elt_one_int
operator|&&
name|old
operator|->
name|elt_one_int
operator|==
name|add
operator|->
name|elt_one_int
operator|&&
name|old
operator|->
name|veclen
operator|==
name|add
operator|->
name|veclen
operator|&&
name|old
operator|->
name|dupno
operator|==
name|add
operator|->
name|dupno
operator|&&
name|old
operator|->
name|opno
operator|==
name|add
operator|->
name|opno
operator|&&
operator|(
name|old
operator|->
name|tests
operator|==
literal|0
operator|||
operator|(
name|add
operator|->
name|enforce_mode
condition|?
name|no_same_mode
argument_list|(
name|old
argument_list|)
else|:
name|old
operator|->
name|next
operator|==
literal|0
operator|)
operator|)
operator|&&
name|old
operator|->
name|code
operator|==
name|add
operator|->
name|code
operator|&&
name|old
operator|->
name|mode
operator|==
name|add
operator|->
name|mode
condition|)
block|{
name|old
operator|->
name|success
operator|=
name|merge_trees
argument_list|(
name|old
operator|->
name|success
argument_list|,
name|add
operator|->
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|insn_code_number
operator|>=
literal|0
operator|&&
name|add
operator|->
name|insn_code_number
operator|>=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Two actions at one point in tree."
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|old
operator|->
name|insn_code_number
operator|=
name|add
operator|->
name|insn_code_number
expr_stmt|;
return|return
literal|1
return|;
block|}
name|old
operator|=
name|old
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Merge ADD into the next-chain that starts with OLD,    preferably after something that tests the same place    that ADD does.    The next-chain of ADD itself is ignored, and it is set    up for entering ADD into the new chain.    Returns the new chain.  */
end_comment

begin_function
name|struct
name|decision
modifier|*
name|try_merge_2
parameter_list|(
name|old
parameter_list|,
name|add
parameter_list|)
name|struct
name|decision
modifier|*
name|old
decl_stmt|,
decl|*
name|add
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
name|struct
name|decision
modifier|*
name|last
init|=
literal|0
decl_stmt|;
name|struct
name|decision
modifier|*
name|last_same_place
init|=
literal|0
decl_stmt|;
comment|/* Put this in after the others that test the same place,      if there are any.  If not, find the last chain element      and insert there.       One modification: if this one is NOT a MATCH_OPERAND,      put it before any MATCH_OPERANDS that test the same place.       Another: if enforce_mode (i.e. this is first operand of a SET),      put this after the last thing that tests the same place for      the same mode.  */
name|int
name|operand
init|=
literal|0
operator|!=
name|add
operator|->
name|tests
decl_stmt|;
for|for
control|(
name|p
operator|=
name|old
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|position
operator|==
name|add
operator|->
name|position
operator|||
operator|(
name|p
operator|->
name|position
operator|&&
name|add
operator|->
name|position
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|position
argument_list|,
name|add
operator|->
name|position
argument_list|)
operator|)
condition|)
block|{
name|last_same_place
operator|=
name|p
expr_stmt|;
comment|/* If enforce_mode, segregate the modes in numerical order.  */
if|if
condition|(
name|p
operator|->
name|enforce_mode
operator|&&
operator|(
name|int
operator|)
name|add
operator|->
name|mode
operator|<
operator|(
name|int
operator|)
name|p
operator|->
name|mode
condition|)
break|break;
if|#
directive|if
literal|0
comment|/* Keep explicit decompositions before those that test predicates. 	     If enforce_mode, do this separately within each mode.  */
block|if (! p->enforce_mode || p->mode == add->mode) 	    if (!operand&& p->tests) 	      break;
endif|#
directive|endif
block|}
comment|/* If this is past the end of the decisions at the same place as ADD, 	 stop looking now; add ADD before here.  */
elseif|else
if|if
condition|(
name|last_same_place
condition|)
break|break;
name|last
operator|=
name|p
expr_stmt|;
block|}
comment|/* Insert before P, which means after LAST.  */
if|if
condition|(
name|last
condition|)
block|{
name|add
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|add
expr_stmt|;
return|return
name|old
return|;
block|}
name|add
operator|->
name|next
operator|=
name|old
expr_stmt|;
return|return
name|add
return|;
block|}
end_block

begin_function
name|int
name|no_same_mode
parameter_list|(
name|node
parameter_list|)
name|struct
name|decision
modifier|*
name|node
decl_stmt|;
block|{
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|node
operator|->
name|mode
decl_stmt|;
for|for
control|(
name|p
operator|=
name|node
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count the number of subnodes of node NODE, assumed to be the start    of a next-chain.  If the number is high enough, make NODE start    a separate subroutine in the C code that is generated.  */
end_comment

begin_function
name|int
name|break_out_subroutines
parameter_list|(
name|node
parameter_list|)
name|struct
name|decision
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|struct
name|decision
modifier|*
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|node
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|size
operator|+=
literal|1
operator|+
name|break_out_subroutines
argument_list|(
name|sub
operator|->
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|SUBROUTINE_THRESHOLD
condition|)
block|{
name|node
operator|->
name|subroutine_number
operator|=
operator|++
name|next_subroutine_number
expr_stmt|;
name|write_subroutine
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
name|void
name|write_subroutine
parameter_list|(
name|tree
parameter_list|)
name|struct
name|decision
modifier|*
name|tree
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"int\nrecog_%d (x0, insn)\n     register rtx x0;\n     rtx insn;\n{\n"
argument_list|,
name|tree
operator|->
name|subroutine_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  register rtx x1, x2, x3, x4, x5;\n  rtx x6, x7, x8, x9, x10, x11;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int tem;\n"
argument_list|)
expr_stmt|;
name|write_tree
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ret0: return -1;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out C code to perform the decisions in the tree.  */
end_comment

begin_function
name|void
name|write_tree
parameter_list|(
name|tree
parameter_list|,
name|prevpos
parameter_list|,
name|afterward
parameter_list|,
name|afterpos
parameter_list|,
name|initial
parameter_list|)
name|struct
name|decision
modifier|*
name|tree
decl_stmt|;
name|char
modifier|*
name|prevpos
decl_stmt|;
name|int
name|afterward
decl_stmt|;
name|char
modifier|*
name|afterpos
decl_stmt|;
name|int
name|initial
decl_stmt|;
block|{
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
specifier|register
name|int
name|depth
decl_stmt|;
name|int
name|ignmode
decl_stmt|;
enum|enum
name|anon1
block|{
name|NO_SWITCH
block|,
name|CODE_SWITCH
block|,
name|MODE_SWITCH
block|}
name|in_switch
init|=
name|NO_SWITCH
enum|;
name|char
name|modemap
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
name|char
name|codemap
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
name|pos
operator|=
name|prevpos
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|subroutine_number
operator|>
literal|0
operator|&&
operator|!
name|initial
condition|)
block|{
name|printf
argument_list|(
literal|" L%d:\n"
argument_list|,
name|tree
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"  tem = recog_%d (x0, insn);\n"
argument_list|,
name|tree
operator|->
name|subroutine_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (tem>= 0) return tem;\n"
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|pos
argument_list|,
name|afterpos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  goto L%d;\n"
argument_list|,
name|afterward
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  return recog_%d (x0, insn);\n"
argument_list|,
name|tree
operator|->
name|subroutine_number
argument_list|)
expr_stmt|;
return|return;
block|}
name|tree
operator|->
name|label_needed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tree
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* Find the next alternative to p 	 that might be true when p is true. 	 Test that one next if p's successors fail. 	 Note that when the `tests' field is nonzero 	 it is up to the specified test-function to compare machine modes 	 and some (such as general_operand) don't always do so. 	 But when inside a switch-on-modes we ignore this and 	 consider all modes mutually exclusive.  */
for|for
control|(
name|p1
operator|=
name|p
operator|->
name|next
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|code
operator|==
name|UNKNOWN
operator|||
name|p1
operator|->
name|code
operator|==
name|UNKNOWN
operator|||
name|p
operator|->
name|code
operator|==
name|p1
operator|->
name|code
operator|)
operator|&&
operator|(
name|p
operator|->
name|mode
operator|==
name|VOIDmode
operator|||
name|p1
operator|->
name|mode
operator|==
name|VOIDmode
operator|||
name|p
operator|->
name|mode
operator|==
name|p1
operator|->
name|mode
operator|||
operator|(
name|in_switch
operator|!=
name|MODE_SWITCH
operator|&&
operator|(
name|p
operator|->
name|tests
operator|||
name|p1
operator|->
name|tests
operator|)
operator|)
operator|)
operator|)
operator|||
name|strcmp
argument_list|(
name|p1
operator|->
name|position
argument_list|,
name|p
operator|->
name|position
argument_list|)
condition|)
break|break;
name|p
operator|->
name|afterward
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|p1
operator|->
name|label_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in_switch
operator|==
name|MODE_SWITCH
operator|&&
operator|(
name|p
operator|->
name|mode
operator|==
name|VOIDmode
operator|||
operator|(
operator|!
name|p
operator|->
name|enforce_mode
operator|&&
name|p
operator|->
name|tests
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|in_switch
operator|=
name|NO_SWITCH
expr_stmt|;
name|printf
argument_list|(
literal|"  }\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_switch
operator|==
name|CODE_SWITCH
operator|&&
name|p
operator|->
name|code
operator|==
name|UNKNOWN
condition|)
block|{
name|in_switch
operator|=
name|NO_SWITCH
expr_stmt|;
name|printf
argument_list|(
literal|"  }\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|label_needed
condition|)
name|printf
argument_list|(
literal|" L%d:\n"
argument_list|,
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|success
operator|==
literal|0
operator|&&
name|p
operator|->
name|insn_code_number
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|change_state
argument_list|(
name|pos
argument_list|,
name|p
operator|->
name|position
argument_list|)
expr_stmt|;
name|pos
operator|=
name|p
operator|->
name|position
expr_stmt|;
name|depth
operator|=
name|strlen
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|ignmode
operator|=
name|p
operator|->
name|ignmode
operator|||
name|pos
index|[
name|depth
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|||
name|p
operator|->
name|tests
expr_stmt|;
if|if
condition|(
name|in_switch
operator|==
name|NO_SWITCH
condition|)
block|{
comment|/* If p and its alternatives all want the same mode, 	     reject all others at once, first, then ignore the mode.  */
if|if
condition|(
operator|!
name|ignmode
operator|&&
name|p
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
name|p
operator|->
name|next
operator|&&
name|same_modes
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|mode
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  if (GET_MODE (x%d) != %smode)\n"
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"    {\n    "
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|pos
argument_list|,
name|afterpos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      goto L%d;\n    }\n"
argument_list|,
name|afterward
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"    goto ret0;\n"
argument_list|)
expr_stmt|;
name|clear_modes
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ignmode
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If p and its alternatives all want the same code, 	     reject all others at once, first, then ignore the code.  */
if|if
condition|(
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
name|p
operator|->
name|next
operator|&&
name|same_codes
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  if (GET_CODE (x%d) != "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|change_state
argument_list|(
name|pos
argument_list|,
name|afterpos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    goto L%d; }\n"
argument_list|,
name|afterward
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"    goto ret0;\n"
argument_list|)
expr_stmt|;
name|clear_codes
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If p and its alternatives all have different modes 	 and there are at least 4 of them, make a switch.  */
if|if
condition|(
name|in_switch
operator|==
name|NO_SWITCH
operator|&&
name|pos
index|[
name|depth
operator|-
literal|1
index|]
operator|!=
literal|'*'
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|mybzero
argument_list|(
name|modemap
argument_list|,
sizeof|sizeof
name|modemap
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p1
operator|&&
name|p1
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
operator|(
name|p1
operator|->
name|tests
operator|==
literal|0
operator|||
name|p1
operator|->
name|enforce_mode
operator|)
operator|)
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|enforce_mode
operator|&&
name|modemap
index|[
operator|(
name|int
operator|)
name|p1
operator|->
name|mode
index|]
condition|)
block|{
name|lose
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|modemap
index|[
operator|(
name|int
operator|)
name|p1
operator|->
name|mode
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lose
operator|&&
name|i
operator|>=
literal|4
condition|)
block|{
name|in_switch
operator|=
name|MODE_SWITCH
expr_stmt|;
name|printf
argument_list|(
literal|" switch (GET_MODE (x%d))\n  {\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_switch
operator|==
name|NO_SWITCH
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|mybzero
argument_list|(
name|codemap
argument_list|,
sizeof|sizeof
name|codemap
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
name|p1
operator|&&
name|p1
operator|->
name|code
operator|!=
name|UNKNOWN
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|codemap
index|[
operator|(
name|int
operator|)
name|p1
operator|->
name|code
index|]
condition|)
break|break;
name|codemap
index|[
operator|(
name|int
operator|)
name|p1
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p1
operator|==
literal|0
operator|||
name|p1
operator|->
name|code
operator|==
name|UNKNOWN
operator|)
operator|&&
name|i
operator|>=
literal|4
condition|)
block|{
name|in_switch
operator|=
name|CODE_SWITCH
expr_stmt|;
name|printf
argument_list|(
literal|" switch (GET_CODE (x%d))\n  {\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_switch
operator|==
name|MODE_SWITCH
condition|)
block|{
if|if
condition|(
name|modemap
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|mode
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"  case %smode:\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|modemap
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|mode
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_switch
operator|==
name|CODE_SWITCH
condition|)
block|{
if|if
condition|(
name|codemap
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|code
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"  case "
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|codemap
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|code
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  if ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exact
operator|||
operator|(
name|p
operator|->
name|code
operator|!=
name|UNKNOWN
operator|&&
name|in_switch
operator|!=
name|CODE_SWITCH
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|exact
condition|)
name|printf
argument_list|(
literal|"x%d == %s"
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|exact
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"GET_CODE (x%d) == "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|p
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
operator|!
name|ignmode
operator|&&
name|in_switch
operator|!=
name|MODE_SWITCH
condition|)
name|printf
argument_list|(
literal|"GET_MODE (x%d) == %smode&& "
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|test_elt_zero_int
condition|)
name|printf
argument_list|(
literal|"XINT (x%d, 0) == %d&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|elt_zero_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|veclen
condition|)
name|printf
argument_list|(
literal|"XVECLEN (x%d, 0) == %d&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|veclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|test_elt_one_int
condition|)
name|printf
argument_list|(
literal|"XINT (x%d, 1) == %d&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|elt_one_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dupno
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"rtx_equal_p (x%d, recog_operand[%d])&& "
argument_list|,
name|depth
argument_list|,
name|p
operator|->
name|dupno
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tests
condition|)
name|printf
argument_list|(
literal|"%s (x%d, %smode)"
argument_list|,
name|p
operator|->
name|tests
argument_list|,
name|depth
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|p
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opno
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|")\n    { recog_operand[%d] = x%d; "
argument_list|,
name|p
operator|->
name|opno
argument_list|,
name|depth
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|")\n    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_test
condition|)
name|printf
argument_list|(
literal|"if (%s) "
argument_list|,
name|p
operator|->
name|c_test
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|insn_code_number
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"return %d;"
argument_list|,
name|p
operator|->
name|insn_code_number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"goto L%d;"
argument_list|,
name|p
operator|->
name|success
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opno
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" }\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Now, if inside a switch, branch to next switch member 	 that might also need to be tested if this one fails.  */
if|if
condition|(
name|in_switch
operator|==
name|CODE_SWITCH
condition|)
block|{
comment|/* Find the next alternative to p 	     that might be applicable if p was applicable.  */
for|for
control|(
name|p1
operator|=
name|p
operator|->
name|next
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
if|if
condition|(
name|p1
operator|->
name|code
operator|==
name|UNKNOWN
operator|||
name|p
operator|->
name|code
operator|==
name|p1
operator|->
name|code
condition|)
break|break;
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p1
operator|->
name|code
operator|==
name|UNKNOWN
condition|)
name|printf
argument_list|(
literal|"  break;\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|!=
name|p
operator|->
name|next
condition|)
block|{
name|printf
argument_list|(
literal|" goto L%d;\n"
argument_list|,
name|p1
operator|->
name|number
argument_list|)
expr_stmt|;
name|p1
operator|->
name|label_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_switch
operator|==
name|MODE_SWITCH
condition|)
block|{
comment|/* Find the next alternative to p 	     that might be applicable if p was applicable.  */
for|for
control|(
name|p1
operator|=
name|p
operator|->
name|next
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
if|if
condition|(
name|p1
operator|->
name|mode
operator|==
name|VOIDmode
operator|||
name|p
operator|->
name|mode
operator|==
name|p1
operator|->
name|mode
condition|)
break|break;
if|if
condition|(
name|p1
operator|==
literal|0
operator|||
name|p1
operator|->
name|mode
operator|==
name|VOIDmode
condition|)
name|printf
argument_list|(
literal|"  break;\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|!=
name|p
operator|->
name|next
condition|)
block|{
name|printf
argument_list|(
literal|" goto L%d;\n"
argument_list|,
name|p1
operator|->
name|number
argument_list|)
expr_stmt|;
name|p1
operator|->
name|label_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|in_switch
operator|!=
name|NO_SWITCH
condition|)
name|printf
argument_list|(
literal|"  }\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterward
condition|)
block|{
name|change_state
argument_list|(
name|pos
argument_list|,
name|afterpos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  goto L%d;\n"
argument_list|,
name|afterward
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  goto ret0;\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tree
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|success
condition|)
block|{
block|{
name|pos
operator|=
name|p
operator|->
name|position
expr_stmt|;
name|write_tree
argument_list|(
name|p
operator|->
name|success
argument_list|,
name|pos
argument_list|,
name|p
operator|->
name|afterward
condition|?
name|p
operator|->
name|afterward
operator|->
name|number
else|:
name|afterward
argument_list|,
name|p
operator|->
name|afterward
condition|?
name|pos
else|:
name|afterpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|>=
literal|'a'
operator|&&
operator|*
name|p1
operator|<=
literal|'z'
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|+
literal|'A'
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|same_codes
parameter_list|(
name|p
parameter_list|,
name|code
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|code
operator|!=
name|code
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|clear_codes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|code
operator|=
name|UNKNOWN
expr_stmt|;
block|}
end_function

begin_function
name|int
name|same_modes
parameter_list|(
name|p
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|mode
operator|!=
name|mode
operator|||
name|p
operator|->
name|tests
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|clear_modes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|decision
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|ignmode
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|change_state
parameter_list|(
name|oldpos
parameter_list|,
name|newpos
parameter_list|)
name|char
modifier|*
name|oldpos
decl_stmt|;
name|char
modifier|*
name|newpos
decl_stmt|;
block|{
name|int
name|odepth
init|=
name|strlen
argument_list|(
name|oldpos
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
name|odepth
decl_stmt|;
name|int
name|ndepth
init|=
name|strlen
argument_list|(
name|newpos
argument_list|)
decl_stmt|;
comment|/* Pop up as many levels as necessary.  */
while|while
condition|(
name|strncmp
argument_list|(
name|oldpos
argument_list|,
name|newpos
argument_list|,
name|depth
argument_list|)
condition|)
operator|--
name|depth
expr_stmt|;
comment|/* Go down to desired level.  */
while|while
condition|(
name|depth
operator|<
name|ndepth
condition|)
block|{
if|if
condition|(
name|newpos
index|[
name|depth
index|]
operator|==
literal|'*'
condition|)
name|printf
argument_list|(
literal|"  x%d = recog_addr_dummy;\n  XEXP (x%d, 0) = x%d;\n"
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newpos
index|[
name|depth
index|]
operator|>=
literal|'a'
operator|&&
name|newpos
index|[
name|depth
index|]
operator|<=
literal|'z'
condition|)
name|printf
argument_list|(
literal|"  x%d = XVECEXP (x%d, 0, %d);\n"
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|,
name|newpos
index|[
name|depth
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  x%d = XEXP (x%d, %c);\n"
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|depth
argument_list|,
name|newpos
index|[
name|depth
index|]
argument_list|)
expr_stmt|;
operator|++
name|depth
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|copystr
parameter_list|(
name|s1
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tem
argument_list|,
name|s1
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
name|void
name|mybzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|0
condition|)
return|return
name|s2
return|;
if|if
condition|(
name|s2
operator|==
literal|0
condition|)
return|return
name|s1
return|;
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tem
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_block

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
block|{
specifier|register
name|int
name|val
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genrecog: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"after %d instruction definitions\n"
argument_list|,
name|next_insn_code
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|struct
name|decision
modifier|*
name|tree
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|extern
name|rtx
name|read_rtx
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|next_insn_code
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genrecog'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|tree
operator|=
name|merge_trees
argument_list|(
name|tree
argument_list|,
name|make_insn_sequence
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|next_insn_code
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\ /* `recog' contains a decision tree\n\    that recognizes whether the rtx X0 is a valid instruction.\n\ \n\    recog returns -1 if the rtx is not valid.\n\    If the rtx is valid, recog returns a nonnegative number\n\    which is the insn code number for the pattern that matched.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   This is the same as the order in the machine description of\n\    the entry that matched.  This number can be used as an index into\n\    insn_templates and insn_n_operands (found in insn-output.c)\n\    or as an argument to output_insn_hairy (also in insn-output.c).  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx recog_operand[MAX_RECOG_OPERANDS];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx *recog_operand_loc[MAX_RECOG_OPERANDS];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx *recog_dup_loc[MAX_DUP_OPERANDS];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"char recog_dup_num[MAX_DUP_OPERANDS];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx recog_addr_dummy;\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands recog_operand\n\n"
argument_list|)
expr_stmt|;
name|break_out_subroutines
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"int\nrecog (x0, insn)\n     register rtx x0;\n     rtx insn;\n{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  register rtx x1, x2, x3, x4, x5;\n  rtx x6, x7, x8, x9, x10, x11;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int tem;\n"
argument_list|)
expr_stmt|;
name|write_tree
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ret0: return -1;\n}\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

