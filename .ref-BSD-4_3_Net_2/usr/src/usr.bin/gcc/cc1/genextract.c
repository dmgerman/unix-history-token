begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to extract operands from insn as rtl.    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Number instruction patterns handled, starting at 0 for first one.  */
end_comment

begin_decl_stmt
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number the occurrences of MATCH_DUP in each instruction,    starting at 0 for the first occurrence.  */
end_comment

begin_decl_stmt
name|int
name|dup_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While tree-walking an instruction pattern, we keep a chain    of these `struct link's to record how to get down to the    current position.  In each one, POS is the operand number,    and if the operand is a vector VEC is the element number.    VEC is -1 if the operand is not a vector.  */
end_comment

begin_struct
struct|struct
name|link
block|{
name|struct
name|link
modifier|*
name|next
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|vecelt
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|walk_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|dup_count
operator|=
literal|0
expr_stmt|;
comment|/* Output the function name and argument declaration.  */
comment|/* It would be cleaner to make `void' the return type      but 4.2 vax compiler doesn't accept that in the array      that these functions are supposed to go in.  */
name|printf
argument_list|(
literal|"VOID\nextract_%d (insn)\n     rtx insn;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* Walk the insn's pattern, remembering at all times the path      down to the walking point.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|link
name|link
decl_stmt|;
name|link
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|link
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like gen_insn but handles `define_peephole'.  */
end_comment

begin_function
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|)
name|rtx
name|peep
decl_stmt|;
block|{
comment|/* Output the function name and argument declaration.  */
name|printf
argument_list|(
literal|"VOID\nextract_%d (insn)\n     rtx insn;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* The vector in the insn says how many operands it has.      And all it contains are operands.  In fact, the vector was      created just for the sake of this function.  */
name|printf
argument_list|(
literal|"\   bcopy (&XVECEXP (insn, 0, 0), recog_operand,\          sizeof (rtx) * XVECLEN (insn, 0));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|walk_rtx
parameter_list|(
name|x
parameter_list|,
name|path
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|link
modifier|*
name|path
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|link
name|link
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
return|return;
case|case
name|MATCH_OPERAND
case|:
name|printf
argument_list|(
literal|"  recog_operand[%d] = *(recog_operand_loc[%d]\n    =&"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_DUP
case|:
name|printf
argument_list|(
literal|"  recog_dup_loc[%d] =&"
argument_list|,
name|dup_count
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  recog_dup_num[%d] = %d;\n"
argument_list|,
name|dup_count
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dup_count
operator|++
expr_stmt|;
break|break;
case|case
name|MATCH_OPERATOR
case|:
name|printf
argument_list|(
literal|"  recog_operand[%d] = *(recog_operand_loc[%d]\n    =&"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ADDRESS
case|:
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
block|{
name|walk_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|link
operator|.
name|vecelt
operator|=
name|j
expr_stmt|;
name|walk_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a PATH, representing a path down the instruction's    pattern from the root to a certain point, output code to    evaluate to the rtx at that point.  */
end_comment

begin_function
name|void
name|print_path
parameter_list|(
name|path
parameter_list|)
name|struct
name|link
modifier|*
name|path
decl_stmt|;
block|{
if|if
condition|(
name|path
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"insn"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|vecelt
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"XVECEXP ("
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d, %d)"
argument_list|,
name|path
operator|->
name|pos
argument_list|,
name|path
operator|->
name|vecelt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"XEXP ("
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
block|{
specifier|register
name|int
name|val
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genextract: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|extern
name|rtx
name|read_rtx
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
comment|/* Assign sequential codes to all entries in the machine description      in parallel with the tables in insn-output.c.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genextract'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx recog_operand[];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx *recog_operand_loc[];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx *recog_dup_loc[];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern char recog_dup_num[];\n\n"
argument_list|)
expr_stmt|;
comment|/* The extractor functions really should return `void';      but old C compilers don't seem to be able to handle the array      definition if `void' is used.  So use `int' in non-ANSI C compilers.  */
name|printf
argument_list|(
literal|"#ifdef __STDC__\n#define VOID void\n#else\n#define VOID int\n#endif\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
block|{
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
name|gen_peephole
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
block|{
name|printf
argument_list|(
literal|"VOID extract_%d () {}\n\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"VOID (*insn_extract_fn[]) () =\n{ "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_code_number
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|4
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|",\n  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extract_%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n};\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"void fatal_insn_not_found ();\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"void\ninsn_extract (insn)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n  if (INSN_CODE (insn) == -1) fatal_insn_not_found (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (*insn_extract_fn[INSN_CODE (insn)]) (PATTERN (insn));\n}\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

