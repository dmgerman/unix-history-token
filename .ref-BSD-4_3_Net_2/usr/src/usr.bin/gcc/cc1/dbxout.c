begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output dbx-format symbol table information from GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Output dbx-format symbol table data.    This consists of many symbol table entries, each of them    a .stabs assembler pseudo-op with four operands:    a "name" which is really a description of one symbol and its type,    a "code", which is a symbol defined in stab.h whose name starts with N_,    an unused operand always 0,    and a "value" which is an address or an offset.    The name is enclosed in doublequote characters.     Each function, variable, typedef, and structure tag    has a symbol table entry to define it.    The beginning and end of each level of name scoping within    a function are also marked by special symbol table entries.     The "name" consists of the symbol name, a colon, a kind-of-symbol letter,    and a data type number.  The data type number may be followed by    "=" and a type definition; normally this will happen the first time    the type number is mentioned.  The type definition may refer to    other types by number, and those type numbers may be followed    by "=" and nested definitions.     This can make the "name" quite long.    When a name is more than 80 characters, we split the .stabs pseudo-op    into two .stabs pseudo-ops, both sharing the same "code" and "value".    The first one is marked as continued with a double-backslash at the    end of its "name".     The kind-of-symbol letter distinguished function names from global    variables from file-scope variables from parameters from auto    variables in memory from typedef names from register variables.    See `dbxout_symbol'.     The "code" is mostly redundant with the kind-of-symbol letter    that goes in the "name", but not entirely: for symbols located    in static storage, the "code" says which segment the address is in,    which controls how it is relocated.     The "value" for a symbol in static storage    is the core address of the symbol (actually, the assembler    label for the symbol).  For a symbol located in a stack slot    it is the stack offset; for one in a register, the register number.    For a typedef symbol, it is zero.     If DEBUG_SYMS_TEXT is defined, all debugging symbols must be    output while in the text section.     For more on data type definitions, see `dbxout_type'.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Typical USG systems don't have stab.h, and they also have    no use for DBX-format debugging info.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SYMS_TEXT
end_ifdef

begin_define
define|#
directive|define
name|FORCE_TEXT
value|text_section ();
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_TEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|"stab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* On BSD, use the system's stab.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_comment
comment|/* Stream for writing to assembler file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|asmfile
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|typestatus
block|{
name|TYPE_UNSEEN
block|,
name|TYPE_XREF
block|,
name|TYPE_DEFINED
block|}
enum|;
end_enum

begin_comment
comment|/* Vector recording the status of describing C data types.    When we first notice a data type (a tree node),    we assign it a number using next_type_number.    That is its index in this vector.    The vector element says whether we have yet output    the definition of the type.  TYPE_XREF says we have    output it as a cross-reference only.  */
end_comment

begin_decl_stmt
name|enum
name|typestatus
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of space allocated in `typevec'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|typevec_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In dbx output, each type gets a unique number.    This is the number for the next type output.    The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_type_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In dbx output, we must assign symbol-blocks id numbers    in the order in which their beginnings are encountered.    We output debugging info that refers to the beginning and    end of the ranges of code in each block    with assembler labels LBBn and LBEn, where n is the block number.    The labels are generated in final, which assigns numbers to the    blocks in the same way.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are for dbxout_symbol to communicate to    dbxout_finish_symbol.    current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.    current_sym_value and current_sym_addr are two ways to address the    value to store in the symtab entry.    current_sym_addr if nonzero represents the value as an rtx.    If that is zero, current_sym_value is used.  This is used    when the value is an offset (such as for auto variables,    register variables and parms).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_sym_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_sym_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|current_sym_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars of symbol-description generated so far for the    current symbol.  Used by CHARS and CONTIN.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_sym_nchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report having output N chars of the current symbol-description.  */
end_comment

begin_define
define|#
directive|define
name|CHARS
parameter_list|(
name|N
parameter_list|)
value|(current_sym_nchars += (N))
end_define

begin_comment
comment|/* Break the current symbol-description, generating a continuation,    if it has become long.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_CONTIN_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DBX_CONTIN_LENGTH
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DBX_CONTIN_LENGTH
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|CONTIN
define|\
value|do {if (current_sym_nchars> DBX_CONTIN_LENGTH) dbxout_continue ();} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONTIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|dbxout_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dbxout_tags
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dbxout_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dbxout_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_finish_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_continue
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* At the beginning of compilation, start writing the symbol table.    Initialize `typevec' and output the standard data types of C.  */
end_comment

begin_function
name|void
name|dbxout_init
parameter_list|(
name|asm_file
parameter_list|,
name|input_file_name
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
name|char
modifier|*
name|input_file_name
decl_stmt|;
block|{
name|asmfile
operator|=
name|asm_file
expr_stmt|;
name|typevec_len
operator|=
literal|100
expr_stmt|;
name|typevec
operator|=
operator|(
expr|enum
name|typestatus
operator|*
operator|)
name|xmalloc
argument_list|(
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|typevec
argument_list|,
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Used to put `Ltext:' before the reference, but that loses on sun 4.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\t.stabs \"%s\",%d,0,0,Ltext\nLtext:\n"
argument_list|,
name|input_file_name
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
name|next_type_number
operator|=
literal|1
expr_stmt|;
name|next_block_number
operator|=
literal|2
expr_stmt|;
comment|/* Make sure that types `int' and `char' have numbers 1 and 2.      Definitions of other integer types will refer to those numbers.  */
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get all permanent types not yet gotten, and output them.  */
name|dbxout_types
argument_list|(
name|get_permanent_types
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Continue a symbol-description that gets too big.    End one symbol table entry with a double-backslash    and start a new one, eventually producing something like    .stabs "start......\\",code,0,value    .stabs "...rest",code,0,value   */
end_comment

begin_function
specifier|static
name|void
name|dbxout_continue
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DBX_CONTIN_CHAR
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%c"
argument_list|,
name|DBX_CONTIN_CHAR
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \""
argument_list|)
expr_stmt|;
name|current_sym_nchars
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a reference to a type.  If the type has not yet been    described in the dbx output, output its definition now.    For a type already defined, just refer to its definition    using the type number.     If FULL is nonzero, and the type has been described only with    a forward-reference, output the definition now.    If FULL is zero in this case, just refer to the forward-reference    using the number previously allocated.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type
parameter_list|(
name|type
parameter_list|,
name|full
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|full
decl_stmt|;
block|{
specifier|register
name|tree
name|tem
decl_stmt|;
comment|/* If there was an input error and we don't really have a type,      avoid crashing and write something that is at least valid      by assuming `int'.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Type has no dbx number assigned.  Assign next available number.  */
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|=
name|next_type_number
operator|++
expr_stmt|;
comment|/* Make sure type vector is long enough to record about this type.  */
if|if
condition|(
name|next_type_number
operator|==
name|typevec_len
condition|)
block|{
name|typevec
operator|=
operator|(
expr|enum
name|typestatus
operator|*
operator|)
name|xrealloc
argument_list|(
name|typevec
argument_list|,
name|typevec_len
operator|*
literal|2
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|typevec
operator|+
name|typevec_len
argument_list|,
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|typevec_len
operator|*=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Output the number of this type, to refer to it.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* If this type's definition has been output or is now being output,      that is all.  */
switch|switch
condition|(
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
condition|)
block|{
case|case
name|TYPE_UNSEEN
case|:
break|break;
case|case
name|TYPE_XREF
case|:
if|if
condition|(
operator|!
name|full
condition|)
return|return;
break|break;
case|case
name|TYPE_DEFINED
case|:
return|return;
block|}
ifdef|#
directive|ifdef
name|DBX_NO_XREFS
comment|/* For systems where dbx output does not allow the `=xsNAME:' syntax,      leave the type-number completely undefined rather than output      a cross-reference.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|full
operator|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_XREF
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Output a definition now.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark it as defined, so that if it is self-referent      we will not get into an infinite recursion of definitions.  */
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_DEFINED
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
comment|/* For a void type, just define it as itself; ie, "5=5". 	 This makes us consider it defined 	 without saying what it is.  The debugger will make it 	 a void type when the reference is seen, and nothing will 	 ever override that default.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|char_type_node
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Output the type `char' as a subrange of itself! 	   I don't understand this definition, just copied it 	   from the output of pcc.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r2;0;127;"
argument_list|)
expr_stmt|;
else|else
comment|/* Output other integer types as subranges of `int'.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r1;%d;%d;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|25
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
comment|/* This must be magic.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r1;%d;0;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Output "a" followed by a range type definition 	 for the index type of the array 	 followed by a reference to the target-type. 	 ar1;0;N;M for an array of type M and size N.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"ar1;0;%d;"
argument_list|,
operator|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|?
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
comment|/* Output a structure type.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|full
operator|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the type is just a cross reference, output one 	     and mark the type as partially described. 	     If it later becomes defined, we will output 	     its real definition. 	     If the type has a name, don't nest its definition within 	     another type's definition; instead, output an xref 	     and let the definition come when the name is defined.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|"xs"
else|:
literal|"xu"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This assertion is legitimately false in C++.  */
comment|/* We shouldn't be outputting a reference to a type before its 	     definition unless the type has a tag name. 	     A typedef name without a tag name should be impossible.  */
block|if (TREE_CODE (TYPE_NAME (type)) != IDENTIFIER_NODE) 	    abort ();
endif|#
directive|endif
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_XREF
expr_stmt|;
break|break;
block|}
name|tem
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|"s%d"
else|:
literal|"u%d"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|use_gdb_dbx_extensions
condition|)
block|{
name|putc
argument_list|(
literal|'!'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|TREE_PUBLIC
argument_list|(
name|TYPE_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|?
literal|'2'
else|:
literal|'0'
operator|)
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|CHARS
argument_list|(
literal|11
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
comment|/* Output the name, type, position (in bits), size (in bits) 	   of each field.  */
comment|/* Omit here the nameless fields that are used to skip bits.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Continue the line if necessary, 	       but not before the first field.  */
if|if
condition|(
name|tem
operator|!=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
name|CONTIN
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TREE_PRIVATE
if|if
condition|(
name|use_gdb_dbx_extensions
operator|&&
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
condition|?
literal|'0'
else|:
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
condition|?
literal|'1'
else|:
literal|'2'
operator|)
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|putc
argument_list|(
literal|':'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FUNCTION_TYPE */
name|dbxout_args
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TREE_VIRTUAL
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":%s;%c"
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_VIRTUAL
argument_list|(
name|tem
argument_list|)
condition|?
literal|'*'
else|:
literal|'.'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHARS
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|use_gdb_dbx_extensions
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":%s"
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",0,0;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,%d;"
argument_list|,
name|DECL_OFFSET
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|tem
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|full
operator|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"xe"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_XREF
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
literal|'e'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s:%d,"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|11
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|CONTIN
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|putc
argument_list|(
literal|'*'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|use_gdb_dbx_extensions
condition|)
block|{
name|putc
argument_list|(
literal|'@'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Treat it as a function type.  */
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|use_gdb_dbx_extensions
condition|)
block|{
name|putc
argument_list|(
literal|'@'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Treat it as a function type.  */
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|putc
argument_list|(
name|use_gdb_dbx_extensions
condition|?
literal|'&'
else|:
literal|'*'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|putc
argument_list|(
literal|'f'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the name of type TYPE, with no punctuation.    Such names can be set up either by typedef declarations    or by struct, enum and union tags.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_name
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a .stabs for the symbol defined by DECL,    which must be a ..._DECL node in the normal namespace.    It may be a CONST_DECL, a FUNCTION_DECL, a PARM_DECL or a VAR_DECL.    LOCAL is nonzero if the scope is less than the entire file.  */
end_comment

begin_function
name|void
name|dbxout_symbol
parameter_list|(
name|decl
parameter_list|,
name|local
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* If global, first output all types and all      struct, enum and union tags that have been created      and not yet output.  */
if|if
condition|(
name|local
operator|==
literal|0
condition|)
block|{
name|dbxout_tags
argument_list|(
name|gettags
argument_list|()
argument_list|)
expr_stmt|;
name|dbxout_types
argument_list|(
name|get_permanent_types
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|current_sym_code
operator|=
literal|0
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
comment|/* The output will always start with the symbol name,      so count that always in the length-output-so-far.  */
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* Enum values are defined by defining the enum type.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
break|break;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:%c"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
literal|'F'
else|:
literal|'f'
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|N_FUN
expr_stmt|;
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dbxout_type
argument_list|(
name|void_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|#
directive|if
literal|0
comment|/* This seems all wrong.  Outputting most kinds of types gives no name 	 at all.  A true definition gives no name; a cross-ref for a 	 structure can give the tag name, but not a type name. 	 It seems that no typedef name is defined by outputting a type.  */
comment|/* If this typedef name was defined by outputting the type, 	 don't duplicate it.  */
block|if (typevec[TYPE_SYMTAB_ADDRESS (type)] == TYPE_DEFINED&& TYPE_NAME (TREE_TYPE (decl)) == decl) 	return;
endif|#
directive|endif
comment|/* Don't output the same typedef twice.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output typedef name.  */
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:t"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
comment|/* Prevent duplicate output of a typedef.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* Parm decls go in their own separate chains 	 and are output by dbxout_reg_parms and dbxout_parms.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Don't mention a variable that is external. 	 Let the file that defines it describe it.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* Don't mention a variable at all 	 if it was completely optimized into nothingness.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
break|break;
comment|/* The kind-of-variable letter depends on where 	 the variable is and on the scope of its name: 	 G and N_GSYM for static storage and global scope, 	 S for static storage and file scope, 	 V for static storage and local scope, 	    for those two, use N_LCSYM if data is in bss segment, 	    N_STSYM if in data segment, N_FUN otherwise. 	    (We used N_FUN originally, then changed to N_STSYM 	    to please GDB.  However, it seems that confused ld. 	    Now GDB has been fixed to like N_FUN, says Kingdon.) 	 no letter at all, and N_LSYM, for auto variable, 	 r and N_RSYM for register variable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|letter
operator|=
literal|'G'
expr_stmt|;
name|current_sym_code
operator|=
name|N_GSYM
expr_stmt|;
block|}
else|else
block|{
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|letter
operator|=
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|?
literal|'S'
else|:
literal|'V'
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|current_sym_code
operator|=
name|N_LCSYM
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* This is not quite right, but it's the closest 		   of all the codes that Unix defines.  */
name|current_sym_code
operator|=
name|N_FUN
expr_stmt|;
else|else
block|{
comment|/* Ultrix `as' seems to need this.  */
ifdef|#
directive|ifdef
name|DBX_STATIC_STAB_DATA_SECTION
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|current_sym_code
operator|=
name|N_STSYM
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|value
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|value
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register 	   that isn't the frame pointer 	   then it means the object is variable-sized and address through 	   that register or stack slot.  DBX has no way to represent this 	   so all we can do is output the variable as a pointer. 	   If it's not a parameter, ignore it. 	   (VAR_DECLs like this can be made by integrate.c.)  */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))). 		 We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Effectively do build_pointer_type, but don't cache this type, 	     since it might be temporary whereas the type it points to 	     might have been saved for inlining.  */
name|type
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))) 	     We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Address might be a MEM, when DECL is a variable-sized object. 	   Or it might be const0_rtx, meaning previous passes 	   want us to ignore this variable.  */
break|break;
comment|/* Ok, start a symtab entry and output the variable name.  */
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
condition|)
name|putc
argument_list|(
name|letter
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dbxout_finish_symbol
parameter_list|()
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\",%d,0,0,"
argument_list|,
name|current_sym_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sym_addr
condition|)
name|output_addr_const
argument_list|(
name|asmfile
argument_list|,
name|current_sym_addr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|current_sym_value
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output definitions of all the decls in a chain.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_syms
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
while|while
condition|(
name|syms
condition|)
block|{
name|dbxout_symbol
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following two functions output definitions of function parameters.    Each parameter gets a definition locating it in the parameter list.    Each parameter that is a register variable gets a second definition    locating it in the register.     Printing or argument lists in gdb uses the definitions that    locate in the parameter list.  But reference to the variable in    expressions uses preferentially the definition as a register.  */
end_comment

begin_comment
comment|/* Output definitions, referring to storage in the parmlist,    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|current_sym_code
operator|=
name|N_PSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:p"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|dbxout_type
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This is the case where the parm is passed as an int or double 		 and it is converted to a char, short or float and stored back 		 in the parmlist.  In this case, describe the parm 		 with the variable's declared type, and adjust the address 		 if the least significant bytes (which we are using) are not 		 the first ones.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
condition|)
name|current_sym_value
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|current_sym_value
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|current_sym_value
operator|=
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
block|}
comment|/* Parm was passed in registers. 	 If it lives in a hard register, output a "regparm" symbol 	 for the register it lives in.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:P"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))). 	     We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:p"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is actually the case in which a parameter 	 is passed in registers but lives on the stack in a local slot. 	 The address we are using is already correct, so don't change it.  */
comment|/* This is the case where the parm is passed as an int or double 	     and it is converted to a char, short or float and stored back 	     in the parmlist.  In this case, describe the parm 	     with the variable's declared type, and adjust the address 	     if the least significant bytes (which we are using) are not 	     the first ones.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
block|if (TREE_TYPE (parms) != DECL_ARG_TYPE (parms)) 	    current_sym_value += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms))) 				  - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output definitions, referring to registers,    of all the parms in PARMS which are stored in registers during the function.    PARMS is a chain of PARM_DECL nodes.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_reg_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
while|while
condition|(
name|parms
condition|)
block|{
comment|/* Report parms that live in registers during the function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:r"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
block|}
comment|/* Report parms that live in memory but outside the parmlist.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|offset
init|=
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
comment|/* A parm declared char is really passed as an int, 	     so it occupies the least significant bytes. 	     On a big-endian machine those are not the low-numbered ones.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
operator|&&
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
condition|)
name|offset
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
block|}
block|}
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of ..._TYPE nodes (as come in a parameter list),    output definitions of those names, in raw form */
end_comment

begin_function
name|void
name|dbxout_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
while|while
condition|(
name|args
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of ..._TYPE nodes,    find those which have typedef names and output those names.    This is to ensure those types get output.  */
end_comment

begin_function
name|void
name|dbxout_types
parameter_list|(
name|types
parameter_list|)
specifier|register
name|tree
name|types
decl_stmt|;
block|{
while|while
condition|(
name|types
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the tags (struct, union and enum definitions with names) for a block,    given a list of them (a chain of TREE_LIST nodes) in TAGS.    We must check to include those that have been mentioned already with    only a cross-reference.  */
end_comment

begin_function
name|void
name|dbxout_tags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|link
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabs \"%s:T"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output everything about a symbol block (that is to say, a LET_STMT node    that represents a scope level),    including recursive output of contained blocks.     STMT is the LET_STMT node.    DEPTH is its depth within containing symbol blocks.    ARGS is usually zero; but for the outermost block of the    body of a function, it is a chain of PARM_DECLs for the function parameters.    We output definitions of all the register parms    as if they were local variables of that block.     Actually, STMT may be several statements chained together.    We handle them all in sequence.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_block
parameter_list|(
name|stmt
parameter_list|,
name|depth
parameter_list|,
name|args
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|int
name|blocknum
decl_stmt|;
while|while
condition|(
name|stmt
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_STMT
case|:
case|case
name|LOOP_STMT
case|:
name|dbxout_block
argument_list|(
name|STMT_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|depth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|dbxout_block
argument_list|(
name|STMT_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|depth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_block
argument_list|(
name|STMT_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|depth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LET_STMT
case|:
comment|/* Ignore LET_STMTs for blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
break|break;
comment|/* In dbx format, the syms of a block come before the N_LBRAC.  */
name|dbxout_tags
argument_list|(
name|STMT_TYPE_TAGS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_syms
argument_list|(
name|STMT_VARS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now output an N_LBRAC symbol to represent the beginning of 	     the block.  Use the block's tree-walk order to generate 	     the assembler symbols LBBn and LBEn 	     that final will define around the code in this block.  */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|blocknum
operator|=
name|next_block_number
operator|++
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBB"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabn %d,0,0,"
argument_list|,
name|N_LBRAC
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output the subblocks.  */
name|dbxout_block
argument_list|(
name|STMT_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Refer to the marker for the end of the block.  */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBE"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|".stabn %d,0,0,"
argument_list|,
name|N_RBRAC
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|stmt
operator|=
name|TREE_CHAIN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output dbx data for a function definition.    This includes a definition of the function name itself (a symbol),    definitions of the parameters (locating them in the parameter list)    and then output the block that makes up the function's body    (including all the auto variables of the function).  */
end_comment

begin_function
name|void
name|dbxout_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we made any temporary types in this fn that weren't      output, output them now.  */
name|dbxout_types
argument_list|(
name|get_temporary_types
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not DBX_DEBUGGING_INFO */
end_comment

begin_function
name|void
name|dbxout_init
parameter_list|(
name|asm_file
parameter_list|,
name|input_file_name
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
name|char
modifier|*
name|input_file_name
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|dbxout_symbol
parameter_list|(
name|decl
parameter_list|,
name|local
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|dbxout_types
parameter_list|(
name|types
parameter_list|)
specifier|register
name|tree
name|types
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|dbxout_tags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|dbxout_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

end_unit

