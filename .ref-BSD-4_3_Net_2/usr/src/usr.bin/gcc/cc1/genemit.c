begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to emit insns as rtl.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_dup_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|register_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_function
name|void
name|max_operand_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|register_constraints
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|||
name|code
operator|==
name|MATCH_OPERATOR
condition|)
name|max_opno
operator|=
name|max
argument_list|(
name|max_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_DUP
condition|)
name|max_dup_opno
operator|=
name|max
argument_list|(
name|max_dup_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|max_operand_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|max_operand_vec
parameter_list|(
name|insn
parameter_list|,
name|arg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|max_dup_opno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
name|arg
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|max_opno
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|>=
literal|'a'
operator|&&
operator|*
name|p1
operator|<=
literal|'z'
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|+
literal|'A'
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a C expression to construct an RTX just like X,    substituting any operand references appearing within.  */
end_comment

begin_function
name|void
name|gen_exp
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_DUP
case|:
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
name|printf
argument_list|(
literal|"gen_rtx (GET_CODE (operand%d)"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|fatal
argument_list|(
literal|"ADDRESS expression code used in named instruction pattern"
argument_list|)
expr_stmt|;
case|case
name|PC
case|:
name|printf
argument_list|(
literal|"pc_rtx"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CC0
case|:
name|printf
argument_list|(
literal|"cc0_rtx"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"const0_rtx"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"const1_rtx"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"gen_rtx ("
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'0'
condition|)
break|break;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|gen_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"gen_rtvec (%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the `gen_...' function for a DEFINE_INSN.  */
end_comment

begin_function
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|operands
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Don't mention instructions whose names are the null string.      They are in the machine description just to be recognized.  */
if|if
condition|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Find out how many operands this function has,      and also whether any of them have register constraints.  */
name|register_constraints
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
name|max_operand_vec
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_dup_opno
operator|>=
name|operands
condition|)
name|fatal
argument_list|(
literal|"match_dup operand number has no match_operand"
argument_list|)
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_%s ("
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|i
condition|?
literal|", operand%d"
else|:
literal|"operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"     rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* Output code to construct and return the rtl for the instruction body */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  return "
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n}\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  return gen_rtx (PARALLEL, VOIDmode, gen_rtvec (%d"
argument_list|,
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"));\n}\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the `gen_...' function for a DEFINE_EXPAND.  */
end_comment

begin_function
name|void
name|gen_expand
parameter_list|(
name|expand
parameter_list|)
name|rtx
name|expand
decl_stmt|;
block|{
name|int
name|operands
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_expand lacks a name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_expand for %s lacks a pattern"
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find out how many operands this function has,      and also whether any of them have register constraints.  */
name|register_constraints
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
name|max_operand_vec
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_%s ("
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|i
condition|?
literal|", operand%d"
else|:
literal|"operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"     rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* For each operand referred to only with MATCH_DUPs,      make a local variable.  */
for|for
control|(
name|i
operator|=
name|operands
init|;
name|i
operator|<=
name|max_dup_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx operands[%d];\n"
argument_list|,
name|max
argument_list|(
name|operands
argument_list|,
name|max_dup_opno
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx _val;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  start_sequence ();\n"
argument_list|)
expr_stmt|;
comment|/* The fourth operand of DEFINE_EXPAND is some code to be executed      before the actual construction.      This code expects to refer to `operands'      just as the output-code in a DEFINE_INSN does,      but here `operands' is an automatic array.      So copy the operand values there before executing it.  */
if|if
condition|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* Output code to copy the arguments into `operands'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operands[%d] = operand%d;\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output the special code to be executed before the sequence 	 is generated.  */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output code to copy the arguments back out of `operands' 	 (unless we aren't going to use them at all).  */
if|if
condition|(
name|XVEC
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max_dup_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output code to construct the rtl for the instruction bodies.      Use emit_insn to add them to the sequence being accumulated.      But don't do this if the user's code has set `no_more' nonzero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|next
init|=
name|XVECEXP
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|RETURN
condition|)
name|printf
argument_list|(
literal|"  emit_jump_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
condition|)
name|printf
argument_list|(
literal|"  emit_call_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|printf
argument_list|(
literal|"  emit_label ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERAND
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERATOR
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
condition|)
name|printf
argument_list|(
literal|"  emit ("
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  emit_insn ("
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|printf
argument_list|(
literal|"  emit_barrier ();"
argument_list|)
expr_stmt|;
block|}
comment|/* Call `gen_sequence' to make a SEQUENCE out of all the      insns emitted within this gen_... function.  */
name|printf
argument_list|(
literal|" _done:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  _val = gen_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  end_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return _val;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
block|{
specifier|register
name|int
name|val
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genemit: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|extern
name|rtx
name|read_rtx
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
comment|/* Assign sequential codes to all entries in the machine description      in parallel with the tables in insn-output.c.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genemit'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"expr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-flags.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern char *insn_operand_constraint[][MAX_RECOG_OPERANDS];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx recog_operand[];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands emit_operand\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define FAIL do { end_sequence (); return 0;} while (0)\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define DONE goto _done\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
block|{
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
block|{
name|gen_expand
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
operator|++
name|insn_code_number
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

