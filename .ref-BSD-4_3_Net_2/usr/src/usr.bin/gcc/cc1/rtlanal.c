begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze RTL for C-Compiler    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_function_decl
specifier|extern
name|void
name|note_stores
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_set_p
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the value of X is unstable    (would be different at a different point in the program).    The frame pointer, arg pointer, etc. are considered stable    (within one function) and so is anything marked `unchanging'.  */
end_comment

begin_function
name|int
name|rtx_unstable_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|QUEUED
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CONST
operator|||
name|code
operator|==
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|!
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.    The frame pointer and the arg pointer are considered constant.  */
end_comment

begin_function
name|int
name|rtx_varies_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|QUEUED
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CONST
operator|||
name|code
operator|==
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|!
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X refers to a memory location whose address     cannot be compared reliably with constant addresses,    or if X refers to a BLKmode memory object.  */
end_comment

begin_function
name|int
name|rtx_addr_varies_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG appears somewhere within IN.    Also works if REG is not a register; in this case it checks    for a subexpression of IN that is Lisp "equal" to REG.  */
end_comment

begin_function
name|int
name|reg_mentioned_p
parameter_list|(
name|reg
parameter_list|,
name|in
parameter_list|)
specifier|register
name|rtx
name|reg
decl_stmt|,
name|in
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|==
name|in
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Compare registers by number.  */
case|case
name|REG
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
comment|/* These codes have no constituent expressions 	 and are unique.  */
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|in
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|reg
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is used in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_used_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|(
operator|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is set or clobbered in an insn between    FROM_INSN and TO_INSN (exclusive of those two).    Does not notice increments, only SET and CLOBBER.  */
end_comment

begin_function
name|int
name|reg_set_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|(
operator|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internals of reg_set_between_p.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_set_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_set_flag
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reg_set_p_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg_set_reg
argument_list|,
name|x
argument_list|)
condition|)
name|reg_set_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|reg_set_p
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|reg_set_reg
operator|=
name|reg
expr_stmt|;
name|reg_set_flag
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|insn
argument_list|,
name|reg_set_p_1
argument_list|)
expr_stmt|;
return|return
name|reg_set_flag
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if hard register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into.     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.  */
end_comment

begin_function
name|int
name|refers_to_regno_p
parameter_list|(
name|regno
parameter_list|,
name|endregno
parameter_list|,
name|x
parameter_list|,
name|loc
parameter_list|)
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|endregno
operator|>
name|i
operator|&&
name|regno
operator|<
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Note setting a SUBREG counts as referring to the REG it is in!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
if|if
condition|(
name|code
operator|==
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if X contains any reg that overlaps hard register REG.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_p
parameter_list|(
name|reg
parameter_list|,
name|x
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|x
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is 1 until after reload pass.  */
end_comment

begin_decl_stmt
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.  */
end_comment

begin_function
name|int
name|rtx_equal_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* These three types of rtx's can be compared nonrecursively.  */
comment|/* Until the end of reload,      don't consider the a reference to the return register of the current      function the same as the return from a called function.  This eases      the job of function integration.  Once the distinction no longer      matters, the insn will be deleted.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
operator|(
operator|!
name|rtx_equal_function_value_matters
operator|||
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|==
name|REG_FUNCTION_VALUE_P
argument_list|(
name|y
argument_list|)
operator|)
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUN on each register or MEM that is stored into or clobbered by X.    (X would be the pattern of an insn).    FUN receives two arguments:      the REG, MEM, CC0 or PC being stored in or clobbered,      the SET or CLOBBER rtx that does the store.  */
end_comment

begin_decl_stmt
name|void
name|note_stores
argument_list|(
name|x
argument_list|,
name|fun
argument_list|)
decl|register
name|rtx
name|x
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|y
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register REG's old contents don't survive after INSN.    This can be because REG dies in INSN or because INSN entirely sets REG.     "Entirely set" means set directly and not through a SUBREG,    ZERO_EXTRACT or SIGN_EXTRACT, so no trace of the old contents remains.     REG may be a hard or pseudo reg.  Renumbering is not taken into account,    but for this use that makes no difference, since regs don't overlap    during their lifetimes.  Therefore, this function may be used    at any time after deaths have been computed (in flow.c).  */
end_comment

begin_function
name|int
name|dead_or_set_p
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|regno
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN, if there is one.    If DATUM is nonzero, look for one whose datum is DATUM.  */
end_comment

begin_function
name|rtx
name|find_reg_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
operator|&&
operator|(
name|datum
operator|==
literal|0
operator|||
name|datum
operator|==
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN which applies to register    number REGNO, if any.  Return 0 if there is no such reg-note.  */
end_comment

begin_function
name|rtx
name|find_regno_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if FROM precedes TO with no intervening labels.  */
end_comment

begin_function
name|int
name|no_labels_between
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
init|=
name|to
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|==
name|from
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if X contains any volatile memory references    or volatile ASM_OPERANDS expressions.  */
end_comment

begin_function
name|int
name|volatile_refs_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CALL
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap.  */
end_comment

begin_function
name|int
name|may_trap_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Handle these cases fast.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
return|return
literal|0
return|;
comment|/* Memory ref can trap unless it's a static var or a stack slot.  */
case|case
name|MEM
case|:
return|return
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Division by a non-constant might trap.  */
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
default|default:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|may_trap_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

