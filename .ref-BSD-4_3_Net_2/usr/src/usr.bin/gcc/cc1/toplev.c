begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)toplev.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Top level of GNU C compiler    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is the top level of cc1.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* This is for hpux.  It is a real screw.  They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* Correct for hpux at least.  Is it good on other USG?  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finput
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|init_lex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_decl_processing
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_rtl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_optabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_reg_sets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_flow_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_local_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rest_of_decl_compilation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error_with_file_and_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_target_switch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_target_switch_defaults
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm-...h file    and set by `-m...' switches.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of current original source file (what was input to cpp).    This comes from each #-command in the actual input.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of top-level original source file (what was input to cpp).    This comes from the #-command at the beginning of the actual input.    If there isn't any there, then this is the cc1 input file name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line number in real source file.  */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of currently pending input files.  */
end_comment

begin_decl_stmt
name|struct
name|file_stack
modifier|*
name|input_file_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented on each change to input_file_stack.  */
end_comment

begin_decl_stmt
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION_DECL for function now being parsed or compiled.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as base of names for dump output files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags saying which kinds of debugging dump have been requested.  */
end_comment

begin_decl_stmt
name|int
name|rtl_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtl_dump_and_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump_opt_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loop_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|combine_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|global_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump2_opt_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbr_sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => write gdb debugging output (using symout.c).  -g    2 => write dbx debugging output (using dbxout.c).  -G    3 => write sdb debugging output (using sdbout.c).  -g.  */
end_comment

begin_decl_stmt
name|enum
name|debugger
name|write_symbols
init|=
name|NO_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means can use our own extensions to DBX format.    Relevant only with write_symbols == DBX_DEBUG.  */
end_comment

begin_decl_stmt
name|int
name|use_gdb_dbx_extensions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do optimizations.  -opt.  */
end_comment

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means `char' should be signed.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give an enum type only as many bytes as it needs.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_enums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcaller-saves: allocate values in regs that need to    be saved across function calls, if that produces overall better code.    Optional now, so people can test it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CALLER_SAVES
end_ifdef

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_pcc_struct_return
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-mem: load memory value into a register    before arithmetic on it.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-addr: load memory address into a register before    reference to memory.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fdefer-pop: don't pop args after each function call;    instead save them up to pop many calls' args with one insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_defer_pop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -ffloat-store: don't allocate floats and doubles    in extended-precision registers.  */
end_comment

begin_decl_stmt
name|int
name|flag_float_store
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcombine-regs:    allow instruction combiner to combine an insn    that just copies one reg to another.  */
end_comment

begin_decl_stmt
name|int
name|flag_combine_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables strength-reduction in loop.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_strength_reduce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fwritable-strings:    store string constants in data segment and don't uniquize them.  */
end_comment

begin_decl_stmt
name|int
name|flag_writable_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't put addresses of constant functions in registers.    Used for compiling the Unix kernel, where strange substitutions are    done on the assembly output.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_function_cse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fomit-frame-pointer:    don't make a frame pointer in simple functions that don't require one.  */
end_comment

begin_decl_stmt
name|int
name|flag_omit_frame_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to inhibit use of define_optimization peephole opts.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_peephole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means all references through pointers are volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means just do syntax checking; don't output anything.  */
end_comment

begin_decl_stmt
name|int
name|flag_syntax_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do stupid register allocation.  -noreg.    This and `optimize' are controlled by different switches in cc1,    but normally cc controls them both with the -O switch.  */
end_comment

begin_decl_stmt
name|int
name|obey_regdecls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print functions as they are compiled and don't print    times taken by the various passes.  -quiet.  */
end_comment

begin_decl_stmt
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do print extra warnings (such as for uninitialized variables).  -W.  */
end_comment

begin_decl_stmt
name|int
name|extra_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about unused local variables.  */
end_comment

begin_decl_stmt
name|int
name|warn_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about all declarations which shadow others.   */
end_comment

begin_decl_stmt
name|int
name|warn_shadow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a switch on an enum fails to have a case for every enum value.  */
end_comment

begin_decl_stmt
name|int
name|warn_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about any identifiers that match in the first N    characters.  The value N is in `id_clash_len'.  */
end_comment

begin_decl_stmt
name|int
name|warn_id_clash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id_clash_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of error messages and warning messages so far.  */
end_comment

begin_decl_stmt
name|int
name|errorcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warningcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sorrycount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of program invoked, sans directories.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling on a line-by-line basis.  */
end_comment

begin_decl_stmt
name|int
name|profile_block_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -pedantic switch: warn about anything    that standard spec forbids.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -finline-functions: ok to inline functions that look like    good inline candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fkeep-inline-functions: even if we make a function    go inline everywhere, keep its defintion around for debugging    purposes.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the text shared if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_shared_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means schedule into delayed branch slots if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_delayed_branch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of arguments to main.  */
end_comment

begin_decl_stmt
name|int
name|save_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of assembly code, specified with -o.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|asm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of GDB symbol segment, specified with -symout.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sym_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of language-independent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
block|}
name|f_options
index|[]
init|=
block|{
block|{
literal|"float-store"
block|,
operator|&
name|flag_float_store
block|,
literal|1
block|}
block|,
block|{
literal|"volatile"
block|,
operator|&
name|flag_volatile
block|,
literal|1
block|}
block|,
block|{
literal|"defer-pop"
block|,
operator|&
name|flag_defer_pop
block|,
literal|1
block|}
block|,
block|{
literal|"omit-frame-pointer"
block|,
operator|&
name|flag_omit_frame_pointer
block|,
literal|1
block|}
block|,
block|{
literal|"strength-reduce"
block|,
operator|&
name|flag_strength_reduce
block|,
literal|1
block|}
block|,
block|{
literal|"writable-strings"
block|,
operator|&
name|flag_writable_strings
block|,
literal|1
block|}
block|,
block|{
literal|"peephole"
block|,
operator|&
name|flag_no_peephole
block|,
literal|0
block|}
block|,
block|{
literal|"force-mem"
block|,
operator|&
name|flag_force_mem
block|,
literal|1
block|}
block|,
block|{
literal|"force-addr"
block|,
operator|&
name|flag_force_addr
block|,
literal|1
block|}
block|,
block|{
literal|"combine-regs"
block|,
operator|&
name|flag_combine_regs
block|,
literal|1
block|}
block|,
block|{
literal|"function-cse"
block|,
operator|&
name|flag_no_function_cse
block|,
literal|0
block|}
block|,
block|{
literal|"inline-functions"
block|,
operator|&
name|flag_inline_functions
block|,
literal|1
block|}
block|,
block|{
literal|"keep-inline-functions"
block|,
operator|&
name|flag_keep_inline_functions
block|,
literal|1
block|}
block|,
block|{
literal|"syntax-only"
block|,
operator|&
name|flag_syntax_only
block|,
literal|1
block|}
block|,
block|{
literal|"shared-data"
block|,
operator|&
name|flag_shared_data
block|,
literal|1
block|}
block|,
block|{
literal|"caller-saves"
block|,
operator|&
name|flag_caller_saves
block|,
literal|1
block|}
block|,
block|{
literal|"pcc-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|1
block|}
block|,
block|{
literal|"delayed-branch"
block|,
operator|&
name|flag_delayed_branch
block|,
literal|1
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Output files for assembler code (real compiler output)    and debugging dumps.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rtl_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|jump_opt_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cse_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|loop_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|flow_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|combine_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|local_reg_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|global_reg_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|jump2_opt_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dbr_sched_dump_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time accumulators, to count the total time spent in various passes.  */
end_comment

begin_decl_stmt
name|int
name|parse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|varconst_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|integration_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loop_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|combine_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_alloc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|global_alloc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbr_sched_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|final_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symout_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dump_time
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return time used so far, in microseconds.  */
end_comment

begin_function
name|int
name|gettime
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USG
name|struct
name|tms
name|tms
decl_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
name|struct
name|rusage
name|rusage
decl_stmt|;
else|#
directive|else
comment|/* VMS */
struct|struct
block|{
name|int
name|proc_user_time
decl_stmt|;
name|int
name|proc_system_time
decl_stmt|;
name|int
name|child_user_time
decl_stmt|;
name|int
name|child_system_time
decl_stmt|;
block|}
name|vms_times
struct|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|quiet_flag
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|USG
name|times
argument_list|(
operator|&
name|tms
argument_list|)
expr_stmt|;
return|return
operator|(
name|tms
operator|.
name|tms_utime
operator|+
name|tms
operator|.
name|tms_stime
operator|)
operator|*
operator|(
literal|1000000
operator|/
name|HZ
operator|)
return|;
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
name|getrusage
argument_list|(
literal|0
argument_list|,
operator|&
name|rusage
argument_list|)
expr_stmt|;
return|return
operator|(
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|+
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|)
return|;
else|#
directive|else
comment|/* VMS */
name|times
argument_list|(
operator|&
name|vms_times
argument_list|)
expr_stmt|;
return|return
operator|(
name|vms_times
operator|.
name|proc_user_time
operator|+
name|vms_times
operator|.
name|proc_system_time
operator|)
operator|*
literal|10000
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|TIMEVAR
parameter_list|(
name|VAR
parameter_list|,
name|BODY
parameter_list|)
define|\
value|do { int otime = gettime (); BODY; VAR += gettime () - otime; } while (0)
end_define

begin_function
name|void
name|print_time
parameter_list|(
name|str
parameter_list|,
name|total
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|total
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"time in %s: %d.%06d\n"
argument_list|,
name|str
argument_list|,
name|total
operator|/
literal|1000000
argument_list|,
name|total
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count an error or warning.  Return 1 if the message should be printed.  */
end_comment

begin_function
name|int
name|count_error
parameter_list|(
name|warningp
parameter_list|)
name|int
name|warningp
decl_stmt|;
block|{
if|if
condition|(
name|warningp
operator|&&
name|inhibit_warnings
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warningp
condition|)
name|warningcount
operator|++
expr_stmt|;
else|else
name|errorcount
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a fatal error message.  NAME is the text.    Also include a system error message based on `errno'.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|35
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal_io_error
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: I/O error\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|35
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|error
argument_list|(
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|34
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from insn-extract to give a better error message when we    don't have an insn to match what we are looking for, rather    than just calling abort().  */
end_comment

begin_function
name|void
name|fatal_insn_not_found
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|error
argument_list|(
literal|"The following insn was not recognizable:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|need_error_newline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function of last error message;    more generally, function such that if next error message is in it    then we don't have to mention the function name.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_error_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to detect when input_file_stack has changed since last described.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|need_error_newline
operator|=
literal|1
expr_stmt|;
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out, if necessary, the name of the current function    which caused an error.  Called from all error and warning functions.  */
end_comment

begin_function
name|void
name|report_error_function
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|need_error_newline
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|need_error_newline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|last_error_function
operator|!=
name|current_function_decl
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"At top level:\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In method %s:\n"
argument_list|,
name|DECL_PRINT_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In function %s:\n"
argument_list|,
name|DECL_PRINT_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
if|if
condition|(
name|input_file_stack
operator|&&
name|input_file_stack
operator|->
name|next
operator|!=
literal|0
operator|&&
name|input_file_stack_tick
operator|!=
name|last_error_tick
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file included"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|input_file_stack
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s:%d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|next
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Report an error at the current line number.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* @@also used as pointer */
name|int
name|v2
decl_stmt|;
comment|/* @@also used as pointer */
block|{
name|error_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error at line LINE of file FILE.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|error_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|v2
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error at the declaration DECL.    S and V are a string and an arg which uses %s to substitute the declaration name.  */
end_comment

begin_function
name|void
name|error_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
literal|"((anonymous))"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error at argument #NUM.    S is a string that uses %s to substitute the error type.    E is the string for the error type.  */
end_comment

begin_function
name|void
name|error_with_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|w
decl_stmt|;
specifier|static
name|char
name|argument
index|[]
init|=
literal|"argument #%d: "
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|w
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|w
argument_list|,
name|argument
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|w
argument_list|,
name|num
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Report an error at the line number of the insn INSN.    S and V are a string and an arg for `printf'.    This is used only when INSN is an `asm' with operands,    and each ASM_OPERANDS records its own source file and line.  */
end_comment

begin_function
name|void
name|error_for_asm
parameter_list|(
name|insn
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* @@also used as pointer */
name|int
name|v2
decl_stmt|;
comment|/* @@also used as pointer */
block|{
name|rtx
name|temp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|asmop
decl_stmt|;
comment|/* Find the (or one of the) ASM_OPERANDS in the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|body
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
name|line
operator|=
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at line LINE.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|warning_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|v2
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at the current line number.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* @@also used as pointer */
name|int
name|v2
decl_stmt|;
block|{
name|warning_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at the declaration DECL.    S is string which uses %s to substitute the declaration name.    V is a second parameter that S can refer to.  */
end_comment

begin_function
name|void
name|warning_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|DECL_PRINT_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
literal|"((anonymous))"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at argument #NUM.    S is a string that uses %s to substitute the error type.    E is the string for the error type.  */
end_comment

begin_function
name|void
name|warning_with_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|w
decl_stmt|;
specifier|static
name|char
name|argument
index|[]
init|=
literal|"argument #%d: "
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
block|{
name|warning
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|w
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|w
argument_list|,
name|argument
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|w
argument_list|,
name|num
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Apologize for not implementing some feature.    S, V, and V2 are a string and args for `printf'.  */
end_comment

begin_function
name|void
name|sorry
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|;
block|{
name|sorrycount
operator|++
expr_stmt|;
if|if
condition|(
name|input_filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sorry, not implemented: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apologize for not implementing some feature, then quit.    S, V, and V2 are a string and args for `printf'.  */
end_comment

begin_function
name|void
name|really_sorry
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|;
block|{
if|if
condition|(
name|input_filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c++: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sorry, not implemented: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|" (fatal)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When `malloc.c' is compiled with `rcheck' defined,    it calls this function to report clobberage.  */
end_comment

begin_function
name|void
name|botch
parameter_list|(
name|s
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as `malloc' but report error if no memory available.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|value
init|=
operator|(
name|int
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"Virtual memory exhausted."
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Same as `realloc' but report error if no memory available.  */
end_comment

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"Virtual memory exhausted."
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.  */
end_comment

begin_function
name|int
name|exact_log2
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|int
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|log
init|=
literal|0
decl_stmt|;
for|for
control|(
name|log
operator|=
literal|0
init|;
name|log
operator|<
name|HOST_BITS_PER_INT
condition|;
name|log
operator|++
control|)
if|if
condition|(
name|x
operator|==
operator|(
literal|1
operator|<<
name|log
operator|)
condition|)
return|return
name|log
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given X, an unsigned number, return the largest int Y such that 2**Y<= X.    If X is 0, return -1.  */
end_comment

begin_function
name|int
name|floor_log2
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|int
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|log
init|=
literal|0
decl_stmt|;
for|for
control|(
name|log
operator|=
literal|0
init|;
name|log
operator|<
name|HOST_BITS_PER_INT
condition|;
name|log
operator|++
control|)
if|if
condition|(
operator|(
name|x
operator|&
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|log
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|log
operator|-
literal|1
return|;
return|return
name|HOST_BITS_PER_INT
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|int
name|float_handled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|float_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify where to longjmp to when a floating arithmetic error happens.    If HANDLER is 0, it means don't handle the errors any more.  */
end_comment

begin_function
name|void
name|set_float_handler
parameter_list|(
name|handler
parameter_list|)
name|jmp_buf
name|handler
decl_stmt|;
block|{
name|float_handled
operator|=
operator|(
name|handler
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|handler
condition|)
name|bcopy
argument_list|(
name|handler
argument_list|,
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Signals actually come here.  */
end_comment

begin_function
specifier|static
name|void
name|float_signal
parameter_list|()
block|{
if|if
condition|(
name|float_handled
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|float_handled
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|float_handler
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handler for SIGPIPE.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_closed
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"output pipe has been closed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compile an entire file of output from cpp, named NAME.    Write a file of assembly output and various debugging dumps.  */
end_comment

begin_function
specifier|static
name|void
name|compile_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|globals
decl_stmt|;
name|int
name|start_time
decl_stmt|;
name|int
name|dump_base_name_length
decl_stmt|;
name|int
name|name_specified
init|=
name|name
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|dump_base_name
operator|==
literal|0
condition|)
name|dump_base_name
operator|=
name|name
condition|?
name|name
else|:
literal|"gccdump"
expr_stmt|;
name|dump_base_name_length
operator|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
expr_stmt|;
name|parse_time
operator|=
literal|0
expr_stmt|;
name|varconst_time
operator|=
literal|0
expr_stmt|;
name|integration_time
operator|=
literal|0
expr_stmt|;
name|jump_time
operator|=
literal|0
expr_stmt|;
name|cse_time
operator|=
literal|0
expr_stmt|;
name|loop_time
operator|=
literal|0
expr_stmt|;
name|flow_time
operator|=
literal|0
expr_stmt|;
name|combine_time
operator|=
literal|0
expr_stmt|;
name|local_alloc_time
operator|=
literal|0
expr_stmt|;
name|global_alloc_time
operator|=
literal|0
expr_stmt|;
name|dbr_sched_time
operator|=
literal|0
expr_stmt|;
name|final_time
operator|=
literal|0
expr_stmt|;
name|symout_time
operator|=
literal|0
expr_stmt|;
name|dump_time
operator|=
literal|0
expr_stmt|;
comment|/* Open input file.  */
if|if
condition|(
name|name
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|finput
operator|=
name|stdin
expr_stmt|;
name|name
operator|=
literal|"stdin"
expr_stmt|;
block|}
else|else
name|finput
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Initialize data in various passes.  */
name|init_tree
argument_list|()
expr_stmt|;
name|init_lex
argument_list|()
expr_stmt|;
name|init_rtl
argument_list|()
expr_stmt|;
name|init_emit_once
argument_list|()
expr_stmt|;
name|init_decl_processing
argument_list|()
expr_stmt|;
name|init_optabs
argument_list|()
expr_stmt|;
comment|/* If rtl dump desired, open the output file.  */
if|if
condition|(
name|rtl_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".rtl"
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If jump_opt dump desired, open the output file.  */
if|if
condition|(
name|jump_opt_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".jump"
argument_list|)
expr_stmt|;
name|jump_opt_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_opt_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If cse dump desired, open the output file.  */
if|if
condition|(
name|cse_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".cse"
argument_list|)
expr_stmt|;
name|cse_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If loop dump desired, open the output file.  */
if|if
condition|(
name|loop_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".loop"
argument_list|)
expr_stmt|;
name|loop_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If flow dump desired, open the output file.  */
if|if
condition|(
name|flow_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".flow"
argument_list|)
expr_stmt|;
name|flow_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If combine dump desired, open the output file.  */
if|if
condition|(
name|combine_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|10
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".combine"
argument_list|)
expr_stmt|;
name|combine_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If local_reg dump desired, open the output file.  */
if|if
condition|(
name|local_reg_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".lreg"
argument_list|)
expr_stmt|;
name|local_reg_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_reg_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If global_reg dump desired, open the output file.  */
if|if
condition|(
name|global_reg_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".greg"
argument_list|)
expr_stmt|;
name|global_reg_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_reg_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If jump2_opt dump desired, open the output file.  */
if|if
condition|(
name|jump2_opt_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".jump2"
argument_list|)
expr_stmt|;
name|jump2_opt_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump2_opt_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If dbr_sched dump desired, open the output file.  */
if|if
condition|(
name|dbr_sched_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".dbr"
argument_list|)
expr_stmt|;
name|dbr_sched_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* Open assembler code output file.  */
if|if
condition|(
operator|!
name|name_specified
operator|&&
name|asm_file_name
operator|==
literal|0
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".c"
argument_list|,
name|dumpname
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|dumpname
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".i"
argument_list|,
name|dumpname
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|dumpname
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".co"
argument_list|,
name|dumpname
operator|+
name|len
operator|-
literal|3
argument_list|)
condition|)
name|dumpname
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_file_name
operator|==
literal|0
condition|)
block|{
name|asm_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dumpname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|asm_file_name
argument_list|,
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
name|asm_out_file
operator|=
name|fopen
argument_list|(
name|asm_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
name|input_filename
operator|=
name|name
expr_stmt|;
comment|/* the beginning of the file is a new line; check for # */
comment|/* With luck, we discover the real source file's name from that      and put it in input_filename.  */
name|ungetc
argument_list|(
name|check_newline
argument_list|()
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* If the input doesn't start with a #line, use the input name      as the official input file name.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|name
expr_stmt|;
comment|/* Put an entry on the input file stack for the main input file.  */
name|input_file_stack
operator|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
expr_stmt|;
name|input_file_stack
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|ASM_FILE_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output something to inform GDB that this compilation was by GCC.  */
ifndef|#
directive|ifndef
name|ASM_IDENTIFY_GCC
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"gcc_compiled.:\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_IDENTIFY_GCC
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If GDB symbol table desired, open the GDB symbol output file.  */
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".c"
argument_list|,
name|dumpname
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|dumpname
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".i"
argument_list|,
name|dumpname
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|dumpname
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".co"
argument_list|,
name|dumpname
operator|+
name|len
operator|-
literal|3
argument_list|)
condition|)
name|dumpname
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".sym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_file_name
operator|==
literal|0
condition|)
name|sym_file_name
operator|=
name|dumpname
expr_stmt|;
name|symout_init
argument_list|(
name|sym_file_name
argument_list|,
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
block|}
comment|/* If dbx symbol table desired, initialize writing it      and output the predefined types.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize yet another pass.  */
name|init_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|gettime
argument_list|()
expr_stmt|;
comment|/* Call the parser, which parses the entire file      (calling rest_of_compilation for each function).  */
name|yyparse
argument_list|()
expr_stmt|;
comment|/* Compilation is now finished except for writing      what's left of the symbol table output.  */
name|parse_time
operator|+=
name|gettime
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|parse_time
operator|-=
name|integration_time
expr_stmt|;
name|parse_time
operator|-=
name|varconst_time
expr_stmt|;
name|globals
operator|=
name|getdecls
argument_list|()
expr_stmt|;
comment|/* Really define vars that have had only a tentative definition.      Really output inline functions that must actually be callable      and have not been output so far.  */
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|globals
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Don't write out static consts, unless we needed 	       to take their address for some reason.  */
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Otherwise maybe mention them just for the debugger.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|varconst_time
argument_list|,
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|varconst_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Warn about any function declared static but not defined.  */
if|if
condition|(
name|warn_unused
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' declared but never defined"
argument_list|)
expr_stmt|;
comment|/* Warn about statics fns or vars defined but not used, 	   but not about inline functions 	   since unused inline statics is normal practice.  */
if|if
condition|(
name|warn_unused
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
comment|/* The TREE_USED bit for file-scope decls 	       is kept in the identifier, to handle multiple 	       external decls in different scopes.  */
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined but not used"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do dbx symbols */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       dbxout_tags (gettags ()); 	       dbxout_types (get_permanent_types ()); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       sdbout_tags (gettags ()); 	       sdbout_types (get_permanent_types ()); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* Do gdb symbols */
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       struct stat statbuf; 	       fstat (fileno (finput),&statbuf); 	       symout_types (get_permanent_types ()); 	       symout_top_blocks (globals, gettags ()); 	       symout_finish (name, statbuf.st_ctime); 	     }
argument_list|)
empty_stmt|;
comment|/* Output some stuff at end of file if nec.  */
name|end_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_FILE_END
name|ASM_FILE_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Close the dump files.  */
if|if
condition|(
name|rtl_dump
condition|)
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_opt_dump
condition|)
name|fclose
argument_list|(
name|jump_opt_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_dump
condition|)
name|fclose
argument_list|(
name|cse_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump
condition|)
name|fclose
argument_list|(
name|loop_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_dump
condition|)
name|fclose
argument_list|(
name|flow_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_dump
condition|)
block|{
name|dump_combine_total_stats
argument_list|(
name|combine_dump_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|combine_dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_reg_dump
condition|)
name|fclose
argument_list|(
name|local_reg_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|fclose
argument_list|(
name|global_reg_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump2_opt_dump
condition|)
name|fclose
argument_list|(
name|jump2_opt_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump
condition|)
name|fclose
argument_list|(
name|dbr_sched_dump_file
argument_list|)
expr_stmt|;
comment|/* Close non-debugging input and output files.  Take special care to note      whether fclose returns an error, since the pages might still be on the      buffer chain while the file is open.  */
name|fclose
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
operator|||
name|fclose
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_io_error
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
comment|/* Print the times.  */
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"parse"
argument_list|,
name|parse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"integration"
argument_list|,
name|integration_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"jump"
argument_list|,
name|jump_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"cse"
argument_list|,
name|cse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"loop"
argument_list|,
name|loop_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"flow"
argument_list|,
name|flow_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"combine"
argument_list|,
name|combine_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"local-alloc"
argument_list|,
name|local_alloc_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"global-alloc"
argument_list|,
name|global_alloc_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"dbranch"
argument_list|,
name|dbr_sched_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"final"
argument_list|,
name|final_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"varconst"
argument_list|,
name|varconst_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"symout"
argument_list|,
name|symout_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"dump"
argument_list|,
name|dump_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called from finish_decl (within yyparse)    for each declaration of a function or variable.    This does nothing for automatic variables.    Otherwise, it sets up the RTL and outputs any assembler code    (label definition, storage allocation and initialization).     DECL is the declaration.  If ASMSPEC is nonzero, it specifies    the assembler symbol name to be used.  TOP_LEVEL is nonzero    if this declaration is not within a function.  */
end_comment

begin_function
name|void
name|rest_of_decl_compilation
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|{
comment|/* Declarations of variables, and of functions defined elsewhere.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|TIMEVAR
argument_list|(
argument|varconst_time
argument_list|,
argument|{ 	       make_decl_rtl (decl, asmspec, top_level);
comment|/* Don't output anything 		  when a tentative file-scope definition is seen. 		  But at end of compilation, do output code for them.  */
argument|if (! (! at_end&& top_level&& (DECL_INITIAL (decl) ==
literal|0
argument||| DECL_INITIAL (decl) == error_mark_node))) 		 assemble_variable (decl, top_level, write_symbols, at_end); 	     }
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|top_level
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid register name `%s' for register variable"
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TIMEVAR
argument_list|(
name|varconst_time
argument_list|,
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TIMEVAR
argument_list|(
name|varconst_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|top_level
condition|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{
comment|/* The initizations make types when they contain 			string constants.  The types are on the temporary 			obstack, so output them now before they go away.  */
argument|symout_types (get_temporary_types ()); 		   }
argument_list|)
empty_stmt|;
block|}
else|else
comment|/* Clean out the temporary type list, since the types will go away.  */
name|get_temporary_types
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from finish_function (within yyparse)    after each top-level definition is parsed.    It is supposed to compile that function or variable    and output the assembler code for it.    After we return, the tree storage is freed.  */
end_comment

begin_function
name|void
name|rest_of_compilation
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|insns
decl_stmt|;
name|int
name|start_time
init|=
name|gettime
argument_list|()
decl_stmt|;
name|int
name|tem
decl_stmt|;
comment|/* If we are reconsidering an inline function      at the end of compilation, skip the stuff for making it inline.  */
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If requested, consider whether to make this function inline.  */
if|if
condition|(
name|flag_inline_functions
operator|||
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|integration_time
argument_list|,
argument|{ 		     int specd = TREE_INLINE (decl); 		     char *lose = function_cannot_inline_p (decl); 		     if (lose !=
literal|0
argument|&& specd) 		       warning_with_decl (decl, lose); 		     if (lose ==
literal|0
argument|) 		       save_for_inline (decl); 		     else 		       TREE_INLINE (decl) =
literal|0
argument|; 		   }
argument_list|)
empty_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Dump the rtl code if we are dumping rtl.  */
if|if
condition|(
name|rtl_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		   fprintf (rtl_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			    IDENTIFIER_POINTER (DECL_NAME (decl))); 		   if (DECL_SAVED_INSNS (decl)) 		     fprintf (rtl_dump_file,
literal|";; (integrable)\n\n"
argument|); 		   print_rtl (rtl_dump_file, insns); 		   fflush (rtl_dump_file); 		 }
argument_list|)
empty_stmt|;
comment|/* If function is inline, and we don't yet know whether to 	 compile it by itself, defer decision till end of compilation. 	 finish_compilation will call rest_of_compilation again 	 for those functions that need to be output.  */
if|if
condition|(
operator|(
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_keep_inline_functions
operator|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
if|if
condition|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
condition|)
block|{
name|get_temporary_types
argument_list|()
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Copy any shared structure that should not be shared.  */
name|unshare_all_rtl
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* See if we have allocated stack slots that are not directly addressable.      If so, scan all the insns and create explicit address computation      for all references to such slots.  */
comment|/*   fixup_stack_slots (); */
comment|/* Do jump optimization the first time, if -opt.      Also do it if -W, but in that case it doesn't change the rtl code,      it only computes whether control can drop off the end of the function.  */
if|if
condition|(
name|optimize
operator|||
name|extra_warnings
operator|||
name|warn_return_type
comment|/* If function is `volatile', we should warn if it tries to return.  */
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after jump, if we are doing that.  */
if|if
condition|(
name|jump_opt_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (jump_opt_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       print_rtl (jump_opt_dump_file, insns); 	       fflush (jump_opt_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* Perform common subexpression elimination.      Nonzero value from `cse_main' means that jumps were simplified      and some code may now be unreachable, so do      jump optimization again.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl code after cse, if we are doing that.  */
if|if
condition|(
name|cse_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (cse_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       print_rtl (cse_dump_file, insns); 	       fflush (cse_dump_file); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|loop_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (loop_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
comment|/* Move constant computations out of loops.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|loop_time
argument_list|,
argument|{ 		 reg_scan (insns, max_reg_num (),
literal|1
argument|); 		 loop_optimize (insns, loop_dump ? loop_dump_file :
literal|0
argument|); 	       }
argument_list|)
empty_stmt|;
block|}
comment|/* Dump rtl code after loop opt, if we are doing that.  */
if|if
condition|(
name|loop_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (loop_dump_file, insns); 	       fflush (loop_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* Now we choose between stupid (pcc-like) register allocation      (if we got the -noreg switch and not -opt)      and smart register allocation.  */
if|if
condition|(
name|optimize
condition|)
comment|/* Stupid allocation probably won't work */
name|obey_regdecls
operator|=
literal|0
expr_stmt|;
comment|/* if optimizations being done.  */
name|regclass_init
argument_list|()
expr_stmt|;
comment|/* Print function header into flow dump now      because doing the flow analysis makes some of the dump.  */
if|if
condition|(
name|flow_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (flow_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|flow_time
argument_list|,
argument|{ 		 regclass (insns, max_reg_num ()); 		 stupid_life_analysis (insns, max_reg_num (), 				       flow_dump_file); 	       }
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Do control and data flow analysis, 	 and write some of the results to dump file.  */
name|TIMEVAR
argument_list|(
name|flow_time
argument_list|,
name|flow_analysis
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|flow_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|uninitialized_vars_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl after flow analysis.  */
if|if
condition|(
name|flow_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (flow_dump_file, insns); 	       fflush (flow_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* If -opt, try combining insns through substitution.  */
if|if
condition|(
name|optimize
condition|)
name|TIMEVAR
argument_list|(
name|combine_time
argument_list|,
name|combine_instructions
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after insn combination.  */
if|if
condition|(
name|combine_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (combine_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       dump_combine_stats (combine_dump_file); 	       print_rtl (combine_dump_file, insns); 	       fflush (combine_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* Unless we did stupid register allocation,      allocate pseudo-regs that are used only within 1 basic block.  */
if|if
condition|(
operator|!
name|obey_regdecls
condition|)
name|TIMEVAR
argument_list|(
argument|local_alloc_time
argument_list|,
argument|{ 	       regclass (insns, max_reg_num ()); 	       local_alloc (); 	     }
argument_list|)
empty_stmt|;
comment|/* Dump rtl code after allocating regs within basic blocks.  */
if|if
condition|(
name|local_reg_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (local_reg_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       dump_flow_info (local_reg_dump_file); 	       dump_local_alloc (local_reg_dump_file); 	       print_rtl (local_reg_dump_file, insns); 	       fflush (local_reg_dump_file); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|fprintf
argument_list|(
name|global_reg_dump_file
argument_list|,
literal|"\n;; Function %s\n\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless we did stupid register allocation,      allocate remaining pseudo-regs, then do the reload pass      fixing up any insns that are invalid.  */
name|TIMEVAR
argument_list|(
argument|global_alloc_time
argument_list|,
argument|{ 	     if (!obey_regdecls) 	       global_alloc (global_reg_dump ? global_reg_dump_file :
literal|0
argument|); 	     else 	       reload (insns,
literal|0
argument|, 		       global_reg_dump ? global_reg_dump_file :
literal|0
argument|); 	   }
argument_list|)
empty_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       dump_global_regs (global_reg_dump_file); 	       print_rtl (global_reg_dump_file, insns); 	       fflush (global_reg_dump_file); 	     }
argument_list|)
empty_stmt|;
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
comment|/* One more attempt to remove jumps to .+1      left by dead-store-elimination.      Also do cross-jumping this time      and delete no-op move insns.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl code after jump, if we are doing that.  */
if|if
condition|(
name|jump2_opt_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (jump2_opt_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       print_rtl (jump2_opt_dump_file, insns); 	       fflush (jump2_opt_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* If a scheduling pass for delayed branches is to be done,      call the scheduling code. */
ifdef|#
directive|ifdef
name|HAVE_DELAYED_BRANCH
if|if
condition|(
name|optimize
operator|&&
name|flag_delayed_branch
condition|)
block|{
name|TIMEVAR
argument_list|(
name|dbr_sched_time
argument_list|,
name|dbr_schedule
argument_list|(
name|insns
argument_list|,
name|dbr_sched_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		   fprintf (dbr_sched_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			    IDENTIFIER_POINTER (DECL_NAME (decl))); 		   print_rtl (dbr_sched_dump_file, insns); 		   fflush (dbr_sched_dump_file); 		 }
argument_list|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Now turn the rtl into assembler code.  */
name|TIMEVAR
argument_list|(
argument|final_time
argument_list|,
argument|{ 	     assemble_function (decl); 	     final_start_function (insns, asm_out_file, 				   write_symbols, optimize); 	     final (insns, asm_out_file, 		    write_symbols, optimize,
literal|0
argument|); 	     final_end_function (insns, asm_out_file, 				 write_symbols, optimize); 	     fflush (asm_out_file); 	   }
argument_list|)
empty_stmt|;
comment|/* Write GDB symbols if requested */
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 		 symout_types (get_permanent_types ()); 		 symout_types (get_temporary_types ());  		 DECL_BLOCK_SYMTAB_ADDRESS (decl) 		   = symout_function (DECL_INITIAL (decl), 				      DECL_ARGUMENTS (decl),
literal|0
argument|); 		 symout_function_end (); 	       }
argument_list|)
empty_stmt|;
block|}
else|else
name|get_temporary_types
argument_list|()
expr_stmt|;
comment|/* Write DBX symbols if requested */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_function
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit_rest_of_compilation
label|:
name|rtx_equal_function_value_matters
operator|=
literal|0
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the real_constant_chain before some of the rtx's      it runs through become garbage.  */
name|clear_const_double_mem
argument_list|()
expr_stmt|;
comment|/* The parsing time is all the time spent in yyparse      *except* what is spent in this function.  */
name|parse_time
operator|-=
name|gettime
argument_list|()
operator|-
name|start_time
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of cc1.  Decode command args, then call compile_file.    Exit code is 35 if can't open files, 34 if fatal error,    33 if had nonfatal errors, else success.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|filename
init|=
literal|0
decl_stmt|;
name|int
name|print_mem_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* save in case md file wants to emit args as a comment.  */
name|save_argc
operator|=
name|argc
expr_stmt|;
name|save_argv
operator|=
name|argv
expr_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_closed
argument_list|)
expr_stmt|;
comment|/* Initialize whether `char' is signed.  */
name|flag_signed_char
operator|=
name|DEFAULT_SIGNED_CHAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_SHORT_ENUMS
comment|/* Initialize how much space enums occupy, by default.  */
name|flag_short_enums
operator|=
name|DEFAULT_SHORT_ENUMS
expr_stmt|;
endif|#
directive|endif
comment|/* This is zeroed by -O.  */
name|obey_regdecls
operator|=
literal|1
expr_stmt|;
comment|/* Initialize register usage now so switches may override.  */
name|init_reg_sets
argument_list|()
expr_stmt|;
name|target_flags
operator|=
literal|0
expr_stmt|;
name|set_target_switch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|str
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'m'
condition|)
name|set_target_switch
argument_list|(
operator|&
name|str
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"dumpbase"
argument_list|)
condition|)
block|{
name|dump_base_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'d'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
name|combine_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbr_sched_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flow_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|global_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|jump_opt_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|jump2_opt_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|loop_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|print_mem_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rtl_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|cse_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|yydebug
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'f'
condition|)
block|{
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Some kind of -f option. 	       P's value is the option sans `-f'. 	       Search for it in the table of options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|f_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|f_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 		       but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"fixed-"
argument_list|,
literal|6
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|6
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"call-used-"
argument_list|,
literal|10
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|10
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"call-saved-"
argument_list|,
literal|11
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|11
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|lang_decode_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"noreg"
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"opt"
argument_list|)
condition|)
name|optimize
operator|=
literal|1
operator|,
name|obey_regdecls
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"O"
argument_list|)
condition|)
name|optimize
operator|=
literal|1
operator|,
name|obey_regdecls
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"pedantic"
argument_list|)
condition|)
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lang_decode_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"quiet"
argument_list|)
condition|)
name|quiet_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"version"
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|,
modifier|*
name|language_string
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s version %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__GNUC__
ifndef|#
directive|ifndef
name|__VERSION__
define|#
directive|define
name|__VERSION__
value|"[unknown]"
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" compiled by GNU C version %s.\n"
argument_list|,
name|__VERSION__
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" compiled by CC.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_target_switch_defaults
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
condition|)
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"W"
argument_list|)
condition|)
name|extra_warnings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"Wunused"
argument_list|)
condition|)
name|warn_unused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"Wshadow"
argument_list|)
condition|)
name|warn_shadow
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"Wswitch"
argument_list|)
condition|)
name|warn_switch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"Wid-clash-"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|char
modifier|*
name|endp
init|=
name|str
operator|+
literal|10
decl_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|>=
literal|'0'
operator|&&
operator|*
name|endp
operator|<=
literal|'9'
condition|)
name|endp
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|warn_id_clash
operator|=
literal|1
expr_stmt|;
name|id_clash_len
operator|=
name|atoi
argument_list|(
name|str
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"p"
argument_list|)
condition|)
name|profile_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"a"
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BLOCK_PROFILER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER
argument_list|)
name|warning
argument_list|(
literal|"`-a' option (basic block profile) not supported"
argument_list|)
expr_stmt|;
else|#
directive|else
name|profile_block_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"gg"
argument_list|)
condition|)
name|write_symbols
operator|=
name|GDB_DEBUG
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"g0"
argument_list|)
condition|)
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"G0"
argument_list|)
condition|)
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"g"
argument_list|)
condition|)
block|{
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
name|use_gdb_dbx_extensions
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"G"
argument_list|)
condition|)
block|{
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
name|use_gdb_dbx_extensions
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"g"
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"G"
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"g0"
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"G0"
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"symout"
argument_list|)
condition|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
name|write_symbols
operator|=
name|GDB_DEBUG
expr_stmt|;
name|sym_file_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"o"
argument_list|)
condition|)
block|{
name|asm_file_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of options.  */
name|OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Now that register usage is specified, convert it to HARD_REG_SETs.  */
name|init_reg_sets_1
argument_list|()
expr_stmt|;
name|compile_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USG
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|print_mem_flag
condition|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Data size %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|lim
operator|-
operator|(
name|int
operator|)
operator|&
name|environ
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|system
argument_list|(
literal|"ps v"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS */
endif|#
directive|endif
comment|/* not USG */
if|if
condition|(
name|errorcount
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorrycount
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
return|return
literal|34
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode -m switches.  */
end_comment

begin_comment
comment|/* Here is a table, controlled by the tm-...h file, listing each -m switch    and which bits in `target_switches' it should set or clear.    If VALUE is positive, it is bits to set.    If VALUE is negative, -VALUE is bits to clear.    (The sign bit is not used so there is no confusion.)  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_comment
comment|/* Decode the switch -mNAME.  */
end_comment

begin_function
name|void
name|set_target_switch
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|<
literal|0
condition|)
name|target_flags
operator|&=
operator|~
operator|-
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
else|else
name|target_flags
operator||=
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print default target switches for -version.  */
end_comment

begin_function
name|void
name|print_target_switch_defaults
parameter_list|()
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|mask
init|=
name|TARGET_DEFAULT
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"default target switches:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|&
name|mask
operator|)
operator|==
name|target_switches
index|[
name|j
index|]
operator|.
name|value
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -m%s"
argument_list|,
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

