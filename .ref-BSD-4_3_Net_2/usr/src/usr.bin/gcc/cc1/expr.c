begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert tree expression to rtl instructions, for GNU compiler.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"gvarargs.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
end_define

begin_comment
comment|/* If it's last to first */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Like STACK_BOUNDARY but in units of bytes, not bits.  */
end_comment

begin_define
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* If this is nonzero, we do not bother generating VOLATILE    around volatile memory references, and we are willing to    output indirect addresses.  If cse is to follow, we reject    indirect addresses so a useful potential cse is generated;    if it is used only once, instruction combination will produce    the same indirect address eventually.  */
end_comment

begin_decl_stmt
name|int
name|cse_not_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to generate code for all the subroutines within an    expression before generating the upper levels of the expression.    Nowadays this is never zero.  */
end_comment

begin_decl_stmt
name|int
name|do_preexpand_calls
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of units that we should eventually pop off the stack.    These are the arguments to function calls that have already returned.  */
end_comment

begin_decl_stmt
name|int
name|pending_stack_adjust
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means stack pops must not be deferred, and deferred stack    pops must not be output.  It is nonzero inside a function call,    inside a conditional expression, inside a statement expression,    and in other cases as well.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_defer_pop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of all cleanups which belong to the arguments of    function calls being expanded by expand_call.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cleanups_of_this_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means __builtin_saveregs has already been done in this function.    The value is the pseudoreg containing the value __builtin_saveregs    returned.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|saveregs_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means current function may call alloca    as a subroutine.  (__builtin_alloca does not count.)  */
end_comment

begin_decl_stmt
name|int
name|may_call_alloca
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
name|store_expr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_constructor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|store_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_call
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_call_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|prepare_call_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|compare_constants
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|compare1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|do_store_flag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|preexpand_calls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_increment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_queue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_pending_stack_adjust
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* MOVE_RATIO is the number of move instructions that is better than    a block move.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_RATIO
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_movstrqi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrhi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrsi
argument_list|)
end_if

begin_define
define|#
directive|define
name|MOVE_RATIO
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* A value of around 6 would minimize code size; infinity would minimize    execution time.  */
end_comment

begin_define
define|#
directive|define
name|MOVE_RATIO
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table indexed by tree code giving 1 if the code is for a    comparison operation, or anything that is most easily    computed with a conditional branch.     We include tree.def to give it the proper length.    The contents thus created are irrelevant.    The real contents are initialized in init_comparisons.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|0,
end_define

begin_decl_stmt
specifier|static
name|char
name|comparison_code
index|[]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* This is run once per compilation.  */
end_comment

begin_function
name|void
name|init_comparisons
parameter_list|()
block|{
name|comparison_code
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
operator|=
literal|1
expr_stmt|;
name|comparison_code
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
operator|=
literal|1
expr_stmt|;
name|comparison_code
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
operator|=
literal|1
expr_stmt|;
name|comparison_code
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
operator|=
literal|1
expr_stmt|;
name|comparison_code
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
operator|=
literal|1
expr_stmt|;
name|comparison_code
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is run at the start of compiling a function.  */
end_comment

begin_function
name|void
name|init_expr
parameter_list|()
block|{
name|init_queue
argument_list|()
expr_stmt|;
name|may_call_alloca
operator|=
literal|0
expr_stmt|;
name|saveregs_value
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manage the queue of increment instructions to be output    for POSTINCREMENT_EXPR expressions, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue up to increment (or change) VAR later.  BODY says how:    BODY should be the same thing you would pass to emit_insn    to increment right away.  It will go to emit_insn later on.     The value is a QUEUED expression to be used in place of VAR    where you want to guarantee the pre-incrementation value of VAR.  */
end_comment

begin_function
specifier|static
name|rtx
name|enqueue_insn
parameter_list|(
name|var
parameter_list|,
name|body
parameter_list|)
name|rtx
name|var
decl_stmt|,
name|body
decl_stmt|;
block|{
name|pending_chain
operator|=
name|gen_rtx
argument_list|(
name|QUEUED
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|body
argument_list|,
name|pending_chain
argument_list|)
expr_stmt|;
return|return
name|pending_chain
return|;
block|}
end_function

begin_comment
comment|/* Use protect_from_queue to convert a QUEUED expression    into something that you can put immediately into an instruction.    If the queued incrementation has not happened yet,    protect_from_queue returns the variable itself.    If the incrementation has happened, protect_from_queue returns a temp    that contains a copy of the old value of the variable.     Any time an rtx which might possibly be a QUEUED is to be put    into an instruction, it must be passed through protect_from_queue first.    QUEUED expressions are not meaningful in instructions.     Do not pass a value through protect_from_queue and then hold    on to it for a while before putting it in an instruction!    If the queue is flushed in between, incorrect code will result.  */
end_comment

begin_function
name|rtx
name|protect_from_queue
parameter_list|(
name|x
parameter_list|,
name|modify
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|QUEUED
condition|)
block|{
comment|/* A special hack for read access to (MEM (QUEUED ...)) 	 to facilitate use of autoincrement. 	 Make a copy of the contents of the memory location 	 rather than a copy of the address.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QUEUED
operator|&&
operator|!
name|modify
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|QUEUED_VAR
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|x
return|;
block|}
comment|/* Otherwise, recursively protect the subexpressions of all 	 the kinds of rtx's that can contain a QUEUED.  */
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MULT
condition|)
block|{
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/* If the increment has not happened, use the variable itself.  */
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
return|;
comment|/* If the increment has happened and a pre-increment copy exists,      use that copy.  */
if|if
condition|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
comment|/* The increment has happened but we haven't set up a pre-increment copy.      Set one up now, and use it.  */
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
argument_list|,
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X contains a QUEUED expression:    if it contains anything that will be altered by a queued increment.    We handle only combinations of MEM, PLUS, MINUS and MULT operators    since memory addresses generally contain only those.  */
end_comment

begin_function
specifier|static
name|int
name|queued_subexp_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform all the pending incrementations.  */
end_comment

begin_function
name|void
name|emit_queue
parameter_list|()
block|{
specifier|register
name|rtx
name|p
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|pending_chain
condition|)
block|{
name|QUEUED_INSN
argument_list|(
name|p
argument_list|)
operator|=
name|emit_insn
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pending_chain
operator|=
name|QUEUED_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_queue
parameter_list|()
block|{
if|if
condition|(
name|pending_chain
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from FROM to TO, where the machine modes are not the same.    Both modes may be integer, or both may be floating.    UNSIGNEDP should be nonzero if FROM is an unsigned type.    This causes zero-extension instead of sign-extension.  */
end_comment

begin_function
name|void
name|convert_move
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
specifier|register
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|to_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
init|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|to_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|to_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|int
name|from_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|from_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|int
name|extending
init|=
operator|(
name|int
operator|)
name|to_mode
operator|>
operator|(
name|int
operator|)
name|from_mode
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real
operator|!=
name|from_real
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|to_mode
operator|==
name|from_mode
operator|||
operator|(
name|from_mode
operator|==
name|VOIDmode
operator|&&
name|CONSTANT_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|to_real
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_extendsfdf2
if|if
condition|(
name|HAVE_extendsfdf2
operator|&&
name|extending
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendsfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfsf2
if|if
condition|(
name|HAVE_truncdfsf2
operator|&&
operator|!
name|extending
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
operator|(
name|extending
condition|?
literal|"__extendsfdf2"
else|:
literal|"__truncdfsf2"
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
operator|(
name|extending
condition|?
name|SFmode
else|:
name|DFmode
operator|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|hard_libcall_value
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now both modes are integers.  */
if|if
condition|(
name|to_mode
operator|==
name|DImode
condition|)
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_zero_extendsidi2
if|if
condition|(
name|HAVE_zero_extendsidi2
operator|&&
name|from_mode
operator|==
name|SImode
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendsidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendhidi2
if|if
condition|(
name|HAVE_zero_extendhidi2
operator|&&
name|from_mode
operator|==
name|HImode
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendhidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendqidi2
if|if
condition|(
name|HAVE_zero_extendqidi2
operator|&&
name|from_mode
operator|==
name|QImode
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendqidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_zero_extendsidi2
if|if
condition|(
name|HAVE_zero_extendsidi2
condition|)
block|{
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendsidi2
argument_list|,
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_clr_insn
argument_list|(
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_extendsidi2
elseif|else
if|if
condition|(
name|HAVE_extendsidi2
operator|&&
name|from_mode
operator|==
name|SImode
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendsidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhidi2
elseif|else
if|if
condition|(
name|HAVE_extendhidi2
operator|&&
name|from_mode
operator|==
name|HImode
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqidi2
elseif|else
if|if
condition|(
name|HAVE_extendqidi2
operator|&&
name|from_mode
operator|==
name|QImode
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendsidi2
elseif|else
if|if
condition|(
name|HAVE_extendsidi2
condition|)
block|{
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendsidi2
argument_list|,
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_slt
elseif|else
if|if
condition|(
name|HAVE_slt
operator|&&
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
index|[
literal|0
index|]
operator|==
name|SImode
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|target
argument_list|,
name|SImode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|target
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_slt
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
specifier|register
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|emit_clr_insn
argument_list|(
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|SImode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|target
argument_list|,
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|to
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
condition|)
block|{
name|convert_move
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now follow all the conversions between integers      no more than a word long.  */
comment|/* For truncation, usually we can just refer to FROM in a narrower mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|to_mode
operator|==
name|SImode
operator|&&
name|from_mode
operator|==
name|HImode
condition|)
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_zero_extendhisi2
if|if
condition|(
name|HAVE_zero_extendhisi2
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendhisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendhisi2
if|if
condition|(
name|HAVE_extendhisi2
condition|)
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|to_mode
operator|==
name|SImode
operator|&&
name|from_mode
operator|==
name|QImode
condition|)
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_zero_extendqisi2
if|if
condition|(
name|HAVE_zero_extendqisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendqisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_zero_extendqihi2
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_extendhisi2
argument_list|)
if|if
condition|(
name|HAVE_zero_extendqihi2
operator|&&
name|HAVE_extendhisi2
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendqihi2
argument_list|,
name|temp
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhisi2
argument_list|,
name|to
argument_list|,
name|temp
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendqisi2
if|if
condition|(
name|HAVE_extendqisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_extendqihi2
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_extendhisi2
argument_list|)
if|if
condition|(
name|HAVE_extendqihi2
operator|&&
name|HAVE_extendhisi2
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqihi2
argument_list|,
name|temp
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhisi2
argument_list|,
name|to
argument_list|,
name|temp
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|to_mode
operator|==
name|HImode
operator|&&
name|from_mode
operator|==
name|QImode
condition|)
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_zero_extendqihi2
if|if
condition|(
name|HAVE_zero_extendqihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendqihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendqihi2
if|if
condition|(
name|HAVE_extendqihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This seems to be redundant with code 100 lines up.  */
comment|/* Now we are truncating an integer to a smaller one.      If the result is a temporary, we might as well just copy it,      since only the low-order part of the result needs to be valid      and it is valid with no change.  */
block|if (GET_CODE (to) == REG)     {       if (GET_CODE (from) == REG) 	{ 	  emit_move_insn (to, gen_lowpart (GET_MODE (to), from)); 	  return; 	}       else if (GET_CODE (from) == SUBREG) 	{ 	  from = copy_rtx (from);
comment|/* This is safe since FROM is not more than one word.  */
block|PUT_MODE (from, GET_MODE (to)); 	  emit_move_insn (to, from); 	  return; 	}
ifndef|#
directive|ifndef
name|BYTES_BIG_ENDIAN
block|else if (GET_CODE (from) == MEM) 	{ 	  register rtx addr = XEXP (from, 0); 	  if (memory_address_p (GET_MODE (to), addr)) 	    { 	      emit_move_insn (to, gen_rtx (MEM, GET_MODE (to), addr)); 	      return; 	    } 	}
endif|#
directive|endif
comment|/* not BYTES_BIG_ENDIAN */
block|}
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsihi2
if|if
condition|(
name|HAVE_truncsihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsiqi2
if|if
condition|(
name|HAVE_truncsiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|HImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunchiqi2
if|if
condition|(
name|HAVE_trunchiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Mode combination is not recognized.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X to mode MODE.    Both X and MODE may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.    This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.  */
end_comment

begin_function
name|rtx
name|convert_to_mode
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|integer_mode_p
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
name|int
name|integer_mode_p
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|mode
operator|>
operator|(
name|int
operator|)
name|VOIDmode
operator|&&
operator|(
name|int
operator|)
name|mode
operator|<=
operator|(
name|int
operator|)
name|TImode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate several move instructions to copy LEN bytes    from block FROM to block TO.  (These are MEM rtx's with BLKmode).    The caller must pass FROM and TO     through protect_from_queue before calling.    ALIGN (in bytes) is maximum alignment we can assume.  */
end_comment

begin_struct
struct|struct
name|move_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|rtx
name|from_addr
decl_stmt|;
name|int
name|autinc_from
decl_stmt|;
name|int
name|explicit_inc_from
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|move_by_pieces_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|move_by_pieces_ninsns
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|move_by_pieces
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|len
decl_stmt|,
name|align
decl_stmt|;
block|{
name|struct
name|move_by_pieces
name|data
decl_stmt|;
name|rtx
name|to_addr
init|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|from_addr
init|=
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|data
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|.
name|from_addr
operator|=
name|from_addr
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|data
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
operator|(
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|reverse
condition|)
name|data
operator|.
name|offset
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* If copying requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
operator|(
name|data
operator|.
name|autinc_from
operator|&&
name|data
operator|.
name|autinc_to
operator|)
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
operator|>
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|from_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
operator|&&
name|CONSTANT_P
argument_list|(
name|from_addr
argument_list|)
condition|)
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
operator|!
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STRICT_ALIGNMENT
if|if
condition|(
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
else|#
directive|else
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movti
if|if
condition|(
name|HAVE_movti
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|TImode
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|gen_movti
argument_list|,
name|TImode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movdi
if|if
condition|(
name|HAVE_movdi
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|gen_movdi
argument_list|,
name|DImode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movsi
if|if
condition|(
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|gen_movsi
argument_list|,
name|SImode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movhi
if|if
condition|(
name|HAVE_movhi
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|gen_movhi
argument_list|,
name|HImode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movqi
name|move_by_pieces_1
argument_list|(
name|gen_movqi
argument_list|,
name|QImode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|movqi
name|instruction
name|required
name|in
name|machine
name|description
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return number of insns required to move L bytes by pieces.    ALIGN (in bytes) is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|int
name|move_by_pieces_ninsns
parameter_list|(
name|l
parameter_list|,
name|align
parameter_list|)
name|unsigned
name|int
name|l
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
specifier|register
name|int
name|n_insns
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|STRICT_ALIGNMENT
if|if
condition|(
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
else|#
directive|else
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movti
if|if
condition|(
name|HAVE_movti
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|TImode
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|TImode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|TImode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movdi
if|if
condition|(
name|HAVE_movdi
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movsi
if|if
condition|(
name|HAVE_movsi
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movhi
if|if
condition|(
name|HAVE_movhi
operator|&&
name|align
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n_insns
operator|+=
name|l
expr_stmt|;
return|return
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of move_by_pieces.  Move as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|move_by_pieces_1
argument_list|(
name|genfun
argument_list|,
name|mode
argument_list|,
name|data
argument_list|)
name|rtx
argument_list|(
operator|*
name|genfun
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|move_by_pieces
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|to1
decl_stmt|,
name|from1
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
name|to1
operator|=
operator|(
name|data
operator|->
name|autinc_to
condition|?
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|)
else|:
name|change_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|from1
operator|=
operator|(
name|data
operator|->
name|autinc_from
condition|?
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|from_addr
argument_list|)
else|:
name|change_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_sub2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|explicit_inc_from
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_sub2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|from1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|explicit_inc_from
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Emit code to move a block Y to a block X.    This may be done with string-move instructions,    with multiple scalar move instructions, or with a library call.     Both X and Y must be MEM rtx's (perhaps inside VOLATILE)    with mode BLKmode.    SIZE is an rtx that says how long they are.    ALIGN is the maximum alignment we can assume they have,    measured in bytes.  */
end_comment

begin_function
specifier|static
name|void
name|emit_block_move
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
operator|<
name|MOVE_RATIO
operator|)
condition|)
name|move_by_pieces
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the most limited insn first, because there's no point 	 including more than one in the machine description unless 	 the more limited one has some advantage.  */
ifdef|#
directive|ifdef
name|HAVE_movstrqi
if|if
condition|(
name|HAVE_movstrqi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstrqi
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrhi
if|if
condition|(
name|HAVE_movstrhi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstrhi
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrsi
if|if
condition|(
name|HAVE_movstrsi
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstrsi
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcpy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bcopy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy all or part of a BLKmode value X into registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
specifier|static
name|void
name|move_block_to_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|x
operator|!=
name|dconst0_rtx
condition|)
name|x
operator|=
name|force_const_double_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|dconst0_rtx
operator|||
name|x
operator|==
name|const0_rtx
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy all or part of a BLKmode value X out of registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
name|void
name|move_block_from_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark NREGS consecutive regs, starting at REGNO, as being live now.  */
end_comment

begin_function
specifier|static
name|void
name|use_regs
parameter_list|(
name|regno
parameter_list|,
name|nregs
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write zeros through the storage of OBJECT.    If OBJECT has BLKmode, SIZE is its length in bytes.  */
end_comment

begin_function
name|void
name|clear_storage
parameter_list|(
name|object
parameter_list|,
name|size
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memset"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|const0_rtx
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bzero"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to copy Y into X.    Both Y and X must have the same mode, except that    Y can be a constant with VOIDmode.    This mode cannot be BLKmode; use emit_block_move for that.     Return the last instruction emitted.  */
end_comment

begin_function
name|rtx
name|emit_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|y
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|y
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|memory_address
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* It turns out you get much better optimization (in cse and flow)      if you define movdi and movdf instruction patterns      even if they must turn into multiple assembler instructions.  */
if|else if (GET_MODE_SIZE (mode)>= GET_MODE_SIZE (SImode))     {       register int count = GET_MODE_SIZE (mode) / GET_MODE_SIZE (SImode);       register int i;       if (GET_CODE (y) == CONST_DOUBLE&& y != dconst0_rtx) 	y = force_const_double_mem (y);       for (i = 0; i< count; i++) 	{ 	  rtx x1, y1; 	  if (GET_CODE (x) == REG) 	    x1 = gen_rtx (SUBREG, SImode, x, i); 	  else 	    x1 = gen_rtx (MEM, SImode, 			  memory_address (SImode, 					  plus_constant (XEXP (x, 0), 							 i * GET_MODE_SIZE (SImode)))); 	  if (GET_CODE (y) == REG) 	    y1 = gen_rtx (SUBREG, SImode, y, i); 	  else if (y == dconst0_rtx) 	    y1 = const0_rtx; 	  else 	    y1 = gen_rtx (MEM, SImode, 			  memory_address (SImode, 					  plus_constant (XEXP (y, 0), 							 i * GET_MODE_SIZE (SImode)))); 	  emit_insn (gen_movsi (protect_from_queue (x1, 1), protect_from_queue (y1, 0))); 	}     }
endif|#
directive|endif
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing data onto the stack.  */
end_comment

begin_comment
comment|/* Push a block of length SIZE (perhaps variable)    and return an rtx to address the beginning of the block.    Note that it is not possible for the value returned to be a QUEUED.    The value may be stack_pointer_rtx.     EXTRA is the number of bytes of padding to push in addition to the block.    The padding is pushed "after" the specified size.     The value we return does take account of STACK_POINTER_OFFSET.  */
end_comment

begin_function
name|rtx
name|push_block
parameter_list|(
name|size
parameter_list|,
name|extra
parameter_list|)
name|rtx
name|size
decl_stmt|;
name|int
name|extra
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|size
argument_list|)
condition|)
name|anti_adjust_stack
argument_list|(
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
operator|&&
name|extra
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|extra
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|anti_adjust_stack
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|temp
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|extra
argument_list|)
expr_stmt|;
else|#
directive|else
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|temp
operator|=
name|force_operand
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
operator|-
name|extra
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_POINTER_OFFSET
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|STACK_POINTER_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STACK_POINTER_OFFSET */
return|return
name|memory_address
argument_list|(
name|QImode
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_push_operand
parameter_list|()
block|{
return|return
name|gen_rtx
argument_list|(
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|PRE_DEC
argument_list|,
else|#
directive|else
name|PRE_INC
argument_list|,
endif|#
directive|endif
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to push X onto the stack, assuming it has mode MODE.    MODE is redundant except when X is a CONST_INT (since they don't    carry mode info).    SIZE is an rtx for the size of data to be copied (in bytes),    needed only if X is BLKmode.     ALIGN (in bytes) is maximum alignment we can assume.     If PARTIAL is nonzero, then copy that many of the first words    of X into registers starting with REG, and push the rest of X.    The amount of space pushed is decreased by PARTIAL words,    rounded *down* to a multiple of PARM_BOUNDARY.    REG must be a hard register in this case.     EXTRA is the amount in bytes of extra space to leave next to this arg.    Within the function, we set EXTRA to zero once the padding is done,    to avoid padding twice.     On a machine that lacks real push insns, ARGS_ADDR is the address of    the bottom of the argument block for this call.  We use indexing off there    to store the arg.  On machines with push insns, ARGS_ADDR is 0.     ARGS_SO_FAR is the size of args previously pushed for this call.  */
end_comment

begin_function
specifier|static
name|void
name|emit_push_insn
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|partial
parameter_list|,
name|reg
parameter_list|,
name|extra
parameter_list|,
name|args_addr
parameter_list|,
name|args_so_far
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|rtx
name|args_addr
decl_stmt|;
name|rtx
name|args_so_far
decl_stmt|;
block|{
name|rtx
name|xinner
decl_stmt|;
name|enum
name|direction
name|stack_direction
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
init|=
name|downward
decl_stmt|;
else|#
directive|else
operator|=
name|upward
expr_stmt|;
endif|#
directive|endif
comment|/* Decide where to pad the argument: `downward' for below,      `upward' for above, or `none' for don't pad it.      Default is below for small data on big-endian machines; else above.  */
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|xinner
operator|=
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
block|{
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
block|{
comment|/* Push padding now if padding above and stack grows down, 	     or if padding below and stack grows up.  */
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
block|{
name|anti_adjust_stack
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If space already allocated, just adjust the address we use.  */
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
block|{
name|args_so_far
operator|=
name|plus_constant
argument_list|(
name|args_so_far
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* If padding comes after a space already allocated, 	     there is nothing to do.  */
name|extra
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Copy a block into the stack, entirely or partially.  */
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|used
init|=
name|partial
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|offset
init|=
name|used
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|used
operator|-=
name|offset
expr_stmt|;
comment|/* USED is now the # of bytes we need not copy to the stack 	 because registers will take care of them.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|xinner
operator|=
name|change_address
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size,    skip the part of stack space corresponding to the registers.    Otherwise, start copying to the beginning of the stack space,    by setting SKIP to 0.  */
ifndef|#
directive|ifndef
name|FIRST_PARM_CALLER_OFFSET
name|skip
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|skip
operator|=
name|used
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Do it with several push insns if that doesn't take lots of insns 	 and if there is no difficulty with push insns that skip bytes 	 on the stack for alignment purposes.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|skip
operator|==
literal|0
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
operator|<
name|MOVE_RATIO
operator|)
operator|&&
name|PUSH_ROUNDING
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|)
name|move_by_pieces
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|gen_push_operand
argument_list|()
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PUSH_ROUNDING */
block|{
comment|/* Otherwise make space on the stack and copy the data 	     to the address of that space.  */
comment|/* Deduct words put into registers from the size we must copy.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|size
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|used
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Get the address of the stack space.  */
if|if
condition|(
operator|!
name|args_addr
condition|)
block|{
name|temp
operator|=
name|push_block
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|skip
operator|+
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|,
name|skip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TEMP is the address of the block.  Copy the data there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
operator|<
name|MOVE_RATIO
operator|)
condition|)
block|{
name|move_by_pieces
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Try the most limited insn first, because there's no point 	     including more than one in the machine description unless 	     the more limited one has some advantage.  */
ifdef|#
directive|ifdef
name|HAVE_movstrqi
if|if
condition|(
name|HAVE_movstrqi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstrqi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrhi
if|if
condition|(
name|HAVE_movstrhi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstrhi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrsi
if|if
condition|(
name|HAVE_movstrsi
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstrsi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
condition|)
block|{
comment|/* Now that emit_library_call does force_operand 		 before pushing anything, preadjustment does not work.  */
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Correct TEMP so it holds what will be a description of 		 the address to copy to, valid after one arg is pushed.  */
block|int xsize = GET_MODE_SIZE (Pmode);
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
block|xsize = PUSH_ROUNDING (xsize);
endif|#
directive|endif
block|xsize = ((xsize + PARM_BOUNDARY / BITS_PER_UNIT - 1) 		       / (PARM_BOUNDARY / BITS_PER_UNIT) 		       * (PARM_BOUNDARY / BITS_PER_UNIT));
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* If we are calling bcopy, we push one arg before TEMP. 		 If calling memcpy, we push two.  */
block|xsize *= 2;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
block|temp = plus_constant (temp, xsize);
else|#
directive|else
block|temp = plus_constant (temp, -xsize);
endif|#
directive|endif
comment|/* not STACK_GROWS_DOWNWARD */
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* Make inhibit_defer_pop nonzero around the library call 	     to force it to pop the bcopy-arguments right away.  */
name|NO_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcpy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bcopy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OK_DEFER_POP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partial
operator|>
literal|0
condition|)
block|{
comment|/* Scalar partly in registers.  */
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|not_stack
decl_stmt|;
comment|/* # words of start of argument 	 that we must make space for but need not store.  */
name|int
name|offset
init|=
name|partial
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|args_offset
init|=
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
comment|/* If we make space by pushing it, we might as well push 	 the real data.  Otherwise, we can leave OFFSET nonzero 	 and leave the space uninitialized.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Now NOT_STACK gets the number of words that we don't need to 	 allocate on the stack.  */
name|not_stack
operator|=
name|partial
operator|-
name|offset
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size,    skip the part of stack space corresponding to the registers.    Otherwise, start copying to the beginning of the stack space,    by setting SKIP to 0.  */
ifndef|#
directive|ifndef
name|FIRST_PARM_CALLER_OFFSET
name|skip
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|skip
operator|=
name|not_stack
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|x
operator|!=
name|dconst0_rtx
condition|)
name|x
operator|=
name|force_const_double_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Loop over all the words allocated on the stack for this arg.  */
comment|/* We can do it by words, because any scalar bigger than a word 	 has a size a multiple of a word.  */
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|not_stack
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
name|not_stack
condition|;
name|i
operator|--
control|)
endif|#
directive|endif
if|if
condition|(
name|i
operator|>=
name|not_stack
operator|+
name|offset
condition|)
block|{
name|rtx
name|wd
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Get the next word of the value in WD.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Copy to a reg, since machine may lack 		   memory-to-memory move insns.  */
name|wd
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|wd
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|dconst0_rtx
operator|||
name|x
operator|==
name|const0_rtx
condition|)
name|wd
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_push_insn
argument_list|(
name|wd
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|args_addr
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|args_offset
operator|+
operator|(
name|i
operator|-
name|not_stack
operator|+
name|skip
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|gen_push_operand
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|ret
label|:
comment|/* If part should go in registers, copy that part      into the appropriate registers.  Do this now, at the end,      since mem-to-mem copies above may do function calls.  */
if|if
condition|(
name|partial
operator|>
literal|0
condition|)
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|x
argument_list|,
name|partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|anti_adjust_stack
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a library call to function FUN (a SYMBOL_REF rtx)    (emitting the queue unless NO_QUEUE is nonzero),    for a value of mode OUTMODE,    with NARGS different arguments, passed as alternating rtx values    and machine_modes to convert them to.    The rtx values should have been passed through protect_from_queue already.  */
end_comment

begin_function
name|void
name|emit_library_call
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
specifier|register
name|va_list
name|p
decl_stmt|;
specifier|register
name|int
name|args_size
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|argnum
decl_stmt|;
name|enum
name|machine_mode
name|outmode
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|rtx
name|orgfun
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
modifier|*
name|regvec
decl_stmt|;
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
struct|struct
name|arg
block|{
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|partial
decl_stmt|;
block|}
struct|;
name|struct
name|arg
modifier|*
name|argvec
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|int
name|stack_padding
init|=
literal|0
decl_stmt|;
name|int
name|no_queue
init|=
literal|0
decl_stmt|;
name|rtx
name|use_insns
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|orgfun
operator|=
name|fun
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|no_queue
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|outmode
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|regvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy all the libcall-arguments out of the varargs data      and into a vector ARGVEC.  */
name|argvec
operator|=
operator|(
expr|struct
name|arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|val
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
decl_stmt|;
name|int
name|arg_size
decl_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
comment|/* Convert the arg value to the mode the library wants. 	 Also make sure it is a reasonable operand 	 for a move or push insn.  */
comment|/* ??? It is wrong to do it here; must do it earlier 	 where we know the signedness of the arg.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|val
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|val
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
operator|(
operator|(
name|CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|force_operand
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|regvec
index|[
name|count
index|]
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If we have no actual push instructions, make space for all the args      right now.  */
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|count
index|]
operator|.
name|mode
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|regvec
index|[
name|count
index|]
decl_stmt|;
specifier|register
name|int
name|partial
init|=
name|argvec
index|[
name|count
index|]
operator|.
name|partial
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|||
name|partial
operator|!=
literal|0
condition|)
name|args_size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|args_size
operator|-=
name|partial
operator|*
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args_size
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|STACK_ARGS_ADJUST
name|struct
name|args_size
name|size
decl_stmt|;
name|size
operator|.
name|constant
operator|=
name|args_size
expr_stmt|;
name|size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
name|STACK_ARGS_ADJUST
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
name|argblock
operator|=
name|push_block
argument_list|(
name|round_push
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|args_size
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no PUSH_ROUNDING */
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|inc
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|=
name|stack_padding
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|regvec
index|[
name|argnum
index|]
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
name|int
name|arg_size
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|emit_push_insn
argument_list|(
name|val
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|argblock
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|args_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute size of stack space used by this argument.  */
if|if
condition|(
name|reg
operator|==
literal|0
operator|||
name|partial
operator|!=
literal|0
condition|)
name|arg_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|arg_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|arg_size
operator|-=
operator|(
operator|(
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|args_size
operator|+=
name|arg_size
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
block|}
comment|/* For version 1.37, try deleting this entirely.  */
if|if
condition|(
operator|!
name|no_queue
condition|)
name|emit_queue
argument_list|()
expr_stmt|;
name|fun
operator|=
name|prepare_call_address
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Any regs containing parms remain in use through the call.  */
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|regvec
index|[
name|count
index|]
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|regvec
index|[
name|count
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|use_insns
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|args_size
operator|=
operator|(
name|args_size
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
expr_stmt|;
endif|#
directive|endif
comment|/* Don't allow popping to be deferred, since then      cse'ing of library calls could delete a call and leave the pop.  */
name|NO_DEFER_POP
expr_stmt|;
name|emit_call_1
argument_list|(
name|fun
argument_list|,
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|orgfun
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|args_size
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outmode
operator|!=
name|VOIDmode
condition|?
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
else|:
literal|0
argument_list|,
name|old_inhibit_defer_pop
operator|+
literal|1
argument_list|,
name|use_insns
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an assignment that stores the value of FROM into TO.    If WANT_VALUE is nonzero, return an rtx for the value of TO.    (This may contain a QUEUED rtx.)    Otherwise, the returned value is not meaningful.     SUGGEST_REG is no longer actually used.    It used to mean, copy the value through a register    and return that register, if that is possible.    But now we do this if WANT_VALUE.     If the value stored is a constant, we return the constant.  */
end_comment

begin_function
name|rtx
name|expand_assignment
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|want_value
parameter_list|,
name|suggest_reg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|want_value
decl_stmt|;
name|int
name|suggest_reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|to_rtx
init|=
literal|0
decl_stmt|;
comment|/* Don't crash if the lhs of the assignment was erroneous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expand_expr
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Assignment of a structure component needs special treatment      if the structure component's rtx is not simply a MEM.      Assignment of an array element at a constant index      has the same problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|volstruct
init|=
literal|0
decl_stmt|;
name|tree
name|tem
init|=
name|to
decl_stmt|;
name|int
name|bitpos
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|mode1
operator|=
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode1
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode1
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute cumulative bit-offset for nested component-refs 	 and array-refs, and find the ultimate containing object.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|bitpos
operator|+=
name|DECL_OFFSET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|tem
argument_list|)
condition|)
name|volstruct
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|bitpos
operator|+=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|tem
argument_list|)
condition|)
name|volstruct
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* TEM is now the containing data object.  */
comment|/* If we are going to use store_bit_field and extract_bit_field, 	 make sure to_rtx will be safe for multiple use.  */
if|if
condition|(
name|mode1
operator|==
name|BImode
operator|&&
name|want_value
condition|)
name|tem
operator|=
name|stabilize_reference
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|volstruct
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|store_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode1
argument_list|,
name|from
argument_list|,
operator|(
name|want_value
comment|/* Spurious cast makes HPUX compiler happy.  */
condition|?
operator|(
expr|enum
name|machine_mode
operator|)
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
else|:
name|VOIDmode
operator|)
argument_list|,
name|unsignedp
argument_list|,
comment|/* Required alignment of containing datum.  */
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Ordinary treatment.  Expand TO to get a REG or MEM rtx.      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute FROM and store the value in the rtx we got.  */
return|return
name|store_expr
argument_list|(
name|from
argument_list|,
name|to_rtx
argument_list|,
name|want_value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code for computing expression EXP,    and storing the value into TARGET.    Returns TARGET or an equivalent value.    TARGET may contain a QUEUED rtx.     If SUGGEST_REG is nonzero, copy the value through a register    and return that register, if that is possible.     If the value stored is a constant, we return the constant.  */
end_comment

begin_function
name|rtx
name|store_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|suggest_reg
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|suggest_reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|dont_return_target
init|=
literal|0
decl_stmt|;
comment|/* Copying a non-constant CONSTRUCTOR needs special treatment.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|suggest_reg
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
condition|)
comment|/* If target is in memory and caller wants value in a register instead,        arrange that.  Pass TARGET as target for expand_expr so that,        if EXP is another assignment, SUGGEST_REG will be nonzero for it.        We know expand_expr will not use the target in that case.  */
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|cse_not_expected
condition|?
literal|0
else|:
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queued_subexp_p
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If target contains a postincrement, it is not safe        to use as the returned value.  It would access the wrong        place by the time the queued increment gets output.        So copy the value through a temporary and use that temp        as the result.  */
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DO return TARGET if it's a specified hardware register. 	 expand_return relies on this.  */
if|if
condition|(
operator|!
operator|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If value was not generated in the target, store it there.      Convert the value to TARGET's type first if nec.  */
if|if
condition|(
name|temp
operator|!=
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_return_target
condition|)
block|{
comment|/* In this case, we will return TEMP, 		 so make sure it has the proper mode. 		 But don't forget to store the value into TARGET.  */
name|temp
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dont_return_target
condition|)
return|return
name|temp
return|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the value of constructor EXP into the rtx TARGET.    TARGET is either a REG or a MEM.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
comment|/* Don't try copying piece by piece into a hard register      since that is vulnerable to being clobbered by EXP.      Instead, construct in a pseudo register and then copy it all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
comment|/* If the constructor has fewer fields than the structure, 	 clear the whole structure first.  */
if|if
condition|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding field of TARGET.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|register
name|tree
name|field
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|store_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
comment|/* The alignment of TARGET is 			  at least what its type requires.  */
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|minelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|maxelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the constructor has fewer fields than the structure, 	 clear the whole structure first.  */
if|if
condition|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|maxelt
operator|-
name|minelt
operator|+
literal|1
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|maxelt
operator|-
name|minelt
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding element of TARGET, determined 	 by counting the elements.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|bitpos
operator|=
operator|(
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|elttype
argument_list|)
operator|)
expr_stmt|;
name|store_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
comment|/* The alignment of TARGET is 			  at least what its type requires.  */
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the value of EXP (an expression tree)    into a subfield of TARGET which has mode MODE and occupies    BITSIZE bits, starting BITPOS bits from the start of TARGET.     If VALUE_MODE is VOIDmode, return nothing in particular.    UNSIGNEDP is not used in this case.     Otherwise, return an rtx for the value stored.  This rtx    has mode VALUE_MODE if that is convenient to do.    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.     ALIGN is the alignment that TARGET is known to have, measured in bytes.    TOTAL_SIZE is its size in bytes, or -1 if variable.  */
end_comment

begin_function
specifier|static
name|rtx
name|store_field
parameter_list|(
name|target
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|value_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
comment|/* If the structure is in a register or if the component      is a bit field, we cannot use addressing to access it.      Use bit-field techniques or SUBREG to store in it.  */
if|if
condition|(
name|mode
operator|==
name|BImode
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|store_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|expand_expr
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|extract_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|value_mode
argument_list|,
literal|0
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
return|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
decl_stmt|;
comment|/* If a value is wanted, it must be the lhs; 	 so make the address stable for multiple use.  */
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Now build a reference to just the desired component.  */
name|to_rtx
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|to_rtx
argument_list|,
name|value_mode
operator|!=
name|VOIDmode
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx VALUE that may contain additions and multiplications,    return an equivalent value that just refers to a register or memory.    This is done by generating instructions to perform the arithmetic    and returning a pseudo-register containing the value.  */
end_comment

begin_function
name|rtx
name|force_operand
parameter_list|(
name|value
parameter_list|,
name|target
parameter_list|)
name|rtx
name|value
decl_stmt|,
name|target
decl_stmt|;
block|{
specifier|register
name|optab
name|binoptab
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|op2
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
specifier|register
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
condition|)
name|binoptab
operator|=
name|add_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
condition|)
name|binoptab
operator|=
name|sub_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|binoptab
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|binoptab
operator|=
name|add_optab
expr_stmt|;
name|op2
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
comment|/* We give UNSIGNEP = 0 to expand_binop 	 because the only operations we are expanding here are signed ones.  */
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* expand_expr: generate code for computing expression EXP.    An rtx for the computed value is returned.  The value is never null.    In the case of a void EXP, const0_rtx is returned.     The value may be stored in TARGET if TARGET is nonzero.    TARGET is just a suggestion; callers must assume that    the rtx returned may not be the same as TARGET.     If TARGET is CONST0_RTX, it means that the value will be ignored.     If TMODE is not VOIDmode, it suggests generating the    result in mode TMODE.  But this is done only when convenient.    Otherwise, TMODE is ignored and the value generated in its natural mode.    TMODE is just a suggestion; callers must assume that    the rtx returned may not have mode TMODE.     If MODIFIER is EXPAND_SUM then when EXP is an addition    we can return an rtx of the form (MULT (REG ...) (CONST_INT ...))    or a nest of (PLUS ...) and (MINUS ...) where the terms are    products as above, or REG or MEM, or constant.    Ordinarily in such cases we would output mul or add instructions    and then return a pseudo reg containing the sum.     If MODIFIER is EXPAND_CONST_ADDRESS then it is ok to return    a MEM rtx whose address is a constant that isn't a legitimate address.  */
end_comment

begin_comment
comment|/* Subroutine of expand_expr:    save the non-copied parts (LIST) of an expr (LHS), and return a list    which can restore these values to their previous values,    should something modify their storage.  */
end_comment

begin_function
specifier|static
name|tree
name|save_noncopied_parts
parameter_list|(
name|lhs
parameter_list|,
name|list
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|parts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|parts
operator|=
name|chainon
argument_list|(
name|parts
argument_list|,
name|save_noncopied_parts
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|part
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|parts
operator|=
name|tree_cons
argument_list|(
name|save_expr
argument_list|(
name|build_component_ref
argument_list|(
name|lhs
argument_list|,
name|part
argument_list|,
name|parts
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_nt
argument_list|(
name|RTL_EXPR
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|)
name|assign_stack_local
argument_list|(
name|TYPE_MODE
argument_list|(
name|part_type
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|part_type
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|parts
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parts
argument_list|)
argument_list|,
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|parts
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr:    return the target to use when recursively expanding    the first operand of an arithmetic operation.  */
end_comment

begin_function
specifier|static
name|rtx
name|validate_subtarget
parameter_list|(
name|subtarget
parameter_list|,
name|otherop
parameter_list|)
name|rtx
name|subtarget
decl_stmt|;
name|tree
name|otherop
decl_stmt|;
block|{
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|otherop
argument_list|)
condition|)
return|return
name|subtarget
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|otherop
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL
argument_list|(
name|otherop
argument_list|)
operator|!=
name|subtarget
condition|)
return|return
name|subtarget
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rtx
name|expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|optab
name|this_optab
decl_stmt|;
name|int
name|negate_1
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
name|rtx
name|original_target
init|=
name|target
decl_stmt|;
name|int
name|ignore
init|=
name|target
operator|==
name|const0_rtx
decl_stmt|;
comment|/* Don't use hard regs as subtargets, because the combiner      can only handle pseudo regs.  */
if|if
condition|(
name|subtarget
operator|&&
name|REGNO
argument_list|(
name|subtarget
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Avoid subtargets inside loops,      since they hide some invariant expressions.  */
if|if
condition|(
name|optimize
operator|&&
name|inside_loop
argument_list|()
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
literal|0
operator|,
name|original_target
operator|=
literal|0
expr_stmt|;
comment|/* If will do cse, generate all results into registers      since 1) that allows cse to find more things      and 2) otherwise cse could produce an insn the machine      cannot support.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
name|target
operator|=
name|subtarget
expr_stmt|;
comment|/* No sense saving up arithmetic to be done      if it's all in the wrong mode to form part of an address.      And force_operand won't know whether to sign-extend or zero-extend.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
name|modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
comment|/* Ensure we reference a volatile object even if value is ignored.  */
if|if
condition|(
name|ignore
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|exp
argument_list|,
literal|"prior parameter's size depends on `%s'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This is the case of an array whose size is to be determined 	 from its initializer, while the initializer is still being parsed. 	 See expand_decl.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
condition|)
block|{
comment|/* DECL_RTL probably contains a constant address. 	     On RISC machines where a constant address isn't valid, 	     make some insns to get that address into a register.  */
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
comment|/* Generate immediate CONST_DOUBLE 	 which will be turned into memory by reload if necessary.  */
return|return
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
return|return
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* If optimized, generate immediate CONST_DOUBLE 	 which will be turned into memory by reload if necessary.  */
if|if
condition|(
operator|!
name|cse_not_expected
condition|)
return|return
name|immed_real_const
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
case|case
name|STRING_CST
case|:
if|if
condition|(
operator|!
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
name|output_constant_def
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* TREE_CST_RTL probably contains a constant address. 	 On RISC machines where a constant address isn't valid, 	 make some insns to get that address into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|change_address
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|reg
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
condition|)
name|save_expr_regs
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
block|}
comment|/* Don't let the same rtl node appear in two places.  */
return|return
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|LET_STMT
case|:
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|STMT_BODY
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
case|case
name|RTL_EXPR
case|:
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|==
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* All elts simple constants => refer to a constant in memory.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* For aggregate types with non-BLKmode modes, 	   this should ideally construct a CONST_INT.  */
block|{
name|rtx
name|constructor
init|=
name|output_constant_def
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|constructor
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|constructor
operator|=
name|change_address
argument_list|(
name|constructor
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|constructor
return|;
block|}
if|if
condition|(
name|ignore
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|assign_stack_local
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|exp2
decl_stmt|;
comment|/* A SAVE_EXPR as the address in an INDIRECT_EXPR is generated 	   for  *PTR += ANYTHING  where PTR is put inside the SAVE_EXPR. 	   This code has the same general effect as simply doing 	   expand_expr on the save expr, except that the expression PTR 	   is computed for use as a memory address.  This means different 	   code, suitable for indexing, may be generated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp1
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|exp1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|exp2
operator|=
name|TREE_OPERAND
argument_list|(
name|exp1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp1
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp2
argument_list|)
argument_list|)
operator|==
name|Pmode
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|op0
operator|=
name|copy_all_regs
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|SAVE_EXPR_RTL
argument_list|(
name|exp1
argument_list|)
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* If address was computed by addition, 	 mark this as an element of an aggregate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|||
name|flag_volatile
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* Nonconstant array index or nonconstant element size. 	     Generate the tree for *(&array+index) and expand that, 	     except do it in a language-independent way 	     and don't complain about non-lvalue arrays. 	     `mark_addressable' should already have been called 	     for any array for which this case will be reached.  */
comment|/* Don't forget the const or volatile flag from the array element. */
name|tree
name|variant_type
init|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|array_adr
init|=
name|build
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|variant_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|elt
decl_stmt|;
comment|/* Convert the integer argument to a type the same size as a pointer 	     so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|index
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* The array address isn't volatile even if the array is.  */
name|TREE_VOLATILE
argument_list|(
name|array_adr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|elt
operator|=
name|build
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|variant_type
argument_list|)
argument_list|,
name|array_adr
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|variant_type
argument_list|)
argument_list|,
name|index
argument_list|,
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|elt
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
comment|/* Fold an expression like: "foo"[2]. 	 This is not done in fold so it won't happen inside&.  */
block|{
name|int
name|i
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|integer_type_node
condition|)
block|{
name|exp
operator|=
name|build_int_2
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|arg0
argument_list|)
operator|)
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
block|{
name|exp
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg0
argument_list|)
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If this is a constant index into a constant array, 	 just get the value from the array.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_LITERAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
name|index
init|=
name|fold
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|init
operator|&&
name|i
operator|--
condition|)
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
block|}
comment|/* Treat array-ref with constant index as a component-ref.  */
case|case
name|COMPONENT_REF
case|:
block|{
specifier|register
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|int
name|volstruct
init|=
literal|0
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|tree
name|tem
init|=
name|exp
decl_stmt|;
name|int
name|bitpos
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|mode1
operator|=
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode1
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode1
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute cumulative bit-offset for nested component-refs 	   and array-refs, and find the ultimate containing object.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|bitpos
operator|+=
name|DECL_OFFSET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|tem
argument_list|)
condition|)
name|volstruct
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|bitpos
operator|+=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|tem
argument_list|)
condition|)
name|volstruct
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
condition|?
name|modifier
else|:
name|EXPAND_NORMAL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode1
operator|==
name|BImode
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|tmode
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Get a reference to just this component.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator||=
name|volstruct
expr_stmt|;
comment|/* If OP0 is in the shared structure-value stack slot, 	   and it is not BLKmode, copy it into a register. 	   The shared slot may be clobbered at any time by another call. 	   BLKmode is safe because our caller will either copy the value away 	   or take another component and come back here.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|mode1
operator|||
name|mode1
operator|==
name|BLKmode
operator|||
name|mode1
operator|==
name|tmode
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Intended for a reference to a buffer of a file-object in Pascal. 	 But it's not certain that a special tree code will really be 	 necessary for these.  INDIRECT_REF might work for them.  */
case|case
name|BUFFER_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|cleanups_of_this_call
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cleanups_of_this_call
argument_list|)
expr_stmt|;
return|return
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOT_BUILT_IN
operator|)
condition|)
return|return
name|expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|tmode
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* If this call was expanded already by preexpand_calls, 	 just return the result we got.  */
if|if
condition|(
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|ignore
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* Avoid problem in convert_move due to unknown mode of OP0.  */
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|PLUS_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op1
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op1
return|;
block|}
name|negate_1
operator|=
literal|1
expr_stmt|;
name|plus_minus
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|negate_1
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
name|this_optab
operator|=
name|add_optab
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
condition|)
goto|goto
name|binop
goto|;
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Put a sum last, to simplify what follows.  */
ifdef|#
directive|ifdef
name|OLD_INDEXING
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|temp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OLD_INDEXING
comment|/* Make sure any term that's a sum with a constant comes last.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If adding to a sum including a constant, 	 associate it to put the constant outside.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|int
name|constant_term
init|=
literal|0
decl_stmt|;
name|op0
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Let's also eliminate constants from op0 if possible.  */
name|tem
operator|=
name|eliminate_constant_term
argument_list|(
name|op0
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|constant_term
operator|!=
literal|0
condition|)
return|return
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|constant_term
argument_list|)
return|;
else|else
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
condition|)
block|{
name|int
name|negated
decl_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
condition|)
block|{
name|negate_1
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|plus_minus
goto|;
block|}
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|negated
operator|=
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|HOST_BITS_PER_INT
condition|)
name|negated
operator|&=
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|op1
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|negated
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|add_optab
expr_stmt|;
goto|goto
name|binop2
goto|;
block|}
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MULT_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If first operand is constant, swap them. 	 Thus the following special case checks need only 	 check the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|tree
name|t1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
comment|/* Attempt to return something suitable for generating an 	 indexed address, for machines that support that.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Apply distributive law if OP0 is x+c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for multiplying things that have been extended 	 from a narrower type.  If this machine supports multiplying 	 in that narrower type with a result in the desired type, 	 do it that way, and avoid the explicit type-conversion.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
comment|/* Don't use a widening multiply if a shift will do.  */
operator|&&
name|exact_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* If both operands are extended, they must either both 		  be zero-extended or both be sign-extended.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE_WIDER_MODE
argument_list|(
name|innermode
argument_list|)
operator|&&
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|binop2
goto|;
block|}
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possible optimization: compute the dividend with EXPAND_SUM 	 then if the divisor is constant can optimize the case 	 where some terms of the dividend have coeffs divisible by it.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|RDIV_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|flodiv_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|HAVE_divmoddisi4
block|if (GET_MODE (op0) != DImode) 	{ 	  temp = gen_reg_rtx (DImode); 	  convert_move (temp, op0, 0); 	  op0 = temp; 	  if (GET_MODE (op1) != SImode&& GET_CODE (op1) != CONST_INT) 	    { 	      temp = gen_reg_rtx (SImode); 	      convert_move (temp, op1, 0); 	      op1 = temp; 	    } 	  temp = gen_reg_rtx (SImode); 	  if (target == 0) 	    target = gen_reg_rtx (SImode); 	  emit_insn (gen_divmoddisi4 (temp, protect_from_queue (op0, 0), 				      protect_from_queue (op1, 0), 				      protect_from_queue (target, 1))); 	  return target; 	}
endif|#
directive|endif
endif|#
directive|endif
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not used for C.  */
case|case
name|FIX_TRUNC_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|QImode
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|expand_fix
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_fix
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
case|case
name|FLOAT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* Avoid problem in convert_move due to unknown mode of OP0.  */
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|QImode
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_float
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
case|case
name|NEGATE_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|ABS_EXPR
case|:
comment|/* First try to do it with a special abs instruction. 	 If that does not win, use conditional jump and negate.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|abs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
name|temp
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|target
argument_list|,
name|expand_expr
argument_list|(
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|target
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|temp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|compare1
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|GEU
argument_list|,
name|LEU
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
else|:
name|compare1
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|GE
argument_list|,
name|LE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|compare1
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|LEU
argument_list|,
name|GEU
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
else|:
name|compare1
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|LE
argument_list|,
name|GE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|!=
name|const1_rtx
condition|)
block|{
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|temp
argument_list|)
index|]
call|)
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
comment|/* ??? Can optimize when the operand of this is a bitwise operation,    by using a different bitwise operation.  */
case|case
name|BIT_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|FFS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
comment|/* ??? Can optimize bitwise operations with one arg constant.    Pastel optimizes (a bitwise1 n) bitwise2 (a bitwise3 b)    and (a bitwise1 b) bitwise2 b (etc)    but that is probably not worth while.  */
comment|/* BIT_AND_EXPR is for bitwise anding.    TRUTH_AND_EXPR is for anding two boolean values    when we want in all cases to compute both of them.    In general it is fastest to do TRUTH_AND_EXPR by    computing both operands as actual zero-or-1 values    and then bitwise anding.  In cases where there cannot    be any side effects, better code would be made by    treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR;    but the question is how to recognize those cases.  */
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_bit_and
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|)
return|;
comment|/* See comment above about TRUTH_AND_EXPR; it applies here too.  */
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|ior_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|BIT_XOR_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|xor_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
comment|/* ??? cv's were used to effect here to combine additive constants    and to determine the answer when only additive constants differ.    Also, the addition of one can be handled by changing the condition.  */
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|do_store_flag
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* For foo != 0, load foo, and if it is nonzero load 1 instead. */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|subtarget
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|subtarget
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|temp
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If no set-flag instruction, must generate a conditional 	 store into a temporary variable.  Drop through 	 and handle this like&& and ||.  */
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_clr_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|exp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_0_to_1_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The parser is careful to generate TRUTH_NOT_EXPR 	 only with operands that are always zero or one.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|COMPOUND_EXPR
case|:
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Note that COND_EXPRs whose type is a structure or union 	 are required to be constructed to contain assignments of 	 a temporary variable, so that we can evaluate them here 	 for side effect only.  If type is void, we must do likewise.  */
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|ignore
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|TREE_LITERAL
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|temp
return|;
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* If lhs is complex, expand calls in rhs before computing it. 	   That's so we don't compute a pointer and save it over a call. 	   If lhs is simple, compute it first so we can give it as a 	   target if the rhs is just a call.  This avoids an extra temp and copy 	   and that prevents a partial-subsumption which makes bad code. 	   Actually we could treat component_ref's of vars like vars.  */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|noncopied_parts
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|noncopied_parts
operator|=
name|save_noncopied_parts
argument_list|(
name|lhs
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|noncopied_parts
operator|!=
literal|0
condition|)
block|{
name|store_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noncopied_parts
operator|=
name|TREE_CHAIN
argument_list|(
name|noncopied_parts
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
condition|)
return|return
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
return|;
name|op0
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
return|;
return|return
name|op0
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ERROR_MARK
case|:
return|return
name|const0_rtx
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Here to do an ordinary binary operator, generating an instruction      from the optab already placed in `this_optab'.  */
name|binop
label|:
comment|/* Detect things like x = y | (a == b)      and do them as (x = y), (a == b ? x |= 1 : 0), x.  */
comment|/* First, get the comparison or conditional into the second arg.  */
if|if
condition|(
name|comparison_code
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|this_optab
operator|==
name|ior_optab
operator|||
name|this_optab
operator|==
name|add_optab
operator|||
name|this_optab
operator|==
name|xor_optab
condition|)
block|{
name|tree
name|exch
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|exch
expr_stmt|;
block|}
block|}
comment|/* Optimize X + (Y ? Z : 0) by computing X and maybe adding Z.  */
if|if
condition|(
name|comparison_code
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|this_optab
operator|==
name|ior_optab
operator|||
name|this_optab
operator|==
name|add_optab
operator|||
name|this_optab
operator|==
name|xor_optab
operator|||
name|this_optab
operator|==
name|sub_optab
operator|||
name|this_optab
operator|==
name|lshl_optab
operator|||
name|this_optab
operator|==
name|ashl_optab
operator|||
name|this_optab
operator|==
name|lshr_optab
operator|||
name|this_optab
operator|==
name|ashr_optab
operator|||
name|this_optab
operator|==
name|rotl_optab
operator|||
name|this_optab
operator|==
name|rotr_optab
condition|)
block|{
name|tree
name|thenexp
decl_stmt|;
name|rtx
name|thenv
init|=
literal|0
decl_stmt|;
comment|/* TARGET gets a reg in which we can perform the computation. 	     Use the specified target if it's a pseudo reg and safe.  */
name|target
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Compute X into the target.  */
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* If other operand is a comparison COMP, treat it as COMP ? 1 : 0 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|COND_EXPR
condition|)
block|{
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thenv
operator|=
name|const1_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thenexp
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|thenexp
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thenv
operator|==
literal|0
condition|)
name|thenv
operator|=
name|expand_expr
argument_list|(
name|thenexp
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* THENV is now Z, the value to operate on, as an rtx. 	     We have already tested that Y isn't zero, so do the operation.  */
if|if
condition|(
name|this_optab
operator|==
name|rotl_optab
operator|||
name|this_optab
operator|==
name|rotr_optab
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|target
argument_list|,
name|thenv
argument_list|,
name|target
argument_list|,
operator|-
literal|1
argument_list|,
name|OPTAB_LIB
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_optab
operator|==
name|lshl_optab
operator|||
name|this_optab
operator|==
name|lshr_optab
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|target
argument_list|,
name|thenv
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|target
argument_list|,
name|thenv
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
name|subtarget
operator|=
name|validate_subtarget
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop2
label|:
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
comment|/* build_function_call changes these into ABS_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_SAVEREGS
case|:
if|if
condition|(
name|saveregs_value
operator|!=
literal|0
condition|)
return|return
name|saveregs_value
return|;
block|{
comment|/* When this function is called, it means that registers must be 	   saved on entry to this function.  So we migrate the 	   call to the first insn of this function.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* Now really call the function.  `expand_call' does not call 	   expand_builtin, so there is no danger of infinite recursion here.  */
name|rtx
name|temp
init|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
decl_stmt|;
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|saveregs_value
operator|=
name|temp
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|BUILT_IN_NEXT_ARG
case|:
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`stdarg.h' facilities used, but function has fixed args"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
return|return
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|arg_pointer_rtx
argument_list|,
name|current_function_arg_offset_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|integer_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|CHAR_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|char_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|enumeral_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|boolean_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|pointer_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|reference_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|offset_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|real_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|complex_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|function_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|method_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|record_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|union_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|array_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|STRING_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|string_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SET_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|set_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FILE_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|file_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LANG_TYPE
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|lang_type_class
argument_list|)
return|;
block|}
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|no_type_class
argument_list|)
return|;
case|case
name|BUILT_IN_ALLOCA
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-integer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|const0_rtx
return|;
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|Pmode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Push that much space (rounding it up).  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_POINTER_OFFSET
comment|/* If we will have to round the result down (which is up 	 if stack grows down), make sure we have extra space so the 	 user still gets at least as much space as he asked for.  */
if|if
condition|(
operator|(
name|STACK_POINTER_OFFSET
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|!=
name|STACK_POINTER_OFFSET
operator|/
name|STACK_BYTES
condition|)
name|op0
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|STACK_BYTES
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|anti_adjust_stack
argument_list|(
name|round_push
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Return a copy of current stack ptr, in TARGET if possible.  */
if|if
condition|(
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|copy_to_reg
argument_list|(
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_POINTER_OFFSET
comment|/* If the contents of the stack pointer reg are offset from the 	 actual top-of-stack address, add the offset here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|STACK_POINTER_OFFSET
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|STACK_POINTER_OFFSET
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|anti_adjust_stack
argument_list|(
name|round_push
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Some systems require a particular insn to refer to the stack 	 to make the pages exist.  */
ifdef|#
directive|ifdef
name|HAVE_probe
if|if
condition|(
name|HAVE_probe
condition|)
name|emit_insn
argument_list|(
name|gen_probe
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|target
return|;
case|case
name|BUILT_IN_FFS
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-integer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|const0_rtx
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute ffs, into TARGET if possible. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|target
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand code for a post- or pre- increment or decrement    and return the RTX for the result.    POST is 1 for postinc/decrements and 0 for preinc/decrements.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_increment
parameter_list|(
name|exp
parameter_list|,
name|post
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|int
name|post
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|;
specifier|register
name|tree
name|incremented
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|optab
name|this_optab
init|=
name|add_optab
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op0_is_copy
init|=
literal|0
decl_stmt|;
comment|/* Stabilize any component ref that might need to be      evaluated more than once below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BImode
operator|)
condition|)
name|incremented
operator|=
name|stabilize_reference
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Compute the operands as RTX.      Note whether OP0 is the actual lvalue or a copy of it:      I believe it is a copy iff it is a register and insns were      generated in computing it.  */
name|temp
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|op0_is_copy
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decide whether incrementing or decrementing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
comment|/* If OP0 is not the actual lvalue, but rather a copy in a register,      then we cannot just increment OP0.  We must      therefore contrive to increment the original value.      Then we can return OP0 since it is a copy of the old value.  */
if|if
condition|(
name|op0_is_copy
condition|)
block|{
comment|/* This is the easiest way to increment the value wherever it is. 	 Problems with multiple evaluation of INCREMENTED 	 are prevented because either (1) it is a component_ref, 	 in which case it was stabilized above, or (2) it is an array_ref 	 with constant index in an array in a register, which is 	 safe to reevaluate.  */
name|tree
name|newexp
init|=
name|build
argument_list|(
operator|(
name|this_optab
operator|==
name|add_optab
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|incremented
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|incremented
argument_list|,
name|newexp
argument_list|,
operator|!
name|post
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|post
condition|?
name|op0
else|:
name|temp
return|;
block|}
comment|/* Convert decrement by a constant into a negative increment.  */
if|if
condition|(
name|this_optab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|add_optab
expr_stmt|;
block|}
if|if
condition|(
name|post
condition|)
block|{
comment|/* We have a true reference to the value in OP0. 	 If there is an insn to add or subtract in this mode, queue it.  */
comment|/* I'm not sure this is still necessary.  */
name|op0
operator|=
name|stabilize
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|enqueue_insn
argument_list|(
name|op0
argument_list|,
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Preincrement, or we can't increment with one simple insn.  */
if|if
condition|(
name|post
condition|)
comment|/* Save a copy of the value before inc or dec, to return it later.  */
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
comment|/* Arrange to return the incremented value.  */
comment|/* Copy the rtx because expand_binop will protect from the queue,        and the results of that would be invalid for us to return        if our caller does emit_queue before using our result.  */
name|temp
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Increment however we can.  */
name|op1
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Make sure the value is stored into OP0.  */
if|if
condition|(
name|op1
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand all function calls contained within EXP, innermost ones first.    But don't look within expressions that have sequence points.    For each CALL_EXPR, record the rtx for its value    in the CALL_EXPR_RTL field.     Calls that return large structures for which a structure return    stack slot is needed are not preexpanded.  Preexpanding them loses    because if more than one were preexpanded they would try to use the    same stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|preexpand_calls
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|nops
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_preexpand_calls
condition|)
return|return;
comment|/* Only expressions and references can contain calls.  */
if|if
condition|(
name|tree_code_type
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
index|[
literal|0
index|]
operator|!=
literal|'e'
operator|&&
name|tree_code_type
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
index|[
literal|0
index|]
operator|!=
literal|'r'
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
comment|/* Do nothing to built-in functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOT_BUILT_IN
operator|)
condition|)
return|return;
comment|/* Precompute calls that don't return values in memory.  */
if|if
condition|(
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* If we find one of these, then we can be sure 	 the adjust will be done for it (since it makes jumps). 	 Do it now, so that if this is inside an argument 	 of a function, we don't get the stack adjustment 	 after some other args have already been pushed.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
return|return;
case|case
name|RTL_EXPR
case|:
return|return;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
name|nops
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|type
init|=
operator|*
name|tree_code_type
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|'e'
operator|||
name|type
operator|==
literal|'r'
condition|)
name|preexpand_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Force FUNEXP into a form suitable for the address of a CALL,    and return that as an rtx.  Also load the static chain register    from either FUNEXP or CONTEXT.  */
end_comment

begin_function
specifier|static
name|rtx
name|prepare_call_address
parameter_list|(
name|funexp
parameter_list|,
name|context
parameter_list|)
name|rtx
name|funexp
decl_stmt|;
name|rtx
name|context
decl_stmt|;
block|{
name|funexp
operator|=
name|protect_from_queue
argument_list|(
name|funexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
name|context
operator|=
name|protect_from_queue
argument_list|(
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Function variable in language with nested functions.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|funexp
argument_list|)
operator|==
name|EPmode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|static_chain_rtx
argument_list|,
name|gen_highpart
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
argument_list|)
expr_stmt|;
name|funexp
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_lowpart
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
comment|/* Unless function variable in C, or top level function constant */
name|emit_move_insn
argument_list|(
name|static_chain_rtx
argument_list|,
name|lookup_static_chain
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a valid memory address and copy constants thru pseudo-regs, 	 but not for a constant address if -fno-function-cse.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|funexp
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
condition|)
name|funexp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Generate instructions to call function FUNEXP,    and optionally pop the results.    The CALL_INSN is the first insn generated.     FUNTYPE is the data type of the function, or, for a library call,    the identifier for the name of the call.  This is given to the    macro RETURN_POPS_ARGS to determine whether this function pops its own args.     STACK_SIZE is the number of bytes of arguments on the stack,    rounded up to STACK_BOUNDARY; zero if the size is variable.    This is both to put into the call insn and    to generate explicit popping code if necessary.     NEXT_ARG_REG is the rtx that results from executing      FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1)    just after all the args have had their registers assigned.    This could be whatever you like, but normally it is the first    arg-register beyond those used for args in this call,    or 0 if all the arg-registers are used in this call.    It is passed on to `gen_call' so you can put this info in the call insn.     VALREG is a hard register in which a value is returned,    or 0 if the call does not return a value.     OLD_INHIBIT_DEFER_POP is the value that `inhibit_defer_pop' had before    the args to this call were processed.    We restore `inhibit_defer_pop' to that value.     USE_INSNS is a SEQUENCE of USE insns to be emitted immediately before    the actual CALL insn.  */
end_comment

begin_function
specifier|static
name|void
name|emit_call_1
parameter_list|(
name|funexp
parameter_list|,
name|funtype
parameter_list|,
name|stack_size
parameter_list|,
name|next_arg_reg
parameter_list|,
name|valreg
parameter_list|,
name|old_inhibit_defer_pop
parameter_list|,
name|use_insns
parameter_list|)
name|rtx
name|funexp
decl_stmt|;
name|tree
name|funtype
decl_stmt|;
name|int
name|stack_size
decl_stmt|;
name|rtx
name|next_arg_reg
decl_stmt|;
name|rtx
name|valreg
decl_stmt|;
name|int
name|old_inhibit_defer_pop
decl_stmt|;
name|rtx
name|use_insns
decl_stmt|;
block|{
name|rtx
name|stack_size_rtx
init|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|stack_size
argument_list|)
decl_stmt|;
name|rtx
name|call_insn
decl_stmt|;
if|if
condition|(
name|valreg
condition|)
name|emit_call_insn
argument_list|(
name|gen_call_value
argument_list|(
name|valreg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_call_insn
argument_list|(
name|gen_call
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the CALL insn we just emitted and write the USE insns before it.  */
for|for
control|(
name|call_insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|call_insn
operator|&&
name|GET_CODE
argument_list|(
name|call_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|;
name|call_insn
operator|=
name|PREV_INSN
argument_list|(
name|call_insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|call_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Put the USE insns before the CALL.  */
name|emit_insn_before
argument_list|(
name|use_insns
argument_list|,
name|call_insn
argument_list|)
expr_stmt|;
name|inhibit_defer_pop
operator|=
name|old_inhibit_defer_pop
expr_stmt|;
comment|/* If returning from the subroutine does not automatically pop the args,      we need an instruction to pop them sooner or later.      Perhaps do it now; perhaps just record how much space to pop later.  */
if|if
condition|(
operator|!
name|RETURN_POPS_ARGS
argument_list|(
name|funtype
argument_list|)
operator|&&
name|stack_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|flag_defer_pop
operator|&&
name|inhibit_defer_pop
operator|==
literal|0
condition|)
name|pending_stack_adjust
operator|+=
name|stack_size
expr_stmt|;
else|else
name|adjust_stack
argument_list|(
name|stack_size_rtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* At the start of a function, record that we have no previously-pushed    arguments waiting to be popped.  */
end_comment

begin_function
name|void
name|init_pending_stack_adjust
parameter_list|()
block|{
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting from function, if safe, clear out any pending stack adjust    so the adjustment won't get done.  */
end_comment

begin_function
name|void
name|clear_pending_stack_adjust
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|flag_omit_frame_pointer
operator|&&
name|EXIT_IGNORE_STACK
operator|&&
operator|!
name|TREE_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|flag_inline_functions
condition|)
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Pop any previously-pushed arguments that have not been popped yet.  */
end_comment

begin_function
name|void
name|do_pending_stack_adjust
parameter_list|()
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_stack_adjust
operator|!=
literal|0
condition|)
name|adjust_stack
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|pending_stack_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Data structure and subroutines used within expand_call.  */
end_comment

begin_struct
struct|struct
name|arg_data
block|{
comment|/* Tree node for this argument.  */
name|tree
name|tree_value
decl_stmt|;
comment|/* Precomputed RTL value, or 0 if it isn't precomputed.  */
name|rtx
name|value
decl_stmt|;
comment|/* Register to pass this argument in, or 0 if passed on stack.  */
name|rtx
name|reg
decl_stmt|;
comment|/* Number of registers to use.  0 means put the whole arg in registers.      Also 0 if not passed in registers.  */
name|int
name|partial
decl_stmt|;
comment|/* Offset of this argument from beginning of stack-args.  */
name|struct
name|args_size
name|offset
decl_stmt|;
comment|/* Size of this argument on the stack, rounded up for any padding it gets,      parts of the argument passed in registers do not count.      If the FIRST_PARM_CALLER_OFFSET is negative, then register parms      are counted here as well.  */
name|struct
name|args_size
name|size
decl_stmt|;
comment|/* Nonzero if this arg has already been stored.  */
name|int
name|stored
decl_stmt|;
comment|/* const0_rtx means should preallocate stack space for this arg.      Other non0 value is the stack slot, preallocated.      Used only for BLKmode.  */
name|rtx
name|stack
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|store_one_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|target_for_arg
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Generate all the code for a function call    and return an rtx for its value.    Store the value in TARGET (specified as an rtx) if convenient.    If the value is stored in TARGET then TARGET is returned.    If IGNORE is nonzero, then we ignore the value of the function call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_call
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
comment|/* List of actual parameters.  */
name|tree
name|actparms
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* RTX for the function to be called.  */
name|rtx
name|funexp
decl_stmt|;
comment|/* Data type of the function.  */
name|tree
name|funtype
decl_stmt|;
comment|/* Declaration of the function being called,      or 0 if the function is computed (not known by name).  */
name|tree
name|fndecl
init|=
literal|0
decl_stmt|;
comment|/* Register in which non-BLKmode value will be returned,      or 0 if no value or if value is BLKmode.  */
name|rtx
name|valreg
decl_stmt|;
comment|/* Address where we should return a BLKmode value;      0 if value not BLKmode.  */
name|rtx
name|structure_value_addr
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if that address is being passed by treating it as      an extra, implicit first parameter.  Otherwise,      it is passed by being copied directly into struct_value_rtx.  */
name|int
name|structure_value_addr_parm
init|=
literal|0
decl_stmt|;
comment|/* Save get_structure_value_addr data to prevent multiple use.  */
name|rtx
name|saved_structure_value_addr
decl_stmt|;
name|int
name|saved_structure_value_size
decl_stmt|;
comment|/* Nonzero if called function returns an aggregate in memory PCC style,      by returning the address of where to find it.  */
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
comment|/* Insn that was used to copy the result to the specified target,      or 0 if no such insn.  */
name|rtx
name|result_copy_insn
init|=
literal|0
decl_stmt|;
comment|/* Number of actual parameters in this call, including struct value addr.  */
name|int
name|num_actuals
decl_stmt|;
comment|/* Number of named args.  Args after this are anonymous ones      and they must all go on the stack.  */
name|int
name|n_named_args
decl_stmt|;
comment|/* Count arg position in order args appear.  */
name|int
name|argpos
decl_stmt|;
comment|/* Vector of information about each argument.      Arguments are numbered in the order they will be pushed,      not the order they are written.  */
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
comment|/* Remember initial value of args_size.constant.  */
name|int
name|starting_args_size
decl_stmt|;
comment|/* Nonzero means count reg-parms' size in ARGS_SIZE.  */
name|int
name|stack_count_regparms
init|=
literal|0
decl_stmt|;
comment|/* Data on reg parms scanned so far.  */
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
comment|/* Nonzero if a reg parm has been scanned.  */
name|int
name|reg_parm_seen
decl_stmt|;
comment|/* Nonzero if we must avoid push-insns in the args for this call.  */
name|int
name|must_preallocate
decl_stmt|;
comment|/* 1 if scanning parms front to back, -1 if scanning back to front.  */
name|int
name|inc
decl_stmt|;
comment|/* Address of space preallocated for stack parms      (on machines that lack push insns), or 0 if space not preallocated.  */
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
comment|/* Amount to align the stack by before or after we push any args.  */
name|int
name|stack_align
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if it is plausible that this is a call to alloca.  */
name|int
name|may_be_alloca
decl_stmt|;
comment|/* Nonzero if this is a call to setjmp or a related function.  */
name|int
name|is_setjmp
decl_stmt|;
comment|/* Nonzero if this is a call to an inline function.  */
name|int
name|is_integrable
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a call to __builtin_new.  */
name|int
name|is_builtin_new
decl_stmt|;
comment|/* Nonzero if this is a call to a `const' function.  */
name|int
name|is_const
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if there are BLKmode args whose data types require them      to be passed in memory, not (even partially) in registers.  */
name|int
name|BLKmode_parms_forced
init|=
literal|0
decl_stmt|;
comment|/* The offset of the first BLKmode parameter which       *must* be passed in memory.  */
name|int
name|BLKmode_parms_first_offset
init|=
literal|0
decl_stmt|;
comment|/* Total size of BLKmode parms which could usefully be preallocated.  */
name|int
name|BLKmode_parms_sizes
init|=
literal|0
decl_stmt|;
comment|/* Amount stack was adjusted to protect BLKmode parameters      which are below the nominal "stack address" value.  */
name|rtx
name|protected_stack
init|=
literal|0
decl_stmt|;
comment|/* The last insn before the things that are intrinsically part of the call.      The beginning reg-note goes on the insn after this one.  */
name|rtx
name|insn_before
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|int
name|old_pending_adj
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|tree
name|old_cleanups
init|=
name|cleanups_of_this_call
decl_stmt|;
name|rtx
name|use_insns
decl_stmt|;
specifier|register
name|tree
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* See if we can find a DECL-node for the actual function.      As a result, decide whether this is a call to an integrable function.  */
name|p
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|fndecl
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|fndecl
operator|!=
name|current_function_decl
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
condition|)
name|is_integrable
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* In case this function later becomes inlineable, 		 record that there was already a non-inline call to it.  */
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|is_const
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* When calling a const function, we must pop the stack args right away,      so that the pop is deleted or moved with the call.  */
if|if
condition|(
name|is_const
condition|)
name|NO_DEFER_POP
expr_stmt|;
comment|/* Set up a place to return a structure.  */
comment|/* Cater to broken compilers.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* This call returns a big structure.  */
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|flag_pcc_struct_return
condition|)
block|{
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
name|is_integrable
operator|=
literal|0
expr_stmt|;
comment|/* Easier than making that case work right.  */
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|structure_value_addr
argument_list|)
condition|)
name|structure_value_addr
operator|=
name|copy_to_reg
argument_list|(
name|structure_value_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|push_structure_value
argument_list|(
operator|&
name|saved_structure_value_addr
argument_list|,
operator|&
name|saved_structure_value_size
argument_list|)
expr_stmt|;
comment|/* Make room on the stack to hold the value.  */
name|structure_value_addr
operator|=
name|get_structure_value_addr
argument_list|(
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* If called function is inline, try to integrate it.  */
if|if
condition|(
name|is_integrable
condition|)
block|{
specifier|extern
name|rtx
name|expand_inline_function
parameter_list|()
function_decl|;
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|expand_inline_function
argument_list|(
name|fndecl
argument_list|,
name|actparms
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
comment|/* If inlining succeeded, return.  */
if|if
condition|(
operator|(
name|int
operator|)
name|temp
operator|!=
operator|-
literal|1
condition|)
return|return
name|temp
return|;
comment|/* If inlining failed, mark FNDECL as needing to be compiled 	 separately after all.  */
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Unless it's a call to a specific function that isn't alloca,      if it has one argument, we must assume it might be alloca.  */
block|may_be_alloca =     (!(fndecl != 0&& strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), 		  "alloca"))&& actparms != 0&& TREE_CHAIN (actparms) == 0);
else|#
directive|else
comment|/* We assume that alloca will always be called by name.  It      makes no sense to pass it as a pointer-to-function to      anything that does not understand its behavior.  */
name|may_be_alloca
operator|=
operator|(
name|fndecl
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"alloca"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_alloca"
argument_list|)
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if this is a call to a function that can return more than once.  */
name|is_setjmp
operator|=
operator|(
name|fndecl
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"setjmp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"_setjmp"
argument_list|)
operator|)
operator|)
expr_stmt|;
name|is_builtin_new
operator|=
operator|(
name|fndecl
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_new"
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|may_be_alloca
condition|)
block|{
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
name|may_call_alloca
operator|=
literal|1
expr_stmt|;
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Don't let pending stack adjusts add up to too much.      Also, do all pending adjustments now      if there is any chance this might be a call to alloca      or if it is const.  */
if|if
condition|(
name|pending_stack_adjust
operator|>=
literal|32
operator|||
name|is_const
operator|||
operator|(
name|pending_stack_adjust
operator|>
literal|0
operator|&&
name|may_be_alloca
operator|)
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Operand 0 is a pointer-to-function; get the type of the function.  */
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|funtype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
expr_stmt|;
comment|/* If structure_value_addr is set, it means pass the address      as if it were an extra parameter.  We typically avoid doing      so here, which would imply that the caller has to pop it off      the stack; but some compilers do expect caller pop. */
if|if
condition|(
name|structure_value_addr
ifdef|#
directive|ifdef
name|STRUCT_RETURN_CALLER_POP
operator|&&
name|flag_pcc_struct_return
else|#
directive|else
operator|&&
name|struct_value_rtx
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|funtype
argument_list|)
expr_stmt|;
name|tem
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
block|{
name|actparms
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|type_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
argument_list|,
name|actparms
argument_list|)
expr_stmt|;
name|structure_value_addr_parm
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STRUCT_RETURN_CALLER_POP
comment|/* Moved in 1.39 from before the preceding open-brace. 	 Should be safe without the conditional because, 	 if STRUCT_RETURN_CALLER_POP is not defined, 	 this can still happen only if struct_value_rtx is 0, 	 and in that case, we would crash anyway if this weren't done.  */
name|structure_value_addr_parm
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Count the arguments and set NUM_ACTUALS.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|i
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
name|num_actuals
operator|=
name|i
expr_stmt|;
comment|/* Compute number of named args.      Don't include the last named arg if anonymous args follow.      (If no anonymous args follow, the result of list_length      is actually one too large.)  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|!=
literal|0
condition|)
name|n_named_args
operator|=
name|list_length
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
comment|/* If we know nothing, treat all args as named.  */
name|n_named_args
operator|=
name|num_actuals
expr_stmt|;
comment|/* Make a vector to hold all the information about each arg.  */
name|args
operator|=
operator|(
expr|struct
name|arg_data
operator|*
operator|)
name|alloca
argument_list|(
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FIRST_PARM_CALLER_OFFSET
name|args_size
operator|.
name|constant
operator|=
name|FIRST_PARM_CALLER_OFFSET
argument_list|(
name|funtype
argument_list|)
expr_stmt|;
name|stack_count_regparms
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|starting_args_size
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
comment|/* In this loop, we consider args in the order they are written.      We fill up ARGS from the front of from the back if necessary      so that in any case the first arg to be pushed ends up at the front.  */
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|i
operator|=
name|num_actuals
operator|-
literal|1
operator|,
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In this case, must reverse order of args      so that we compute and push the last arg first.  */
else|#
directive|else
name|i
operator|=
literal|0
operator|,
name|inc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|funtype
argument_list|)
expr_stmt|;
comment|/* I counts args in order (to be) pushed; ARGPOS counts in order written.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|argpos
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|,
name|i
operator|+=
name|inc
operator|,
name|argpos
operator|++
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|args_size
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Decide where to pass this arg.  */
comment|/* args[i].reg is nonzero if all or part is passed in registers. 	 args[i].partial is nonzero if part but not all is passed in registers, 	  and the exact value says how many words are passed in registers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|args_size
operator|.
name|var
operator|==
literal|0
comment|/* error_mark_node here is a flag for the fake argument 	     for a structure value address.  */
operator|&&
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
comment|/* If this argument needs more than the usual parm alignment, do 	     extrinsic padding to reach that alignment.  */
ifdef|#
directive|ifdef
name|MAX_PARM_BOUNDARY
comment|/* If MAX_PARM_BOUNDARY is not defined, it means that the usual 	     alignment requirements are relaxed for parms, and that no parm 	     needs more than PARM_BOUNDARY, regardless of data type.  */
if|if
condition|(
name|PARM_BOUNDARY
operator|<
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|boundary
init|=
name|PARM_BOUNDARY
decl_stmt|;
comment|/* Determine the boundary to pad up to.  */
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|boundary
condition|)
name|boundary
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|MAX_PARM_BOUNDARY
condition|)
name|boundary
operator|=
name|MAX_PARM_BOUNDARY
expr_stmt|;
comment|/* If the previous args don't reach such a boundary, 		 advance to the next one.  */
name|boundary
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|.
name|constant
operator|+=
name|boundary
operator|-
literal|1
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|.
name|constant
operator|&=
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
expr_stmt|;
name|args_size
operator|.
name|constant
operator|+=
name|boundary
operator|-
literal|1
expr_stmt|;
name|args_size
operator|.
name|constant
operator|&=
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|args_size
operator|.
name|var
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This case not implemented yet */
block|}
endif|#
directive|endif
comment|/* MAX_PARM_BOUNDARY */
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|i
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Compute the stack-size of this argument.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|==
literal|0
operator|&&
operator|!
name|stack_count_regparms
condition|)
comment|/* On most machines, don't count stack space for a register arg.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|size
decl_stmt|;
comment|/* If we are counting "up to zero" and find a stack parm 	     before we reach zero, skip up to zero. 	     Negative offsets correspond to registers.  */
if|if
condition|(
name|stack_count_regparms
operator|&&
name|args_size
operator|.
name|constant
operator|<
literal|0
comment|/* This used to check args[i].partial != 0, 		 but on the Sparc now that seems to be 0.  */
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
condition|)
block|{
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
block|}
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute how much space the push instruction will push. 	     On many machines, pushing a byte will advance the stack 	     pointer by a halfword.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute how much space the argument should get: 	     maybe pad to a multiple of the alignment for arguments.  */
if|if
condition|(
name|none
operator|==
name|FUNCTION_ARG_PADDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
operator|=
name|size
expr_stmt|;
else|else
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|tree
name|size
init|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If we are counting "up to zero" and find a stack parm 	     before we reach zero, skip up to zero. 	     Negative offsets correspond to registers.  */
if|if
condition|(
name|stack_count_regparms
operator|&&
name|args_size
operator|.
name|constant
operator|<
literal|0
comment|/* This used to check args[i].partial != 0, 		 but on the Sparc now that seems to be 0.  */
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
condition|)
block|{
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
block|}
comment|/* A nonscalar.  Round its size up to a multiple 	     of PARM_BOUNDARY bits, unless it is not supposed to be padded.  */
if|if
condition|(
name|none
operator|!=
name|FUNCTION_ARG_PADDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|convert_units
argument_list|(
name|convert_units
argument_list|(
name|size
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|PARM_BOUNDARY
argument_list|)
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ADD_PARM_SIZE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Certain data types may not be passed in registers 	     (eg C++ classes with constructors). 	     Also, BLKmode parameters initialized from CALL_EXPRs 	     are treated specially, if it is a win to do so.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|BLKmode_parms_forced
operator|=
literal|1
expr_stmt|;
comment|/* This is a marker for such a parameter.  */
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
name|const0_rtx
expr_stmt|;
name|BLKmode_parms_sizes
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* If this parm's location is "below" the nominal stack pointer, 		 note to decrement the stack pointer while it is computed.  */
ifdef|#
directive|ifdef
name|FIRST_PARM_CALLER_OFFSET
if|if
condition|(
name|BLKmode_parms_first_offset
operator|==
literal|0
condition|)
name|BLKmode_parms_first_offset
comment|/* If parameter's offset is variable, assume the worst.  */
operator|=
operator|(
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|.
name|var
condition|?
name|FIRST_PARM_CALLER_OFFSET
argument_list|(
name|funtype
argument_list|)
else|:
name|args
index|[
name|i
index|]
operator|.
name|offset
operator|.
name|constant
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If a part of the arg was put into registers, 	 don't include that part in the amount pushed.  */
if|if
condition|(
operator|!
name|stack_count_regparms
condition|)
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
operator|-=
operator|(
operator|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Update ARGS_SIZE, the total stack space for args so far.  */
name|args_size
operator|.
name|constant
operator|+=
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|var
condition|)
block|{
name|ADD_PARM_SIZE
argument_list|(
name|args_size
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Increment ARGS_SO_FAR, which has info about which arg-registers 	 have been used, etc.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|i
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
block|}
comment|/* If we would have to push a partially-in-regs parm      before other stack parms, preallocate stack space instead.  */
name|must_preallocate
operator|=
literal|0
expr_stmt|;
block|{
name|int
name|partial_seen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|>
literal|0
condition|)
name|partial_seen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|partial_seen
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Precompute all register parameters.  It isn't safe to compute anything      once we have started filling any specific hard regs.      If this function call is cse'able, precompute all the parameters.  */
name|reg_parm_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|||
name|is_const
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|struct_value_lossage
init|=
literal|0
decl_stmt|;
comment|/* First, see if this is a precomputed struct-returning function call 	   and other subsequent parms are also such.  */
if|if
condition|(
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|||
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|CALL_EXPR
condition|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|num_actuals
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|j
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|||
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|j
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|args
index|[
name|j
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|args
index|[
name|j
index|]
operator|.
name|reg
operator|!=
literal|0
operator|||
name|is_const
condition|)
block|{
comment|/* We have two precomputed structure-values call expressions 		   in our parm list.  Both of them would normally use 		   the structure-value block.  To avoid the conflict, 		   compute this parm with a different temporary block.  */
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|structval
init|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|structval
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|struct_value_lossage
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|struct_value_lossage
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
condition|)
name|reg_parm_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here, 	   but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Get the function to call, in the form of RTL, if it is a constant.  */
if|if
condition|(
name|fndecl
operator|&&
name|is_const
condition|)
block|{
comment|/* Get a SYMBOL_REF rtx for the function address.  */
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
comment|/* Pass the address through a pseudoreg, if desired, 	 before the "beginning" of the library call. 	 So this insn isn't "part of" the library call, in case that 	 is deleted, or cse'd.  */
if|if
condition|(
operator|!
name|flag_no_function_cse
condition|)
name|funexp
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now we are about to start emitting insns that can be deleted      if the libcall is deleted.  */
name|insn_before
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Maybe do additional rounding on the size of the arguments.  */
ifdef|#
directive|ifdef
name|STACK_ARGS_ADJUST
name|STACK_ARGS_ADJUST
argument_list|(
name|args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we have no actual push instructions, or shouldn't use them,      or we need a variable amount of space, make space for all args right now.      Round the needed size up to multiple of STACK_BOUNDARY.  */
if|if
condition|(
name|args_size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
name|old_stack_level
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|argblock
operator|=
name|push_block
argument_list|(
name|round_push
argument_list|(
name|ARGS_SIZE_RTX
argument_list|(
name|args_size
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args_size
operator|.
name|constant
operator|>
literal|0
condition|)
block|{
name|int
name|needed
init|=
name|args_size
operator|.
name|constant
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|needed
operator|=
operator|(
name|needed
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
expr_stmt|;
name|stack_align
operator|=
name|needed
operator|-
name|args_size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|.
name|constant
operator|=
name|needed
expr_stmt|;
if|if
condition|(
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
literal|1
comment|/* Always preallocate if no push insns.  */
else|#
directive|else
name|must_preallocate
operator|||
name|BLKmode_parms_forced
operator|||
name|BLKmode_parms_sizes
operator|>
operator|(
name|args_size
operator|.
name|constant
operator|>>
literal|1
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
comment|/* Try to reuse some or all of the pending_stack_adjust 		 to get this space.  Maybe we can avoid any pushing.  */
if|if
condition|(
name|needed
operator|>
name|pending_stack_adjust
condition|)
block|{
name|needed
operator|-=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pending_stack_adjust
operator|-=
name|needed
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|argblock
operator|=
name|push_block
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|needed
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
elseif|else
if|if
condition|(
name|BLKmode_parms_forced
condition|)
block|{
comment|/* If we have reg-parms that need to be temporarily on the stack, 	 set up an arg block address even though there is no space 	 to be allocated for it.  */
name|argblock
operator|=
name|push_block
argument_list|(
name|const0_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* If stack needs padding below the args, increase all arg offsets      so the args are stored above the padding.  */
block|if (stack_padding)     for (i = 0; i< num_actuals; i++)       args[i].offset.constant += stack_padding;
endif|#
directive|endif
comment|/* Don't try to defer pops if preallocating, not even from the first arg,      since ARGBLOCK probably refers to the SP.  */
if|if
condition|(
name|argblock
condition|)
name|NO_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
comment|/* If any BLKmode parms need to be preallocated in space      below the nominal stack-pointer address, we need to adjust the      stack pointer so that this location is temporarily above it.      This ensures that computation won't clobber that space.  */
if|if
condition|(
name|BLKmode_parms_first_offset
operator|<
literal|0
operator|&&
name|argblock
operator|!=
literal|0
condition|)
block|{
name|int
name|needed
init|=
operator|-
name|BLKmode_parms_first_offset
decl_stmt|;
name|argblock
operator|=
name|copy_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|needed
operator|=
operator|(
name|needed
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
expr_stmt|;
endif|#
directive|endif
name|protected_stack
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|needed
argument_list|)
expr_stmt|;
name|anti_adjust_stack
argument_list|(
name|protected_stack
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STACK_GROWS_DOWNWARD */
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
comment|/* If we push args individually in reverse order, perform stack alignment      before the first push (the last arg).  */
if|if
condition|(
name|argblock
operator|==
literal|0
operator|&&
name|stack_align
operator|>
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|stack_align
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Get the function to call, in the form of RTL.  */
if|if
condition|(
name|fndecl
condition|)
comment|/* Get a SYMBOL_REF rtx for the function address.  */
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Generate an rtx (probably a pseudo-register) for the address.  */
block|{
name|funexp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Now compute and store all non-register parms.      These come before register parms, since they can require block-moves,      which could clobber the registers used for register parms.      Parms which have partial registers are not stored here,      but we do preallocate space here if they want that.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
comment|/* Preallocate the stack space for a parm if appropriate 	 so it can be computed directly in the stack space.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|!=
literal|0
operator|&&
name|argblock
operator|!=
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
name|target_for_arg
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|size
argument_list|)
argument_list|,
name|argblock
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
else|else
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|may_be_alloca
argument_list|)
expr_stmt|;
block|}
comment|/* Now store any partially-in-registers parm.      This is the last place a block-move can happen.  */
if|if
condition|(
name|reg_parm_seen
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
condition|)
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|may_be_alloca
argument_list|)
expr_stmt|;
if|if
condition|(
name|protected_stack
operator|!=
literal|0
condition|)
name|adjust_stack
argument_list|(
name|protected_stack
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
comment|/* If we pushed args in forward order, perform stack alignment      after pushing the last arg.  */
if|if
condition|(
name|argblock
operator|==
literal|0
operator|&&
name|stack_align
operator|>
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|stack_align
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* If the function will be returning a structure, and if the address in      which to return the value isn't being passed as a parameter, pass it      now.  This may result in a register move or in a push; if it's a push,      we count on the called routine to pop it.  */
if|if
condition|(
name|structure_value_addr
operator|&&
operator|!
name|structure_value_addr_parm
condition|)
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|structure_value_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now set up any wholly-register parms.  They were computed already.  */
if|if
condition|(
name|reg_parm_seen
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|==
literal|0
condition|)
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|may_be_alloca
argument_list|)
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* All arguments and registers used for the call must be set up by now!  */
comment|/* ??? Other languages need a nontrivial second argument (static chain).  */
name|funexp
operator|=
name|prepare_call_address
argument_list|(
name|funexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark all register-parms as living through the call.  */
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|>
literal|0
condition|)
name|use_regs
argument_list|(
name|REGNO
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|partial
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
name|use_regs
argument_list|(
name|REGNO
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
argument_list|,
operator|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|structure_value_addr
operator|&&
operator|!
name|structure_value_addr_parm
operator|&&
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|struct_value_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|use_insns
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Figure out the register where the value, if any, will come back.  */
name|valreg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|pcc_struct_value
condition|)
name|valreg
operator|=
name|hard_libcall_value
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the actual call instruction.  */
comment|/* This also has the effect of turning off any pop-inhibition      done in expand_call.  */
if|if
condition|(
name|args_size
operator|.
name|constant
operator|<
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|emit_call_1
argument_list|(
name|funexp
argument_list|,
name|funtype
argument_list|,
name|args_size
operator|.
name|constant
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|valreg
argument_list|,
name|old_inhibit_defer_pop
argument_list|,
name|use_insns
argument_list|)
expr_stmt|;
comment|/* ???  Nothing has been done here to record control flow    when contained functions can do nonlocal gotos.  */
comment|/* For calls to `setjmp', etc., inform flow.c it should complain      if nonvolatile values are live.  */
if|if
condition|(
name|is_setjmp
condition|)
block|{
name|emit_note
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|NOTE_INSN_SETJMP
argument_list|)
expr_stmt|;
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Notice functions that cannot return.      If optimizing, insns emitted below will be dead.      If not optimizing, they will exist, which is useful      if the user uses the `return' command in the debugger.  */
if|if
condition|(
name|fndecl
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* If this call is to be cse'd, then make sure it balances the stack.  */
if|if
condition|(
name|is_const
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* For calls to __builtin_new, note that it can never return 0.      This is because a new handler will be called, and 0 it not      among the numbers it is supposed to return.  */
if|#
directive|if
literal|0
block|if (is_builtin_new)     emit_note (IDENTIFIER_POINTER (DECL_NAME (fndecl)), NOTE_INSN_BUILTIN_NEW);
endif|#
directive|endif
comment|/* If value type not void, return an rtx for the value.  */
comment|/* If there are cleanups to be called, don't use a hard reg as target.  */
if|if
condition|(
name|cleanups_of_this_call
operator|!=
name|old_cleanups
operator|&&
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|result_copy_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|||
name|ignore
condition|)
block|{
name|target
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
condition|)
name|target
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcc_struct_value
condition|)
block|{
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
name|result_copy_insn
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
argument_list|)
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
condition|)
name|result_copy_insn
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
else|else
comment|/* This tells expand_inline_function to copy valreg to its target.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
expr_stmt|;
name|result_copy_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* Perform all cleanups needed for the arguments of this call      (i.e. destructors in C++).  */
while|while
condition|(
name|cleanups_of_this_call
operator|!=
name|old_cleanups
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|cleanups_of_this_call
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanups_of_this_call
operator|=
name|TREE_CHAIN
argument_list|(
name|cleanups_of_this_call
argument_list|)
expr_stmt|;
block|}
comment|/* If we pushed this, pop it.  */
if|if
condition|(
name|saved_structure_value_addr
operator|!=
literal|0
condition|)
name|pop_structure_value
argument_list|(
name|saved_structure_value_addr
argument_list|,
name|saved_structure_value_size
argument_list|)
expr_stmt|;
comment|/* If size of args is variable, restore saved stack-pointer value.  */
if|if
condition|(
name|old_stack_level
condition|)
block|{
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|old_stack_level
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
name|old_pending_adj
expr_stmt|;
block|}
comment|/* If call is cse'able, make appropriate pair of reg-notes around it.  */
if|if
condition|(
name|is_const
condition|)
block|{
name|rtx
name|insn_first
init|=
name|NEXT_INSN
argument_list|(
name|insn_before
argument_list|)
decl_stmt|;
name|rtx
name|insn_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|note
init|=
literal|0
decl_stmt|;
comment|/* Don't put the notes on if we don't have insns that can hold them.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn_first
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn_first
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn_first
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn_last
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn_last
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn_last
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
name|insn_last
operator|==
name|result_copy_insn
condition|)
block|{
comment|/* Construct an "equal form" for the value 	     which mentions all the arguments in order 	     as well as the function name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|||
name|is_const
condition|)
name|note
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn_last
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|note
argument_list|,
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_RETVAL
argument_list|,
name|insn_first
argument_list|,
name|REG_NOTES
argument_list|(
name|insn_last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn_first
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|REG_LIBCALL
argument_list|,
name|insn_last
argument_list|,
name|REG_NOTES
argument_list|(
name|insn_first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx which represents a suitable home on the stack    given TYPE, the type of the argument looking for a home.    This is called only for BLKmode arguments.     SIZE is the size needed for this target.    ARGS_ADDR is the address of the bottom of the argument block for this call.    OFFSET describes this parameter's offset into ARGS_ADDR.  It is meaningless    if this machine uses push insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|target_for_arg
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|,
name|args_addr
parameter_list|,
name|offset
parameter_list|)
name|tree
name|type
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|rtx
name|args_addr
decl_stmt|;
name|struct
name|args_size
name|offset
decl_stmt|;
block|{
name|rtx
name|target
decl_stmt|;
name|rtx
name|offset_rtx
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|offset
argument_list|)
decl_stmt|;
comment|/* We do not call memory_address if possible,      because we want to address as close to the stack      as possible.  For non-variable sized arguments,      this will be stack-pointer relative addressing.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|target
operator|=
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* I have no idea how to guarantee that this 	 will work in the presence of register parameters.  */
name|target
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|memory_address
argument_list|(
name|QImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store a single argument for a function call    into the register or memory area where it must be passed.    *ARG describes the argument value and where to pass it.    ARGBLOCK is the address of the stack-block for all the arguments,    or 0 on a machine where arguemnts are pushed individually.    MAY_BE_ALLOCA nonzero says this could be a call to `alloca'    so must be careful about how the stack is used.  */
end_comment

begin_function
specifier|static
name|void
name|store_one_arg
parameter_list|(
name|arg
parameter_list|,
name|argblock
parameter_list|,
name|may_be_alloca
parameter_list|)
name|struct
name|arg_data
modifier|*
name|arg
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|may_be_alloca
decl_stmt|;
block|{
specifier|register
name|tree
name|pval
init|=
name|arg
operator|->
name|tree_value
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|arg
operator|->
name|reg
operator|!=
literal|0
operator|&&
name|arg
operator|->
name|partial
operator|==
literal|0
condition|)
block|{
comment|/* Being passed entirely in a register.  */
if|if
condition|(
name|arg
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|arg
operator|->
name|value
argument_list|)
operator|==
name|BLKmode
condition|)
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|arg
operator|->
name|reg
argument_list|)
argument_list|,
name|arg
operator|->
name|value
argument_list|,
operator|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|arg
operator|->
name|reg
argument_list|,
name|arg
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|store_expr
argument_list|(
name|pval
argument_list|,
name|arg
operator|->
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't allow anything left on stack from computation 	 of argument to alloca.  */
if|if
condition|(
name|may_be_alloca
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|size
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Argument is a scalar, not entirely passed in registers. 	 (If part is passed in registers, arg->partial says how much 	 and emit_push_insn will take care of putting it there.) 	  	 Push it, and if its size is less than the 	 amount of space allocated to it, 	 also bump stack pointer by the additional space. 	 Note that in C the default argument promotions 	 will prevent such mismatches.  */
name|used
operator|=
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute how much space the push instruction will push. 	 On many machines, pushing a byte will advance the stack 	 pointer by a halfword.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute how much space the argument should get: 	 round up to a multiple of the alignment for arguments.  */
if|if
condition|(
name|none
operator|!=
name|FUNCTION_ARG_PADDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
condition|)
name|used
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|tem
operator|=
name|arg
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
block|{
name|tem
operator|=
name|expand_expr
argument_list|(
name|pval
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here, 	     but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Don't allow anything left on stack from computation 	 of argument to alloca.  */
if|if
condition|(
name|may_be_alloca
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_push_insn
argument_list|(
name|tem
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|arg
operator|->
name|partial
argument_list|,
name|arg
operator|->
name|reg
argument_list|,
name|used
operator|-
name|size
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|stack
operator|!=
literal|0
condition|)
block|{
comment|/* BLKmode parm, not entirely passed in registers, 	 and with space already allocated.  */
name|tree
name|sizetree
init|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s1
init|=
name|convert_units
argument_list|(
name|sizetree
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|PARM_BOUNDARY
argument_list|)
decl_stmt|;
name|tree
name|s2
init|=
name|convert_units
argument_list|(
name|s1
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Find out if the parm needs padding, and whether above or below.  */
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|sizetree
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If it is padded below, adjust the stack address 	 upward over the padding.  */
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|arg
operator|->
name|stack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|args_size
name|stack_offset
decl_stmt|;
name|stack_offset
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|stack_offset
operator|.
name|var
operator|=
literal|0
expr_stmt|;
comment|/* Compute amount of padding.  */
name|ADD_PARM_SIZE
argument_list|(
name|stack_offset
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
name|stack_offset
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
expr_stmt|;
comment|/* Adjust the address to store at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|address
operator|=
name|plus_constant
argument_list|(
name|address
argument_list|,
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|address
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|address
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
name|address
operator|=
name|memory_address
argument_list|(
name|QImode
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
name|arg
operator|->
name|stack
operator|=
name|change_address
argument_list|(
name|arg
operator|->
name|stack
argument_list|,
name|VOIDmode
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
comment|/* ARG->stack probably refers to the stack-pointer.  If so, 	 stabilize it, in case stack-pointer changes during evaluation.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|arg
operator|->
name|stack
argument_list|)
condition|)
name|arg
operator|->
name|stack
operator|=
name|change_address
argument_list|(
name|arg
operator|->
name|stack
argument_list|,
name|VOIDmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* BLKmode argument that should go in a prespecified stack location.  */
if|if
condition|(
name|arg
operator|->
name|value
operator|==
literal|0
condition|)
comment|/* Not yet computed => compute it there.  */
comment|/* ??? This should be changed to tell expand_expr 	   that it can store directly in the target.  */
name|arg
operator|->
name|value
operator|=
name|store_expr
argument_list|(
name|arg
operator|->
name|tree_value
argument_list|,
name|arg
operator|->
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|value
operator|!=
name|arg
operator|->
name|stack
condition|)
comment|/* It was computed somewhere, but not where we wanted. 	   For example, the value may have come from an official 	   local variable or parameter.  In that case, expand_expr 	   does not fill our suggested target.  */
name|emit_block_move
argument_list|(
name|arg
operator|->
name|stack
argument_list|,
name|arg
operator|->
name|value
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|size
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Now, if this value wanted to be partly in registers, 	 move the value from the stack to the registers 	 that are supposed to hold the values.  */
if|if
condition|(
name|arg
operator|->
name|partial
operator|>
literal|0
condition|)
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|arg
operator|->
name|reg
argument_list|)
argument_list|,
name|arg
operator|->
name|stack
argument_list|,
name|arg
operator|->
name|partial
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* BLKmode, at least partly to be pushed.  */
specifier|register
name|rtx
name|tem
init|=
name|arg
operator|->
name|value
condition|?
name|arg
operator|->
name|value
else|:
name|expand_expr
argument_list|(
name|pval
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|excess
decl_stmt|;
name|rtx
name|size_rtx
decl_stmt|;
comment|/* Pushing a nonscalar. 	 If part is passed in registers, arg->partial says how much 	 and emit_push_insn will take care of putting it there.  */
comment|/* Round its size up to a multiple 	 of the allocation unit for arguments.  */
if|if
condition|(
name|arg
operator|->
name|size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
name|excess
operator|=
literal|0
expr_stmt|;
name|size_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|tree
name|size
init|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
decl_stmt|;
comment|/* PUSH_ROUNDING has no effect on us, because 	     emit_push_insn for BLKmode is careful to avoid it.  */
name|excess
operator|=
operator|(
name|arg
operator|->
name|size
operator|.
name|constant
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|+
name|arg
operator|->
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|size_rtx
operator|=
name|expand_expr
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|stack
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_push_insn
argument_list|(
name|tem
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|size_rtx
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|arg
operator|->
name|partial
argument_list|,
name|arg
operator|->
name|reg
argument_list|,
name|excess
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Once we have pushed something, pops can't safely      be deferred during the rest of the arguments.  */
name|NO_DEFER_POP
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand conditional expressions.  */
end_comment

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is zero.    LABEL is an rtx of code CODE_LABEL, in this function and all the    functions here.  */
end_comment

begin_function
name|void
name|jumpifnot
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
end_comment

begin_function
name|void
name|jumpif
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if    the result is zero, or IF_TRUE_LABEL if the result is one.    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,    meaning fall through in that case.     This function is responsible for optimizing cases such as&&, || and comparison operators in EXP.  */
end_comment

begin_function
name|void
name|do_jump
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Some cases need to create a label to jump to      in order to properly fall through.      These cases set DROP_THROUGH_LABEL nonzero.  */
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|comparison
init|=
literal|0
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|integer_zerop
argument_list|(
name|exp
argument_list|)
condition|?
name|if_false_label
else|:
name|if_true_label
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|emit_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* The address of something can never be zero.  */
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
if|if
condition|(
name|if_false_label
operator|==
literal|0
condition|)
name|if_false_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
name|if_true_label
operator|==
literal|0
condition|)
name|if_true_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
block|{
specifier|register
name|rtx
name|label1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now the THEN-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
comment|/* Now the ELSE-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy to register to avoid generating bad insns by cse 	 from (set (mem ...) (arithop))  (set (cc0) (mem ...)).  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|{
name|rtx
name|zero
init|=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|comparison
operator|=
name|compare_constants
argument_list|(
name|NE
argument_list|,
literal|0
argument_list|,
name|INTVAL
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|comparison
operator|=
name|compare1
argument_list|(
name|temp
argument_list|,
name|zero
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* If COMPARISON is nonzero here, it is an rtx that can be substituted      straight into a conditional jump instruction as the jump condition.      Otherwise, all the work has been done already.  */
if|if
condition|(
name|comparison
operator|==
name|const1_rtx
condition|)
block|{
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comparison
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comparison
condition|)
block|{
if|if
condition|(
name|if_true_label
condition|)
block|{
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|if_true_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_false_label
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
comment|/* Now invert the sense of the jump by exchanging the two arms 	     of each IF_THEN_ELSE.  Note that inverting the condition 	     would be incorrect for IEEE floating point with nans!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We can invert a sequence if the only jump is at the end.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
name|invert_exp
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|invert_exp
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two integer constant rtx's, OP0 and OP1.    The comparison operation is OPERATION.    Return an rtx representing the value 1 or 0.    WIDTH is the width in bits that is significant.  */
end_comment

begin_function
specifier|static
name|rtx
name|compare_constants
parameter_list|(
name|operation
parameter_list|,
name|unsignedp
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|width
parameter_list|)
name|enum
name|rtx_code
name|operation
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|width
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
comment|/* Sign-extend or zero-extend the operands to a full word      from an initial width of WIDTH bits.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
block|{
name|op0
operator|&=
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|op1
operator|&=
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
if|if
condition|(
name|op0
operator|&
operator|(
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|op0
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|op1
operator|&
operator|(
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|op1
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|EQ
case|:
name|val
operator|=
name|op0
operator|==
name|op1
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|val
operator|=
name|op0
operator|!=
name|op1
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|val
operator|=
name|op0
operator|>
name|op1
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
name|val
operator|=
name|op0
operator|<
name|op1
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|val
operator|=
name|op0
operator|>=
name|op1
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|val
operator|=
name|op0
operator|<=
name|op1
expr_stmt|;
block|}
return|return
name|val
condition|?
name|const1_rtx
else|:
name|const0_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code for a comparison expression EXP    (including code to compute the values to be compared)    and set (CC0) according to the result.    SIGNED_FORWARD should be the rtx operation for this comparison for    signed data; UNSIGNED_FORWARD, likewise for use if data is unsigned.    SIGNED_REVERSE and UNSIGNED_REVERSE are used if it is desirable    to interchange the operands for the compare instruction.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.  */
end_comment

begin_function
specifier|static
name|rtx
name|compare
parameter_list|(
name|exp
parameter_list|,
name|signed_forward
parameter_list|,
name|unsigned_forward
parameter_list|,
name|signed_reverse
parameter_list|,
name|unsigned_reverse
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|enum
name|rtx_code
name|signed_forward
decl_stmt|,
name|unsigned_forward
decl_stmt|;
name|enum
name|rtx_code
name|signed_reverse
decl_stmt|,
name|unsigned_reverse
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
comment|/* If one operand is 0, make it the second one.  */
if|if
condition|(
name|op0
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|signed_forward
operator|=
name|signed_reverse
expr_stmt|;
name|unsigned_forward
operator|=
name|unsigned_reverse
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|unsignedp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|compare_constants
argument_list|(
name|signed_forward
argument_list|,
name|unsignedp
argument_list|,
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
name|emit_cmp_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|expr_size
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
operator|(
name|unsignedp
condition|?
name|unsigned_forward
else|:
name|signed_forward
operator|)
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like compare but expects the values to compare as two rtx's.    The decision as to signed or unsigned comparison must be made by the caller.    BLKmode is not allowed.  */
end_comment

begin_function
specifier|static
name|rtx
name|compare1
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|forward_op
parameter_list|,
name|reverse_op
parameter_list|,
name|unsignedp
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|forward_op
decl_stmt|,
name|reverse_op
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* If one operand is 0, make it the second one.  */
if|if
condition|(
name|op0
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|forward_op
operator|=
name|reverse_op
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|compare_constants
argument_list|(
name|forward_op
argument_list|,
name|unsignedp
argument_list|,
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
name|emit_cmp_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|forward_op
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to calculate EXP using a store-flag instruction    and return an rtx for the result.    If TARGET is nonzero, store the result there if convenient.     Return zero if there is no suitable set-flag instruction    available on this machine.  */
end_comment

begin_function
specifier|static
name|rtx
name|do_store_flag
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|comparison
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_seq
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|HAVE_seq
condition|)
block|{
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_seq
expr_stmt|;
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_seq
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_sne
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|HAVE_sne
condition|)
block|{
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_sne
expr_stmt|;
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_sne
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_slt
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sltu
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sgt
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sgtu
argument_list|)
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|HAVE_slt
operator|&&
name|HAVE_sltu
operator|&&
name|HAVE_sgt
operator|&&
name|HAVE_sgtu
condition|)
block|{
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_slt
expr_stmt|;
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|HAVE_slt
operator|&&
name|HAVE_sltu
operator|&&
name|HAVE_sgt
operator|&&
name|HAVE_sgtu
condition|)
block|{
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_slt
expr_stmt|;
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sle
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sleu
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sge
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sgeu
argument_list|)
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|HAVE_sle
operator|&&
name|HAVE_sleu
operator|&&
name|HAVE_sge
operator|&&
name|HAVE_sgeu
condition|)
block|{
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_sle
expr_stmt|;
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_sle
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|HAVE_sle
operator|&&
name|HAVE_sleu
operator|&&
name|HAVE_sge
operator|&&
name|HAVE_sgeu
condition|)
block|{
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_sle
expr_stmt|;
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_sle
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
comment|/* Don't use specified target unless the insn can handle it.  */
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
comment|/* When modes don't match, don't use specified target, 	 because it might be the same as an operand, 	 and then the CLOBBER output below would screw up.  */
operator|||
operator|(
name|mode
operator|!=
name|compare_mode
operator|&&
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Store the comparison in its proper mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|CONST_INT
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|comparison
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compare_mode
condition|)
block|{
comment|/* We want a different mode: store result in its natural mode. 	 Combine the mode conversion with the truncation we must do anyway.  */
comment|/* Put a CLOBBER before the compare, so we don't come between 	 the compare and the insn that uses the result.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|prev_insn
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|compare_mode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the desired mode is wider than what we got, 	 use an AND to convert it, but not if we will do one anyway.  */
if|#
directive|if
name|STORE_FLAG_VALUE
operator|==
literal|1
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|compare_mode
argument_list|)
condition|)
name|expand_bit_and
argument_list|(
name|mode
argument_list|,
name|target
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|emit_insn
argument_list|(
call|(
modifier|*
name|setcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|STORE_FLAG_VALUE
operator|!=
literal|1
if|#
directive|if
name|STORE_FLAG_VALUE
operator|&
literal|1
name|expand_bit_and
argument_list|(
name|mode
argument_list|,
name|target
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|#
directive|else
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a tablejump instruction (used for switch statements).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_tablejump
end_ifdef

begin_comment
comment|/* INDEX is the value being switched on, with the lowest value    in the table already subtracted.    RANGE is the length of the jump table.    TABLE_LABEL is a CODE_LABEL rtx for the table itself.     DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the    index value is out of range.  */
end_comment

begin_function
name|void
name|do_tablejump
parameter_list|(
name|index
parameter_list|,
name|range
parameter_list|,
name|table_label
parameter_list|,
name|default_label
parameter_list|)
name|rtx
name|index
decl_stmt|,
name|range
decl_stmt|,
name|table_label
decl_stmt|,
name|default_label
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|emit_cmp_insn
argument_list|(
name|range
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bltu
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If flag_force_addr were to affect this address      it could interfere with the tricky assumptions made      about addresses that contain label-refs,      which may be valid only very near the tablejump itself.  */
name|index
operator|=
name|memory_address_noforce
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|index
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|table_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_tablejump
argument_list|(
name|temp
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_tablejump */
end_comment

end_unit

