begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used by or related to instruction recognition.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_function_decl
specifier|static
name|int
name|inequality_comparisons_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|strict_memory_address_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|memory_address_p
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero means allow operands to be volatile.    This is 1 if you use recog_memoized, 0 if you don't.    init_recog and recog_memoized are responsible for setting it.    This way of handling it is not really clean and will be change later.  */
end_comment

begin_decl_stmt
name|int
name|volatile_ok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|recog_addr_dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from `constrain_operands', indicate which alternative    was satisfied.  */
end_comment

begin_decl_stmt
name|int
name|which_alternative
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after end of reload pass.    Set to 1 or 0 by toplev.c.    Controls the significance of (SUBREG (MEM)).  */
end_comment

begin_decl_stmt
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data used by the function `recog'.    This must be called once in the compilation of a function    before any insn recognition may be done in the function.  */
end_comment

begin_function
name|void
name|init_recog
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|0
expr_stmt|;
name|recog_addr_dummy
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try recognizing the instruction INSN,    and return the code number that results.    Remeber the code so that repeated calls do not    need to spend the time for actual rerecognition.     This function is the normal interface to instruction recognition.    The automatically-generated function `recog' is normally called    through this one.  (The only exception is in combine.c.)  */
end_comment

begin_function
name|int
name|recog_memoized
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|volatile_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the insn following INSN does not contain    any ordered tests applied to the condition codes.    EQ and NE tests do not count.  */
end_comment

begin_function
name|int
name|next_insn_tests_no_inequality
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
operator|!
name|inequality_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the CC value set up by INSN is not used.  */
end_comment

begin_function
name|int
name|next_insns_test_no_inequality
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|next
operator|!=
literal|0
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inequality_comparisons_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|cc0_rtx
operator|)
return|;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid general operand for machine mode MODE.    This is either a register reference, a memory reference,    or a constant.  In the case of a memory reference, the address    is checked for general validity for the target machine.     Register and memory references must have mode MODE in order to be valid,    but some constants have no machine mode and are valid for any mode.     If MODE is VOIDmode, OP is checked for validity for whatever mode    it has.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|general_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|mode_altering_drug
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
comment|/* Except for certain constants with VOIDmode, already checked for,      OP's mode must match MODE if MODE specifies a mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No longer needed, since (SUBREG (MEM...)) 	 will load the MEM into a reload reg in the MEM's own mode.  */
block|mode_altering_drug = 1;
endif|#
directive|endif
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|volatile_ok
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Use the mem's mode, since it will be reloaded thus.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|y
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|win
label|:
if|if
condition|(
name|mode_altering_drug
condition|)
return|return
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid memory address for a memory reference    of mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
operator|||
name|volatile_ok
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference of mode MODE.    If MODE is VOIDmode, accept a register in any mode.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid immediate operand for mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|)
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand that is not an immediate operand.  */
end_comment

begin_function
name|int
name|nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference or immediate value of mode MODE.  */
end_comment

begin_function
name|int
name|nonmemory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for pushing a    value of mode MODE onto the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|push_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PRE_DEC
condition|)
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PRE_INC
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE.  */
end_comment

begin_function
name|int
name|memory_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory reference with mode MODE,    including a valid address.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
decl_stmt|;
name|int
name|mode_altering_drug
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
comment|/* Note that no SUBREG is a memory operand before end of reload pass,        because (SUBREG (MEM...)) forces reloading into a register.  */
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|op
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid indirect memory reference with mode MODE;    that is, a memory reference whose address is a general_operand.  */
end_comment

begin_function
name|int
name|indirect_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If BODY is an insn body that uses ASM_OPERANDS,    return the number of operands (both input and output) in the insn.    Otherwise return -1.  */
end_comment

begin_function
name|int
name|asm_noperands
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* No output operands: return number of input operands.  */
return|return
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|3
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */
return|return
name|XVECLEN
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* Multiple output operands, or 1 output plus some clobbers: 	 body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
comment|/* Count backwards through CLOBBERs to determine number of SETs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* N_SETS is now number of output operands.  */
name|n_sets
operator|=
name|i
expr_stmt|;
comment|/* Verify that all the SETs we have 	 came from a single original asm_operands insn 	 (so that invalid combinations are blocked).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If these ASM_OPERANDS rtx's came from different original insns 	     then they aren't allowed together.  */
if|if
condition|(
name|XVEC
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|!=
name|XVEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|XVECLEN
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|+
name|n_sets
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* 0 outputs, but some clobbers: 	 body is [(asm_operands ...) (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
comment|/* Make sure all the other parallel things really are clobbers.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|XVECLEN
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|3
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assuming BODY is an insn body that uses ASM_OPERANDS,    copy its operands (both input and output) into the vector OPERANDS,    the locations of the operands within the insn into the vector OPERAND_LOCS,    and the constraints for the operands into CONSTRAINTS.    Write the modes of the operands into MODES.    Return the assembler-template.     If MODES, OPERAND_LOCS, CONSTRAINTS or OPERANDS is 0,    we don't store that info.  */
end_comment

begin_function
name|char
modifier|*
name|decode_asm_operands
parameter_list|(
name|body
parameter_list|,
name|operands
parameter_list|,
name|operand_locs
parameter_list|,
name|constraints
parameter_list|,
name|modes
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|operand_locs
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|modes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|char
modifier|*
name|template
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */
name|noperands
operator|=
name|XVECLEN
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The output is in the SET. 	 Its constraint is in the ASM_OPERANDS itself.  */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
literal|0
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
literal|0
index|]
operator|=
name|XSTR
argument_list|(
name|asmop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
literal|0
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|XSTR
argument_list|(
name|asmop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|body
decl_stmt|;
comment|/* No output operands: BODY is (asm_operands ....).  */
name|noperands
operator|=
name|XVECLEN
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|XSTR
argument_list|(
name|asmop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nparallel
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Includes CLOBBERs.  */
name|int
name|nin
init|=
name|XVECLEN
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|nout
init|=
literal|0
decl_stmt|;
comment|/* Does not include CLOBBERs.  */
comment|/* At least one output, plus some CLOBBERs.  */
comment|/* The outputs are in the SETs. 	 Their constraints are in the ASM_OPERANDS itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparallel
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
comment|/* Past last SET */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nout
operator|++
expr_stmt|;
block|}
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
operator|+
name|nout
index|]
operator|=
operator|&
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|XSTR
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|XSTR
argument_list|(
name|asmop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* No outputs, but some CLOBBERs.  */
name|rtx
name|asmop
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|nin
init|=
name|XVECLEN
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|asmop
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|XSTR
argument_list|(
name|asmop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|template
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|extern
name|rtx
name|plus_constant
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|copy_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Given an rtx *P, if it is a sum containing an integer constant term,    return the location (type rtx *) of the pointer to that constant term.    Otherwise, return a null pointer.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_constant_term_loc
parameter_list|(
name|p
parameter_list|)
name|rtx
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|tem
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
comment|/* If *P IS such a constant term, P is its location.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
operator|||
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
operator|||
name|code
operator|==
name|CONST
condition|)
return|return
name|p
return|;
comment|/* Otherwise, if not a sum, it has no constant term.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
comment|/* If one of the summands is constant, return its location.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|p
return|;
comment|/* Otherwise, check each summand for containing a constant term.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a memory reference    whose address contains no side effects    and remains valid after the addition    of a positive integer less than the    size of the object being referenced.     We assume that the original address is valid and do not check it.     This uses strict_memory_address_p as a subroutine, so    don't use it before reload.  */
end_comment

begin_function
name|int
name|offsettable_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if Y is a memory address which contains no side effects    and would remain valid for mode MODE    after the addition of a positive integer less than the    size of that mode.     We assume that the original address is valid and do not check it.     If STRICTP is nonzero, we require a strictly valid address,    for the sake of use in reload.c.  */
end_comment

begin_function
name|int
name|offsettable_address_p
parameter_list|(
name|strictp
parameter_list|,
name|mode
parameter_list|,
name|y
parameter_list|)
name|int
name|strictp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|y
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|ycode
init|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|z
decl_stmt|;
name|rtx
name|y1
init|=
name|y
decl_stmt|;
name|rtx
modifier|*
name|y2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|addressp
function_decl|)
parameter_list|()
init|=
operator|(
name|strictp
condition|?
name|strict_memory_address_p
operator|:
name|memory_address_p
init|)
function_decl|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|OFFSETTABLE_ADDRESS_P
return|return
name|OFFSETTABLE_ADDRESS_P
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
return|;
else|#
directive|else
comment|/* If the expression contains a constant term,      see if it remains valid when max possible offset is added.  */
if|if
condition|(
operator|(
name|ycode
operator|==
name|PLUS
operator|)
operator|&&
operator|(
name|y2
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|y1
argument_list|)
operator|)
condition|)
block|{
name|int
name|old
init|=
name|INTVAL
argument_list|(
name|y1
operator|=
operator|*
name|y2
argument_list|)
decl_stmt|;
name|int
name|good
decl_stmt|;
name|INTVAL
argument_list|(
name|y1
argument_list|)
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
expr_stmt|;
name|good
operator|=
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* In any case, restore old contents of memory.  */
name|INTVAL
argument_list|(
name|y1
argument_list|)
operator|=
name|old
expr_stmt|;
return|return
name|good
return|;
block|}
if|if
condition|(
name|ycode
operator|==
name|PRE_DEC
operator|||
name|ycode
operator|==
name|PRE_INC
operator|||
name|ycode
operator|==
name|POST_DEC
operator|||
name|ycode
operator|==
name|POST_INC
condition|)
return|return
literal|0
return|;
comment|/* The offset added here is chosen as the maximum offset that      any instruction could need to add when operating on something      of the specified mode.  We assume that if Y and Y+c are      valid addresses then so is Y+d for all 0<d<c.  */
name|z
operator|=
name|plus_constant
argument_list|(
name|y
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|mode
argument_list|,
name|z
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is an address-expression whose effect depends    on the mode of the memory reference it is used in.     Autoincrement addressing is a typical example of mode-dependence    because the amount of the increment depends on the mode.  */
end_comment

begin_function
name|int
name|mode_dependent_address_p
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand    other than a memory ref with a mode dependent address.  */
end_comment

begin_function
name|int
name|mode_independent_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|lose
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an operand OP that is a valid memory reference    which satisfies offsettable_memref_p,    return a new memory reference whose address has been adjusted by OFFSET.    OFFSET should be positive and less than the size of the object referenced. */
end_comment

begin_function
name|rtx
name|adj_offsettable_operand
parameter_list|(
name|op
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|y
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|z
init|=
name|y
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|const_loc
decl_stmt|;
name|op
operator|=
name|copy_rtx
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|z
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|const_loc
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_loc
condition|)
block|{
operator|*
name|const_loc
operator|=
name|plus_constant
argument_list|(
operator|*
name|const_loc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
block|}
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|y
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Check the operands of an insn (found in recog_operands)    against the insn's operand constraints (found via INSN_CODE_NUM)    and return 1 if they are valid.     WHICH_ALTERNATIVE is set to a number which indicates which    alternative of constraints was matched: 0 for the first alternative,    1 for the next, etc.     In addition, when two operands are match    and it happens that the output operand is (reg) while the    input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),    make the output operand look like the input.    This is because the output operand is the one the template will print.     This is used in final, just before printing the assembler code.  */
end_comment

begin_struct
struct|struct
name|funny_match
block|{
name|int
name|this
decl_stmt|,
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|constrain_operands
parameter_list|(
name|insn_code_num
parameter_list|)
name|int
name|insn_code_num
decl_stmt|;
block|{
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|noperands
init|=
name|insn_n_operands
index|[
name|insn_code_num
index|]
decl_stmt|;
name|struct
name|funny_match
name|funny_match
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|funny_match_index
decl_stmt|;
name|int
name|nalternatives
init|=
name|insn_n_alternatives
index|[
name|insn_code_num
index|]
decl_stmt|;
if|if
condition|(
name|noperands
operator|==
literal|0
operator|||
name|nalternatives
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|noperands
condition|;
name|c
operator|++
control|)
name|constraints
index|[
name|c
index|]
operator|=
name|insn_operand_constraint
index|[
name|insn_code_num
index|]
index|[
name|c
index|]
expr_stmt|;
name|which_alternative
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|which_alternative
operator|<
name|nalternatives
condition|)
block|{
specifier|register
name|int
name|opno
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|funny_match_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|noperands
condition|;
name|opno
operator|++
control|)
block|{
specifier|register
name|rtx
name|op
init|=
name|recog_operand
index|[
name|opno
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* `alter_subreg' should already have converted any SUBREG 	     that appears at the level of an operand.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
comment|/* This operand must be the same as a previous one.  */
comment|/* This kind of constraint is used for instructions such 		   as add when they take only two operands.  */
comment|/* Note that the lower-numbered operand is passed first.  */
name|val
operator|=
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|c
operator|-
literal|'0'
index|]
argument_list|,
name|recog_operand
index|[
name|opno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If output is *x and input is *--x, 		   arrange later to change the output to *--x as well, 		   since the output op is the one that will be printed.  */
if|if
condition|(
name|val
operator|==
literal|2
condition|)
block|{
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
operator|=
name|opno
expr_stmt|;
name|funny_match
index|[
name|funny_match_index
operator|++
index|]
operator|.
name|other
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* p is used for address_operands, and everything 		   that must be checked was checked already.  */
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* No need to check general_operand again; 		   it was done in insn-recog.c.  */
case|case
literal|'g'
case|:
comment|/* Anything goes unless it is a REG and really has a hard reg 		   but the hard reg is not in the class GENERAL_REGS.  */
if|if
condition|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
name|constraints
index|[
name|opno
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand did not win somehow, 	     this alternative loses.  */
if|if
condition|(
operator|!
name|win
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This alternative won; the operands are ok. 	 Change whichever operands this alternative says to change.  */
if|if
condition|(
operator|!
name|lose
condition|)
block|{
while|while
condition|(
operator|--
name|funny_match_index
operator|>=
literal|0
condition|)
block|{
name|recog_operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|other
index|]
operator|=
name|recog_operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|which_alternative
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff OPERAND (assumed to be a REG rtx)    is a hard reg in class CLASS when its regno is offsetted by OFFSET    and changed to mode MODE.    If REG occupies multiple hard regs, all of them must be in CLASS.  */
end_comment

begin_function
name|int
name|reg_fits_class_p
parameter_list|(
name|operand
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|operand
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|offset
argument_list|)
condition|)
block|{
specifier|register
name|int
name|sr
decl_stmt|;
name|regno
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|sr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|sr
operator|>
literal|0
condition|;
name|sr
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|sr
argument_list|)
condition|)
break|break;
return|return
name|sr
operator|==
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

end_unit

