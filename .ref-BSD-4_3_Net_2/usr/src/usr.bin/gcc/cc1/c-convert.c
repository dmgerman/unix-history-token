begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-level data type conversion for GNU C.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains the functions for converting C expressions    to different data types.  The only entry point is `convert'.    Every language front end must have a `convert' function    but what kind of conversions it does will depend on the language.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* Change of width--truncation and extension of integers or reals--    is represented with NOP_EXPR.  Proper functioning of many things    assumes that no other conversions can be NOP_EXPRs.     Conversion between integer and pointer is represented with CONVERT_EXPR.    Converting integer to real uses FLOAT_EXPR    and real to integer uses FIX_TRUNC_EXPR.     Here is a list of all the functions that assume that widening and    narrowing is always done with a NOP_EXPR:      In c-convert.c, convert_to_integer.      In c-typeck.c, build_binary_op_nodefault (boolean ops),         and truthvalue_conversion.      In expr.c: expand_expr, for operands of a MULT_EXPR.      In fold-const.c: fold.      In tree.c: get_narrower and get_unwidened.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `convert'.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_pointer
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
return|return
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|type_precision
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_SIZE
condition|)
return|return
name|build
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"cannot convert to a pointer type"
argument_list|)
expr_stmt|;
return|return
name|null_pointer_node
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|convert_to_real
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|flag_float_store
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|REAL_TYPE
condition|)
return|return
name|build
argument_list|(
name|flag_float_store
condition|?
name|CONVERT_EXPR
else|:
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|build
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
name|error
argument_list|(
literal|"pointer value used where a float was expected"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"aggregate value used where a float was expected"
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|tem
init|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_REAL_CST
argument_list|(
name|tem
argument_list|)
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The result of this is always supposed to be a newly created tree node    not in use in any existing structure.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_integer
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
specifier|extern
name|tree
name|build_binary_op_nodefault
parameter_list|()
function_decl|;
specifier|extern
name|tree
name|build_unary_op
parameter_list|()
function_decl|;
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|intype
operator|==
name|type
condition|)
return|return
name|expr
return|;
block|}
if|if
condition|(
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
specifier|register
name|int
name|outprec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|inprec
init|=
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|ex_form
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|inprec
condition|)
return|return
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* Here detect when we can distribute the truncation down past some arithmetic.    For example, if adding two longs and converting to an int,    we can equally well convert both to ints and then add.    For the operations handled here, such truncation distribution    is always safe.    It is desirable in these cases:    1) when truncating down to full-word from a larger size    2) when truncating takes no work.    3) when at least one operand of the arithmetic has been extended    (as by C's default conversions).  In this case we need two conversions    if we do the arithmetic as already requested, so we might as well    truncate both and then combine.  Perhaps that way we need only one.     Note that in general we cannot do the arithmetic in a type    shorter than the desired result of conversion, even if the operands    are both extended from a shorter type, because they might overflow    if combined in that type.  The exceptions to this--the times when    two narrow values can be combined in their narrow type even to    make a wider result--are handled by "shorten" in build_binary_op.  */
switch|switch
condition|(
name|ex_form
condition|)
block|{
case|case
name|RSHIFT_EXPR
case|:
comment|/* We can pass truncation down through right shifting 	     when the shift count is a negative constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
break|break;
goto|goto
name|trunc1
goto|;
case|case
name|LSHIFT_EXPR
case|:
comment|/* We can pass truncation down through left shifting 	     when the shift count is a positive constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
comment|/* In this case, shifting is like multiplication.  */
goto|goto
name|trunc1
goto|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MULT_EXPR
case|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Don't distribute unless the output precision is at least as big 	       as the actual inputs.  Otherwise, the comparison of the 	       truncated values will be wrong.  */
if|if
condition|(
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* If signedness of arg0 and arg1 don't match, 		   we can't necessarily find a type to compare them in.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|trunc1
goto|;
break|break;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
name|trunc1
label|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|BITS_PER_WORD
operator|||
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|outprec
argument_list|,
name|inprec
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do the arithmetic in type TYPEX, 		   then convert result to TYPE.  */
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 		   so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 		   In that case, do nothing special here. 		   (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		       or vice versa. 		       Exception: if the original operands were unsigned 		       then can safely do the work as unsigned. 		       And we may need to do it as unsigned 		       if we truncate to the original size.  */
name|typex
operator|=
operator|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build_binary_op_nodefault
argument_list|(
name|ex_form
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|ex_form
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
comment|/* If we want result of comparison converted to a byte, 	     we can just regard it as a byte, since it is 0 or 1.  */
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ABS_EXPR
case|:
block|{
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 	       so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 	       In that case, do nothing special here. 	       (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		   or vice versa.  */
name|typex
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build_unary_op
argument_list|(
name|ex_form
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
case|case
name|NOP_EXPR
case|:
comment|/* If truncating after truncating, might as well do all at once. 	     If truncating after extending, we may get rid of wasted work.  */
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Can treat the two alternative values like the operands 	     of an arithmetic expression.  */
block|{
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|BITS_PER_WORD
operator|||
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|outprec
argument_list|,
name|inprec
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do the arithmetic in type TYPEX, 		   then convert result to TYPE.  */
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 		   so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 		   In that case, do nothing special here. 		   (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		       or vice versa.  */
name|typex
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|typex
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
name|form
operator|==
name|REAL_TYPE
condition|)
return|return
name|build
argument_list|(
name|FIX_TRUNC_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|error
argument_list|(
literal|"aggregate value used where an integer was expected"
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|tem
init|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an expression whose value is that of EXPR,    converted to type TYPE.  The TREE_TYPE of the value    is always TYPE.  This function implements all reasonable    conversions; callers should filter out those that are    not permitted by the language being compiled.  */
end_comment

begin_function
name|tree
name|convert
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|e
init|=
name|expr
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* This is incorrect.  A truncation can't be stripped this way.      Extensions will be stripped by the use of get_unwidened.  */
block|if (TREE_CODE (expr) == NOP_EXPR)     return convert (type, TREE_OPERAND (expr, 0));
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
name|error
argument_list|(
literal|"conversion to non-scalar type requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

end_unit

