begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Delayed branch scheduling pass.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU CC General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU CC, but only under the conditions described in the GNU CC General Public License.   A copy of this license is supposed to have been given to you along with GNU CC so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/*  Delayed Branch Scheduling Optimization  If the HAVE_DELAYED_BRANCH macro is defined in the machine  description, this code is called by toplev.c during optimizing  compilation immediately after the final jump optimization pass and just before assembler output generation, if delayed branch scheduling is requested with the -fdelayed-branch switch.  Machines with delayed branch allow one or more instructions placed *after* a branch instruction to be executed while the hardware is off fetching the next instruction.  These instructions are executed after the branch is issued, but before the branch  actually takes effect.  The decision as to whether or not the branch is to be taken, and the address of the branch target are fixed at the time the branch is issued, so only instructions that do not appear in the dependency graphs for computing the  branch decision and/or target address may be relocated "after"  the branch.  Some machines might have additional restrictions, such as not allowing memory instructions or condition code modification in the delay sequence.  Note that this scheduling pass occurs after register allocation, and (of course) final jump optimization.  This mechanism is *not* intended to be hacked to deal with similar memory-latency pipeline scheduling (i.e. slots after loads/stores), as tempting as that might be.  The right place to do load-store latency scheduling is prior to register allocation, since allocation may introduce artificial dependencies that could have been avoided; note that these artificial dependencies are *not* reflected in the flow information, which is one reason for the somewhat ad hoc analysis done in this pass.   The strategy and methods used are as follows.  The function DBR_SCHEDULE is called from toplev.c if the scheduling pass is to be run.  That function sets up the dump file, then scans the current function from top to bottom for "d-blocks", which are like basic blocks (single-entry, single-exit), with the additional condition that the last instruction in the block has delay slots.  Note that if calls have slots, d-blocks can be smaller than basic blocks.  If a basic block does not end with a delay-instruction, it is skipped.  To re-order instructions in a d-block (see DBR_DBLOCK_SCHED), the scheduler scans backward from the "d-instruction", trying to fill the slots.  The scheduler is somewhat conservative.  Volatile memory references are serialized (their order is never changed to avoid possible aliasing problems).  Definitions of registers are serialized (so there is no possibility of deadlock).  Since hard register dependencies are not noted by flow analysis, the scheduler does its own simplified tracking of the registers, memory, and condition code uses/defines by the d-instruction and the instructions it depends on).  Information available from flow analysis is used to shortcut the analysis where possible.    Since only data dependencies are considered by the scheduler, any machine-specific restrictions, e.g. to keep memory instructions from being scheduled into slots, must be explicit in the definition of DBR_INSN_ELIGIBLE_P.  The scheduler scans backwards over the block, looking for eligible insns to fill the slot(s).  If none are found, nothing is done, and no changes are made to the code.  As eligible insns are found, they are removed from the chain, and recorded in an INSN_LIST rtx.  When all slots are full (or the top of the d-block is reached), the *pattern* of the d-insn is replaced with a SEQUENCE rtx, which consists of a copy of the original d-insn followed by the slot fillers.  Slot filling instructions remain in the original relative order in the sequence.  When the SEQUENCE pattern is encountered by final, the instructions are output "normally", though the output code for the instructions may test for this and alter their behavior appropriately.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_decl_stmt
name|FILE
modifier|*
name|dbr_dump_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of unfilled delay slots in the current sequence. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|slots_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A flag, nonzero indicating that some insn that could not     go in a slot writes to memory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|memw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A flag, nonzero indicating that the condition code is written     by some insn that couldn't go in a delay slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ccw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each bit is nonzero if the corresponding hard register    is written by an insn that couldn't go in a delay slot.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A flag, set nonzero if ENOTE determines that    the current insn can't go in a delay slot because of a    data dependency detected by note_stores.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The insn having delay slots.  Global because of the calls through    note_stores that need it.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dinsn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The insn being currently considered for a delay slot.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An INSN_LIST (just like the insn field) that we use to hold    LOG_LINKS of ineligible insns.  We use what flow analysis     stuff we can - this prevents exhaustive searches for write-read    dependencies in most cases.  This tactic only loses on reloads    and code generated with hard regs (instead of pseudos).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dep_insn_list
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Called by note_stores on "ineligible" insns to keep track of    pre-branch dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|pnote
parameter_list|(
name|x
parameter_list|,
name|in
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|in
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regw
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
name|memw
operator|=
name|TRUE
expr_stmt|;
comment|/* this might be relaxed somewhat later */
return|return;
case|case
name|CC0
case|:
name|ccw
operator|=
name|TRUE
expr_stmt|;
return|return;
case|case
name|PC
case|:
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* should never happen */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  The d-block end insn is in DINSN.  Initialize the flags to     start building the delay sequence.  Calls PNOTE from note_stores     to track the written registers and memory.      */
end_comment

begin_function
specifier|static
name|void
name|init_flags
parameter_list|()
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|regw
argument_list|)
expr_stmt|;
name|memw
operator|=
name|ccw
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|dinsn
argument_list|)
argument_list|,
name|pnote
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|dinsn
argument_list|)
condition|)
name|dep_insn_list
operator|=
name|copy_rtx
argument_list|(
name|LOG_LINKS
argument_list|(
name|dinsn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dep_insn_list
operator|=
literal|0
expr_stmt|;
name|slots_avail
operator|=
name|DBR_SLOTS_AFTER
argument_list|(
name|dinsn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called through note_stores on possibly eligible insn patterns.    Checks to see if a register written by the pattern is needed by an already    ineligible insn.  Sets the global EFLAG nonzero if a dependency    is found.  */
end_comment

begin_function
specifier|static
name|void
name|enote
parameter_list|(
name|x
parameter_list|,
name|p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|p
decl_stmt|;
block|{
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg_used_between_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|dinsn
argument_list|)
condition|)
goto|goto
name|lose
goto|;
if|if
condition|(
operator|(
operator|!
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|dinsn
argument_list|)
operator|!=
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
operator|(
name|PATTERN
argument_list|(
name|dinsn
argument_list|)
operator|)
argument_list|)
condition|)
goto|goto
name|lose
goto|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|cc0_rtx
operator|&&
name|reg_used_between_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|NEXT_INSN
argument_list|(
name|dinsn
argument_list|)
argument_list|)
condition|)
goto|goto
name|lose
goto|;
return|return;
name|lose
label|:
name|eflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Search the current dependency list DEP_INSN_LIST for INSN,     return nonzero if found. */
end_comment

begin_function
specifier|static
name|int
name|in_dep_list_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|dep_insn_list
init|;
name|l
condition|;
name|l
operator|=
name|XEXP
argument_list|(
name|l
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|insn
operator|==
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns zero if INSN is ineligible to be put in a delay slot    of DINSN.  INSN is ineligible if it:      - is in the dependency list of an ineligible insn.      - writes a hard register needed by an ineligible insn.      - reads a register written by an ineligible insn.      - refers to memory.      - sets the condition code.          - violates a machine-dependent constraint.  */
end_comment

begin_function
specifier|static
name|int
name|insn_eligible_p
parameter_list|()
block|{
name|rtx
name|dest
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
comment|/* See if there are any explicit dependencies on this insn. */
if|if
condition|(
name|in_dep_list_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check for implicit dependencies by calling enote on each      store rtx.  ENOTE makes sure that no ineligible instruction      refers to a register in a way that flow analysis       has missed or ignored.         */
name|eflag
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|enote
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
return|return
literal|0
return|;
comment|/* Check for volatile memory refs if any already ineligible. */
if|if
condition|(
name|memw
operator|&&
name|volatile_refs_p
argument_list|(
name|pat
argument_list|)
condition|)
block|{
name|memw
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See if it refers to any regs that are clobbered by ineligibles. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regw
argument_list|,
name|i
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pat
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DBR_INSN_ELIGIBLE_P
comment|/*  Check for arbitrary machine constraints if any. */
if|if
condition|(
operator|!
name|DBR_INSN_ELIGIBLE_P
argument_list|(
name|insn
argument_list|,
name|dinsn
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add the links in LIST to the dependency list.  We put them    at the front since this should make searches faster in long    d-blocks. */
end_comment

begin_function
specifier|static
name|void
name|prepend_to_dep_list
parameter_list|(
name|list
parameter_list|)
name|rtx
name|list
decl_stmt|;
block|{
name|rtx
name|l
init|=
name|copy_rtx
argument_list|(
name|list
argument_list|)
decl_stmt|;
while|while
condition|(
name|XEXP
argument_list|(
name|l
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|l
operator|=
name|XEXP
argument_list|(
name|l
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|l
argument_list|,
literal|1
argument_list|)
operator|=
name|dep_insn_list
expr_stmt|;
name|dep_insn_list
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the flags for ineligible INSN - it can't be put in a delay slot.  This involves setting bits to indicate the stores of INSN, and adding any flow-analysis dependencies of INSN's insn-list to the ineligible list.  (Should ultimately catch reloads too.) */
end_comment

begin_function
specifier|static
name|void
name|update_flags
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|l
decl_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pnote
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
condition|)
name|prepend_to_dep_list
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace    the pattern of INSN with the SEQUENCE.  Include the available    slots AVAIL in the SEQUENCE insn.  */
end_comment

begin_function
specifier|static
name|void
name|emit_delay_sequence
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|,
name|length
parameter_list|,
name|avail
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|avail
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|register
name|rtx
name|li
decl_stmt|,
name|tem
decl_stmt|;
comment|/* Allocate the the rtvec to hold the insns and the SEQUENCE. */
name|rtvec
name|seqv
init|=
name|rtvec_alloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
name|gen_rtx
argument_list|(
name|SEQUENCE
argument_list|,
name|VOIDmode
argument_list|,
name|seqv
argument_list|)
decl_stmt|;
comment|/* Make a copy of the insn having delay slots. */
name|tem
operator|=
name|copy_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Replace the original pattern with a sequence whose      first insn is the copy. */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|seq
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
comment|/* Copy in the delay-slot filling insns. */
for|for
control|(
name|li
operator|=
name|list
init|;
name|li
condition|;
name|li
operator|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Try to reorganize code in a d-block */
end_comment

begin_function
specifier|static
name|void
name|dbr_dblock_sched
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|delay_insn_list
init|=
literal|0
decl_stmt|;
name|int
name|seq_len
init|=
literal|0
decl_stmt|;
name|dinsn
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
return|return;
name|init_flags
argument_list|()
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|dinsn
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
condition|)
block|{
if|if
condition|(
name|slots_avail
operator|>=
name|DBR_INSN_SLOTS
argument_list|(
name|insn
argument_list|)
operator|&&
name|insn_eligible_p
argument_list|()
condition|)
block|{
comment|/* Add this insn to the delay sequence and 		 update the number of slots available. */
specifier|register
name|rtx
name|t
init|=
name|delay_insn_list
decl_stmt|;
name|delay_insn_list
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|seq_len
operator|++
expr_stmt|;
name|slots_avail
operator|-=
name|DBR_INSN_SLOTS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Now remove it from the chain. */
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|update_flags
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|slots_avail
operator|==
literal|0
operator|||
name|insn
operator|==
name|first
condition|)
break|break;
else|else
name|insn
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Done.  If the delay list is non-empty, emit a sequence      in place of the dinsn.  */
if|if
condition|(
name|delay_insn_list
operator|!=
literal|0
condition|)
name|emit_delay_sequence
argument_list|(
name|dinsn
argument_list|,
name|delay_insn_list
argument_list|,
name|seq_len
argument_list|,
name|slots_avail
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Identify d-blocks of a function, which are sort of like basic blocks, except that any instruction with delay slots defines the end of a dblock, and dblocks that do not end in delay-instructions are uninteresting degenerate cases.  This function finds d-blocks in the code for a function, and calls dbr_dblock_sched on non-degenerate blocks.  Called from toplev.c if HAVE_DELAYED_BRANCH is defined and we are doing optimizing compilation.   F is the first insn of the function, DUMP_FILE is the file to output debugging info on if requested.  */
end_comment

begin_function
name|void
name|dbr_schedule
parameter_list|(
name|f
parameter_list|,
name|dump_file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|rtx
name|first
init|=
name|f
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Dump output if requested */
if|if
condition|(
name|dbr_dump_file
operator|=
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dbr_dump_file
argument_list|,
literal|"Delayed-branch reordering dump.\n"
argument_list|)
expr_stmt|;
comment|/* Search for d-blocks by scanning the insns from top to bottom. */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|DBR_SLOTS_AFTER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* An insn with delay slots always terminates a d-block. 	     Call the scheduler to fill in the slots if possible. */
name|dbr_dblock_sched
argument_list|(
name|first
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Resume scanning after the end of the sequence. */
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|dinsn
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Not an end of a real d-block, but need to check 	   if it is the end of a degenerate one.  Note that 	   calls or jumps will only reach here if they aren't 	   delayed instructions.              */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

