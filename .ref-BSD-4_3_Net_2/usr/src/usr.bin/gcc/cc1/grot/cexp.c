begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  A Bison parser, made from ccdir/cexp.y  */
end_comment

begin_define
define|#
directive|define
name|INT
value|258
end_define

begin_define
define|#
directive|define
name|CHAR
value|259
end_define

begin_define
define|#
directive|define
name|NAME
value|260
end_define

begin_define
define|#
directive|define
name|ERROR
value|261
end_define

begin_define
define|#
directive|define
name|OR
value|262
end_define

begin_define
define|#
directive|define
name|AND
value|263
end_define

begin_define
define|#
directive|define
name|EQUAL
value|264
end_define

begin_define
define|#
directive|define
name|NOTEQUAL
value|265
end_define

begin_define
define|#
directive|define
name|LEQ
value|266
end_define

begin_define
define|#
directive|define
name|GEQ
value|267
end_define

begin_define
define|#
directive|define
name|LSH
value|268
end_define

begin_define
define|#
directive|define
name|RSH
value|269
end_define

begin_define
define|#
directive|define
name|UNARY
value|270
end_define

begin_line
line|#
directive|line
number|26
file|"ccdir/cexp.y"
end_line

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* #define YYDEBUG 1 */
end_comment

begin_function_decl
name|int
name|yylex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|yyerror
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|expression_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|parse_return_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some external tables of character types */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|is_idstart
index|[]
decl_stmt|,
name|is_idchar
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_line
line|#
directive|line
number|45
file|"ccdir/cexp.y"
end_line

begin_typedef
typedef|typedef
union|union
block|{
struct|struct
name|constant
block|{
name|long
name|value
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|}
name|integer
struct|;
name|int
name|voidval
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|YYLTYPE
end_ifndef

begin_typedef
typedef|typedef
struct|struct
name|yyltype
block|{
name|int
name|timestamp
decl_stmt|;
name|int
name|first_line
decl_stmt|;
name|int
name|first_column
decl_stmt|;
name|int
name|last_line
decl_stmt|;
name|int
name|last_column
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|}
name|yyltype
typedef|;
end_typedef

begin_define
define|#
directive|define
name|YYLTYPE
value|yyltype
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYFINAL
value|61
end_define

begin_define
define|#
directive|define
name|YYFLAG
value|-32768
end_define

begin_define
define|#
directive|define
name|YYNTBASE
value|33
end_define

begin_define
define|#
directive|define
name|YYTRANSLATE
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x)<= 270 ? yytranslate[x] : 36)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|yytranslate
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|29
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|27
block|,
literal|14
block|,
literal|2
block|,
literal|31
block|,
literal|32
block|,
literal|25
block|,
literal|23
block|,
literal|9
block|,
literal|24
block|,
literal|2
block|,
literal|26
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|8
block|,
literal|2
block|,
literal|17
block|,
literal|2
block|,
literal|18
block|,
literal|7
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|13
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|12
block|,
literal|2
block|,
literal|30
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|10
block|,
literal|11
block|,
literal|15
block|,
literal|16
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
end_if

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyrline
index|[]
init|=
block|{
literal|0
block|,
literal|74
block|,
literal|79
block|,
literal|80
block|,
literal|85
block|,
literal|88
block|,
literal|91
block|,
literal|93
block|,
literal|96
block|,
literal|101
block|,
literal|107
block|,
literal|118
block|,
literal|129
block|,
literal|132
block|,
literal|135
block|,
literal|141
block|,
literal|147
block|,
literal|150
block|,
literal|153
block|,
literal|159
block|,
literal|165
block|,
literal|171
block|,
literal|177
block|,
literal|180
block|,
literal|183
block|,
literal|186
block|,
literal|189
block|,
literal|192
block|,
literal|195
block|,
literal|197
block|,
literal|199
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yytname
index|[]
init|=
block|{
literal|0
block|,
literal|"error"
block|,
literal|"$illegal."
block|,
literal|"INT"
block|,
literal|"CHAR"
block|,
literal|"NAME"
block|,
literal|"ERROR"
block|,
literal|"'?'"
block|,
literal|"':'"
block|,
literal|"','"
block|,
literal|"OR"
block|,
literal|"AND"
block|,
literal|"'|'"
block|,
literal|"'^'"
block|,
literal|"'&'"
block|,
literal|"EQUAL"
block|,
literal|"NOTEQUAL"
block|,
literal|"'<'"
block|,
literal|"'>'"
block|,
literal|"LEQ"
block|,
literal|"GEQ"
block|,
literal|"LSH"
block|,
literal|"RSH"
block|,
literal|"'+'"
block|,
literal|"'-'"
block|,
literal|"'*'"
block|,
literal|"'/'"
block|,
literal|"'%'"
block|,
literal|"UNARY"
block|,
literal|"'!'"
block|,
literal|"'~'"
block|,
literal|"'('"
block|,
literal|"')'"
block|,
literal|"start"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyr1
index|[]
init|=
block|{
literal|0
block|,
literal|33
block|,
literal|34
block|,
literal|34
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyr2
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefact
index|[]
init|=
block|{
literal|0
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|6
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|8
block|,
literal|3
block|,
literal|0
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|,
literal|23
block|,
literal|22
block|,
literal|16
block|,
literal|17
block|,
literal|20
block|,
literal|21
block|,
literal|18
block|,
literal|19
block|,
literal|14
block|,
literal|15
block|,
literal|12
block|,
literal|13
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|0
block|,
literal|27
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefgoto
index|[]
init|=
block|{
literal|59
block|,
literal|9
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yypact
index|[]
init|=
block|{
literal|31
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|1
block|,
literal|77
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|0
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
operator|-
literal|32768
block|,
literal|77
block|,
literal|56
block|,
literal|94
block|,
literal|25
block|,
literal|109
block|,
literal|123
block|,
literal|136
block|,
literal|147
block|,
literal|147
block|,
literal|154
block|,
literal|154
block|,
literal|154
block|,
literal|154
block|,
operator|-
literal|19
block|,
operator|-
literal|19
block|,
literal|32
block|,
literal|32
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|31
block|,
literal|77
block|,
literal|11
block|,
literal|33
block|,
operator|-
literal|32768
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yypgoto
index|[]
init|=
block|{
operator|-
literal|32768
block|,
literal|48
block|,
operator|-
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYLAST
value|181
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yytable
index|[]
init|=
block|{
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|16
block|,
literal|16
block|,
literal|60
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|36
block|,
literal|61
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|58
block|,
literal|4
block|,
literal|5
block|,
literal|15
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|17
block|,
literal|57
block|,
literal|0
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|17
block|,
literal|0
block|,
literal|0
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yycheck
index|[]
init|=
block|{
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|32
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|57
block|,
literal|23
block|,
literal|24
block|,
literal|8
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|7
block|,
literal|8
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYPURE
value|1
end_define

begin_comment
comment|/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
end_comment

begin_line
line|#
directive|line
number|3
file|"bison.simple"
end_line

begin_comment
comment|/* Skeleton output parser for bison,    Copyright (C) 1984 Bob Corbett and Richard Stallman     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GNU C.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|sparc
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sparc.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not GNU C.  */
end_comment

begin_comment
comment|/* This is the parser code that is written into each bison parser   when the %semantic_parser declaration is not specified in the grammar.   It was written by Richard Stallman by simplifying the hairy parser   used when %semantic_parser is specified.  */
end_comment

begin_comment
comment|/* Note: there must be only one dollar sign in this file.    It is replaced by the list of actions, each action    as one case of the switch.  */
end_comment

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrstatus = 0)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|-2
end_define

begin_define
define|#
directive|define
name|YYEOF
value|0
end_define

begin_define
define|#
directive|define
name|YYFAIL
value|goto yyerrlab;
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|return(0)
end_define

begin_define
define|#
directive|define
name|YYABORT
value|return(1)
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYTERROR
value|1
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYIMPURE
end_ifndef

begin_define
define|#
directive|define
name|YYLEX
value|yylex()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYPURE
end_ifndef

begin_define
define|#
directive|define
name|YYLEX
value|yylex(&yylval,&yylloc)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If nonreentrant, generate the variables here */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYIMPURE
end_ifndef

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
end_ifdef

begin_decl_stmt
name|YYLTYPE
name|yylloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  location data for the lookahead	*/
end_comment

begin_comment
comment|/*  symbol				*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|yynerrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  number of parse errors so far       */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYIMPURE */
end_comment

begin_if
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
end_if

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  nonzero means print parse trace	*/
end_comment

begin_comment
comment|/* Since this is uninitialized, it does not stop multiple parsers    from coexisting.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  YYMAXDEPTH indicates the initial size of the parser's stacks	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  YYMAXLIMIT is the maximum size the stacks can grow to     (effective only if the built-in stack extension method is used).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXLIMIT
end_ifndef

begin_define
define|#
directive|define
name|YYMAXLIMIT
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the most reliable way to avoid incompatibilities    in available built-in functions on various systems.  */
end_comment

begin_function
specifier|static
name|void
name|__yy_bcopy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|f
init|=
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
init|=
name|to
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|count
decl_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
block|}
end_function

begin_line
line|#
directive|line
number|111
file|"bison.simple"
end_line

begin_function
name|int
name|yyparse
parameter_list|()
block|{
specifier|register
name|int
name|yystate
decl_stmt|;
specifier|register
name|int
name|yyn
decl_stmt|;
specifier|register
name|short
modifier|*
name|yyssp
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yyvsp
decl_stmt|;
name|int
name|yyerrstatus
decl_stmt|;
comment|/*  number of tokens to shift before error messages enabled */
name|int
name|yychar1
decl_stmt|;
comment|/*  lookahead token as an internal (translated) token number */
name|short
name|yyssa
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
comment|/*  the state stack			*/
name|YYSTYPE
name|yyvsa
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
comment|/*  the semantic value stack		*/
name|short
modifier|*
name|yyss
init|=
name|yyssa
decl_stmt|;
comment|/*  refer to the stacks thru separate pointers */
name|YYSTYPE
modifier|*
name|yyvs
init|=
name|yyvsa
decl_stmt|;
comment|/*  to allow yyoverflow to reallocate them elsewhere */
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|YYLTYPE
modifier|*
name|yyls
init|=
name|yylsa
decl_stmt|;
name|YYLTYPE
modifier|*
name|yylsp
decl_stmt|;
name|YYLTYPE
name|yylsa
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
comment|/*  the location stack			*/
endif|#
directive|endif
name|int
name|yymaxdepth
init|=
name|YYMAXDEPTH
decl_stmt|;
ifndef|#
directive|ifndef
name|YYPURE
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
name|int
name|yynerrs
decl_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|YYLTYPE
name|yylloc
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|YYSTYPE
name|yyval
decl_stmt|;
comment|/*  the variable used to return		*/
comment|/*  semantic values from the action	*/
comment|/*  routines				*/
name|int
name|yylen
decl_stmt|;
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Starting parse\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
literal|0
expr_stmt|;
name|yyerrstatus
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
comment|/* Cause a token to be read.  */
comment|/* Initialize stack pointers.      Waste one element of value and location stack      so that they stay on the same level as the state stack.  */
name|yyssp
operator|=
name|yyss
operator|-
literal|1
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yylsp
operator|=
name|yyls
expr_stmt|;
endif|#
directive|endif
comment|/* Push a new state, which is found in  yystate  .  */
comment|/* In all cases, when you get here, the value and location stacks    have just been pushed. so pushing a state here evens the stacks.  */
name|yynewstate
label|:
operator|*
operator|++
name|yyssp
operator|=
name|yystate
expr_stmt|;
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yymaxdepth
operator|-
literal|1
condition|)
block|{
comment|/* Give user a chance to reallocate the stack */
comment|/* Use copies of these so that the&'s don't force the real ones into memory. */
name|YYSTYPE
modifier|*
name|yyvs1
init|=
name|yyvs
decl_stmt|;
name|short
modifier|*
name|yyss1
init|=
name|yyss
decl_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|YYLTYPE
modifier|*
name|yyls1
init|=
name|yyls
decl_stmt|;
endif|#
directive|endif
comment|/* Get the current used size of the three stacks, in elements.  */
name|int
name|size
init|=
name|yyssp
operator|-
name|yyss
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|yyoverflow
comment|/* Each stack pointer address is followed by the size of 	 the data in use in that stack, in bytes.  */
name|yyoverflow
argument_list|(
literal|"parser stack overflow"
argument_list|,
operator|&
name|yyss1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|,
operator|&
name|yyvs1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|,
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
operator|&
name|yyls1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|,
endif|#
directive|endif
operator|&
name|yymaxdepth
argument_list|)
expr_stmt|;
name|yyss
operator|=
name|yyss1
expr_stmt|;
name|yyvs
operator|=
name|yyvs1
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yyls
operator|=
name|yyls1
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* no yyoverflow */
comment|/* Extend the stack our own way.  */
if|if
condition|(
name|yymaxdepth
operator|>=
name|YYMAXLIMIT
condition|)
name|yyerror
argument_list|(
literal|"parser stack overflow"
argument_list|)
expr_stmt|;
name|yymaxdepth
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|yymaxdepth
operator|>
name|YYMAXLIMIT
condition|)
name|yymaxdepth
operator|=
name|YYMAXLIMIT
expr_stmt|;
name|yyss
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|yymaxdepth
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|)
expr_stmt|;
name|__yy_bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yyss1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yyss
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|)
expr_stmt|;
name|yyvs
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|alloca
argument_list|(
name|yymaxdepth
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|)
expr_stmt|;
name|__yy_bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yyvs1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yyvs
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yyls
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|alloca
argument_list|(
name|yymaxdepth
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|)
expr_stmt|;
name|__yy_bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yyls1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yyls
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* no yyoverflow */
name|yyssp
operator|=
name|yyss
operator|+
name|size
operator|-
literal|1
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
operator|+
name|size
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yylsp
operator|=
name|yyls
operator|+
name|size
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stack size increased to %d\n"
argument_list|,
name|yymaxdepth
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yymaxdepth
operator|-
literal|1
condition|)
name|YYABORT
expr_stmt|;
block|}
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering state %d\n"
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do appropriate processing given the current state.  */
comment|/* Read a lookahead token if we need one and don't already have one.  */
comment|/* yyresume: */
comment|/* First try to decide what to do without reference to lookahead token.  */
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yydefault
goto|;
comment|/* Not known => get a lookahead token if don't already have one.  */
comment|/* yychar is either YYEMPTY or YYEOF      or a valid token in external form.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
block|{
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reading a token: "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
name|YYLEX
expr_stmt|;
block|}
comment|/* Convert token to internal form (in yychar1) for indexing tables with */
if|if
condition|(
name|yychar
operator|<=
literal|0
condition|)
comment|/* This means end of input. */
block|{
name|yychar1
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEOF
expr_stmt|;
comment|/* Don't call YYLEX any more */
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Now at end of input.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|yychar1
operator|=
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Next token is %d (%s)\n"
argument_list|,
name|yychar
argument_list|,
name|yytname
index|[
name|yychar1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|yyn
operator|+=
name|yychar1
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|yyn
operator|>
name|YYLAST
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|yychar1
condition|)
goto|goto
name|yydefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
comment|/* yyn is what to do for this token type in this state.      Negative => reduce, -yyn is rule number.      Positive => shift, yyn is new state.        New state is final state => don't bother to shift,        just return success.      0, or most negative number => error.  */
if|if
condition|(
name|yyn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrlab
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
elseif|else
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
comment|/* Shift the lookahead token.  */
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Shifting token %d (%s), "
argument_list|,
name|yychar
argument_list|,
name|yytname
index|[
name|yychar1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Discard the token being shifted unless it is eof.  */
if|if
condition|(
name|yychar
operator|!=
name|YYEOF
condition|)
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
comment|/* count tokens shifted since error; after three, turn off error status.  */
if|if
condition|(
name|yyerrstatus
condition|)
name|yyerrstatus
operator|--
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/* Do the default action for the current state.  */
name|yydefault
label|:
name|yyn
operator|=
name|yydefact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
comment|/* Do a reduction.  yyn is the number of a rule to reduce with.  */
name|yyreduce
label|:
name|yylen
operator|=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
literal|1
operator|-
name|yylen
index|]
expr_stmt|;
comment|/* implement default value of the action */
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
name|yylen
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reducing 1 value via rule %d (line %d), "
argument_list|,
name|yyn
argument_list|,
name|yyrline
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reducing %d values via rule %d (line %d), "
argument_list|,
name|yylen
argument_list|,
name|yyn
argument_list|,
name|yyrline
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|yyn
condition|)
block|{
case|case
literal|1
case|:
line|#
directive|line
number|75
file|"ccdir/cexp.y"
block|{
name|expression_value
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|3
case|:
line|#
directive|line
number|81
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|4
case|:
line|#
directive|line
number|86
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|-
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|5
case|:
line|#
directive|line
number|89
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|!
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|6
case|:
line|#
directive|line
number|92
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|7
case|:
line|#
directive|line
number|94
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|~
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|8
case|:
line|#
directive|line
number|97
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|integer
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|9
case|:
line|#
directive|line
number|102
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|10
case|:
line|#
directive|line
number|108
file|"ccdir/cexp.y"
block|{
if|if
condition|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|=
literal|1
expr_stmt|;
block|}
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|/
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|/
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|11
case|:
line|#
directive|line
number|119
file|"ccdir/cexp.y"
block|{
if|if
condition|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|=
literal|1
expr_stmt|;
block|}
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|%
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|%
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|12
case|:
line|#
directive|line
number|130
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|+
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|13
case|:
line|#
directive|line
number|133
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|-
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|14
case|:
line|#
directive|line
number|136
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|<<
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|<<
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|15
case|:
line|#
directive|line
number|142
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|>>
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|>>
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|16
case|:
line|#
directive|line
number|148
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|==
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|)
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|17
case|:
line|#
directive|line
number|151
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|!=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|)
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|18
case|:
line|#
directive|line
number|154
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|<=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|<=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|19
case|:
line|#
directive|line
number|160
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|>=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|>=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|20
case|:
line|#
directive|line
number|166
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|<
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|<
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|21
case|:
line|#
directive|line
number|172
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
condition|)
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|unsigned
operator|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|>
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
else|else
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|>
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|22
case|:
line|#
directive|line
number|178
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|&
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|23
case|:
line|#
directive|line
number|181
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|^
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|24
case|:
line|#
directive|line
number|184
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|25
case|:
line|#
directive|line
number|187
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|)
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|26
case|:
line|#
directive|line
number|190
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
operator|)
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|27
case|:
line|#
directive|line
number|193
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|integer
operator|.
name|value
condition|?
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|value
else|:
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|value
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|integer
operator|.
name|unsignedp
operator|||
name|yyvsp
index|[
literal|0
index|]
operator|.
name|integer
operator|.
name|unsignedp
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|28
case|:
line|#
directive|line
number|196
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|=
name|yylval
operator|.
name|integer
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|29
case|:
line|#
directive|line
number|198
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|=
name|yylval
operator|.
name|integer
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|30
case|:
line|#
directive|line
number|200
file|"ccdir/cexp.y"
block|{
name|yyval
operator|.
name|integer
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|yyval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
empty_stmt|;
break|break;
block|}
block|}
comment|/* the action file gets copied in in place of this dollarsign */
line|#
directive|line
number|362
file|"bison.simple"
name|yyvsp
operator|-=
name|yylen
expr_stmt|;
name|yyssp
operator|-=
name|yylen
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yylsp
operator|-=
name|yylen
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
block|{
name|short
modifier|*
name|ssp1
init|=
name|yyss
operator|-
literal|1
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state stack now"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssp1
operator|!=
name|yyssp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|++
name|ssp1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
operator|++
name|yyvsp
operator|=
name|yyval
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yylsp
operator|++
expr_stmt|;
if|if
condition|(
name|yylen
operator|==
literal|0
condition|)
block|{
name|yylsp
operator|->
name|first_line
operator|=
name|yylloc
operator|.
name|first_line
expr_stmt|;
name|yylsp
operator|->
name|first_column
operator|=
name|yylloc
operator|.
name|first_column
expr_stmt|;
name|yylsp
operator|->
name|last_line
operator|=
operator|(
name|yylsp
operator|-
literal|1
operator|)
operator|->
name|last_line
expr_stmt|;
name|yylsp
operator|->
name|last_column
operator|=
operator|(
name|yylsp
operator|-
literal|1
operator|)
operator|->
name|last_column
expr_stmt|;
name|yylsp
operator|->
name|text
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|yylsp
operator|->
name|last_line
operator|=
operator|(
name|yylsp
operator|+
name|yylen
operator|-
literal|1
operator|)
operator|->
name|last_line
expr_stmt|;
name|yylsp
operator|->
name|last_column
operator|=
operator|(
name|yylsp
operator|+
name|yylen
operator|-
literal|1
operator|)
operator|->
name|last_column
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now "shift" the result of the reduction.      Determine what state that goes to,      based on the state we popped back to      and the rule number reduced by.  */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yystate
operator|=
name|yypgoto
index|[
name|yyn
operator|-
name|YYNTBASE
index|]
operator|+
operator|*
name|yyssp
expr_stmt|;
if|if
condition|(
name|yystate
operator|>=
literal|0
operator|&&
name|yystate
operator|<=
name|YYLAST
operator|&&
name|yycheck
index|[
name|yystate
index|]
operator|==
operator|*
name|yyssp
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yystate
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydefgoto
index|[
name|yyn
operator|-
name|YYNTBASE
index|]
expr_stmt|;
goto|goto
name|yynewstate
goto|;
name|yyerrlab
label|:
comment|/* here on detecting error */
if|if
condition|(
operator|!
name|yyerrstatus
condition|)
comment|/* If not already recovering from an error, report this error.  */
block|{
operator|++
name|yynerrs
expr_stmt|;
ifdef|#
directive|ifdef
name|YYERROR_VERBOSE
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|>
name|YYFLAG
operator|&&
name|yyn
operator|<
name|YYLAST
condition|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|x
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|yytname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|yycheck
index|[
name|x
operator|+
name|yyn
index|]
operator|==
name|x
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|yytname
index|[
name|x
index|]
argument_list|)
operator|+
literal|15
operator|,
name|count
operator|++
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|15
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|msg
argument_list|,
literal|"parse error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|5
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|yytname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|yycheck
index|[
name|x
operator|+
name|yyn
index|]
operator|==
name|x
condition|)
block|{
name|strcat
argument_list|(
name|msg
argument_list|,
name|count
operator|==
literal|0
condition|?
literal|", expecting `"
else|:
literal|" or `"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|yytname
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|yyerror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* YYERROR_VERBOSE */
name|yyerror
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyerrstatus
operator|==
literal|3
condition|)
block|{
comment|/* if just tried and failed to reuse lookahead token after an error, discard it.  */
comment|/* return failure if at end of input */
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
name|YYABORT
expr_stmt|;
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Discarding token %d (%s).\n"
argument_list|,
name|yychar
argument_list|,
name|yytname
index|[
name|yychar1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
block|}
comment|/* Else will try to reuse lookahead token      after shifting the error token.  */
name|yyerrstatus
operator|=
literal|3
expr_stmt|;
comment|/* Each real token shifted decrements this */
goto|goto
name|yyerrhandle
goto|;
name|yyerrdefault
label|:
comment|/* current state does not do anything special for the error token. */
if|#
directive|if
literal|0
comment|/* This is wrong; only states that explicitly want error tokens      should shift them.  */
block|yyn = yydefact[yystate];
comment|/* If its default is to accept any token, ok.  Otherwise pop it.*/
block|if (yyn) goto yydefault;
endif|#
directive|endif
name|yyerrpop
label|:
comment|/* pop the current state because it cannot handle the error token */
if|if
condition|(
name|yyssp
operator|==
name|yyss
condition|)
name|YYABORT
expr_stmt|;
name|yyvsp
operator|--
expr_stmt|;
name|yystate
operator|=
operator|*
operator|--
name|yyssp
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
name|yylsp
operator|--
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
block|{
name|short
modifier|*
name|ssp1
init|=
name|yyss
operator|-
literal|1
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: state stack now"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssp1
operator|!=
name|yyssp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|++
name|ssp1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yyerrhandle
label|:
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrdefault
goto|;
name|yyn
operator|+=
name|YYTERROR
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|yyn
operator|>
name|YYLAST
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|YYTERROR
condition|)
goto|goto
name|yyerrdefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrpop
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
elseif|else
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrpop
goto|;
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Shifting error token, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
ifdef|#
directive|ifdef
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
block|}
end_function

begin_line
line|#
directive|line
number|203
file|"ccdir/cexp.y"
end_line

begin_escape
end_escape

begin_comment
comment|/* During parsing of a C expression, the pointer to the next character    is in this variable.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lexptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take care of parsing a number (anything that starts with a digit).    Set yylval and return the token type; update lexptr.    LEN is the number of characters in it.  */
end_comment

begin_comment
comment|/* maybe needs to actually deal with floating point numbers */
end_comment

begin_function
name|int
name|parse_number
parameter_list|(
name|olen
parameter_list|)
name|int
name|olen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|lexptr
decl_stmt|;
specifier|register
name|long
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|base
init|=
literal|10
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|olen
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|len
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|p
index|[
name|c
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* It's a float since it contains a point.  */
name|yyerror
argument_list|(
literal|"floating point numbers not allowed in #if expressions"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
name|yylval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"0X"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|*=
name|base
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
block|{
name|n
operator|*=
name|base
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* `l' means long, and `u' means unsigned.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
name|yylval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* Don't look for any more digits after the suffixes.  */
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid number in #if expression"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* If too big to be signed, consider it unsigned.  */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|yylval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
name|lexptr
operator|=
name|p
expr_stmt|;
name|yylval
operator|.
name|integer
operator|.
name|value
operator|=
name|n
expr_stmt|;
return|return
name|INT
return|;
block|}
end_function

begin_struct
struct|struct
name|token
block|{
name|char
modifier|*
name|operator
decl_stmt|;
name|int
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|token
name|tokentab2
index|[]
init|=
block|{
block|{
literal|"&&"
block|,
name|AND
block|}
block|,
block|{
literal|"||"
block|,
name|OR
block|}
block|,
block|{
literal|"<<"
block|,
name|LSH
block|}
block|,
block|{
literal|">>"
block|,
name|RSH
block|}
block|,
block|{
literal|"=="
block|,
name|EQUAL
block|}
block|,
block|{
literal|"!="
block|,
name|NOTEQUAL
block|}
block|,
block|{
literal|"<="
block|,
name|LEQ
block|}
block|,
block|{
literal|">="
block|,
name|GEQ
block|}
block|,
block|{
name|NULL
block|,
name|ERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read one token, getting characters through lexptr.  */
end_comment

begin_function
name|int
name|yylex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|namelen
decl_stmt|;
specifier|register
name|char
modifier|*
name|tokstart
decl_stmt|;
specifier|register
name|struct
name|token
modifier|*
name|toktab
decl_stmt|;
name|retry
label|:
name|tokstart
operator|=
name|lexptr
expr_stmt|;
name|c
operator|=
operator|*
name|tokstart
expr_stmt|;
comment|/* See if it is a special token of length 2.  */
for|for
control|(
name|toktab
operator|=
name|tokentab2
init|;
name|toktab
operator|->
name|operator
operator|!=
name|NULL
condition|;
name|toktab
operator|++
control|)
if|if
condition|(
name|c
operator|==
operator|*
name|toktab
operator|->
name|operator
operator|&&
name|tokstart
index|[
literal|1
index|]
operator|==
name|toktab
operator|->
name|operator
index|[
literal|1
index|]
condition|)
block|{
name|lexptr
operator|+=
literal|2
expr_stmt|;
return|return
name|toktab
operator|->
name|token
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|lexptr
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'\''
case|:
name|lexptr
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|lexptr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|lexptr
argument_list|)
expr_stmt|;
comment|/* Sign-extend the constant if chars are signed on target machine.  */
block|{
if|if
condition|(
name|lookup
argument_list|(
literal|"__CHAR_UNSIGNED__"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"__CHAR_UNSIGNED__"
argument_list|)
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|||
operator|(
operator|(
name|c
operator|>>
operator|(
name|CHAR_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|yylval
operator|.
name|integer
operator|.
name|value
operator|=
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|yylval
operator|.
name|integer
operator|.
name|value
operator|=
name|c
operator||
operator|~
operator|(
operator|(
literal|1
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|yylval
operator|.
name|integer
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|lexptr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid character constant in #if"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
return|return
name|CHAR
return|;
comment|/* some of these chars are invalid in constant expressions;        maybe do something about them later */
case|case
literal|'/'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'|'
case|:
case|case
literal|'&'
case|:
case|case
literal|'^'
case|:
case|case
literal|'~'
case|:
case|case
literal|'!'
case|:
case|case
literal|'@'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'.'
case|:
case|case
literal|'?'
case|:
case|case
literal|':'
case|:
case|case
literal|'='
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|','
case|:
name|lexptr
operator|++
expr_stmt|;
return|return
name|c
return|;
case|case
literal|'"'
case|:
name|yyerror
argument_list|(
literal|"double quoted strings not allowed in #if expressions"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* It's a number */
for|for
control|(
name|namelen
operator|=
literal|0
init|;
name|c
operator|=
name|tokstart
index|[
name|namelen
index|]
operator|,
name|is_idchar
index|[
name|c
index|]
operator|||
name|c
operator|==
literal|'.'
condition|;
name|namelen
operator|++
control|)
empty_stmt|;
return|return
name|parse_number
argument_list|(
name|namelen
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
name|c
index|]
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid token in expression"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* It is a name.  See how long it is.  */
for|for
control|(
name|namelen
operator|=
literal|0
init|;
name|is_idchar
index|[
name|tokstart
index|[
name|namelen
index|]
index|]
condition|;
name|namelen
operator|++
control|)
empty_stmt|;
name|lexptr
operator|+=
name|namelen
expr_stmt|;
return|return
name|NAME
return|;
block|}
end_function

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|int
name|parse_escape
parameter_list|(
name|string_ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
name|TARGET_BELL
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'e'
case|:
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'v'
case|:
return|return
name|TARGET_VT
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'^'
case|:
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|parse_escape
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
return|return
literal|0177
return|;
return|return
operator|(
name|c
operator|&
literal|0200
operator|)
operator||
operator|(
name|c
operator|&
literal|037
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|&=
operator|(
literal|1
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|"octal character constant does not fit in a byte"
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
case|case
literal|'x'
case|:
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|&=
operator|(
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|"hex character constant does not fit in a byte"
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_function
name|void
name|yyerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|parse_return_error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the entry point to this file.  */
end_comment

begin_comment
comment|/* Parse STRING as an expression, and complain if this fails    to use up all of the contents of STRING.  */
end_comment

begin_comment
comment|/* We do not support C comments.  They should be removed before    this function is called.  */
end_comment

begin_function
name|int
name|parse_c_expression
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|lexptr
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|lexptr
operator|==
literal|0
operator|||
operator|*
name|lexptr
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty #if expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* don't include the #if group */
block|}
comment|/* if there is some sort of scanning error, just return 0 and assume      the parsing routine has printed an error message somewhere.      there is surely a better thing to do than this.     */
if|if
condition|(
name|setjmp
argument_list|(
name|parse_return_error
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|yyparse
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* actually this is never reached 				   the way things stand. */
if|if
condition|(
operator|*
name|lexptr
condition|)
name|error
argument_list|(
literal|"Junk after end of expression."
argument_list|)
expr_stmt|;
return|return
name|expression_value
return|;
comment|/* set by yyparse () */
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_EXP_READER
end_ifdef

begin_comment
comment|/* main program, for testing purposes. */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|extern
name|int
name|yydebug
decl_stmt|;
comment|/*   yydebug = 1; */
name|initialize_random_junk
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"enter expression: "
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|buf
index|[
name|n
index|]
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|buf
index|[
name|n
index|]
operator|!=
name|EOF
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|n
index|]
operator|==
name|EOF
condition|)
break|break;
name|buf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"parser returned %d\n"
argument_list|,
name|parse_c_expression
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* table to tell if char can be part of a C identifier. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be first char of a c identifier. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal space.  isspace () thinks that    newline is space; this is not a good idea for this program. */
end_comment

begin_decl_stmt
name|char
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * initialize random junk in the hash table and maybe other places  */
end_comment

begin_macro
name|initialize_random_junk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Set up is_idchar and is_idstart tables.  These should be    * faster than saying (is_alpha (c) || c == '_'), etc.    * Must do set up these things before calling any routines tthat    * refer to them.    */
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
operator|++
name|is_idchar
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
expr_stmt|;
operator|++
name|is_idchar
index|[
name|i
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
operator|++
name|is_idchar
index|[
name|i
index|]
expr_stmt|;
operator|++
name|is_idchar
index|[
literal|'_'
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
literal|'_'
index|]
expr_stmt|;
if|#
directive|if
name|DOLLARS_IN_IDENTIFIERS
operator|++
name|is_idchar
index|[
literal|'$'
index|]
expr_stmt|;
operator|++
name|is_idstart
index|[
literal|'$'
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* horizontal space table */
operator|++
name|is_hor_space
index|[
literal|' '
index|]
expr_stmt|;
operator|++
name|is_hor_space
index|[
literal|'\t'
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|msg
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"error: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|warning
argument_list|(
argument|msg
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"warning: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|hashnode
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
return|return
operator|(
name|DEFAULT_SIGNED_CHAR
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
expr|struct
name|hashnode
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

