begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Everything you wanted to know about your machine and C compiler,    but didn't know who to ask.    Author: Steven Pemberton, CWI, Amsterdam; steven@cwi.nl    Bugfixes and upgrades gratefully received.     Name changed to `hard-params' by Richard Stallman, April 89.    xmalloc function defined, Richard Stallman, June 89.    Avoid macro in #include, Richard Stallman, Jan 90.    Undef CHAR_BIT, etc., if defined in stdio.h, Richard Stallman, Aug 90.     Copyright (c) 1988, 1989 Steven Pemberton, CWI, Amsterdam.    All rights reserved.     COMPILING    With luck and a following wind, just the following will work: 	cc hard-params.c -o hard-params     If your compiler doesn't support:		add flag: 	signed char (eg pcc)			-DNO_SC 	unsigned char				-DNO_UC 	unsigned short and long			-DNO_UI 	signal(), or setjmp/longjmp()		-DNO_SIG     Try it first with no flags, and see if you get any errors - you might be    surprised. (Most non-ANSI compilers need -DNO_SC, though.)    Some compilers need a -f flag for floating point.     Don't use any optimisation flags: the program may not work if you do.    Though "while (a+1.0-a-1.0 == 0.0)" may look like "while(1)" to an    optimiser, to a floating-point unit there's a world of difference.     Some compilers offer various flags for different floating point    modes; it's worth trying all possible combinations of these.     Add -DID=\"name\" if you want the machine/flags identified in the output.     SYSTEM DEPENDENCIES    You may possibly need to add some calls to signal() for other sorts of    exception on your machine than SIGFPE, and SIGOVER.  See lines beginning    #ifdef SIGxxx in main() (and communicate the differences to me!).     If your C preprocessor doesn't have the predefined __FILE__ macro, and    you want to call this file anything other than hard-params.c, change the    #define command for __FILE__ accordingly.  If it doesn't accept macro    names at all in #include lines, order a new C compiler. While you're    waiting for it to arrive, change the last #include in this file (the    last but one line) accordingly.     OUTPUT    Run without argument to get the information as English text.  If run    with argument -l (e.g. hard-params -l), output is a series of #define's for    the ANSI standard limits.h include file, excluding MB_MAX_CHAR.  If run    with argument -f, output is a series of #define's for the ANSI standard    float.h include file.  Flag -v gives verbose output: output includes the    English text above as C comments.  The program exit(0)'s if everything    went ok, otherwise it exits with a positive number, telling how many    problems there were.     VERIFYING THE COMPILER    If, having produced the float.h and limits.h header files, you want to    verify that the compiler reads them back correctly (there are a lot of    boundary cases, of course, like minimum and maximum numbers), you can    recompile hard-params.c with -DVERIFY set (plus the other flags that you used    when compiling the version that produced the header files).  This then    recompiles the program so that it #includes "limits.h" and "float.h",    and checks that the constants it finds there are the same as the    constants it produces. Run the resulting program with hard-params -fl.  As of    this writing, of 21 compiler/flags combinations only 1 compiler has    passed without error! (The honour goes to 'pcc' on an IBM RT.)     You can also use this option if your compiler already has both files,    and you want to confirm that this program produces the right results.     TROUBLE SHOOTING.    This program is now quite trustworthy, and suspicious and wrong output    may well be caused by bugs in the compiler, not in the program (however    of course, this is not guaranteed, and no responsibility can be    accepted, etc.)     The program only works if overflows are ignored by the C system or    are catchable with signal().     If the program fails to run to completion (often with the error message    "Unexpected signal at point x"), this often turns out to be a bug in the    C compiler's run-time system. Check what was about to be printed, and    try to narrow the problem down.     Another possible problem is that you have compiled the program to produce    loss-of-precision arithmetic traps. The program cannot cope with these,    and you should re-compile without them. (They should never be the default).     Make sure you compiled with optimisation turned off.     Output preceded by *** WARNING: identifies behaviour of the C system    deemed incorrect by the program. Likely problems are that printf or    scanf don't cope properly with certain boundary numbers.  For each float    and double that is printed, the printed value is checked that it is    correct by using sscanf to read it back.  Care is taken that numbers are    printed with enough digits to uniquely identify them, and therefore that    they can be read back identically. If the number read back is different,    the program prints a warning message. If the two numbers in the warning    look identical, then printf is more than likely rounding the last    digit(s) incorrectly.  To put you at ease that the two really are    different, the bit patterns of the two numbers are also printed.  The    difference is very likely in the last bit.  Many scanf's read the    minimum double back as 0.0, and similarly cause overflow when reading    the maximum double.  The program quite ruthlessly declares all these    behaviours faulty.     The warning that "a cast didn't work" refers to cases like this:        float f;       #define C 1.234567890123456789       f= C;       if (f != (float) C) printf ("Wrong!");     A faulty compiler will widen f to double and ignore the cast to float,    and because there is more accuracy in a double than a float, fail to    recognise that they are the same. In the actual case in point, f and C    are passed as parameters to a function that discovers they are not equal,    so it's just possible that the error was in the parameter passing,    not in the cast (see function Validate()).    For ANSI C, which has float constants, the error message is "constant has    wrong precision".     REPORTING PROBLEMS    If the program doesn't work for you for any reason that can't be    narrowed down to a problem in the C compiler, or it has to be changed in    order to get it to compile, or it produces suspicious output (like a very    low maximum float, for instance), please mail the problem and an example    of the incorrect output to steven@cwi.nl or mcvax!steven.uucp, so that    improvements can be worked into future versions; mcvax/cwi.nl is the    European backbone, and is connected to uunet and other fine hosts.     This version of the program is the first to try to catch and diagnose    bugs in the compiler/run-time system. I would be especially pleased to    have reports of failures so that I can improve this service.     I apologise unreservedly for the contorted use of the preprocessor...     THE SMALL PRINT    You may copy and distribute verbatim copies of this source file.     You may modify this source file, and copy and distribute such    modified versions, provided that you leave the copyright notice    at the top of the file and also cause the modified file to carry    prominent notices stating that you changed the files and the date    of any change; and cause the whole of any work that you distribute    or publish, that in whole or in part contains or is a derivative of    this program or any part thereof, to be licensed at no charge to    all third parties on terms identical to those here.     If you do have a fix to any problem, please send it to me, so that    other people can have the benefits.     While every effort has been taken to make this program as reliable as    possible, no responsibility can be taken for the correctness of the    output, or suitability for any particular use.     ACKNOWLEDGEMENTS    Many people have given time and ideas to making this program what it is.    To all of them thanks, and apologies for not mentioning them by name. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__FILE__
end_ifndef

begin_define
define|#
directive|define
name|__FILE__
value|"hard-params.c"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PASS
end_ifndef

begin_define
define|#
directive|define
name|PASS
value|1
end_define

begin_define
define|#
directive|define
name|PASS1
value|1
end_define

begin_define
define|#
directive|define
name|VERSION
value|"4.1"
end_define

begin_comment
comment|/* Procedure just marks the functions that don't return a result */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Procedure
end_ifdef

begin_undef
undef|#
directive|undef
name|Procedure
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Procedure
end_define

begin_define
define|#
directive|define
name|Vprintf
value|if (V) printf
end_define

begin_comment
comment|/* stdc is used in tests like if (stdc) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|stdc
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|stdc
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* volatile is used to reduce the chance of optimisation,    and to prevent variables being put in registers (when setjmp/longjmp    wouldn't work as we want)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_define
define|#
directive|define
name|volatile
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Kludge around the possiblity that<stdio.h> includes<limits.h> */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_BIT
end_ifdef

begin_undef
undef|#
directive|undef
name|CHAR_BIT
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MAX
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_MIN
end_undef

begin_undef
undef|#
directive|undef
name|SCHAR_MAX
end_undef

begin_undef
undef|#
directive|undef
name|SCHAR_MIN
end_undef

begin_undef
undef|#
directive|undef
name|UCHAR_MAX
end_undef

begin_undef
undef|#
directive|undef
name|UCHAR_MIN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_include
include|#
directive|include
file|"limits.h"
end_include

begin_include
include|#
directive|include
file|"float.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SIG
end_ifdef

begin_comment
comment|/* There's no signal(), or setjmp/longjmp() */
end_comment

begin_comment
comment|/* Dummy routines instead */
end_comment

begin_decl_stmt
name|int
name|lab
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|setjmp
parameter_list|(
name|lab
parameter_list|)
name|int
name|lab
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|signal
argument_list|(
argument|i
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|,
argument_list|(
operator|*
name|p
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{}
end_block

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|jmp_buf
name|lab
decl_stmt|;
end_decl_stmt

begin_macro
name|overflow
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* what to do on overflow/underflow */
name|signal
argument_list|(
name|sig
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NO_SIG*/
end_comment

begin_define
define|#
directive|define
name|Unexpected
parameter_list|(
name|place
parameter_list|)
value|if (setjmp(lab)!=0) croak(place)
end_define

begin_decl_stmt
name|int
name|V
init|=
literal|0
decl_stmt|,
comment|/* verbose */
name|L
init|=
literal|0
decl_stmt|,
comment|/* produce limits.h */
name|F
init|=
literal|0
decl_stmt|,
comment|/* produce float.h  */
name|bugs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of (possible) bugs in the output */
end_comment

begin_decl_stmt
name|char
name|co
index|[
literal|4
index|]
decl_stmt|,
name|oc
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Comment starter and ender symbols */
end_comment

begin_decl_stmt
name|int
name|bits_per_byte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the number of bits per unit returned by sizeof() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Set the fp modes on a SUN with 68881 chip, to check that different    rounding modes etc. get properly detected.    Compile with additional flag -DTEST, and run with additional parameter    +hex-number, to set the 68881 mode register to hex-number */
end_comment

begin_comment
comment|/* Bits 0x30 = rounding mode: */
end_comment

begin_define
define|#
directive|define
name|ROUND_BITS
value|0x30
end_define

begin_define
define|#
directive|define
name|TO_NEAREST
value|0x00
end_define

begin_define
define|#
directive|define
name|TO_ZERO
value|0x10
end_define

begin_define
define|#
directive|define
name|TO_MINUS_INF
value|0x20
end_define

begin_define
define|#
directive|define
name|TO_PLUS_INF
value|0x30
end_define

begin_comment
comment|/* The SUN FP user's guide seems to be wrong here */
end_comment

begin_comment
comment|/* Bits 0xc0 = extended rounding: */
end_comment

begin_define
define|#
directive|define
name|EXT_BITS
value|0xc0
end_define

begin_define
define|#
directive|define
name|ROUND_EXTENDED
value|0x00
end_define

begin_define
define|#
directive|define
name|ROUND_SINGLE
value|0x40
end_define

begin_define
define|#
directive|define
name|ROUND_DOUBLE
value|0x80
end_define

begin_comment
comment|/* Enabled traps: */
end_comment

begin_define
define|#
directive|define
name|EXE_INEX1
value|0x100
end_define

begin_define
define|#
directive|define
name|EXE_INEX2
value|0x200
end_define

begin_define
define|#
directive|define
name|EXE_DZ
value|0x400
end_define

begin_define
define|#
directive|define
name|EXE_UNFL
value|0x800
end_define

begin_define
define|#
directive|define
name|EXE_OVFL
value|0x1000
end_define

begin_define
define|#
directive|define
name|EXE_OPERR
value|0x2000
end_define

begin_define
define|#
directive|define
name|EXE_SNAN
value|0x4000
end_define

begin_define
define|#
directive|define
name|EXE_BSUN
value|0x8000
end_define

begin_macro
name|printmode
argument_list|(
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|new
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fpmode_
argument_list|(
operator|&
name|new
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"New fp mode:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Round toward "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new
operator|&
name|ROUND_BITS
condition|)
block|{
case|case
name|TO_NEAREST
case|:
name|printf
argument_list|(
literal|"nearest"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TO_ZERO
case|:
name|printf
argument_list|(
literal|"zero"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TO_MINUS_INF
case|:
name|printf
argument_list|(
literal|"minus infinity"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TO_PLUS_INF
case|:
name|printf
argument_list|(
literal|"plus infinity"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n  Extended rounding precision: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new
operator|&
name|EXT_BITS
condition|)
block|{
case|case
name|ROUND_EXTENDED
case|:
name|printf
argument_list|(
literal|"extended"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROUND_SINGLE
case|:
name|printf
argument_list|(
literal|"single"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROUND_DOUBLE
case|:
name|printf
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n  Enabled exceptions:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_INEX1
condition|)
name|printf
argument_list|(
literal|" inex1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_INEX2
condition|)
name|printf
argument_list|(
literal|" inex2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_DZ
condition|)
name|printf
argument_list|(
literal|" dz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_UNFL
condition|)
name|printf
argument_list|(
literal|" unfl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_OVFL
condition|)
name|printf
argument_list|(
literal|" ovfl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_OPERR
condition|)
name|printf
argument_list|(
literal|" operr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_SNAN
condition|)
name|printf
argument_list|(
literal|" snan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&
operator|(
name|unsigned
operator|)
name|EXE_BSUN
condition|)
name|printf
argument_list|(
literal|" bsun"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|setmode
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|mode
init|=
literal|0
decl_stmt|,
name|dig
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|dig
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|dig
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|dig
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|1
return|;
name|mode
operator|=
name|mode
operator|<<
literal|4
operator||
name|dig
expr_stmt|;
block|}
name|printmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|setmode
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't set mode: not compiled with TEST\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|croak
argument_list|(
argument|place
argument_list|)
end_macro

begin_decl_stmt
name|int
name|place
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"*** Unexpected signal at point %d\n"
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|bugs
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* An exit isn't essential here, but avoids loops */
block|}
end_block

begin_comment
comment|/* This is here in case alloca.c is used.  That wants to call this.  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|char
modifier|*
name|value
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Virtual memory exceeded\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|bugs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|dprec
decl_stmt|,
name|fprec
decl_stmt|,
name|lprec
decl_stmt|,
name|basic
argument_list|()
decl_stmt|,
name|fprop
argument_list|()
decl_stmt|,
name|dprop
argument_list|()
decl_stmt|,
name|efprop
argument_list|()
decl_stmt|,
name|edprop
argument_list|()
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|unsigned
name|int
name|size
decl_stmt|;
name|long
name|total
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|bad
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGFPE
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGOVER
name|signal
argument_list|(
name|SIGOVER
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add more calls as necessary */
name|Unexpected
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|s
operator|++
operator|)
condition|)
block|{
case|case
literal|'v'
case|:
name|V
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|L
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|F
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|bad
operator|=
name|setmode
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-vlf]\n  v=Verbose l=Limits.h f=Float.h\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|L
operator|||
name|F
condition|)
block|{
name|co
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|oc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|co
index|[
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|oc
index|[
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|co
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
name|oc
index|[
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
name|co
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|oc
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|co
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|oc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|V
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|L
condition|)
name|printf
argument_list|(
literal|"%slimits.h%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|printf
argument_list|(
literal|"%sfloat.h%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID
name|printf
argument_list|(
literal|"%sProduced on %s by hard-params version %s, CWI, Amsterdam%s\n"
argument_list|,
name|co
argument_list|,
name|ID
argument_list|,
name|VERSION
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%sProduced by hard-params version %s, CWI, Amsterdam%s\n"
argument_list|,
name|co
argument_list|,
name|VERSION
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VERIFY
name|printf
argument_list|(
literal|"%sVerification phase%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SIG
name|Vprintf
argument_list|(
literal|"%sCompiled without signal(): %s%s\n"
argument_list|,
name|co
argument_list|,
literal|"there's nothing that can be done if overflow occurs"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SC
name|Vprintf
argument_list|(
literal|"%sCompiled without signed char%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_UC
name|Vprintf
argument_list|(
literal|"%Compiled without unsigned char%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_UI
name|Vprintf
argument_list|(
literal|"%Compiled without unsigned short or long%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__STDC__
name|Vprintf
argument_list|(
literal|"%sCompiler claims to be ANSI C level %d%s\n"
argument_list|,
name|co
argument_list|,
name|__STDC__
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|#
directive|else
name|Vprintf
argument_list|(
literal|"%sCompiler does not claim to be ANSI C%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bits_per_byte
operator|=
name|basic
argument_list|()
expr_stmt|;
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
operator|||
name|V
condition|)
block|{
name|fprec
operator|=
name|fprop
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
name|dprec
operator|=
name|dprop
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
name|lprec
operator|=
name|ldprop
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
name|efprop
argument_list|(
name|fprec
argument_list|,
name|dprec
argument_list|,
name|lprec
argument_list|)
expr_stmt|;
name|edprop
argument_list|(
name|fprec
argument_list|,
name|dprec
argument_list|,
name|lprec
argument_list|)
expr_stmt|;
name|eldprop
argument_list|(
name|fprec
argument_list|,
name|dprec
argument_list|,
name|lprec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|V
condition|)
block|{
comment|/* An extra goody: the approximate amount of data-space */
comment|/* Allocate store until no more available */
name|size
operator|=
literal|1
operator|<<
operator|(
operator|(
name|bits_per_byte
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|2
operator|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|total
operator|+=
operator|(
name|size
operator|/
literal|2
operator|)
expr_stmt|;
name|size
operator|/=
literal|2
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sMemory mallocatable ~= %ld Kbytes%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|total
operator|+
literal|511
operator|)
operator|/
literal|512
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|bugs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Procedure
name|eek_a_bug
parameter_list|(
name|problem
parameter_list|)
name|char
modifier|*
name|problem
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\n%s*** WARNING: %s%s\n"
argument_list|,
name|co
argument_list|,
name|problem
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Procedure
name|i_define
parameter_list|(
name|sort
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|)
name|char
modifier|*
name|sort
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|val
decl_stmt|,
name|req
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"#define %s%s %ld\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"#define %s%s (%ld)\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
name|req
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       Compiler has %ld for value%s\n\n"
argument_list|,
name|req
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UI
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|U
value|"U"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|U
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Procedure
name|u_define
parameter_list|(
name|sort
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|)
name|char
modifier|*
name|sort
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|long
name|val
decl_stmt|,
name|req
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"#define %s%s %lu%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|U
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|req
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       Compiler has %lu for value%s\n\n"
argument_list|,
name|req
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Long_double is the longest floating point type available: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|Long_double
value|long double
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Long_double
value|double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|f_rep
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Procedure
name|f_define
parameter_list|(
name|sort
parameter_list|,
name|name
parameter_list|,
name|precision
parameter_list|,
name|val
parameter_list|,
name|mark
parameter_list|)
name|char
modifier|*
name|sort
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|precision
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Long_double
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mark
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|stdc
condition|)
block|{
name|printf
argument_list|(
literal|"#define %s%s %s%s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mark
operator|==
literal|'F'
condition|)
block|{
comment|/* non-ANSI C has no float constants, so cast the constant */
name|printf
argument_list|(
literal|"#define %s%s ((float)%s)\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"#define %s%s %s\n"
argument_list|,
name|sort
argument_list|,
name|name
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|floor_log
parameter_list|(
name|base
parameter_list|,
name|x
parameter_list|)
name|int
name|base
decl_stmt|;
name|Long_double
name|x
decl_stmt|;
block|{
comment|/* return floor(log base(x)) */
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|>=
name|base
condition|)
block|{
name|r
operator|++
expr_stmt|;
name|x
operator|/=
name|base
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ceil_log
parameter_list|(
name|base
parameter_list|,
name|x
parameter_list|)
name|int
name|base
decl_stmt|;
name|Long_double
name|x
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|>
literal|1.0
condition|)
block|{
name|r
operator|++
expr_stmt|;
name|x
operator|/=
name|base
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|exponent
parameter_list|(
name|x
parameter_list|,
name|fract
parameter_list|,
name|exp
parameter_list|)
name|Long_double
name|x
decl_stmt|;
name|double
modifier|*
name|fract
decl_stmt|;
name|int
modifier|*
name|exp
decl_stmt|;
block|{
comment|/* Split x into a fraction and a power of ten; 	   returns 0 if x is unusable, 1 otherwise. 	   Only used for error messages about faulty output. 	*/
name|int
name|r
init|=
literal|0
decl_stmt|,
name|neg
init|=
literal|0
decl_stmt|;
name|Long_double
name|old
decl_stmt|;
operator|*
name|fract
operator|=
literal|0.0
expr_stmt|;
operator|*
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0.0
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|neg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0.0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|>=
literal|10.0
condition|)
block|{
while|while
condition|(
name|x
operator|>=
literal|10.0
condition|)
block|{
name|old
operator|=
name|x
expr_stmt|;
name|r
operator|++
expr_stmt|;
name|x
operator|/=
literal|10.0
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|x
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|x
operator|<
literal|1.0
condition|)
block|{
name|old
operator|=
name|x
expr_stmt|;
name|r
operator|--
expr_stmt|;
name|x
operator|*=
literal|10.0
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|x
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|neg
condition|)
operator|*
name|fract
operator|=
operator|-
name|x
expr_stmt|;
else|else
operator|*
name|fract
operator|=
name|x
expr_stmt|;
operator|*
name|exp
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fabs
parameter_list|(
name|x
parameter_list|)
value|(((x)<0.0)?(-x):(x))
end_define

begin_function
name|char
modifier|*
name|f_rep
parameter_list|(
name|precision
parameter_list|,
name|val
parameter_list|)
name|int
name|precision
decl_stmt|;
name|Long_double
name|val
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
condition|)
block|{
comment|/* Assume they're the same, and use non-stdc format */
comment|/* This is for stdc compilers using non-stdc libraries */
name|f1
operator|=
literal|"%.*e"
expr_stmt|;
block|}
else|else
block|{
comment|/* It had better support Le then */
name|f1
operator|=
literal|"%.*Le"
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
name|f1
argument_list|,
name|precision
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|Procedure
name|bitpattern
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|size
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bits_per_byte
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|c
operator|>>
name|j
operator|)
operator|&
literal|1
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|size
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|Order
parameter_list|(
name|x
parameter_list|,
name|px
parameter_list|,
name|mode
parameter_list|)
define|\
value|printf("%s    %s ", co, mode); for (i=0; i<sizeof(x); i++) px[i]= c[i]; \    for (i=1; i<=sizeof(x); i++) { putchar((char)((x>>(bits_per_byte*(sizeof(x)-i)))&mask)); }\    printf("%s\n", oc);
end_define

begin_function
name|Procedure
name|endian
parameter_list|(
name|bits_per_byte
parameter_list|)
name|int
name|bits_per_byte
decl_stmt|;
block|{
comment|/*unsigned*/
name|short
name|s
init|=
literal|0
decl_stmt|;
comment|/*unsigned*/
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|/*unsigned*/
name|long
name|l
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ps
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|s
decl_stmt|,
modifier|*
name|pj
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|j
decl_stmt|,
modifier|*
name|pl
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l
decl_stmt|,
modifier|*
name|c
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|bits_per_byte
condition|;
name|i
operator|++
control|)
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
name|V
condition|)
block|{
name|printf
argument_list|(
literal|"%sCharacter order:%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Order
argument_list|(
name|s
argument_list|,
name|ps
argument_list|,
literal|"short:"
argument_list|)
expr_stmt|;
name|Order
argument_list|(
name|j
argument_list|,
name|pj
argument_list|,
literal|"int:  "
argument_list|)
expr_stmt|;
name|Order
argument_list|(
name|l
argument_list|,
name|pl
argument_list|,
literal|"long: "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|SCHAR_MAX
value|char_max
end_define

begin_define
define|#
directive|define
name|SCHAR_MIN
value|char_min
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHAR_BIT
value|char_bit
end_define

begin_define
define|#
directive|define
name|CHAR_MAX
value|char_max
end_define

begin_define
define|#
directive|define
name|CHAR_MIN
value|char_min
end_define

begin_define
define|#
directive|define
name|SCHAR_MAX
value|char_max
end_define

begin_define
define|#
directive|define
name|SCHAR_MIN
value|char_min
end_define

begin_define
define|#
directive|define
name|UCHAR_MAX
value|char_max
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERIFY */
end_comment

begin_function
name|int
name|cprop
parameter_list|()
block|{
comment|/* Properties of character */
specifier|volatile
name|char
name|c
decl_stmt|,
name|char_max
decl_stmt|,
name|char_min
decl_stmt|;
specifier|volatile
name|int
name|bits_per_byte
decl_stmt|,
name|is_signed
decl_stmt|;
name|long
name|char_bit
decl_stmt|;
name|Unexpected
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Calculate number of bits per character *************************/
name|c
operator|=
literal|1
expr_stmt|;
name|bits_per_byte
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
name|c
operator|<<
literal|1
expr_stmt|;
name|bits_per_byte
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|c
operator|)
operator|<
literal|0
condition|)
name|is_signed
operator|=
literal|1
expr_stmt|;
else|else
name|is_signed
operator|=
literal|0
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sChar = %d bits, %ssigned%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|c
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|is_signed
condition|?
literal|""
else|:
literal|"un"
operator|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|char_bit
operator|=
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|c
argument_list|)
operator|*
name|bits_per_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|i_define
argument_list|(
literal|"CHAR"
argument_list|,
literal|"_BIT"
argument_list|,
name|char_bit
argument_list|,
operator|(
name|long
operator|)
name|CHAR_BIT
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_max
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_max */
while|while
condition|(
name|c
operator|>
name|char_max
condition|)
block|{
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sCharacter overflow generates a trap!%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
name|char_min
operator|=
literal|0
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_min */
while|while
condition|(
name|c
operator|<
name|char_min
condition|)
block|{
name|char_min
operator|=
name|c
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
block|{
name|i_define
argument_list|(
literal|"CHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|CHAR_MAX
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
literal|"CHAR"
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|char_min
argument_list|,
operator|(
name|long
operator|)
name|CHAR_MIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_signed
condition|)
block|{
name|i_define
argument_list|(
literal|"SCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MAX
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
literal|"SCHAR"
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|char_min
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i_define
argument_list|(
literal|"UCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|UCHAR_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_signed
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_UC
specifier|volatile
name|unsigned
name|char
name|c
decl_stmt|,
name|char_max
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_max
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_max */
while|while
condition|(
name|c
operator|>
name|char_max
condition|)
block|{
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
literal|"UCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|UCHAR_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_SC
comment|/* Define NO_SC if the next line gives a syntax error */
specifier|volatile
name|signed
name|char
name|c
decl_stmt|,
name|char_max
decl_stmt|,
name|char_min
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|char_max
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_max */
while|while
condition|(
name|c
operator|>
name|char_max
condition|)
block|{
name|char_max
operator|=
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|c
operator|=
literal|0
expr_stmt|;
name|char_min
operator|=
literal|0
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields char_min */
while|while
condition|(
name|c
operator|<
name|char_min
condition|)
block|{
name|char_min
operator|=
name|c
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
literal|"SCHAR"
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|char_min
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MIN
argument_list|)
expr_stmt|;
name|i_define
argument_list|(
literal|"SCHAR"
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|char_max
argument_list|,
operator|(
name|long
operator|)
name|SCHAR_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NO_SC */
block|}
block|}
return|return
name|bits_per_byte
return|;
block|}
end_function

begin_function
name|int
name|basic
parameter_list|()
block|{
comment|/* The properties of the basic types. 	   Returns number of bits per sizeof unit */
specifier|volatile
name|int
name|bits_per_byte
decl_stmt|;
name|bits_per_byte
operator|=
name|cprop
argument_list|()
expr_stmt|;
comment|/* Shorts, ints and longs *****************************************/
name|Vprintf
argument_list|(
literal|"%sShort=%d int=%d long=%d float=%d double=%d bits %s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdc
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sLong double=%d bits%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sChar pointers = %d bits%s%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|?
literal|" BEWARE! larger than int!"
else|:
literal|""
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sInt pointers = %d bits%s%s\n"
argument_list|,
name|co
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
name|bits_per_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|?
literal|" BEWARE! larger than int!"
else|:
literal|""
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|sprop
argument_list|()
expr_stmt|;
name|iprop
argument_list|()
expr_stmt|;
name|lprop
argument_list|()
expr_stmt|;
name|usprop
argument_list|()
expr_stmt|;
name|uiprop
argument_list|()
expr_stmt|;
name|ulprop
argument_list|()
expr_stmt|;
name|Unexpected
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* Alignment constants ********************************************/
name|Vprintf
argument_list|(
literal|"%sAlignments used for char=%d short=%d int=%d long=%d%s\n"
argument_list|,
argument|co
argument_list|,
argument|(int)sizeof(struct{char i1; char c1;})-(int)sizeof(char)
argument_list|,
argument|(int)sizeof(struct{short i2; char c2;})-(int)sizeof(short)
argument_list|,
argument|(int)sizeof(struct{int i3; char c3;})-(int)sizeof(int)
argument_list|,
argument|(int)sizeof(struct{long i4; char c4;})-(int)sizeof(long)
argument_list|,
argument|oc
argument_list|)
empty_stmt|;
comment|/* Ten little endians *********************************************/
name|endian
argument_list|(
name|bits_per_byte
argument_list|)
expr_stmt|;
comment|/* Pointers *******************************************************/
if|if
condition|(
name|V
condition|)
block|{
if|if
condition|(
literal|"abcd"
operator|==
literal|"abcd"
condition|)
name|printf
argument_list|(
literal|"%sStrings are shared%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%sStrings are not shared%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
return|return
name|bits_per_byte
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifndef PASS */
end_comment

begin_comment
comment|/* As I said, I apologise for the contortions below. The functions are    expanded by the preprocessor twice or three times (for float and double,    and maybe for long double, and for short, int and long). That way,    I never make a change to one that I forget to make to the other.    You can look on it as C's fault for not supporting multi-line macro's.    This whole file is read 3 times by the preprocessor, with PASSn set for    n=1, 2 or 3, to decide which parts to reprocess. */
end_comment

begin_comment
comment|/* #undef on an already undefined thing is (wrongly) flagged as an error    by some compilers, therefore the #ifdef that follows:  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Number
end_ifdef

begin_undef
undef|#
directive|undef
name|Number
end_undef

begin_undef
undef|#
directive|undef
name|THING
end_undef

begin_undef
undef|#
directive|undef
name|Thing
end_undef

begin_undef
undef|#
directive|undef
name|thing
end_undef

begin_undef
undef|#
directive|undef
name|FPROP
end_undef

begin_undef
undef|#
directive|undef
name|Fname
end_undef

begin_undef
undef|#
directive|undef
name|Store
end_undef

begin_undef
undef|#
directive|undef
name|Sum
end_undef

begin_undef
undef|#
directive|undef
name|Diff
end_undef

begin_undef
undef|#
directive|undef
name|Mul
end_undef

begin_undef
undef|#
directive|undef
name|Div
end_undef

begin_undef
undef|#
directive|undef
name|Self
end_undef

begin_undef
undef|#
directive|undef
name|F_check
end_undef

begin_undef
undef|#
directive|undef
name|Validate
end_undef

begin_undef
undef|#
directive|undef
name|EPROP
end_undef

begin_undef
undef|#
directive|undef
name|MARK
end_undef

begin_undef
undef|#
directive|undef
name|F_RADIX
end_undef

begin_undef
undef|#
directive|undef
name|F_MANT_DIG
end_undef

begin_undef
undef|#
directive|undef
name|F_DIG
end_undef

begin_undef
undef|#
directive|undef
name|F_ROUNDS
end_undef

begin_undef
undef|#
directive|undef
name|F_EPSILON
end_undef

begin_undef
undef|#
directive|undef
name|F_MIN_EXP
end_undef

begin_undef
undef|#
directive|undef
name|F_MIN
end_undef

begin_undef
undef|#
directive|undef
name|F_MIN_10_EXP
end_undef

begin_undef
undef|#
directive|undef
name|F_MAX_EXP
end_undef

begin_undef
undef|#
directive|undef
name|F_MAX
end_undef

begin_undef
undef|#
directive|undef
name|F_MAX_10_EXP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Integer
end_ifdef

begin_undef
undef|#
directive|undef
name|Integer
end_undef

begin_undef
undef|#
directive|undef
name|INT
end_undef

begin_undef
undef|#
directive|undef
name|IPROP
end_undef

begin_undef
undef|#
directive|undef
name|Iname
end_undef

begin_undef
undef|#
directive|undef
name|UPROP
end_undef

begin_undef
undef|#
directive|undef
name|Uname
end_undef

begin_undef
undef|#
directive|undef
name|OK_UI
end_undef

begin_undef
undef|#
directive|undef
name|I_MAX
end_undef

begin_undef
undef|#
directive|undef
name|I_MIN
end_undef

begin_undef
undef|#
directive|undef
name|U_MAX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS1
end_ifdef

begin_define
define|#
directive|define
name|Number
value|float
end_define

begin_define
define|#
directive|define
name|THING
value|"FLOAT"
end_define

begin_define
define|#
directive|define
name|Thing
value|"Float"
end_define

begin_define
define|#
directive|define
name|thing
value|"float"
end_define

begin_define
define|#
directive|define
name|Fname
value|"FLT"
end_define

begin_define
define|#
directive|define
name|FPROP
value|fprop
end_define

begin_define
define|#
directive|define
name|Store
value|fStore
end_define

begin_define
define|#
directive|define
name|Sum
value|fSum
end_define

begin_define
define|#
directive|define
name|Diff
value|fDiff
end_define

begin_define
define|#
directive|define
name|Mul
value|fMul
end_define

begin_define
define|#
directive|define
name|Div
value|fDiv
end_define

begin_define
define|#
directive|define
name|Self
value|fSelf
end_define

begin_define
define|#
directive|define
name|F_check
value|fCheck
end_define

begin_define
define|#
directive|define
name|Validate
value|fValidate
end_define

begin_define
define|#
directive|define
name|MARK
value|"F"
end_define

begin_define
define|#
directive|define
name|EPROP
value|efprop
end_define

begin_define
define|#
directive|define
name|Integer
value|short
end_define

begin_define
define|#
directive|define
name|INT
value|"short"
end_define

begin_define
define|#
directive|define
name|IPROP
value|sprop
end_define

begin_define
define|#
directive|define
name|Iname
value|"SHRT"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UI
end_ifndef

begin_define
define|#
directive|define
name|OK_UI
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UPROP
value|usprop
end_define

begin_define
define|#
directive|define
name|Uname
value|"USHRT"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_define
define|#
directive|define
name|I_MAX
value|SHRT_MAX
end_define

begin_define
define|#
directive|define
name|I_MIN
value|SHRT_MIN
end_define

begin_define
define|#
directive|define
name|U_MAX
value|USHRT_MAX
end_define

begin_define
define|#
directive|define
name|F_RADIX
value|FLT_RADIX
end_define

begin_define
define|#
directive|define
name|F_MANT_DIG
value|FLT_MANT_DIG
end_define

begin_define
define|#
directive|define
name|F_DIG
value|FLT_DIG
end_define

begin_define
define|#
directive|define
name|F_ROUNDS
value|FLT_ROUNDS
end_define

begin_define
define|#
directive|define
name|F_EPSILON
value|FLT_EPSILON
end_define

begin_define
define|#
directive|define
name|F_MIN_EXP
value|FLT_MIN_EXP
end_define

begin_define
define|#
directive|define
name|F_MIN
value|FLT_MIN
end_define

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|FLT_MIN_10_EXP
end_define

begin_define
define|#
directive|define
name|F_MAX_EXP
value|FLT_MAX_EXP
end_define

begin_define
define|#
directive|define
name|F_MAX
value|FLT_MAX
end_define

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|FLT_MAX_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERIFY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS2
end_ifdef

begin_define
define|#
directive|define
name|Number
value|double
end_define

begin_define
define|#
directive|define
name|THING
value|"DOUBLE"
end_define

begin_define
define|#
directive|define
name|Thing
value|"Double"
end_define

begin_define
define|#
directive|define
name|thing
value|"double"
end_define

begin_define
define|#
directive|define
name|Fname
value|"DBL"
end_define

begin_define
define|#
directive|define
name|FPROP
value|dprop
end_define

begin_define
define|#
directive|define
name|Store
value|dStore
end_define

begin_define
define|#
directive|define
name|Sum
value|dSum
end_define

begin_define
define|#
directive|define
name|Diff
value|dDiff
end_define

begin_define
define|#
directive|define
name|Mul
value|dMul
end_define

begin_define
define|#
directive|define
name|Div
value|dDiv
end_define

begin_define
define|#
directive|define
name|Self
value|dSelf
end_define

begin_define
define|#
directive|define
name|F_check
value|dCheck
end_define

begin_define
define|#
directive|define
name|Validate
value|dValidate
end_define

begin_define
define|#
directive|define
name|MARK
value|""
end_define

begin_define
define|#
directive|define
name|EPROP
value|edprop
end_define

begin_define
define|#
directive|define
name|Integer
value|int
end_define

begin_define
define|#
directive|define
name|INT
value|"int"
end_define

begin_define
define|#
directive|define
name|IPROP
value|iprop
end_define

begin_define
define|#
directive|define
name|Iname
value|"INT"
end_define

begin_define
define|#
directive|define
name|OK_UI
value|1
end_define

begin_comment
comment|/* Unsigned int is always possible */
end_comment

begin_define
define|#
directive|define
name|UPROP
value|uiprop
end_define

begin_define
define|#
directive|define
name|Uname
value|"UINT"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_define
define|#
directive|define
name|I_MAX
value|INT_MAX
end_define

begin_define
define|#
directive|define
name|I_MIN
value|INT_MIN
end_define

begin_define
define|#
directive|define
name|U_MAX
value|UINT_MAX
end_define

begin_define
define|#
directive|define
name|F_MANT_DIG
value|DBL_MANT_DIG
end_define

begin_define
define|#
directive|define
name|F_DIG
value|DBL_DIG
end_define

begin_define
define|#
directive|define
name|F_EPSILON
value|DBL_EPSILON
end_define

begin_define
define|#
directive|define
name|F_MIN_EXP
value|DBL_MIN_EXP
end_define

begin_define
define|#
directive|define
name|F_MIN
value|DBL_MIN
end_define

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|DBL_MIN_10_EXP
end_define

begin_define
define|#
directive|define
name|F_MAX_EXP
value|DBL_MAX_EXP
end_define

begin_define
define|#
directive|define
name|F_MAX
value|DBL_MAX
end_define

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|DBL_MAX_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERIFY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS3
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|Number
value|long double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|THING
value|"LONG DOUBLE"
end_define

begin_define
define|#
directive|define
name|Thing
value|"Long double"
end_define

begin_define
define|#
directive|define
name|thing
value|"long double"
end_define

begin_define
define|#
directive|define
name|Fname
value|"LDBL"
end_define

begin_define
define|#
directive|define
name|FPROP
value|ldprop
end_define

begin_define
define|#
directive|define
name|Store
value|ldStore
end_define

begin_define
define|#
directive|define
name|Sum
value|ldSum
end_define

begin_define
define|#
directive|define
name|Diff
value|ldDiff
end_define

begin_define
define|#
directive|define
name|Mul
value|ldMul
end_define

begin_define
define|#
directive|define
name|Div
value|ldDiv
end_define

begin_define
define|#
directive|define
name|Self
value|ldSelf
end_define

begin_define
define|#
directive|define
name|F_check
value|ldCheck
end_define

begin_define
define|#
directive|define
name|Validate
value|ldValidate
end_define

begin_define
define|#
directive|define
name|MARK
value|"L"
end_define

begin_define
define|#
directive|define
name|EPROP
value|eldprop
end_define

begin_define
define|#
directive|define
name|Integer
value|long
end_define

begin_define
define|#
directive|define
name|INT
value|"long"
end_define

begin_define
define|#
directive|define
name|IPROP
value|lprop
end_define

begin_define
define|#
directive|define
name|Iname
value|"LONG"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UI
end_ifndef

begin_define
define|#
directive|define
name|OK_UI
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UPROP
value|ulprop
end_define

begin_define
define|#
directive|define
name|Uname
value|"ULONG"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_define
define|#
directive|define
name|I_MAX
value|LONG_MAX
end_define

begin_define
define|#
directive|define
name|I_MIN
value|LONG_MIN
end_define

begin_define
define|#
directive|define
name|U_MAX
value|ULONG_MAX
end_define

begin_define
define|#
directive|define
name|F_MANT_DIG
value|LDBL_MANT_DIG
end_define

begin_define
define|#
directive|define
name|F_DIG
value|LDBL_DIG
end_define

begin_define
define|#
directive|define
name|F_EPSILON
value|LDBL_EPSILON
end_define

begin_define
define|#
directive|define
name|F_MIN_EXP
value|LDBL_MIN_EXP
end_define

begin_define
define|#
directive|define
name|F_MIN
value|LDBL_MIN
end_define

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|LDBL_MIN_10_EXP
end_define

begin_define
define|#
directive|define
name|F_MAX_EXP
value|LDBL_MAX_EXP
end_define

begin_define
define|#
directive|define
name|F_MAX
value|LDBL_MAX
end_define

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|LDBL_MAX_10_EXP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERIFY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PASS3 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VERIFY
end_ifndef

begin_define
define|#
directive|define
name|I_MAX
value|int_max
end_define

begin_define
define|#
directive|define
name|I_MIN
value|int_min
end_define

begin_define
define|#
directive|define
name|U_MAX
value|int_max
end_define

begin_define
define|#
directive|define
name|F_RADIX
value|f_radix
end_define

begin_define
define|#
directive|define
name|F_MANT_DIG
value|f_mant_dig
end_define

begin_define
define|#
directive|define
name|F_DIG
value|f_dig
end_define

begin_define
define|#
directive|define
name|F_ROUNDS
value|f_rounds
end_define

begin_define
define|#
directive|define
name|F_EPSILON
value|f_epsilon
end_define

begin_define
define|#
directive|define
name|F_MIN_EXP
value|f_min_exp
end_define

begin_define
define|#
directive|define
name|F_MIN
value|f_min
end_define

begin_define
define|#
directive|define
name|F_MIN_10_EXP
value|f_min_10_exp
end_define

begin_define
define|#
directive|define
name|F_MAX_EXP
value|f_max_exp
end_define

begin_define
define|#
directive|define
name|F_MAX
value|f_max
end_define

begin_define
define|#
directive|define
name|F_MAX_10_EXP
value|f_max_10_exp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Procedure
name|IPROP
parameter_list|()
block|{
comment|/* for short, int, and long */
specifier|volatile
name|Integer
name|newi
decl_stmt|,
name|int_max
decl_stmt|,
name|maxeri
decl_stmt|,
name|int_min
decl_stmt|,
name|minneri
decl_stmt|;
specifier|volatile
name|int
name|ibits
decl_stmt|,
name|ipower
decl_stmt|,
name|two
init|=
literal|2
decl_stmt|;
comment|/* Calculate max short/int/long ***********************************/
comment|/* Calculate 2**n-1 until overflow - then use the previous value  */
name|newi
operator|=
literal|1
expr_stmt|;
name|int_max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields int_max */
for|for
control|(
name|ipower
operator|=
literal|0
init|;
name|newi
operator|>
name|int_max
condition|;
name|ipower
operator|++
control|)
block|{
name|int_max
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|*
name|two
operator|+
literal|1
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sOverflow of a%s %s does not generate a trap%s\n"
argument_list|,
name|co
argument_list|,
name|INT
index|[
literal|0
index|]
operator|==
literal|'i'
condition|?
literal|"n"
else|:
literal|""
argument_list|,
name|INT
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sOverflow of a%s %s generates a trap%s\n"
argument_list|,
name|co
argument_list|,
name|INT
index|[
literal|0
index|]
operator|==
literal|'i'
condition|?
literal|"n"
else|:
literal|""
argument_list|,
name|INT
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* Minimum value: assume either two's or one's complement *********/
name|int_min
operator|=
operator|-
name|int_max
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields int_min */
if|if
condition|(
name|int_min
operator|-
literal|1
operator|<
name|int_min
condition|)
name|int_min
operator|--
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Now for those daft Cybers: */
name|maxeri
operator|=
literal|0
expr_stmt|;
name|newi
operator|=
name|int_max
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields maxeri */
for|for
control|(
name|ibits
operator|=
name|ipower
init|;
name|newi
operator|>
name|maxeri
condition|;
name|ibits
operator|++
control|)
block|{
name|maxeri
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|+
name|newi
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|minneri
operator|=
operator|-
name|maxeri
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields minneri */
if|if
condition|(
name|minneri
operator|-
literal|1
operator|<
name|minneri
condition|)
name|minneri
operator|--
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMaximum %s = %ld (= 2**%d-1)%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|int_max
argument_list|,
name|ipower
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMinimum %s = %ld%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|int_min
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|i_define
argument_list|(
name|Iname
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|long
operator|)
name|int_max
argument_list|,
operator|(
name|long
operator|)
name|I_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|i_define
argument_list|(
name|Iname
argument_list|,
literal|"_MIN"
argument_list|,
operator|(
name|long
operator|)
name|int_min
argument_list|,
operator|(
name|long
operator|)
name|I_MIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxeri
operator|>
name|int_max
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sThere is a larger %s, %ld (= 2**%d-1), %s %s%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|maxeri
argument_list|,
name|ibits
argument_list|,
literal|"but only for addition, not multiplication"
argument_list|,
literal|"(I smell a Cyber!)"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minneri
operator|<
name|int_min
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sThere is a smaller %s, %ld, %s %s%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|long
operator|)
name|minneri
argument_list|,
literal|"but only for addition, not multiplication"
argument_list|,
literal|"(I smell a Cyber!)"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Procedure
name|UPROP
parameter_list|()
block|{
comment|/* unsigned short/int/long */
ifdef|#
directive|ifdef
name|OK_UI
specifier|volatile
name|unsigned
name|Integer
name|int_max
decl_stmt|,
name|newi
decl_stmt|,
name|two
decl_stmt|;
name|newi
operator|=
literal|1
expr_stmt|;
name|int_max
operator|=
literal|0
expr_stmt|;
name|two
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields int_max */
while|while
condition|(
name|newi
operator|>
name|int_max
condition|)
block|{
name|int_max
operator|=
name|newi
expr_stmt|;
name|newi
operator|=
name|newi
operator|*
name|two
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|Unexpected
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMaximum unsigned %s = %lu%s\n"
argument_list|,
name|co
argument_list|,
name|INT
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|int_max
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
condition|)
name|u_define
argument_list|(
name|Uname
argument_list|,
literal|"_MAX"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|int_max
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|U_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|Number
end_ifdef

begin_comment
comment|/* These routines are intended to defeat any attempt at optimisation    or use of extended precision, and to defeat faulty narrowing casts: */
end_comment

begin_function
name|Procedure
name|Store
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|Number
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|b
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_function
name|Number
name|Sum
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|Number
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|+
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Diff
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|Number
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|-
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Mul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|Number
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|*
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Div
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|Number
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
operator|/
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Number
name|Self
parameter_list|(
name|a
parameter_list|)
name|Number
name|a
decl_stmt|;
block|{
name|Number
name|r
decl_stmt|;
name|Store
argument_list|(
name|a
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|Procedure
name|F_check
parameter_list|(
name|precision
parameter_list|,
name|val1
parameter_list|)
name|int
name|precision
decl_stmt|;
name|Long_double
name|val1
decl_stmt|;
block|{
comment|/* You don't think I'm going to go to all the trouble of writing 	   a program that works out what all sorts of values are, only to 	   have printf go and print the wrong values out, do you? 	   No, you're right, so this function tries to see if printf 	   has written the right value, by reading it back again. 	   This introduces a new problem of course: suppose printf writes 	   the correct value, and scanf reads it back wrong... oh well. 	   But I'm adamant about this: the precision given is enough 	   to uniquely identify the printed number, therefore I insist 	   that sscanf read the number back identically. Harsh yes, but 	   sometimes you've got to be cruel to be kind. 	*/
name|Long_double
name|new1
decl_stmt|;
name|Number
name|val
decl_stmt|,
name|new
decl_stmt|,
name|diff
decl_stmt|;
name|double
name|rem
decl_stmt|;
name|int
name|e
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|char
modifier|*
name|f2
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Long_double
argument_list|)
condition|)
block|{
comment|/* Assume they're the same, and use non-stdc format */
comment|/* This is for stdc compilers using non-stdc libraries */
name|f2
operator|=
literal|"%le"
expr_stmt|;
comment|/* Input */
block|}
else|else
block|{
comment|/* It had better support Le then */
name|f2
operator|=
literal|"%Le"
expr_stmt|;
block|}
name|val
operator|=
name|val1
expr_stmt|;
name|rep
operator|=
name|f_rep
argument_list|(
name|precision
argument_list|,
operator|(
name|Long_double
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sscanf
argument_list|(
name|rep
argument_list|,
name|f2
argument_list|,
operator|&
name|new1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"sscanf caused a trap"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    scanning: %s format: %s%s\n\n"
argument_list|,
name|co
argument_list|,
name|rep
argument_list|,
name|f2
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* See if new is usable */
name|new
operator|=
name|new1
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0.0
condition|)
block|{
name|diff
operator|=
name|val
operator|/
name|new
operator|-
literal|1.0
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.1
condition|)
name|diff
operator|=
literal|1.0
expr_stmt|;
comment|/* That should be enough to generate a trap */
block|}
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"sscanf returned an unusable number"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    scanning: %s with format: %s%s\n\n"
argument_list|,
name|co
argument_list|,
name|rep
argument_list|,
name|f2
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|13
argument_list|)
expr_stmt|;
return|return;
block|}
name|Unexpected
argument_list|(
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|val
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"Possibly bad output from printf above"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exponent
argument_list|(
name|val
argument_list|,
operator|&
name|rem
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s    but value was an unusable number%s\n\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s    expected value around %.*fe%d, bit pattern:\n    "
argument_list|,
name|co
argument_list|,
name|precision
argument_list|,
name|rem
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bitpattern
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    sscanf gave           %s, bit pattern:\n    "
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
operator|(
name|Long_double
operator|)
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|bitpattern
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s    difference= %s%s\n\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|precision
argument_list|,
call|(
name|Long_double
call|)
argument_list|(
name|val
operator|-
name|new
argument_list|)
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Procedure
name|Validate
parameter_list|(
name|prec
parameter_list|,
name|val
parameter_list|,
name|req
parameter_list|,
name|same
parameter_list|)
name|int
name|prec
decl_stmt|,
name|same
decl_stmt|;
name|Long_double
name|val
decl_stmt|,
name|req
decl_stmt|;
block|{
name|Unexpected
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for the case that req == nan */
name|printf
argument_list|(
literal|"       Compiler has %s for value%s\n"
argument_list|,
name|f_rep
argument_list|(
name|prec
argument_list|,
name|req
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"       Compiler has %s for value%s\n"
argument_list|,
literal|"an unusable number"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|F_check
argument_list|(
name|prec
argument_list|,
operator|(
name|Long_double
operator|)
name|req
argument_list|)
expr_stmt|;
block|}
comment|/*else forget it*/
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|>
literal|0.0
operator|&&
name|val
operator|>
literal|0.0
condition|)
block|{
name|printf
argument_list|(
literal|"%s    difference= %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|prec
argument_list|,
name|val
operator|-
name|req
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*else forget it*/
name|Unexpected
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
name|req
condition|)
block|{
if|if
condition|(
name|stdc
condition|)
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n"
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       Constant has the wrong precision%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
else|else
name|eek_a_bug
argument_list|(
literal|"the cast didn't work"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|FPROP
parameter_list|(
name|bits_per_byte
parameter_list|)
name|int
name|bits_per_byte
decl_stmt|;
block|{
comment|/* Properties of floating types, using algorithms by Cody and Waite 	   from MA Malcolm, as modified by WM Gentleman and SB Marovich. 	   Further extended by S Pemberton.  	   Returns the number of digits in the fraction. 	*/
specifier|volatile
name|int
name|i
decl_stmt|,
name|f_radix
decl_stmt|,
name|iexp
decl_stmt|,
name|irnd
decl_stmt|,
name|mrnd
decl_stmt|,
name|f_rounds
decl_stmt|,
name|f_mant_dig
decl_stmt|,
name|iz
decl_stmt|,
name|k
decl_stmt|,
name|inf
decl_stmt|,
name|machep
decl_stmt|,
name|f_max_exp
decl_stmt|,
name|f_min_exp
decl_stmt|,
name|mx
decl_stmt|,
name|negeps
decl_stmt|,
name|mantbits
decl_stmt|,
name|digs
decl_stmt|,
name|f_dig
decl_stmt|,
name|trap
decl_stmt|,
name|hidden
decl_stmt|,
name|normal
decl_stmt|,
name|f_min_10_exp
decl_stmt|,
name|f_max_10_exp
decl_stmt|;
specifier|volatile
name|Number
name|a
decl_stmt|,
name|b
decl_stmt|,
name|base
decl_stmt|,
name|basein
decl_stmt|,
name|basem1
decl_stmt|,
name|f_epsilon
decl_stmt|,
name|epsneg
decl_stmt|,
name|f_max
decl_stmt|,
name|newxmax
decl_stmt|,
name|f_min
decl_stmt|,
name|xminner
decl_stmt|,
name|y
decl_stmt|,
name|y1
decl_stmt|,
name|z
decl_stmt|,
name|z1
decl_stmt|,
name|z2
decl_stmt|;
name|Unexpected
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sPROPERTIES OF %s:%s\n"
argument_list|,
name|co
argument_list|,
name|THING
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Base and size of mantissa **************************************/
comment|/* First repeatedly double until adding 1 has no effect.	  */
comment|/* For instance, if base is 10, with 3 significant digits	  */
comment|/* it will try 1, 2, 4, 8, ... 512, 1024, and stop there,	  */
comment|/* since 1024 is only representable as 1020.			  */
name|a
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* inexact trap? */
do|do
block|{
name|a
operator|=
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
do|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Program got loss-of-precision trap!\n"
argument_list|)
expr_stmt|;
comment|/* And supporting those is just TOO much trouble! */
name|exit
argument_list|(
name|bugs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|18
argument_list|)
expr_stmt|;
comment|/* Now double until you find a number that can be added to the	  */
comment|/* above number. For 1020 this is 8 or 16, depending whether the  */
comment|/* result is rounded or truncated.				  */
comment|/* In either case the result is 1030. 1030-1020= the base, 10.	  */
name|b
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|b
operator|=
name|Sum
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|base
operator|=
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|a
argument_list|)
operator|)
operator|==
literal|0.0
condition|)
do|;
name|f_radix
operator|=
name|base
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sBase = %d%s\n"
argument_list|,
name|co
argument_list|,
name|f_radix
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Sanity check; if base<2, I can't guarantee the rest will work  */
if|if
condition|(
name|f_radix
operator|<
literal|2
condition|)
block|{
name|eek_a_bug
argument_list|(
literal|"Function return or parameter passing faulty? (This is a guess.)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PASS1
comment|/* only for FLT */
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
literal|"FLT"
argument_list|,
literal|"_RADIX"
argument_list|,
operator|(
name|long
operator|)
name|f_radix
argument_list|,
operator|(
name|long
operator|)
name|F_RADIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now the number of digits precision: */
name|f_mant_dig
operator|=
literal|0
expr_stmt|;
name|b
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|f_mant_dig
operator|++
expr_stmt|;
name|b
operator|=
name|Mul
argument_list|(
name|b
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|b
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|b
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
do|;
name|f_dig
operator|=
name|floor_log
argument_list|(
literal|10
argument_list|,
call|(
name|Long_double
call|)
argument_list|(
name|b
operator|/
name|base
argument_list|)
argument_list|)
operator|+
operator|(
name|base
operator|==
literal|10
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sSignificant base digits = %d %s %d %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_mant_dig
argument_list|,
literal|"(= at least"
argument_list|,
name|f_dig
argument_list|,
literal|"decimal digits)"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|Fname
argument_list|,
literal|"_MANT_DIG"
argument_list|,
operator|(
name|long
operator|)
name|f_mant_dig
argument_list|,
operator|(
name|long
operator|)
name|F_MANT_DIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|Fname
argument_list|,
literal|"_DIG"
argument_list|,
operator|(
name|long
operator|)
name|f_dig
argument_list|,
operator|(
name|long
operator|)
name|F_DIG
argument_list|)
expr_stmt|;
name|digs
operator|=
name|ceil_log
argument_list|(
literal|10
argument_list|,
operator|(
name|Long_double
operator|)
name|b
argument_list|)
expr_stmt|;
comment|/* the number of digits to printf */
comment|/* Rounding *******************************************************/
name|basem1
operator|=
name|Diff
argument_list|(
name|base
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
literal|0.0
condition|)
block|{
if|if
condition|(
name|f_radix
operator|==
literal|2
condition|)
name|basem1
operator|=
literal|0.375
expr_stmt|;
else|else
name|basem1
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
literal|0.0
condition|)
name|irnd
operator|=
literal|2
expr_stmt|;
comment|/* away from 0 */
else|else
name|irnd
operator|=
literal|1
expr_stmt|;
comment|/* to nearest */
block|}
else|else
name|irnd
operator|=
literal|0
expr_stmt|;
comment|/* towards 0 */
name|basem1
operator|=
name|Diff
argument_list|(
name|base
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
operator|-
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
operator|-
name|a
argument_list|)
operator|!=
literal|0.0
condition|)
block|{
if|if
condition|(
name|f_radix
operator|==
literal|2
condition|)
name|basem1
operator|=
literal|0.375
expr_stmt|;
else|else
name|basem1
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
operator|-
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
operator|-
name|a
argument_list|)
operator|!=
literal|0.0
condition|)
name|mrnd
operator|=
literal|2
expr_stmt|;
comment|/* away from 0*/
else|else
name|mrnd
operator|=
literal|1
expr_stmt|;
comment|/* to nearest */
block|}
else|else
name|mrnd
operator|=
literal|0
expr_stmt|;
comment|/* towards 0 */
name|f_rounds
operator|=
literal|4
expr_stmt|;
comment|/* Unknown rounding */
if|if
condition|(
name|irnd
operator|==
literal|0
operator|&&
name|mrnd
operator|==
literal|0
condition|)
name|f_rounds
operator|=
literal|0
expr_stmt|;
comment|/* zero = chops */
if|if
condition|(
name|irnd
operator|==
literal|1
operator|&&
name|mrnd
operator|==
literal|1
condition|)
name|f_rounds
operator|=
literal|1
expr_stmt|;
comment|/* nearest */
if|if
condition|(
name|irnd
operator|==
literal|2
operator|&&
name|mrnd
operator|==
literal|0
condition|)
name|f_rounds
operator|=
literal|2
expr_stmt|;
comment|/* +inf */
if|if
condition|(
name|irnd
operator|==
literal|0
operator|&&
name|mrnd
operator|==
literal|2
condition|)
name|f_rounds
operator|=
literal|3
expr_stmt|;
comment|/* -inf */
if|if
condition|(
name|f_rounds
operator|!=
literal|4
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sArithmetic rounds towards "
argument_list|,
name|co
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|f_rounds
condition|)
block|{
case|case
literal|0
case|:
name|Vprintf
argument_list|(
literal|"zero (i.e. it chops)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|Vprintf
argument_list|(
literal|"nearest"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Vprintf
argument_list|(
literal|"+infinity"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Vprintf
argument_list|(
literal|"-infinity"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Vprintf
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
break|break;
block|}
name|Vprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Hmm, try to give some help here: */
name|Vprintf
argument_list|(
literal|"%sArithmetic rounds oddly: %s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s    Negative numbers %s%s\n"
argument_list|,
name|co
argument_list|,
name|mrnd
operator|==
literal|0
condition|?
literal|"towards zero"
else|:
name|mrnd
operator|==
literal|1
condition|?
literal|"to nearest"
else|:
literal|"away from zero"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s    Positive numbers %s%s\n"
argument_list|,
name|co
argument_list|,
name|irnd
operator|==
literal|0
condition|?
literal|"towards zero"
else|:
name|irnd
operator|==
literal|1
condition|?
literal|"to nearest"
else|:
literal|"away from zero"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
comment|/* An extra goody */
if|if
condition|(
name|f_radix
operator|==
literal|2
operator|&&
name|f_rounds
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
literal|0.0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s   Tie breaking rounds up%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
name|a
argument_list|,
literal|3.0
argument_list|)
argument_list|,
name|a
argument_list|)
operator|==
literal|4.0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s   Tie breaking rounds to even%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%s   Tie breaking rounds down%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PASS1
comment|/* only for FLT */
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
literal|"FLT"
argument_list|,
literal|"_ROUNDS"
argument_list|,
operator|(
name|long
operator|)
name|f_rounds
argument_list|,
operator|(
name|long
operator|)
name|F_ROUNDS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Various flavours of epsilon ************************************/
name|negeps
operator|=
name|f_mant_dig
operator|+
name|f_mant_dig
expr_stmt|;
name|basein
operator|=
literal|1.0
operator|/
name|base
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|negeps
condition|;
name|i
operator|++
control|)
name|a
operator|*=
name|basein
expr_stmt|;
name|b
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|a
operator|*=
name|base
expr_stmt|;
name|negeps
operator|--
expr_stmt|;
block|}
name|negeps
operator|=
operator|-
name|negeps
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0-base**x != 1.0 = %d%s\n"
argument_list|,
name|co
argument_list|,
name|negeps
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|epsneg
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|f_radix
operator|!=
literal|2
operator|)
operator|&&
name|irnd
condition|)
block|{
comment|/*	a=(a*(1.0+a))/(1.0+1.0); => */
name|a
operator|=
name|Div
argument_list|(
name|Mul
argument_list|(
name|a
argument_list|,
name|Sum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|)
argument_list|,
name|Sum
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	if ((1.0-a)-1.0 != 0.0) epsneg=a; => */
if|if
condition|(
name|Diff
argument_list|(
name|Diff
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|!=
literal|0.0
condition|)
name|epsneg
operator|=
name|a
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sSmall x such that 1.0-x != 1.0 = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|epsneg
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* it may not be the smallest */
if|if
condition|(
name|V
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|epsneg
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|19
argument_list|)
expr_stmt|;
name|machep
operator|=
operator|-
name|f_mant_dig
operator|-
name|f_mant_dig
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|a
operator|*=
name|base
expr_stmt|;
name|machep
operator|++
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0+base**x != 1.0 = %d%s\n"
argument_list|,
name|co
argument_list|,
name|machep
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|f_epsilon
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|f_radix
operator|!=
literal|2
operator|)
operator|&&
name|irnd
condition|)
block|{
comment|/*	a=(a*(1.0+a))/(1.0+1.0); => */
name|a
operator|=
name|Div
argument_list|(
name|Mul
argument_list|(
name|a
argument_list|,
name|Sum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|)
argument_list|,
name|Sum
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	if ((1.0+a)-1.0 != 0.0) f_epsilon=a; => */
if|if
condition|(
name|Diff
argument_list|(
name|Sum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|!=
literal|0.0
condition|)
name|f_epsilon
operator|=
name|a
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sSmallest x such that 1.0+x != 1.0 = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Possible loss of precision warnings here from non-stdc compilers: */
if|if
condition|(
name|F
condition|)
name|f_define
argument_list|(
name|Fname
argument_list|,
literal|"_EPSILON"
argument_list|,
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
operator|||
name|F
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|Validate
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_epsilon
argument_list|,
operator|(
name|Long_double
operator|)
name|F_EPSILON
argument_list|,
name|f_epsilon
operator|==
name|Self
argument_list|(
name|F_EPSILON
argument_list|)
argument_list|)
expr_stmt|;
name|Unexpected
argument_list|(
literal|21
argument_list|)
expr_stmt|;
comment|/* Extra chop info *************************************************/
if|if
condition|(
name|f_rounds
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Diff
argument_list|(
name|Mul
argument_list|(
name|Sum
argument_list|(
literal|1.0
argument_list|,
name|f_epsilon
argument_list|)
argument_list|,
literal|1.0
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|!=
literal|0.0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sAlthough arithmetic chops, it uses guard digits%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Size of and minimum normalised exponent ************************/
name|y
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|z
operator|=
name|basein
expr_stmt|;
name|z1
operator|=
operator|(
literal|1.0
operator|+
name|f_epsilon
operator|)
operator|/
name|base
expr_stmt|;
comment|/* Coarse search for the largest power of two */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for underflow trap */
comment|/* Yields i, k, y, y1 */
do|do
block|{
name|y
operator|=
name|z
expr_stmt|;
name|y1
operator|=
name|z1
expr_stmt|;
name|z
operator|=
name|Mul
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z1
operator|=
name|Mul
argument_list|(
name|z1
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|a
operator|=
name|Mul
argument_list|(
name|z
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|z2
operator|=
name|Div
argument_list|(
name|z1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2
operator|!=
name|y1
condition|)
break|break;
if|if
condition|(
operator|(
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|z
argument_list|)
operator|>=
name|y
operator|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|k
operator|+=
name|k
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%s%s underflow generates a trap%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|22
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_radix
operator|!=
literal|10
condition|)
block|{
name|iexp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* for the sign */
name|mx
operator|=
name|k
operator|+
name|k
expr_stmt|;
block|}
else|else
block|{
name|iexp
operator|=
literal|2
expr_stmt|;
name|iz
operator|=
name|f_radix
expr_stmt|;
while|while
condition|(
name|k
operator|>=
name|iz
condition|)
block|{
name|iz
operator|*=
name|f_radix
expr_stmt|;
name|iexp
operator|++
expr_stmt|;
block|}
name|mx
operator|=
name|iz
operator|+
name|iz
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Fine tune starting with y and y1 */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for underflow trap */
comment|/* Yields k, f_min */
do|do
block|{
name|f_min
operator|=
name|y
expr_stmt|;
name|z1
operator|=
name|y1
expr_stmt|;
name|y
operator|=
name|Div
argument_list|(
name|y
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|y1
operator|=
name|Div
argument_list|(
name|y1
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|a
operator|=
name|Mul
argument_list|(
name|y
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|z2
operator|=
name|Mul
argument_list|(
name|y1
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2
operator|!=
name|z1
condition|)
break|break;
if|if
condition|(
operator|(
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|y
argument_list|)
operator|>=
name|f_min
operator|)
condition|)
break|break;
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
name|Unexpected
argument_list|(
literal|23
argument_list|)
expr_stmt|;
name|f_min_exp
operator|=
operator|(
operator|-
name|k
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mx
operator|<=
name|k
operator|+
name|k
operator|-
literal|3
operator|)
operator|&&
operator|(
name|f_radix
operator|!=
literal|10
operator|)
condition|)
block|{
name|mx
operator|+=
name|mx
expr_stmt|;
name|iexp
operator|+=
literal|1
expr_stmt|;
block|}
name|Vprintf
argument_list|(
literal|"%sNumber of bits used for exponent = %d%s\n"
argument_list|,
name|co
argument_list|,
name|iexp
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMinimum normalised exponent = %d%s\n"
argument_list|,
name|co
argument_list|,
name|f_min_exp
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|Fname
argument_list|,
literal|"_MIN_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_min_exp
argument_list|,
operator|(
name|long
operator|)
name|F_MIN_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sMinimum normalised positive number = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"printf can't print the smallest normalised number"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|24
argument_list|)
expr_stmt|;
comment|/* Possible loss of precision warnings here from non-stdc compilers: */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F
condition|)
name|f_define
argument_list|(
name|Fname
argument_list|,
literal|"_MIN"
argument_list|,
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
operator|||
name|F
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"xxx_MIN caused a trap"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F
condition|)
name|Validate
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_min
argument_list|,
operator|(
name|Long_double
operator|)
name|F_MIN
argument_list|,
name|f_min
operator|==
name|Self
argument_list|(
name|F_MIN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n    %s %s\n\n"
argument_list|,
name|co
argument_list|,
literal|"Compiler has an unusable number for value"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
name|f_min_10_exp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|a
operator|>
name|f_min
operator|*
literal|10.0
condition|)
block|{
name|a
operator|/=
literal|10.0
expr_stmt|;
name|f_min_10_exp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|Fname
argument_list|,
literal|"_MIN_10_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_min_10_exp
argument_list|,
operator|(
name|long
operator|)
name|F_MIN_10_EXP
argument_list|)
expr_stmt|;
comment|/* Minimum exponent ************************************************/
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* for underflow trap */
comment|/* Yields xminner */
do|do
block|{
name|xminner
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|Div
argument_list|(
name|y
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|a
operator|=
name|Mul
argument_list|(
name|y
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Sum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|y
argument_list|)
operator|>=
name|xminner
operator|)
condition|)
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
name|Unexpected
argument_list|(
literal|26
argument_list|)
expr_stmt|;
if|if
condition|(
name|xminner
operator|!=
literal|0.0
operator|&&
name|xminner
operator|!=
name|f_min
condition|)
block|{
name|normal
operator|=
literal|0
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sThe smallest numbers are not kept normalised%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sSmallest unnormalised positive number = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|xminner
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|xminner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"printf can't print the smallest unnormalised number."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|27
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
literal|1
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sThe smallest numbers are normalised%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
comment|/* Maximum exponent ************************************************/
name|f_max_exp
operator|=
literal|2
expr_stmt|;
name|f_max
operator|=
literal|1.0
expr_stmt|;
name|newxmax
operator|=
name|base
operator|+
literal|1.0
expr_stmt|;
name|inf
operator|=
literal|0
expr_stmt|;
name|trap
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|f_max
operator|<
name|newxmax
condition|)
block|{
name|f_max
operator|=
name|newxmax
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields inf, f_max_exp */
name|newxmax
operator|=
name|Mul
argument_list|(
name|newxmax
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Div
argument_list|(
name|newxmax
argument_list|,
name|base
argument_list|)
operator|!=
name|f_max
condition|)
block|{
name|inf
operator|=
literal|1
expr_stmt|;
comment|/* ieee infinity */
break|break;
block|}
name|f_max_exp
operator|++
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|28
argument_list|)
expr_stmt|;
if|if
condition|(
name|trap
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s overflow generates a trap%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inf
condition|)
name|Vprintf
argument_list|(
literal|"%sThere is an 'infinite' value%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sMaximum exponent = %d%s\n"
argument_list|,
name|co
argument_list|,
name|f_max_exp
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|Fname
argument_list|,
literal|"_MAX_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_max_exp
argument_list|,
operator|(
name|long
operator|)
name|F_MAX_EXP
argument_list|)
expr_stmt|;
comment|/* Largest number ***************************************************/
name|f_max
operator|=
name|Diff
argument_list|(
literal|1.0
argument_list|,
name|epsneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mul
argument_list|(
name|f_max
argument_list|,
literal|1.0
argument_list|)
operator|!=
name|f_max
condition|)
name|f_max
operator|=
name|Diff
argument_list|(
literal|1.0
argument_list|,
name|Mul
argument_list|(
name|base
argument_list|,
name|epsneg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|f_max_exp
condition|;
name|i
operator|++
control|)
name|f_max
operator|=
name|Mul
argument_list|(
name|f_max
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sMaximum number = %s%s\n"
argument_list|,
name|co
argument_list|,
name|f_rep
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|)
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"printf can't print the largest double."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Possible loss of precision warnings here from non-stdc compilers: */
if|if
condition|(
name|F
condition|)
name|f_define
argument_list|(
name|Fname
argument_list|,
literal|"_MAX"
argument_list|,
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|V
operator|||
name|F
condition|)
name|F_check
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eek_a_bug
argument_list|(
literal|"xxx_MAX caused a trap"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F
condition|)
name|Validate
argument_list|(
name|digs
argument_list|,
operator|(
name|Long_double
operator|)
name|f_max
argument_list|,
operator|(
name|Long_double
operator|)
name|F_MAX
argument_list|,
name|f_max
operator|==
name|Self
argument_list|(
name|F_MAX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s*** Verify failed for above #define!\n    %s %s\n\n"
argument_list|,
name|co
argument_list|,
literal|"Compiler has an unusable number for value"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|bugs
operator|++
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|29
argument_list|)
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
name|f_max_10_exp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|a
operator|<
name|f_max
operator|/
literal|10.0
condition|)
block|{
name|a
operator|*=
literal|10.0
expr_stmt|;
name|f_max_10_exp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|F
condition|)
name|i_define
argument_list|(
name|Fname
argument_list|,
literal|"_MAX_10_EXP"
argument_list|,
operator|(
name|long
operator|)
name|f_max_10_exp
argument_list|,
operator|(
name|long
operator|)
name|F_MAX_10_EXP
argument_list|)
expr_stmt|;
comment|/* Hidden bit + sanity check ****************************************/
if|if
condition|(
name|f_radix
operator|!=
literal|10
condition|)
block|{
name|hidden
operator|=
literal|0
expr_stmt|;
name|mantbits
operator|=
name|floor_log
argument_list|(
literal|2
argument_list|,
operator|(
name|Long_double
operator|)
name|f_radix
argument_list|)
operator|*
name|f_mant_dig
expr_stmt|;
if|if
condition|(
name|mantbits
operator|+
name|iexp
operator|==
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Number
argument_list|)
operator|*
name|bits_per_byte
condition|)
block|{
name|hidden
operator|=
literal|1
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%sArithmetic uses a hidden bit%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mantbits
operator|+
name|iexp
operator|+
literal|1
operator|==
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|Number
argument_list|)
operator|*
name|bits_per_byte
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sArithmetic doesn't use a hidden bit%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n%s%s\n    %s %s %s!%s\n\n"
argument_list|,
name|co
argument_list|,
literal|"*** Something fishy here!"
argument_list|,
literal|"Exponent size + mantissa size doesn't match"
argument_list|,
literal|"with the size of a"
argument_list|,
name|thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hidden
operator|&&
name|f_radix
operator|==
literal|2
operator|&&
name|f_max_exp
operator|+
name|f_min_exp
operator|==
literal|3
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sIt looks like %s length IEEE format%s\n"
argument_list|,
name|co
argument_list|,
name|f_mant_dig
operator|==
literal|24
condition|?
literal|"single"
else|:
name|f_mant_dig
operator|==
literal|53
condition|?
literal|"double"
else|:
name|f_mant_dig
operator|>
literal|53
condition|?
literal|"extended"
else|:
literal|"some"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_rounds
operator|!=
literal|1
operator|||
name|normal
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s   though "
argument_list|,
name|co
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_rounds
operator|!=
literal|1
condition|)
block|{
name|Vprintf
argument_list|(
literal|"the rounding is unusual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|normal
condition|)
name|Vprintf
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|normal
condition|)
name|Vprintf
argument_list|(
literal|"the normalisation is unusual"
argument_list|)
expr_stmt|;
name|Vprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%sIt doesn't look like IEEE format%s\n"
argument_list|,
name|co
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* regardless of verbosity */
return|return
name|f_mant_dig
return|;
block|}
end_function

begin_function
name|Procedure
name|EPROP
parameter_list|(
name|fprec
parameter_list|,
name|dprec
parameter_list|,
name|lprec
parameter_list|)
name|int
name|fprec
decl_stmt|,
name|dprec
decl_stmt|,
name|lprec
decl_stmt|;
block|{
comment|/* See if expressions are evaluated in extended precision. 	   Some compilers optimise even if you don't want it, 	   and then this function fails to produce the right result. 	   We try to diagnose this if it happens. 	*/
specifier|volatile
name|int
name|eprec
decl_stmt|;
specifier|volatile
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|base
decl_stmt|,
name|old
decl_stmt|;
specifier|volatile
name|Number
name|d
decl_stmt|,
name|oldd
decl_stmt|,
name|dbase
decl_stmt|,
name|one
decl_stmt|,
name|zero
decl_stmt|;
specifier|volatile
name|int
name|bad
init|=
literal|0
decl_stmt|;
comment|/* Size of mantissa **************************************/
name|a
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields nothing */
do|do
block|{
name|old
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|+
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
operator|(
name|a
operator|+
literal|1.0
operator|)
operator|-
name|a
operator|)
operator|-
literal|1.0
operator|)
operator|==
literal|0.0
operator|&&
name|a
operator|>
name|old
condition|)
do|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a
operator|<=
name|old
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|b
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields nothing */
do|do
block|{
name|old
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|+
name|b
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|base
operator|=
operator|(
operator|(
name|a
operator|+
name|b
operator|)
operator|-
name|a
operator|)
operator|)
operator|==
literal|0.0
operator|&&
name|b
operator|>
name|old
condition|)
do|;
if|if
condition|(
name|b
operator|<=
name|old
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|eprec
operator|=
literal|0
expr_stmt|;
name|d
operator|=
literal|1.0
expr_stmt|;
name|dbase
operator|=
name|base
expr_stmt|;
name|one
operator|=
literal|1.0
expr_stmt|;
name|zero
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yields nothing */
do|do
block|{
name|eprec
operator|++
expr_stmt|;
name|oldd
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|*
name|dbase
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
operator|(
name|d
operator|+
name|one
operator|)
operator|-
name|d
operator|)
operator|-
name|one
operator|)
operator|==
name|zero
operator|&&
name|d
operator|>
name|oldd
condition|)
do|;
if|if
condition|(
name|d
operator|<=
name|oldd
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bad
operator|=
literal|1
expr_stmt|;
block|}
name|Unexpected
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%sCan't determine precision for %s expressions:\n%s%s\n"
argument_list|,
name|co
argument_list|,
name|thing
argument_list|,
literal|"   check that you compiled without optimisation!"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eprec
operator|==
name|dprec
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in double precision%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eprec
operator|==
name|fprec
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in float precision%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eprec
operator|==
name|lprec
condition|)
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in long double precision%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vprintf
argument_list|(
literal|"%s%s expressions are evaluated in a %s %s %d %s%s\n"
argument_list|,
name|co
argument_list|,
name|Thing
argument_list|,
name|eprec
operator|>
name|dprec
condition|?
literal|"higher"
else|:
literal|"lower"
argument_list|,
literal|"precision than double,\n   using"
argument_list|,
name|eprec
argument_list|,
literal|"base digits"
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Number */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FPROP
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|FPROP
parameter_list|(
name|bits_per_byte
parameter_list|)
name|int
name|bits_per_byte
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EPROP
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Procedure
name|EPROP
parameter_list|(
name|fprec
parameter_list|,
name|dprec
parameter_list|,
name|lprec
parameter_list|)
name|int
name|fprec
decl_stmt|,
name|dprec
decl_stmt|,
name|lprec
decl_stmt|;
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef Number */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS3
end_ifdef

begin_undef
undef|#
directive|undef
name|PASS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS2
end_ifdef

begin_undef
undef|#
directive|undef
name|PASS2
end_undef

begin_define
define|#
directive|define
name|PASS3
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASS1
end_ifdef

begin_undef
undef|#
directive|undef
name|PASS1
end_undef

begin_define
define|#
directive|define
name|PASS2
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If your C compiler doesn't accept the next #include,    replace __FILE__ with the file name - and get a new C compiler... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS
end_ifdef

begin_include
include|#
directive|include
file|"hard-params.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

end_unit

