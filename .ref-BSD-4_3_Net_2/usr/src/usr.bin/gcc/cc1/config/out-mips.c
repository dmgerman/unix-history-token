begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for MIPS    Contributed by A. Lichnewsky, lich@inria.inria.fr.    Changes by     Michael Meissner, meissner@osf.org.    Copyright (C) 1989, 1990 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_function_decl
specifier|extern
name|void
name|debug_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|abort_with_insn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_numchar
index|[]
init|=
name|REGISTER_NUMCHAR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Threshold for data being put into the small data/bss area, instead    of the normal data area (references to the small data/bss area take    1 instruction, and use the global pointer, references to the normal    data area takes 2 instructions).  */
end_comment

begin_decl_stmt
name|int
name|mips_section_threshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of words that are pushed to pass arguments.  */
end_comment

begin_decl_stmt
name|int
name|stack_args_pushed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes for args preallocated by function_prolog. */
end_comment

begin_decl_stmt
name|int
name|stack_args_preallocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of the number of functions created so far, in order to make    unique labels for omitting the frame pointer.  */
end_comment

begin_decl_stmt
name|int
name|number_functions_processed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next label # for each statment for Silicon Graphics IRIS systems. */
end_comment

begin_decl_stmt
name|int
name|sym_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inside of a function, because the stupid MIPS asm can't    handle .files inside of functions.  */
end_comment

begin_decl_stmt
name|int
name|inside_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be used for the unique name given to the difference between    the stack pointer and frame pointer when the frame pointer is to be    omitted.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sp_fp_difference
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Files to separate the text and the data output, so that all of the data    can be emitted before the text, which will mean that the assembler will    generate smaller code, based on the global pointer.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_data_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_text_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all externals that are to be emitted when optimizing    for the global pointer if they haven't been declared by the end of    the program with an appropriate .comm or initialization.  */
end_comment

begin_struct
struct|struct
name|extern_list
block|{
name|struct
name|extern_list
modifier|*
name|next
decl_stmt|;
comment|/* next external */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the external */
name|int
name|size
decl_stmt|;
comment|/* size in bytes */
block|}
modifier|*
name|extern_head
init|=
literal|0
struct|;
end_struct

begin_comment
comment|/* Name of the current function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the frame allocated for this function.  */
end_comment

begin_decl_stmt
name|int
name|current_function_total_framesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes used to hold saved registers.  */
end_comment

begin_decl_stmt
name|int
name|current_function_saved_reg_size
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP can be used as an operands    where a register or 16 bit unsigned integer is needed.  */
end_comment

begin_function
name|int
name|uns_arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT_UNSIGNED
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operands    where a 16 bit integer is needed  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operand in a two    address arithmetic insn (such as set 123456,%o4) of mode MODE.  */
end_comment

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits in 16 bits  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Initialize CUMULATIVE_ARGS for a function.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
comment|/* argument info to initialize */
name|tree
name|fntype
decl_stmt|;
comment|/* tree ptr for function decl */
block|{
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cum
operator|->
name|gp_reg_found
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|arg_number
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|=
literal|0
expr_stmt|;
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  The standard MIPS calling sequence      passes all arguments in the general purpose registers in this      case. */
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
operator|(
name|tree
operator|)
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine if the function is returning a structure, if so,      advance by one argument.  */
if|if
condition|(
name|fntype
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|ret_code
init|=
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|RECORD_TYPE
operator|||
name|ret_code
operator|==
name|UNION_TYPE
condition|)
block|{
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_number
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Advance the argument to the next argument position.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
block|{
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, 0x%.8x, %d )\n"
argument_list|,
name|cum
operator|->
name|gp_reg_found
argument_list|,
name|cum
operator|->
name|arg_number
argument_list|,
name|cum
operator|->
name|arg_words
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
expr_stmt|;
name|cum
operator|->
name|arg_number
operator|++
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Illegal mode given to function_arg_advance"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOIDmode
case|:
break|break;
case|case
name|BLKmode
case|:
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|+=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|cum
operator|->
name|arg_words
operator|++
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|cum
operator|->
name|arg_words
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|arg_words
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return a RTL expression containing the register for the given mode,    or 0 if the argument is too be passed on the stack.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
name|int
name|regbase
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bias
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, 0x%.8x, %d ) = "
argument_list|,
name|cum
operator|->
name|gp_reg_found
argument_list|,
name|cum
operator|->
name|arg_number
argument_list|,
name|cum
operator|->
name|arg_words
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Illegal mode given to function_arg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
if|if
condition|(
name|cum
operator|->
name|gp_reg_found
operator|||
name|cum
operator|->
name|arg_number
operator|>=
literal|2
condition|)
name|regbase
operator|=
name|GP_ARG_FIRST
expr_stmt|;
else|else
block|{
name|regbase
operator|=
name|FP_ARG_FIRST
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|arg_words
operator|==
literal|1
condition|)
comment|/* first arg was float */
name|bias
operator|=
literal|1
expr_stmt|;
comment|/* use correct reg */
block|}
break|break;
case|case
name|DFmode
case|:
name|cum
operator|->
name|arg_words
operator|+=
operator|(
name|cum
operator|->
name|arg_words
operator|&
literal|1
operator|)
expr_stmt|;
name|regbase
operator|=
operator|(
name|cum
operator|->
name|gp_reg_found
operator|)
condition|?
name|GP_ARG_FIRST
else|:
name|FP_ARG_FIRST
expr_stmt|;
break|break;
case|case
name|VOIDmode
case|:
case|case
name|BLKmode
case|:
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
case|case
name|DImode
case|:
name|regbase
operator|=
name|GP_ARG_FIRST
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cum
operator|->
name|arg_words
operator|>=
name|MAX_ARGS_IN_REGISTERS
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<stack>\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|regbase
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|reg_numchar
index|[
name|regbase
operator|+
name|cum
operator|->
name|arg_number
operator|+
name|bias
index|]
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regbase
operator|+
name|cum
operator|->
name|arg_words
operator|+
name|bias
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|cum
operator|->
name|arg_number
operator|<
name|MAX_ARGS_IN_REGISTERS
condition|)
block|{
name|int
name|words
init|=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|words
operator|+
name|cum
operator|->
name|arg_words
operator|<
name|MAX_ARGS_IN_REGISTERS
condition|)
return|return
literal|0
return|;
comment|/* structure fits in registers */
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs = %d\n"
argument_list|,
name|MAX_ARGS_IN_REGISTERS
operator|-
name|cum
operator|->
name|arg_words
argument_list|)
expr_stmt|;
return|return
name|MAX_ARGS_IN_REGISTERS
operator|-
name|cum
operator|->
name|arg_words
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|cum
operator|->
name|arg_number
operator|==
name|MAX_ARGS_IN_REGISTERS
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUGE_MODE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs = 1\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to merge the compare and branch operators into a single entity.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|branch_cmp_op
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|branch_cmp_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save the mode and operands on the current compare operator.  */
end_comment

begin_function
name|void
name|compare_collect
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_DEBUGD_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compare_collect mode = %s, operands::"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|branch_cmp_op
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|branch_cmp_op
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|branch_cmp_mode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the mode and operands saved with compare_collect for use    in a branch operator.  */
end_comment

begin_function
name|void
name|compare_restore
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|,
name|insn
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|branch_cmp_op
index|[
literal|0
index|]
operator|||
operator|!
name|branch_cmp_op
index|[
literal|1
index|]
condition|)
name|abort_with_insn
argument_list|(
name|insn
argument_list|,
literal|"Compare_restore did not follow compare_collect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUGD_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compare_restore returning mode = %s, operands:%X,%X:"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|branch_cmp_mode
argument_list|)
argument_list|,
name|branch_cmp_op
index|[
literal|0
index|]
argument_list|,
name|branch_cmp_op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|branch_cmp_op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|branch_cmp_op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|0
index|]
operator|=
name|branch_cmp_op
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|branch_cmp_op
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|mode
operator|=
name|branch_cmp_mode
expr_stmt|;
comment|/* If the next insn is not a JUMP (after accounting for line numbers),      zero out the branch_cmp_array.  Switch statements implemented as if's      tend to have multiple jumps.  */
do|do
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
if|if
condition|(
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
block|{
name|branch_cmp_op
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|branch_cmp_op
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|branch_cmp_mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the options used in the assembly file.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_function
name|void
name|print_options
parameter_list|(
name|out
parameter_list|)
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|line_len
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|mask
init|=
name|TARGET_DEFAULT
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|,
modifier|*
name|language_string
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Allow assembly language comparisons with -mdebug eliminating the      compiler version number and switch lists.  */
block|if (!TARGET_DEBUG_MODE)     {       fprintf (out, "\n # %s %s", language_string, version_string);
ifdef|#
directive|ifdef
name|TARGET_VERSION_INTERNAL
block|TARGET_VERSION_INTERNAL (out);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__GNUC__
block|fprintf (out, " compiled by GNU C\n\n");
else|#
directive|else
block|fprintf (out, " compiled by CC\n\n");
endif|#
directive|endif
block|fprintf (out, " # Cc1 defaults:");       line_len = 32767;       for (j = 0; j< sizeof target_switches / sizeof target_switches[0]; j++) 	if (target_switches[j].name[0] != '\0'&& target_switches[j].value> 0&& (target_switches[j].value& mask) == target_switches[j].value) 	  { 	    len = strlen (target_switches[j].name) + 1; 	    if (len + line_len> 79) 	      { 		line_len = 2; 		fputs ("\n #", out); 	      } 	    fprintf (out, " -m%s", target_switches[j].name); 	    line_len += len; 	  }        fprintf (out, "\n\n # Cc1 arguments (-G value = %d):", 	       mips_section_threshold);        line_len = 32767;       for (p =&save_argv[1]; *p != (char *)0; p++) 	if (**p == '-') 	  { 	    len = strlen (*p) + 1; 	    if (len + line_len> 79) 	      { 		line_len = 2; 		fputs ("\n #", out); 	      } 	    fprintf (out, " %s", *p); 	    line_len += len; 	  }       fputs ("\n\n", out);     }
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Abort after printing out a specific insn.  */
end_comment

begin_function
name|void
name|abort_with_insn
parameter_list|(
name|insn
parameter_list|,
name|reason
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
name|error
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a message to stderr (for use in macros expanded in files that do not    include stdio.h).  */
end_comment

begin_function
name|void
name|trace
parameter_list|(
name|s
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Set up the threshold for data to go into the small data area, instead    of the normal data area, and detect any conflicts in the switches.  */
end_comment

begin_function
name|void
name|overide_options
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|TARGET_GVALUE
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|6
condition|)
name|i
operator|+=
literal|3
expr_stmt|;
name|mips_section_threshold
operator|=
operator|(
name|i
operator|!=
literal|0
operator|)
condition|?
literal|1
operator|<<
name|i
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If optimizing for the global pointer, keep track of all of    the externs, so that at the end of the file, we can emit    the appropriate .extern declaration for them, before writing    out the text section.  We assume that all names passed to    us are in the permanent obstack, so that they will be valid    at the end of the compilation.     If we have -G 0, or the extern size is unknown, don't bother    emitting the .externs.  */
end_comment

begin_function
name|int
name|mips_output_external
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|permalloc
parameter_list|()
function_decl|;
specifier|register
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|TARGET_GP_OPT
operator|&&
name|mips_section_threshold
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|)
operator|!=
name|FUNCTION_DECL
operator|)
operator|&&
operator|(
operator|(
name|len
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|permalloc
argument_list|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are optimizing the global pointer, emit the text section now    and any small externs which did not have .comm, etc that are    needed.  Also, give a warning if the data area is more than 32K and    -pic because 3 instructions are needed to reference the data    pointers.  */
end_comment

begin_function
name|int
name|mips_asm_file_end
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|8192
index|]
decl_stmt|;
name|tree
name|name_tree
decl_stmt|;
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|extern
name|tree
name|lookup_name
parameter_list|()
function_decl|;
if|if
condition|(
name|TARGET_GP_OPT
condition|)
block|{
if|if
condition|(
name|extern_head
condition|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extern_head
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|name_tree
argument_list|)
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern\t%s, %d\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t.text\n"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|asm_out_text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_text_file
argument_list|)
condition|)
name|fatal_io_error
argument_list|(
literal|"write of text assembly file in mips_asm_file_end"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|asm_out_text_file
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|file
argument_list|)
operator|!=
name|len
condition|)
name|pfatal_with_name
argument_list|(
literal|"write of final assembly file in mips_asm_file_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"read of text assembly file in mips_asm_file_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|asm_out_text_file
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"close of tempfile in mips_asm_file_end"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fix references to the frame pointer to be off of the stack pointer.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|mips_fix_frame_pointer
parameter_list|(
name|oldaddr
parameter_list|,
name|depth
parameter_list|)
name|rtx
name|oldaddr
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|rtx
name|newaddr
decl_stmt|;
name|rtx
name|sp_diff_rtx
decl_stmt|;
name|char
name|temp
index|[
literal|40
index|]
decl_stmt|;
name|int
name|frame_offset
init|=
literal|0
decl_stmt|;
specifier|extern
name|rtx
name|eliminate_constant_term
parameter_list|()
function_decl|;
name|newaddr
operator|=
name|eliminate_constant_term
argument_list|(
name|oldaddr
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|newaddr
operator|!=
name|frame_pointer_rtx
condition|)
return|return
name|oldaddr
return|;
if|if
condition|(
name|sp_fp_difference
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"$Ls%d"
argument_list|,
name|number_functions_processed
argument_list|)
expr_stmt|;
name|sp_fp_difference
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|get_identifier
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp_diff_rtx
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|SImode
argument_list|,
name|sp_fp_difference
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_offset
operator|+
name|depth
operator|==
literal|0
condition|)
name|newaddr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sp_diff_rtx
argument_list|)
expr_stmt|;
else|else
name|newaddr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|sp_diff_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|frame_offset
operator|+
name|depth
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUGC_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==================== FIX_FRAME, depth = %d, sp prealloc = %d, offset = %d\n"
argument_list|,
name|depth
argument_list|,
name|stack_args_preallocated
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"old INSN:"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|oldaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnew INSN:"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|newaddr
argument_list|)
expr_stmt|;
block|}
return|return
name|newaddr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the stack and frame (if desired) for the function.  */
end_comment

begin_function
name|void
name|function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|reg_numchar
index|[]
decl_stmt|;
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|fmask
decl_stmt|;
name|int
name|push_loc
decl_stmt|;
name|int
name|tsize
decl_stmt|;
name|int
name|num_regs
decl_stmt|;
name|char
modifier|*
modifier|*
name|reg_name_ptr
init|=
operator|(
name|TARGET_NAME_REGS
operator|)
condition|?
name|reg_names
else|:
name|reg_numchar
decl_stmt|;
name|char
modifier|*
name|base_str
decl_stmt|;
name|char
modifier|*
name|sp_str
init|=
name|reg_name_ptr
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|fp_str
init|=
operator|(
operator|!
name|frame_pointer_needed
operator|)
condition|?
name|sp_str
else|:
name|reg_name_ptr
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
comment|/* current... is tooo long */
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fnargs
init|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
condition|?
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|next_arg
decl_stmt|;
name|tree
name|cur_arg
decl_stmt|;
name|char
modifier|*
name|arg_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|inside_function
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ent\t%s\n%s:\n"
argument_list|,
name|current_function_name
argument_list|,
name|current_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" #PROLOGUE\n"
argument_list|)
expr_stmt|;
comment|/* Determine the last argument, and get it's name.  */
for|for
control|(
name|cur_arg
operator|=
name|fnargs
init|;
name|cur_arg
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|;
name|cur_arg
operator|=
name|next_arg
control|)
block|{
name|next_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|cur_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
operator|==
operator|(
name|tree
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|cur_arg
argument_list|)
condition|)
name|arg_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|cur_arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this function is a varargs function, store any registers that      would normally hold arguments ($4 - $7) on the stack.  */
if|if
condition|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
operator|||
operator|(
name|arg_name
operator|&&
operator|(
name|strcmp
argument_list|(
name|arg_name
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg_name
argument_list|,
literal|"va_alist"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|tree
name|parm
decl_stmt|;
name|regno
operator|=
literal|4
expr_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
operator|(
name|parm
operator|&&
operator|(
name|regno
operator|<=
literal|7
operator|)
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|rtx
name|entry_parm
decl_stmt|;
name|enum
name|machine_mode
name|passed_mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|passed_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_parm
condition|)
block|{
name|int
name|words
decl_stmt|;
comment|/* passed in a register, so will get homed automatically */
if|if
condition|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|BLKmode
condition|)
name|words
operator|=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
else|else
name|words
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
operator|+
name|words
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|regno
operator|=
literal|8
expr_stmt|;
break|break;
block|}
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsd\t%s,0(%s)\t#varargs: home regs 4-5\n"
argument_list|,
name|reg_name_ptr
index|[
literal|4
index|]
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsd\t%s,8(%s)\t#varargs: home regs 6-7\n"
argument_list|,
name|reg_name_ptr
index|[
literal|6
index|]
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsw\t%s,4(%s)\t#varargs: home reg  5\n"
argument_list|,
name|reg_name_ptr
index|[
literal|5
index|]
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsd\t%s,8(%s)\t#varargs: home regs 6-7\n"
argument_list|,
name|reg_name_ptr
index|[
literal|6
index|]
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsd\t%s,8(%s)\t#varargs: home regs 6-7\n"
argument_list|,
name|reg_name_ptr
index|[
literal|6
index|]
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsw\t%s,12(%s)\t#varargs: home reg 7\n"
argument_list|,
name|reg_name_ptr
index|[
literal|7
index|]
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|mask
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
name|num_regs
operator|=
literal|0
expr_stmt|;
name|push_loc
operator|=
name|stack_args_preallocated
expr_stmt|;
name|tsize
operator|=
name|AL_ADJUST_ALIGN
argument_list|(
name|size
argument_list|)
operator|+
name|stack_args_preallocated
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GP_REG_FIRST
init|;
name|regno
operator|<=
name|GP_REG_LAST
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|tsize
operator|+=
literal|4
expr_stmt|;
name|num_regs
operator|+=
literal|4
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
name|GP_REG_FIRST
operator|)
expr_stmt|;
block|}
name|tsize
operator|=
name|AL_ADJUST_ALIGN
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
name|num_regs
operator|=
name|AL_ADJUST_ALIGN
argument_list|(
name|num_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
init|;
name|regno
operator|<=
name|FP_REG_LAST
condition|;
name|regno
operator|+=
literal|2
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|tsize
operator|+=
literal|8
expr_stmt|;
name|num_regs
operator|+=
literal|8
expr_stmt|;
name|fmask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
name|FP_REG_FIRST
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tsize
condition|)
name|tsize
operator|-=
name|STARTING_FRAME_OFFSET
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|&&
name|sp_fp_difference
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\t= %d\t\t\t#Difference between SP& FP\n\n"
argument_list|,
name|sp_fp_difference
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|current_function_total_framesize
operator|=
name|tsize
expr_stmt|;
name|current_function_saved_reg_size
operator|=
name|num_regs
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tsize
operator|<=
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubu\t%s,%s,%d\t# temp= %d, regs= %d, args= %d, sfo= %d\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|,
name|size
argument_list|,
name|num_regs
argument_list|,
name|stack_args_preallocated
argument_list|,
name|STARTING_FRAME_OFFSET
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,%d\n\tsubu\t%s,%s,%s\t# temp= %d, regs= %d, args= %d, sfo= %d\n"
argument_list|,
name|reg_name_ptr
index|[
name|MIPS_TEMP1_REGNUM
index|]
argument_list|,
name|tsize
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|reg_name_ptr
index|[
name|MIPS_TEMP1_REGNUM
index|]
argument_list|,
name|size
argument_list|,
name|num_regs
argument_list|,
name|stack_args_preallocated
argument_list|,
name|STARTING_FRAME_OFFSET
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame\t%s,%d,%s\n"
argument_list|,
name|fp_str
argument_list|,
operator|(
name|frame_pointer_needed
operator|)
condition|?
literal|0
else|:
name|tsize
argument_list|,
name|reg_name_ptr
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_loc
operator|>
literal|32767
operator|&&
name|num_regs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tsize
operator|-
operator|(
name|push_loc
operator|+
name|num_regs
operator|)
operator|)
operator|<=
literal|32767
condition|)
block|{
name|base_str
operator|=
name|reg_name_ptr
index|[
name|MIPS_TEMP1_REGNUM
index|]
expr_stmt|;
name|push_loc
operator|=
name|tsize
operator|-
name|push_loc
expr_stmt|;
block|}
else|else
block|{
name|base_str
operator|=
name|reg_name_ptr
index|[
name|MIPS_TEMP2_REGNUM
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,%d\n"
argument_list|,
name|base_str
argument_list|,
name|push_loc
argument_list|)
expr_stmt|;
name|push_loc
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|base_str
operator|=
name|sp_str
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GP_REG_FIRST
init|;
name|regno
operator|<=
name|GP_REG_LAST
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|-
name|GP_REG_FIRST
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsw\t%s,%d(%s)\n"
argument_list|,
name|reg_name_ptr
index|[
name|regno
index|]
argument_list|,
name|push_loc
argument_list|,
name|base_str
argument_list|)
expr_stmt|;
name|push_loc
operator|+=
literal|4
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask\t0x%08x,%d\n"
argument_list|,
name|mask
argument_list|,
name|push_loc
operator|-
name|tsize
operator|-
literal|4
argument_list|)
expr_stmt|;
name|push_loc
operator|=
name|AL_ADJUST_ALIGN
argument_list|(
name|push_loc
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
init|;
name|regno
operator|<=
name|FP_REG_LAST
condition|;
name|regno
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|fmask
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|-
name|FP_REG_FIRST
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\ts.d\t%s,%d(%s)\n"
argument_list|,
name|reg_name_ptr
index|[
name|regno
index|]
argument_list|,
name|push_loc
argument_list|,
name|base_str
argument_list|)
expr_stmt|;
name|push_loc
operator|+=
literal|8
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask\t0x%08x,%d\n"
argument_list|,
name|fmask
argument_list|,
name|push_loc
operator|-
name|tsize
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|tsize
operator|<=
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%d\t# set up frame pointer\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%s\t# set up frame pointer\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|reg_name_ptr
index|[
name|MIPS_TEMP1_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" #END PROLOGUE\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any necessary cleanup after a function to restore stack, frame, and regs. */
end_comment

begin_function
name|void
name|function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|FILE
modifier|*
name|asm_out_data_file
decl_stmt|,
modifier|*
name|asm_out_file
decl_stmt|;
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|reg_numchar
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|current_function_name
decl_stmt|;
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|push_loc
init|=
name|stack_args_preallocated
decl_stmt|;
name|int
name|tsize
init|=
name|current_function_total_framesize
decl_stmt|;
name|int
name|num_regs
init|=
name|current_function_saved_reg_size
decl_stmt|;
name|char
modifier|*
modifier|*
name|reg_name_ptr
init|=
operator|(
name|TARGET_NAME_REGS
operator|)
condition|?
name|reg_names
else|:
name|reg_numchar
decl_stmt|;
name|char
modifier|*
name|sp_str
init|=
name|reg_name_ptr
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|t1_str
init|=
name|reg_name_ptr
index|[
name|MIPS_TEMP1_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|base_str
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" #EPILOGUE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,%d\n"
argument_list|,
name|t1_str
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|char
modifier|*
name|fp_str
init|=
name|reg_name_ptr
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubu\t%s,%s,%s\t# sp not trusted  here\n"
argument_list|,
name|sp_str
argument_list|,
name|fp_str
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubu\t%s,%s,%d\t# sp not trusted  here\n"
argument_list|,
name|sp_str
argument_list|,
name|fp_str
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|push_loc
operator|>
literal|32767
operator|&&
name|num_regs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tsize
operator|-
operator|(
name|push_loc
operator|+
name|num_regs
operator|)
operator|)
operator|<=
literal|32767
condition|)
block|{
name|base_str
operator|=
name|t1_str
expr_stmt|;
name|push_loc
operator|=
name|tsize
operator|-
name|push_loc
expr_stmt|;
block|}
else|else
block|{
name|base_str
operator|=
name|reg_name_ptr
index|[
name|MIPS_TEMP2_REGNUM
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tli\t%s,%d\n"
argument_list|,
name|base_str
argument_list|,
name|push_loc
argument_list|)
expr_stmt|;
name|push_loc
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|base_str
operator|=
name|sp_str
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GP_REG_FIRST
init|;
name|regno
operator|<=
name|GP_REG_LAST
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlw\t%s,%d(%s)\n"
argument_list|,
name|reg_name_ptr
index|[
name|regno
index|]
argument_list|,
name|push_loc
argument_list|,
name|base_str
argument_list|)
expr_stmt|;
name|push_loc
operator|+=
literal|4
expr_stmt|;
block|}
name|push_loc
operator|=
name|AL_ADJUST_ALIGN
argument_list|(
name|push_loc
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
init|;
name|regno
operator|<=
name|FP_REG_LAST
condition|;
name|regno
operator|+=
literal|2
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl.d\t%s,%d(%s)\n"
argument_list|,
name|reg_name_ptr
index|[
name|regno
index|]
argument_list|,
name|push_loc
argument_list|,
name|base_str
argument_list|)
expr_stmt|;
name|push_loc
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|tsize
operator|>
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t%s,%s,%d\n"
argument_list|,
name|sp_str
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tj\t%s\n"
argument_list|,
name|reg_name_ptr
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" #END EPILOGUE\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.end\t%s\n"
argument_list|,
name|current_function_name
argument_list|)
expr_stmt|;
comment|/* Reset state info for each function.  */
name|stack_args_pushed
operator|=
literal|0
expr_stmt|;
name|stack_args_preallocated
operator|=
literal|0
expr_stmt|;
name|inside_function
operator|=
literal|0
expr_stmt|;
name|sp_fp_difference
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|number_functions_processed
operator|++
expr_stmt|;
comment|/* Restore the output file if optimizing the GP (optimizing the GP causes      the text to be diverted to a tempfile, so that data decls come before      references to the data).  */
if|if
condition|(
name|TARGET_GP_OPT
condition|)
name|asm_out_file
operator|=
name|asm_out_data_file
expr_stmt|;
block|}
end_function

end_unit

