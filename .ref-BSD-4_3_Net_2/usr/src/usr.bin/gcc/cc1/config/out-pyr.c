begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Pyramid 90 Series.    Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Some output-actions in pyr.md need these.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * Do FUNCTION_ARG.  * This cannot be defined as a macro on pyramids, because Pyramid Technology's  * C compiler dies on (several equivalent definitions of) this macro.  * The only way around this cc bug was to make this a function.  * While it would be possible to use a macro version for gcc, it seems  * more reliable to have a single version of the code.  */
end_comment

begin_function
name|void
modifier|*
name|pyr_function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|FUNCTION_ARG_HELPER
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do the hard part of PARAM_SAFE_FOR_REG_P.  * This cannot be defined as a macro on pyramids, because Pyramid Technology's  * C compiler dies on (several equivalent definitions of) this macro.  * The only way around this cc bug was to make this a function.  */
end_comment

begin_function
name|int
name|inner_param_safe_helper
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|INNER_PARAM_SAFE_HELPER
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a non-indexed operand of mode MODE.    This is either a register reference, a memory reference,    or a constant.  In the case of a memory reference, the address    is checked to make sure it isn't indexed.     Register and memory references must have mode MODE in order to be valid,    but some constants have no machine mode and are valid for any mode.     If MODE is VOIDmode, OP is checked for validity for whatever mode    it has.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     It is  useful to compare this with general_operand().  They should    be identical except for one line.     This function seems necessary because of the non-orthogonality of    Pyramid insns.    For any 2-operand insn, and any combination of operand modes,    if indexing is valid for the isn's second operand, it is invalid    for the first operand to be indexed. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|volatile_ok
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|nonindexed_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|mode_altering_drug
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
comment|/* Except for certain constants with VOIDmode, already checked for,      OP's mode must match MODE if MODE specifies a mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No longer needed, since (SUBREG (MEM...)) 	 will load the MEM into a reload reg in the MEM's own mode.  */
block|mode_altering_drug = 1;
endif|#
directive|endif
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|volatile_ok
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|GO_IF_NONINDEXED_ADDRESS
argument_list|(
name|y
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|win
label|:
if|if
condition|(
name|mode_altering_drug
condition|)
return|return
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the rtx OP has an immediate component.  An    immediate component or additive term equal to zero is rejected    due to assembler problems.  */
end_comment

begin_function
name|int
name|has_direct_base
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|&&
name|op
operator|!=
name|const0_rtx
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
operator|)
operator|||
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|has_index
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|swap_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* weird_memory_memory -- return 1 if OP1 and OP2 can be compared (or    exchanged with xchw) with one instruction.  If the operands need to    be swapped, set the global variable SWAP_OPERANDS.  This function    silently assumes that both OP0 and OP1 are valid memory references.    */
end_comment

begin_function
name|int
name|weird_memory_memory
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
name|RTX_CODE
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|swap_operands
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|SUBREG
condition|)
block|{
name|swap_operands
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|has_direct_base
argument_list|(
name|op0
argument_list|)
operator|&&
name|has_direct_base
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|has_index
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|has_index
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|0
return|;
name|swap_operands
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|signed_comparison
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|!
name|TRULY_UNSIGNED_COMPARE_P
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|rtx
name|force_reg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|rtx
name|test_op0
decl_stmt|,
name|test_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|test_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sign-extend or zero-extend constant X from FROM_MODE to TO_MODE.  */
end_comment

begin_function
name|rtx
name|extend_const
parameter_list|(
name|x
parameter_list|,
name|extop
parameter_list|,
name|from_mode
parameter_list|,
name|to_mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|RTX_CODE
name|extop
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
decl_stmt|,
name|to_mode
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|int
name|negative
decl_stmt|;
if|if
condition|(
name|from_mode
operator|==
name|to_mode
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|negative
operator|=
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|==
name|HOST_BITS_PER_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|negative
operator|&&
name|extop
operator|==
name|SIGN_EXTEND
condition|)
name|val
operator|=
name|val
operator||
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|)
operator|)
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|&
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|==
name|HOST_BITS_PER_INT
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
return|;
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|val
operator|&
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|ensure_extended
parameter_list|(
name|op
parameter_list|,
name|extop
parameter_list|,
name|from_mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|RTX_CODE
name|extop
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|extend_const
argument_list|(
name|op
argument_list|,
name|extop
argument_list|,
name|from_mode
argument_list|,
name|SImode
argument_list|)
return|;
else|else
return|return
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|extop
argument_list|,
name|SImode
argument_list|,
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit rtl for a branch, as well as any delayed (integer) compare insns.    The compare insn to perform is determined by the global variables    test_op0 and test_op1.  */
end_comment

begin_function
name|void
name|extend_and_branch
parameter_list|(
name|extop
parameter_list|)
name|RTX_CODE
name|extop
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|RTX_CODE
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|op0
operator|=
name|test_op0
operator|,
name|op1
operator|=
name|test_op1
expr_stmt|;
if|if
condition|(
name|op0
operator|==
literal|0
condition|)
return|return;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
literal|0
condition|)
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|test_op0
operator|=
name|test_op1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op1
operator|==
literal|0
condition|)
block|{
name|op0
operator|=
name|ensure_extended
argument_list|(
name|op0
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|ensure_extended
argument_list|(
name|op0
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|ensure_extended
argument_list|(
name|op1
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|extop
operator|==
name|ZERO_EXTEND
operator|&&
name|test_mode
operator|==
name|HImode
condition|)
block|{
comment|/* Pyramids have no unsigned "cmphi" instructions.  We need to 	     zero extend unsigned halfwords into temporary registers. */
name|op0
operator|=
name|ensure_extended
argument_list|(
name|op0
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|ensure_extended
argument_list|(
name|op1
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|ensure_extended
argument_list|(
name|op0
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|ensure_extended
argument_list|(
name|op1
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op1
operator|=
name|ensure_extended
argument_list|(
name|op1
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|ensure_extended
argument_list|(
name|op0
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
operator|)
condition|)
block|{
comment|/* I could do this case without extension, by using the virtual 	     register address (but that would lose for global regs).  */
name|op0
operator|=
name|ensure_extended
argument_list|(
name|op0
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|ensure_extended
argument_list|(
name|op1
argument_list|,
name|extop
argument_list|,
name|test_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MEM
operator|&&
name|code1
operator|==
name|MEM
condition|)
block|{
comment|/* Load into a reg if the address combination can't be handled 	     directly.  */
if|if
condition|(
operator|!
name|weird_memory_memory
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|test_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|COMPARE
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the two single-word moves with operands[0]    and operands[1] for the first single-word move, and operands[2]    and operands[3] for the second single-word move, is possible to    combine to a double word move.     The criterion is whether the operands are in consecutive memory cells,    registers, etc.  */
end_comment

begin_function
name|int
name|movdi_possible
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|cnst_diff0
decl_stmt|,
name|cnst_diff1
decl_stmt|;
name|RTX_CODE
name|code0
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code1
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* Don't dare to combine (possibly overlapping) memory -> memory moves.  */
comment|/* It would be possible to detect the cases where we dare, by using      constant_diff (operands[0], operands[1])!!!  */
if|if
condition|(
name|code0
operator|==
name|MEM
operator|&&
name|code1
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
name|cnst_diff0
operator|=
name|consecutive_operands
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnst_diff0
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|cnst_diff1
operator|=
name|consecutive_operands
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnst_diff1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cnst_diff0
operator|&
name|cnst_diff1
condition|)
block|{
comment|/* The source and destination operands are consecutive.  */
comment|/* If the first move writes into the source of the second move, 	 we cannot combine.  */
if|if
condition|(
operator|(
name|code0
operator|==
name|REG
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
operator|)
operator|||
operator|(
name|code0
operator|==
name|SUBREG
operator|&&
name|subreg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cnst_diff0
operator|&
literal|1
condition|)
comment|/* operands[0],[1] has higher addresses than operands[2],[3].  */
name|swap_operands
operator|=
literal|0
expr_stmt|;
else|else
comment|/* operands[0],[1] has lower addresses than operands[2],[3].  */
name|swap_operands
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like reg_overlap_mentioned_p, but accepts a subreg rtx instead    of a reg.  */
end_comment

begin_function
name|int
name|subreg_overlap_mentioned_p
parameter_list|(
name|subreg
parameter_list|,
name|x
parameter_list|)
name|rtx
name|subreg
decl_stmt|,
name|x
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|SUBREG_REG
argument_list|(
name|subreg
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|subreg
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP0 is a consecutive operand to OP1, 2 if OP1 is a    consecutive operand to OP0.     This function is used to determine if addresses are consecutive,    and therefore possible to combine to fewer instructions.  */
end_comment

begin_function
name|int
name|consecutive_operands
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|RTX_CODE
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|int
name|cnst_diff
decl_stmt|;
name|int
name|regno_off0
decl_stmt|,
name|regno_off1
decl_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|regno_off0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
name|regno_off0
operator|=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|REG
expr_stmt|;
block|}
name|regno_off1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
name|regno_off1
operator|=
name|SUBREG_WORD
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|REG
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|!=
name|code1
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code0
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Cannot permit any symbolic constants, even if the consecutive 	 operand is 0, since a movl really performs sign extension.  */
if|if
condition|(
name|code1
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|==
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|==
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|REG
case|:
name|regno_off0
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
name|regno_off0
expr_stmt|;
name|regno_off1
operator|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
name|regno_off1
expr_stmt|;
name|cnst_diff
operator|=
name|regno_off0
operator|-
name|regno_off1
expr_stmt|;
if|if
condition|(
name|cnst_diff
operator|==
literal|1
condition|)
block|{
comment|/* movl with the highest numbered parameter (local) register as 	     source or destination, doesn't wrap to the lowest numbered local 	     (temporary) register.  */
if|if
condition|(
name|regno_off0
operator|%
literal|16
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cnst_diff
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|regno_off1
operator|%
literal|16
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
else|else
return|return
literal|0
return|;
block|}
break|break;
case|case
name|MEM
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnst_diff
operator|=
name|constant_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnst_diff
condition|)
block|{
if|if
condition|(
name|cnst_diff
operator|==
literal|4
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cnst_diff
operator|==
operator|-
literal|4
condition|)
return|return
literal|2
return|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the constant difference of the rtx expressions OP0 and OP1,    or 0 if they don't have a constant difference.     This function is used to determine if addresses are consecutive,    and therefore possible to combine to fewer instructions.  */
end_comment

begin_function
name|int
name|constant_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|RTX_CODE
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|int
name|cnst_diff
decl_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|!=
name|code1
condition|)
block|{
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|code0
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
return|;
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|cnst_diff
operator|=
name|constant_diff
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnst_diff
condition|)
return|return
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|?
name|cnst_diff
else|:
literal|0
return|;
name|cnst_diff
operator|=
name|constant_diff
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnst_diff
condition|)
return|return
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|?
name|cnst_diff
else|:
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|already_sign_extended
parameter_list|(
name|insn
parameter_list|,
name|from_mode
parameter_list|,
name|op
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
block|{
name|rtx
name|xinsn
decl_stmt|,
name|xdest
decl_stmt|,
name|xsrc
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
return|return
literal|0
return|;
name|xinsn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xinsn
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|xdest
operator|=
name|SET_DEST
argument_list|(
name|xinsn
argument_list|)
expr_stmt|;
name|xsrc
operator|=
name|SET_SRC
argument_list|(
name|xinsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xdest
argument_list|)
operator|==
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|xdest
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|REGNO
argument_list|(
name|xdest
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|xsrc
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|xsrc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|from_mode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|xsrc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|xsrc
argument_list|)
operator|==
name|from_mode
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* The register is modified by another operation.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|xdest
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
comment|/* In an integer, the low-order word is in CONST_DOUBLE_LOW.  */
name|rtx
name|const_op
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"movl %1,%0"
return|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"movw %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"movw %1,%0"
return|;
block|}
else|else
block|{
comment|/* In a real, the low-address word is in CONST_DOUBLE_LOW.  */
name|rtx
name|const_op
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"movl %1,%0"
return|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|const_op
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"movw %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|const_op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"movw %1,%0"
return|;
block|}
block|}
return|return
literal|"movl %1,%0"
return|;
block|}
end_function

begin_comment
comment|/* Output a shift insns, after having reduced integer arguments to    avoid as warnings.  */
end_comment

begin_function
name|char
modifier|*
name|output_shift
parameter_list|(
name|pattern
parameter_list|,
name|op2
parameter_list|,
name|mod
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|int
name|mod
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|cnt
init|=
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|%
name|mod
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|cc_status
operator|=
name|cc_prev_status
expr_stmt|;
return|return
literal|""
return|;
block|}
name|op2
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
return|return
name|pattern
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the code of this rtx pattern is a relop.  */
end_comment

begin_function
name|int
name|relop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|notice_update_cc
parameter_list|(
name|EXP
parameter_list|,
name|INSN
parameter_list|)
name|rtx
name|EXP
decl_stmt|,
name|INSN
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|EXP
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CC0
case|:
name|cc_status
operator|.
name|mdep
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC
case|:
break|break;
case|case
name|REG
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CALL
case|:
goto|goto
name|call
goto|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
argument_list|)
operator|==
name|QImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|cc_status
operator|.
name|mdep
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else: Fall through.  */
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|REG
case|:
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
name|cc_status
operator|.
name|mdep
operator|=
name|CC_VALID_FOR_UNSIGNED
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cc_status
operator|.
name|mdep
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MEM
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
argument_list|)
operator|==
name|QImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* else: Fall through.  */
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|MEM
case|:
comment|/* Need to forget cc_status about memory positions each 		 time a memory store is made, even if the memory store 		 insns in question doesn't modify the condition codes.  */
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|==
name|MEM
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|==
name|MEM
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_DEST
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_SRC
argument_list|(
name|EXP
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CALL
case|:
name|call
label|:
name|CC_STATUS_INIT
expr_stmt|;
break|break;
comment|/* Do calls preserve the condition codes?  (At least forget 	 cc_status expressions if they refer to registers 	 not preserved across calls.  Also forget expressions 	 about memory contents.)  */
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
operator|(
name|refers_to_regno_p
argument_list|(
name|PYR_TREG
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PYR_TREG
argument_list|(
literal|15
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|,
literal|0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
operator|(
name|refers_to_regno_p
argument_list|(
name|PYR_TREG
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PYR_TREG
argument_list|(
literal|15
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|,
literal|0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|forget_cc_if_dependent
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|cc_status
operator|=
name|cc_prev_status
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|op
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|op
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

