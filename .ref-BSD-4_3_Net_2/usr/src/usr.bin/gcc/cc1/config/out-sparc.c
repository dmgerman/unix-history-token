begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Sun SPARC.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Global variables for machine-dependend things.  */
end_comment

begin_comment
comment|/* This should go away if we pass floats to regs via    the stack instead of the frame, and if we learn how    to renumber all the registers when we don't do a save (hard!).  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|next_real_insn_no_labels
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if INSN is a conditional insn with a predicate    valid after an addcc or subcc instruction.  */
end_comment

begin_function
name|int
name|ignore_overflow_conditional_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this pattern, can be evaluated safely, even if it    was not asked for.  */
end_comment

begin_function
name|int
name|safe_insn_src_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Just experimenting.  */
comment|/* No floating point src is safe if it contains an arithmetic      operation, since that operation may trap.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
return|return
literal|1
return|;
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
case|case
name|PLUS
case|:
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if REG is clobbered in IN.    Return 0 if REG is used in IN (other than being clobbered).    Return 2 if REG does not appear in IN.  */
end_comment

begin_function
specifier|static
name|int
name|reg_clobbered_p
parameter_list|(
name|reg
parameter_list|,
name|in
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|2
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Let these fail out quickly.  */
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|2
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|in
argument_list|)
operator|!=
literal|0
condition|)
name|in
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|in
operator|=
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
expr_stmt|;
case|case
name|REG
case|:
if|if
condition|(
name|in
operator|==
name|reg
operator|||
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|2
return|;
case|case
name|SET
case|:
if|if
condition|(
name|SET_SRC
argument_list|(
name|in
argument_list|)
operator|==
name|reg
operator|||
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|in
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|in
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
return|return
literal|2
return|;
case|case
name|USE
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|||
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|2
return|;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
comment|/* If the CLOBBER expression is a SUBREG, accept that as a 	 clobber.  But if it is some expression based on this register, 	 that is like a USE as far as this register is concerned, 	 so we won't take it.  */
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
return|return
literal|2
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|result
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
switch|switch
condition|(
name|reg_clobbered_p
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|2
case|:
continue|continue;
case|case
literal|1
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
switch|switch
condition|(
name|reg_clobbered_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|2
case|:
continue|continue;
case|case
literal|1
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if OP can be written to without screwing up    GCC's model of what's going on.  It is assumed that this operand    appears in the dest position of a SET insn in a conditional    branch's delay slot.  AFTER is the label to start looking from.  */
end_comment

begin_function
name|int
name|operand_clobbered_before_used_after
parameter_list|(
name|op
parameter_list|,
name|after
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
comment|/* Just experimenting.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
switch|switch
condition|(
name|reg_clobbered_p
argument_list|(
name|op
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|2
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This is a jump insn which has already 		 been mangled.  We can't tell what it does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Keep following jumps.  */
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* In both of these cases, the first insn executed      for this op will be a sethi %hi(whatever),%g1,      which is tolerable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this pattern, as a source to a "SET",    is known to yield an instruction of unit size.  */
end_comment

begin_function
name|int
name|single_insn_src_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
if|#
directive|if
literal|1
comment|/* This is not always a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|SMALL_INT
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We can put this set insn into delay slot, because this is one 	 insn; 'sethi'.  */
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* This is not a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
endif|#
directive|endif
if|#
directive|if
literal|1
case|case
name|SYMBOL_REF
case|:
comment|/* This is not a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|#
directive|if
literal|0
comment|/* This is not a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
block|if (GET_CODE (XEXP (op, 0)) == SYMBOL_REF) 	return 0;
endif|#
directive|endif
return|return
literal|1
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
return|return
literal|1
return|;
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
comment|/* If the target is cc0, then these insns will take 	 two insns (one being a nop).  */
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|PLUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|single_insn_src_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
comment|/* Lazy... could check for more cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This extra test must be done to verify that a move insn    really is just one assembler insn.  */
end_comment

begin_function
name|int
name|single_insn_extra_test
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
block|{
comment|/* Moves between FP regs and CPU regs are two insns.  */
return|return
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|FP_REG_P
argument_list|(
name|src
argument_list|)
operator|!=
name|FP_REG_P
argument_list|(
name|dest
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero only if this *really* is a single insn operand.  */
end_comment

begin_function
name|int
name|strict_single_insn_op_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|SMALL_INT
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We can put this set insn into delay slot, because this is one 	 insn; 'sethi'.  */
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|&&
name|mode
operator|!=
name|DImode
operator|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|&&
name|mode
operator|!=
name|DImode
operator|)
return|;
return|return
literal|0
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
return|return
literal|1
return|;
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
comment|/* If the target is cc0, then these insns will take 	 two insns (one being a nop).  */
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|PLUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|strict_single_insn_op_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP is a relational operator.  */
end_comment

begin_function
name|int
name|relop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of wheterh OP is EQ or NE.  */
end_comment

begin_function
name|int
name|eq_or_neq
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP can be used as an operands in a three    address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operand in a two    address arithmetic insn (such as set 123456,%o4) of mode MODE.  */
end_comment

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in three-address insns.  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m0),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"st %1,[%%lo(%m0)+%%g1]"
return|;
block|}
else|else
return|return
literal|"st %r1,%0"
return|;
else|else
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_F0_IS_0
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SFmode
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|xoperands
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|xoperands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|xoperands
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m1),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"ld [%%lo(%m1)+%%g1],%0"
return|;
block|}
return|return
literal|"ld %1,%0"
return|;
block|}
return|return
literal|"mov %1,%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the first move would clobber the source of the second one,      do them in the other order.       RMS says "This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance."       but it happens on the sparc when loading parameter registers,      so I am going to define that circumstance, and make it work      as expected.  */
comment|/* Easy case: try moving both words at once.  */
comment|/* First check for moving between an even/odd register pair      and a memory location.  */
if|if
condition|(
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|optype1
operator|!=
name|CNSTOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|optype0
operator|!=
name|REGOP
operator|&&
name|optype1
operator|!=
name|CNSTOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|,
name|offset
init|=
name|const0_rtx
decl_stmt|;
comment|/* OP1 gets the register pair, and OP2 gets the memory address.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|op1
operator|=
name|operands
index|[
literal|0
index|]
operator|,
name|op2
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|operands
index|[
literal|1
index|]
operator|,
name|op2
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now see if we can trust the address to be 8-byte aligned.  */
comment|/* Trust global variables.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|op2
argument_list|)
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|op1
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|op2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|op2
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%1),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|op2
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|operands
index|[
literal|0
index|]
condition|)
return|return
literal|"ldd [%%lo(%1)+%%g1],%0"
return|;
else|else
return|return
literal|"std [%%lo(%1)+%%g1],%0"
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
operator|,
name|offset
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|1
argument_list|)
operator|,
name|offset
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Trust round enough offsets from the stack or frame pointer.  */
if|if
condition|(
name|base
operator|&&
operator|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|op1
operator|==
name|operands
index|[
literal|0
index|]
condition|)
return|return
literal|"ldd %1,%0"
return|;
else|else
return|return
literal|"std %1,%0"
return|;
block|}
block|}
else|else
block|{
comment|/* We know structs not on the stack are properly aligned. 	     Since a double asks for 8-byte alignment, 	     we know it must have got that if it is in a struct. 	     But a DImode need not be 8-byte aligned, because it could be a 	     struct containing two ints or pointers.  */
comment|/* Sun fucks us here.  We cannot trust references 	     to doubles via varying addresses.  It might be on the stack 	     even if we don't know that it is; and then it might not be 	     double-word aligned.  */
if|#
directive|if
literal|0
block|if (GET_CODE (operands[1]) == MEM&& GET_MODE (operands[1]) == DFmode&& MEM_IN_STRUCT_P (operands[1])) 	    return "ldd %1,%0"; 	  else if (GET_CODE (operands[0]) == MEM&& GET_MODE (operands[0]) == DFmode&& MEM_IN_STRUCT_P (operands[0])) 	    return "std %1,%0";
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Do the late half first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Then clobber.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|output_fp_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"fmovs %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"fmovs %1,%0"
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"std %1,[%%fp-8]\n\tldd [%%fp-8],%0"
return|;
else|else
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st %2,[%%fp-4]\n\tst %1,[%%fp-8]\n\tldd [%%fp-8],%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* Use ldd if known to be aligned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
operator|)
if|#
directive|if
literal|0
comment|/* An array in a structure that is a parm need not be aligned!  */
comment|/* Arrays are known to be aligned, 		 and reg+reg addresses are used (on this machine) 		 only for array accesses.  */
expr||| (REG_P (XEXP (XEXP (operands[1], 0), 0))&& REG_P (XEXP (XEXP (operands[1], 0), 1)))
endif|#
directive|endif
operator|)
condition|)
return|return
literal|"ldd %1,%0"
return|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m1),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"ldd [%%lo(%m1)+%%g1],%0"
return|;
block|}
comment|/* Otherwise use two ld insns.  */
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|inc_reg
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inc_reg
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|frame_pointer_rtx
condition|)
name|inc_reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_reg
operator|==
name|frame_pointer_rtx
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov %%fp,%%g1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|inc_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|xoperands
index|[
literal|1
index|]
operator|=
name|inc_reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add 4,%1,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|inc_reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add -4,%1,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"std %1,[%%fp-8]\n\tldd [%%fp-8],%0"
return|;
else|else
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"std %2,[%%fp-8]\n\tld [%%fp-4],%1\n\tld [%%fp-8],%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* Use std if we can be sure it is well-aligned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
operator|)
if|#
directive|if
literal|0
comment|/* An array in a structure that is a parm need not be aligned!  */
comment|/* Arrays are known to be aligned, 		 and reg+reg addresses are used (on this machine) 		 only for array accesses.  */
expr||| (REG_P (XEXP (XEXP (operands[0], 0), 0))&& REG_P (XEXP (XEXP (operands[0], 0), 1)))
endif|#
directive|endif
operator|)
condition|)
return|return
literal|"std %1,%0"
return|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m0),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"std %1,[%%lo(%m0)+%%g1]"
return|;
block|}
comment|/* Otherwise use two st insns.  */
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|output_asm_insn
argument_list|(
literal|"st %r1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st %r1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|inc_reg
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inc_reg
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|frame_pointer_rtx
condition|)
name|inc_reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc_reg
operator|==
name|frame_pointer_rtx
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov %%fp,%%g1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|inc_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|xoperands
index|[
literal|0
index|]
operator|=
name|inc_reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add 4,%0,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st %r1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|inc_reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add -4,%0,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st %r1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_sized_memop
parameter_list|(
name|opname
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|opname
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|extern
name|struct
name|_iobuf
modifier|*
name|asm_out_file
decl_stmt|;
specifier|static
name|char
modifier|*
name|ld_size_suffix
index|[]
init|=
block|{
literal|"ub"
block|,
literal|"uh"
block|,
literal|""
block|,
literal|"?"
block|,
literal|"d"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|st_size_suffix
index|[]
init|=
block|{
literal|"b"
block|,
literal|"h"
block|,
literal|""
block|,
literal|"?"
block|,
literal|"d"
block|}
decl_stmt|;
name|char
modifier|*
name|modename
init|=
operator|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'l'
condition|?
name|ld_size_suffix
else|:
name|st_size_suffix
operator|)
index|[
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s%s"
argument_list|,
name|opname
argument_list|,
name|modename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a store-in-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a MEM, and OPERANDS[1] is a reg or zero.  */
end_comment

begin_function
name|char
modifier|*
name|output_store
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m0),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
comment|/* Store zero in two parts when appropriate.  */
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|&&
name|operands
index|[
literal|1
index|]
operator|==
name|dconst0_rtx
condition|)
block|{
comment|/* We can't cross a page boundary here because the 	 SYMBOL_REF must be double word aligned, and for this 	 to be the case, SYMBOL_REF+4 cannot cross.  */
name|output_sized_memop
argument_list|(
literal|"st"
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"%r1,[%%g1+%%lo(%m0)]"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_sized_memop
argument_list|(
literal|"st"
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
return|return
literal|"%r1,[%%g1+%%lo(%m0)+4]"
return|;
block|}
comment|/* Code below isn't smart enough to move a doubleword in two parts,      so use output_move_double to do that in the cases that require it.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|)
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
name|output_sized_memop
argument_list|(
literal|"st"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|"%r1,[%%g1+%%lo(%m0)]"
return|;
block|}
end_function

begin_comment
comment|/* Output a fixed-point load-from-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a reg, and OPERANDS[1] is a mem.  */
end_comment

begin_function
name|char
modifier|*
name|output_load_fixed
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We don't bother trying to see if we know %hi(address).      This is because we are doing a load, and if we know the      %hi value, we probably also know that value in memory.  */
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|cc_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m1),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
comment|/* Code below isn't smart enough to do a doubleword in two parts.      So handle that case the slow way.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
comment|/* Moving to nonaligned reg pair */
operator|&&
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&
literal|1
operator|)
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
name|output_sized_memop
argument_list|(
literal|"ld"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|"[%%g1+%%lo(%m1)],%0"
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a floating-point load-from-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a reg, and OPERANDS[1] is a mem.    We also handle the case where OPERANDS[0] is a mem.  */
end_comment

begin_function
name|char
modifier|*
name|output_load_floating
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We don't bother trying to see if we know %hi(address).      This is because we are doing a load, and if we know the      %hi value, we probably also know that value in memory.  */
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_G1
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|cc_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m1),%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&
literal|1
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
else|else
return|return
literal|"ldd [%%g1+%%lo(%m1)],%0"
return|;
block|}
name|cc_status
operator|.
name|flags
operator|&=
operator|~
operator|(
name|CC_F0_IS_0
operator||
name|CC_F1_IS_0
operator|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldd [%%g1+%%lo(%m1)],%%f0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|DFmode
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
name|output_fp_move_double
argument_list|(
name|operands
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_F1_IS_0
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld [%%g1+%%lo(%1)],%%f1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"sethi %%hi(%m0),%%g1\n\tst %%f1,[%%g1+%%lo(%m0)]"
return|;
block|}
else|else
return|return
literal|"st %%f1,%0"
return|;
block|}
return|return
literal|"ld [%%g1+%%lo(%m1)],%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the address specified by OPERANDS[3] into the register    specified by OPERANDS[0].     OPERANDS[3] may be the result of a sum, hence it could either be:     (1) CONST    (2) REG    (2) REG + CONST_INT    (3) REG + REG + CONST_INT    (4) REG + REG  (special case of 3).     Note that (3) is not a legitimate address.    All cases are handled here.  */
end_comment

begin_function
name|void
name|output_load_address
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"set %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* Operand is (PLUS (REG) (REG)).  */
name|base
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|operands
index|[
literal|6
index|]
operator|=
name|base
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"add %6,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"set %7,%0\n\tadd %0,%6,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|operands
index|[
literal|6
index|]
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|8
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"add %6,%7,%0\n\tadd %0,%8,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"set %8,%0\n\tadd %0,%6,%0\n\tadd %0,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code to place a size count SIZE in register REG.    ALIGN is the size of the unit of transfer.     Because block moves are pipelined, we don't include the    first element in the transfer of SIZE to REG.  */
end_comment

begin_function
specifier|static
name|void
name|output_size_for_block_move
parameter_list|(
name|size
parameter_list|,
name|reg
parameter_list|,
name|align
parameter_list|)
name|rtx
name|size
decl_stmt|,
name|reg
decl_stmt|;
name|rtx
name|align
decl_stmt|;
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|reg
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|size
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|align
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
condition|)
name|output_asm_insn
argument_list|(
literal|"sub %1,%2,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_G1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"set %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move.     OPERANDS[0] is the destination.    OPERANDS[1] is the source.    OPERANDS[2] is the size.    OPERANDS[3] is the alignment safe to use.    OPERANDS[4] is a register we can safely clobber as a temp.  */
end_comment

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* A vector for our computed operands.  Note that load_output_address      makes use of (and can clobber) up to the 8th element of this vector.  */
name|rtx
name|xoperands
index|[
literal|10
index|]
decl_stmt|;
name|rtx
name|zoperands
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|int
name|movstrsi_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|temp1
init|=
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|alignrtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|alignrtx
argument_list|)
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|temp1
expr_stmt|;
comment|/* We can't move more than four bytes at a time      because we have only one register to move them through.  */
if|if
condition|(
name|align
operator|>
literal|4
condition|)
block|{
name|align
operator|=
literal|4
expr_stmt|;
name|alignrtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Since we clobber untold things, nix the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Recognize special cases of block moves.  These occur      when GNU C++ is forced to treat something as BLKmode      to keep it in memory, when its mode could be represented      with something smaller.       We cannot do this for global variables, since we don't know      what pages they don't cross.  Sigh.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|<=
literal|16
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_G1
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|xoperands
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|xoperands
index|[
literal|1
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We will store different integers into this particular RTX.  */
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|)
operator|=
name|i
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldub [%a1+%2],%%g1\n\tstb %%g1,[%a0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|align
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|xoperands
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|xoperands
index|[
literal|1
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We will store different integers into this particular RTX.  */
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|1
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|)
operator|=
name|i
operator|<<
literal|1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lduh [%a1+%2],%%g1\n\tsth %%g1,[%a0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|xoperands
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|xoperands
index|[
literal|1
index|]
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We will store different integers into this particular RTX.  */
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|2
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|)
operator|=
name|i
operator|<<
literal|2
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld [%a1+%2],%%g1\n\tst %%g1,[%a0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
block|}
comment|/* This is the size of the transfer.      Either use the register which already contains the size,      or use a free register (used by no operands).      Also emit code to decrement the size value by ALIGN.  */
name|output_size_for_block_move
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|temp1
argument_list|,
name|alignrtx
argument_list|)
expr_stmt|;
name|zoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|zoperands
index|[
literal|3
index|]
operator|=
name|plus_constant
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|output_load_address
argument_list|(
name|zoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|1
condition|)
name|output_asm_insn
argument_list|(
literal|"\nLm%3:\n\tldub [%1+%2],%%g1\n\tsubcc %2,%4,%2\n\tbge Lm%3\n\tstb %%g1,[%0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|==
literal|2
condition|)
name|output_asm_insn
argument_list|(
literal|"\nLm%3:\n\tlduh [%1+%2],%%g1\n\tsubcc %2,%4,%2\n\tbge Lm%3\n\tsth %%g1,[%0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"\nLm%3:\n\tld [%1+%2],%%g1\n\tsubcc %2,%4,%2\n\tbge Lm%3\n\tst %%g1,[%0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* What the sparc lacks in hardware, make up for in software.    Compute a fairly good sequence of shift and add insns    to make a multiply happen.  */
end_comment

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|x
parameter_list|)
value|((x)< 0 ? -(x) : x)
end_define

begin_function
name|char
modifier|*
name|output_mul_by_constant
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
comment|/* Size of constant */
name|int
name|shifts
index|[
name|BITS_PER_WORD
index|]
decl_stmt|;
comment|/* Table of shifts */
name|unsigned
name|int
name|p
decl_stmt|,
name|log
decl_stmt|;
comment|/* A power of two, and its log */
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|;
comment|/* Differences of c and p */
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* True if dst has unknown data in it */
name|int
name|i
decl_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* Does happen, at least when not optimizing.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"st %%g0,%0"
return|;
return|return
literal|"mov %%g0,%0"
return|;
block|}
name|output_asm_insn
argument_list|(
literal|"! start open coded multiply"
argument_list|)
expr_stmt|;
comment|/* Clear out the table of shifts. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS_PER_WORD
condition|;
operator|++
name|i
control|)
name|shifts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
comment|/* Find the power of two nearest ABS(c) */
name|p
operator|=
literal|1
operator|,
name|log
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|d1
operator|=
name|ABS
argument_list|(
name|c
argument_list|)
operator|-
name|p
expr_stmt|;
name|p
operator|*=
literal|2
expr_stmt|;
operator|++
name|log
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|ABS
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|d2
operator|=
name|p
operator|-
name|ABS
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Make an appropriate entry in shifts for p. */
if|if
condition|(
name|d2
operator|<
name|d1
condition|)
block|{
name|shifts
index|[
name|log
index|]
operator|=
name|c
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|c
operator|=
name|c
operator|<
literal|0
condition|?
name|d2
else|:
operator|-
name|d2
expr_stmt|;
block|}
else|else
block|{
name|shifts
index|[
name|log
operator|-
literal|1
index|]
operator|=
name|c
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|c
operator|=
name|c
operator|<
literal|0
condition|?
operator|-
name|d1
else|:
name|d1
expr_stmt|;
block|}
block|}
comment|/* Take care of the first insn in sequence.      We know we have at least one. */
comment|/* A value of -1 in shifts says to subtract that power of two, and a value      of 1 says to add that power of two. */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|shifts
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"sll %1,%2,%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"mov %1,%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|log
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shifts
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"sub %%g0,%%g1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov %%g1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* A value of -1 in shifts says to subtract that power of two, and a value      of 1 says to add that power of two--continued.  */
for|for
control|(
name|i
operator|+=
literal|1
init|;
name|i
operator|<
name|BITS_PER_WORD
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|shifts
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|-
name|log
operator|>
literal|0
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|i
operator|-
name|log
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"sll %%g1,%2,%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|log
operator|-
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"sra %%g1,%2,%%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|log
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shifts
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"sub %0,%%g1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add %0,%%g1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"! end open coded multiply"
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_mul_insn
parameter_list|(
name|operands
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|lucky1
init|=
operator|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|-
literal|8
operator|)
operator|<=
literal|1
decl_stmt|;
name|int
name|lucky2
init|=
operator|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|-
literal|8
operator|)
operator|<=
literal|1
decl_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|lucky1
condition|)
block|{
if|if
condition|(
name|lucky2
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
literal|8
condition|)
name|output_asm_insn
argument_list|(
literal|"mov %%o0,%%o1"
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov %%o1,%%o0"
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"call .mul,2\n\tnop"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|8
operator|^
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
literal|8
operator|)
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"call .mul,2\n\tmov %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lucky2
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|8
operator|^
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|8
operator|)
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"call .mul,2\n\tmov %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"mov %1,%%o0\n\tcall .mul,2\n\tmov %2,%%o1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
literal|8
condition|)
return|return
literal|""
return|;
return|return
literal|"mov %%o0,%0"
return|;
block|}
end_function

begin_comment
comment|/* Make floating point register f0 contain 0.    SIZE is the number of registers (including f0)    which should contain 0.  */
end_comment

begin_function
name|void
name|make_f0_contain_0
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cc_status
operator|.
name|flags
operator|&
operator|(
name|CC_F0_IS_0
operator|)
operator|)
operator|==
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"ld [%%fp-16],%%f0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_F0_IS_0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_F0_IS_0
operator|)
operator|==
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"ld [%%fp-16],%%f0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc_status
operator|.
name|flags
operator|&
operator|(
name|CC_F1_IS_0
operator|)
operator|)
operator|==
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"ld [%%fp-12],%%f1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_F0_IS_0
operator||
name|CC_F1_IS_0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Since condition codes don't have logical links, we need to keep    their setting and use together for set-cc insns.  */
end_comment

begin_function
name|void
name|gen_scc_insn
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|extern
name|rtx
name|sequence_stack
decl_stmt|;
name|rtx
name|last_insn
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|sequence_stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|last_pat
decl_stmt|;
comment|/* Skip back over the CLOBBERs that may precede this insn.  */
while|while
condition|(
name|last_insn
operator|&&
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
comment|/* We should have found the preceding compare.  */
if|if
condition|(
name|last_insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_pat
operator|=
name|PATTERN
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|last_pat
argument_list|)
argument_list|)
operator|!=
name|CC0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Turn off that previous insn, now that we have got the data out of it.  */
name|PUT_CODE
argument_list|(
name|last_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|last_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
comment|/* Emit one replacement insn to compare operands and store result.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SET_SRC
argument_list|(
name|last_pat
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output reasonable peephole for set-on-condition-code insns.    Note that these insns assume a particular way of defining    labels.  Therefore, *both* tm-sparc.h and this function must    be changed if a new syntax is needed.  */
end_comment

begin_function
name|char
modifier|*
name|output_scc_insn
parameter_list|(
name|code
parameter_list|,
name|operand
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|operand
decl_stmt|;
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|cc_in_fccr
init|=
name|cc_status
operator|.
name|flags
operator|&
name|CC_IN_FCCR
decl_stmt|;
name|int
name|antisymmetric
init|=
literal|0
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|label
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|output_asm_insn
argument_list|(
literal|"fbne,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bne,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|output_asm_insn
argument_list|(
literal|"fbe,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"be,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|output_asm_insn
argument_list|(
literal|"fbge,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bge,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|output_asm_insn
argument_list|(
literal|"fbg,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bg,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|output_asm_insn
argument_list|(
literal|"fble,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"ble,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|output_asm_insn
argument_list|(
literal|"fbl,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bl,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bgeu,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bgu,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"bleu,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|cc_in_fccr
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"blu,a %l0"
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|antisymmetric
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|antisymmetric
operator|&&
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_REVERSED
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orcc %%g0,0,%0\n\torcc %%g0,1,%0\n%l1:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"orcc %%g0,1,%0\n\torcc %%g0,0,%0\n%l1:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_IN_FCCR
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a delayed branch insn with the delay insn in its    branch slot.  The delayed branch insn template is in TEMPLATE,    with operands OPERANDS.  The insn in its delay slot is INSN.     As a special case, since we know that all memory transfers are via    ld/st insns, if we see a (MEM (SYMBOL_REF ...)) we divide the memory    reference around the branch as  	sethi %hi(x),%%g1 	b ... 	ld/st [%g1+%lo(x)],...     As another special case, we handle loading (SYMBOL_REF ...) and    other large constants around branches as well:  	sethi %hi(x),%0 	b ... 	or %0,%lo(x),%1     */
end_comment

begin_function
name|char
modifier|*
name|output_delayed_branch
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|,
name|insn
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|extern
name|rtx
name|recog_operand
index|[]
decl_stmt|;
name|rtx
name|src
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
operator|(
name|SMALL_INT
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
comment|/* Output the `sethi' insn.  */
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%1),%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Output the branch instruction next.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now output the `or' insn.  */
name|output_asm_insn
argument_list|(
literal|"or %0,%%lo(%1),%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|split_template
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
comment|/* Output the `sethi' insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m1),%%g1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|split_template
operator|=
literal|"ld [%%g1+%%lo(%m1)],%0"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_G1
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi %%hi(%m0),%%g1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|split_template
operator|=
literal|"st %r1,[%%g1+%%lo(%m0)]"
expr_stmt|;
block|}
comment|/* Output the branch instruction next.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now output the load or store. 	 No need to do a CC_STATUS_INIT, because we are branching anyway.  */
name|output_asm_insn
argument_list|(
name|split_template
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|char
modifier|*
name|insn_template
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|insn_outfun
index|[]
function_decl|)
parameter_list|()
function_decl|;
name|int
name|insn_code_number
decl_stmt|;
name|rtx
name|pat
init|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|rtx
name|delay_insn
init|=
name|gen_rtx
argument_list|(
name|INSN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pat
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
comment|/* Output the branch instruction first.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now recognize the insn which we put in its delay slot. 	 We must do this after outputing the branch insn, 	 since operands may just be a pointer to `recog_operand'.  */
name|insn_code_number
operator|=
name|recog
argument_list|(
name|pat
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the template for what this insn would 	 have been, without the branch.  Its operands are 	 exactly the same as they would be, so we don't 	 need to do an insn_extract.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
block|}
name|CC_STATUS_INIT
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a newly constructed insn DELAY_INSN.  */
end_comment

begin_function
name|char
modifier|*
name|output_delay_insn
parameter_list|(
name|delay_insn
parameter_list|)
name|rtx
name|delay_insn
decl_stmt|;
block|{
name|char
modifier|*
name|template
decl_stmt|;
specifier|extern
name|rtx
name|recog_operand
index|[]
decl_stmt|;
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|insn_template
index|[]
decl_stmt|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|insn_outfun
index|[]
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
name|int
name|insn_code_number
decl_stmt|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Now recognize the insn which we put in its delay slot.      We must do this after outputing the branch insn,      since operands may just be a pointer to `recog_operand'.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Extract the operands of this delay insn.  */
name|INSN_CODE
argument_list|(
name|delay_insn
argument_list|)
operator|=
name|insn_code_number
expr_stmt|;
name|insn_extract
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* It is possible that this insn has not been properly scaned by final      yet.  If this insn's operands don't appear in the peephole's      actual operands, then they won't be fixed up by final, so we      make sure they get fixed up here.  -- This is a kludge.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction.      The instruction's output routine may change it further.      If the output routine for a jump insn needs to depend      on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|delay_insn
argument_list|)
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* Now get the template for what this insn would      have been, without the branch.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output the insn HEAD, keeping OPERANDS protected (wherever they are).    HEAD comes from the target of some branch, so before we output it,    we delete it from the target, lest we execute it twice.  The caller    of this function promises that such code motion is permissable.  */
end_comment

begin_function
name|char
modifier|*
name|output_eager_then_insn
parameter_list|(
name|head
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|head
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|extern
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
specifier|extern
name|rtx
name|recog_operand
index|[]
decl_stmt|;
name|rtx
name|xoperands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|,
name|i
decl_stmt|,
name|nbytes
decl_stmt|;
name|rtx
name|nhead
decl_stmt|;
comment|/* Micro-hack: run peephole on head if it looks like a good idea.      Right now there's only one such case worth doing...       This could be made smarter if the peephole for ``2-insn combine''      were also made smarter.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|nhead
operator|=
name|next_real_insn_no_labels
argument_list|(
name|head
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|nhead
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|nhead
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|nhead
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
operator|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|nhead
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|||
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|nhead
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* Something's wrong if this does not fly.  */
if|if
condition|(
operator|!
name|peephole
argument_list|(
name|head
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Save our contents of `operands', since output_delay_insn sets them.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|operands
argument_list|,
name|xoperands
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Output the delay insn, and prevent duplication later.  */
name|delete_insn
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|output_delay_insn
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* Restore this insn's operands.  */
name|bcopy
argument_list|(
name|xoperands
argument_list|,
name|operands
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next INSN, CALL_INSN or JUMP_INSN after LABEL;    or 0, if there is none.  Also return 0 if we cross a label.  */
end_comment

begin_function
name|rtx
name|next_real_insn_no_labels
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
return|return
name|insn
return|;
block|}
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
return|return
name|insn
return|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|operands_satisfy_eager_branch_peephole
parameter_list|(
name|operands
parameter_list|,
name|conditional
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|conditional
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
if|if
condition|(
name|conditional
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
name|label
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
decl_stmt|;
while|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|head
init|=
name|next_real_insn_no_labels
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|head
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|strict_single_insn_op_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|strict_single_insn_op_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
argument_list|)
comment|/* Moves between FP regs and CPU regs are two insns.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|FP_REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|FP_REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|conditional
operator|==
literal|2
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|PC
operator|&&
name|safe_insn_src_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|strict_single_insn_op_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|operand_clobbered_before_used_after
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|label
argument_list|)
operator|)
return|;
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|conditional
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|PC
operator|&&
name|safe_insn_src_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|strict_single_insn_op_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|operand_clobbered_before_used_after
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|label
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

