begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Intel 860    Copyright (C) 1989 Free Software Foundation, Inc.    Derived from out-sparc.c.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Global variables for machine-dependend things.  */
end_comment

begin_comment
comment|/* This should go away if we pass floats to regs via    the stack instead of the frame, and if we learn how    to renumber all the registers when we don't do a save (hard!).  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this pattern, can be evaluated safely, even if it    was not asked for.  */
end_comment

begin_function
name|int
name|safe_insn_src_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Just experimenting.  */
comment|/* No floating point src is safe if it contains an arithmetic      operation, since that operation may trap.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
case|case
name|ZERO_EXTEND
case|:
return|return
literal|1
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
case|case
name|MINUS
case|:
case|case
name|PLUS
case|:
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if REG is clobbered in IN.    Return 2 if REG is used in IN.     Return 3 if REG is both used and clobbered in IN.    Return 0 if neither.  */
end_comment

begin_function
specifier|static
name|int
name|reg_clobbered_p
parameter_list|(
name|reg
parameter_list|,
name|in
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|set
init|=
literal|0
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|reg
condition|)
name|set
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
comment|/* Anything that sets just part of the register 	     is considered using as well as setting it. 	     But note that a straight SUBREG of a single-word value 	     clobbers the entire value.   */
if|if
condition|(
name|dest
operator|!=
name|SET_DEST
argument_list|(
name|in
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|UNITS_PER_WORD
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
condition|)
name|used
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|set
condition|)
name|used
operator|=
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|in
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|used
operator|=
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|set
operator|+
name|used
operator|*
literal|2
return|;
block|}
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if OP can be written to without screwing up    GCC's model of what's going on.  It is assumed that this operand    appears in the dest position of a SET insn in a conditional    branch's delay slot.  AFTER is the label to start looking from.  */
end_comment

begin_function
name|int
name|operand_clobbered_before_used_after
parameter_list|(
name|op
parameter_list|,
name|after
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
comment|/* Just experimenting.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|0
return|;
comment|/* Scan forward from the label, to see if the value of OP 	 is clobbered before the first use.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
switch|switch
condition|(
name|reg_clobbered_p
argument_list|(
name|op
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|0
case|:
break|break;
block|}
block|}
comment|/* If we reach another label without clobbering OP, 	     then we cannot safely write it here.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This is a jump insn which has already 		 been mangled.  We can't tell what it does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Keep following jumps.  */
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* In both of these cases, the first insn executed      for this op will be a orh whatever%h,r0,r31,      which is tolerable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this pattern, as a source to a "SET",    is known to yield an instruction of unit size.  */
end_comment

begin_function
name|int
name|single_insn_src_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* This is not always a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* This is not a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
literal|1
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
case|case
name|ZERO_EXTEND
case|:
return|return
literal|1
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* Detect cases that require multiple instructions.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|rtx
name|arg
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|SMALL_INT
argument_list|(
name|arg
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xffff
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* Both small and round numbers take one instruction; 	 others take two.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|single_insn_src_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero only if this *really* is a single insn operand.  */
end_comment

begin_function
name|int
name|strict_single_insn_op_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|SMALL_INT
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We can put this set insn into delay slot, because this is one 	 insn; 'sethi'.  */
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
if|#
directive|if
literal|0
comment|/* This loses when moving an freg to a general reg.  */
block|return HARD_REGNO_NREGS (REGNO (op), mode) == 1;
endif|#
directive|endif
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|&&
name|mode
operator|!=
name|DImode
operator|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|&&
name|mode
operator|!=
name|DImode
operator|)
return|;
return|return
literal|0
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
case|case
name|ZERO_EXTEND
case|:
return|return
literal|1
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* Detect cases that require multiple instructions.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
return|return
literal|1
return|;
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|rtx
name|arg
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|SMALL_INT
argument_list|(
name|arg
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xffff
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* Both small and round numbers take one instruction; 	 others take two.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|strict_single_insn_op_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP is a relational operator.  */
end_comment

begin_function
name|int
name|relop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP can be used as an operands in a three    address add/subtract insn (such as add %o1,7,%l2) of mode MODE.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand for a logical insn of mode MODE.  */
end_comment

begin_function
name|int
name|logic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|LOGIC_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand for either a logical insn    or an add insn of mode MODE.  */
end_comment

begin_function
name|int
name|compare_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|&&
name|LOGIC_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operand    of a bte insn.  */
end_comment

begin_function
name|int
name|bte_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x20
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an indexed memory reference of mode MODE.  */
end_comment

begin_function
name|int
name|indexed_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a suitable source operand for a load insn    with mode MODE.  */
end_comment

begin_function
name|int
name|load_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|indexed_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in add/subtract insns.  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in logic insns.  */
end_comment

begin_function
name|int
name|logic_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|LOGIC_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m0,r0,r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"st.l %r1,l%%%m0(r31)"
return|;
block|}
else|else
return|return
literal|"st.l %r1,%0"
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|{ 	  rtx xoperands[2];  	  cc_status.flags&= ~CC_F0_IS_0; 	  xoperands[0] = gen_rtx (REG, SFmode, 32); 	  xoperands[1] = operands[1]; 	  output_asm_insn (singlemove_string (xoperands), xoperands); 	  xoperands[1] = xoperands[0]; 	  xoperands[0] = operands[0]; 	  output_asm_insn (singlemove_string (xoperands), xoperands); 	  return ""; 	}
endif|#
directive|endif
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m1,r0,r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"ld.l l%%%m1(r31),%0"
return|;
block|}
return|return
literal|"ld.l %1,%0"
return|;
block|}
return|return
literal|"mov %1,%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Perhaps in some cases move double words    if there is a spare pair of floating regs.  */
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the first move would clobber the source of the second one,      do them in the other order.       RMS says "This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance."       but it happens on the sparc when loading parameter registers,      so I am going to define that circumstance, and make it work      as expected.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Do the late half first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Then clobber.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|output_fp_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"fmov.dd %1,%0"
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ixfr %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"ixfr %1,%0"
return|;
block|}
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|dconst0_rtx
condition|)
return|return
literal|"fmov.dd f0,%0"
return|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m1,r0,r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"fld.d l%%%m1(r31),%0"
return|;
block|}
return|return
literal|"fld.d %1,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"fxfr %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"fxfr %1,%0"
return|;
block|}
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m0,r0,r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"fst.d %1,l%%%m0(r31)"
return|;
block|}
return|return
literal|"fst.d %1,%0"
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a template for a load instruction with mode MODE and    arguments from the string ARGS.     This string is in static storage.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|load_opcode
parameter_list|(
name|mode
parameter_list|,
name|args
parameter_list|,
name|reg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
name|opcode
operator|=
literal|"ld.b"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|opcode
operator|=
literal|"ld.s"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|opcode
operator|=
literal|"fld.l"
expr_stmt|;
else|else
name|opcode
operator|=
literal|"ld.l"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
name|DFmode
case|:
name|opcode
operator|=
literal|"fld.d"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|opcode
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return a template for a store instruction with mode MODE and    arguments from the string ARGS.     This string is in static storage.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|store_opcode
parameter_list|(
name|mode
parameter_list|,
name|args
parameter_list|,
name|reg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
name|opcode
operator|=
literal|"st.b"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|opcode
operator|=
literal|"st.s"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|opcode
operator|=
literal|"fst.l"
expr_stmt|;
else|else
name|opcode
operator|=
literal|"st.l"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
name|DFmode
case|:
name|opcode
operator|=
literal|"fst.d"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|opcode
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a store-in-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a MEM, and OPERANDS[1] is a reg or zero.     This function returns a template for an insn.    This is in static storage.     It may also output some insns directly.    It may alter the values of operands[0] and operands[1].  */
end_comment

begin_function
name|char
modifier|*
name|output_store
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m0,r0,r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
comment|/* Store zero in two parts when appropriate.  */
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|&&
name|operands
index|[
literal|1
index|]
operator|==
name|dconst0_rtx
condition|)
return|return
name|store_opcode
argument_list|(
name|DFmode
argument_list|,
literal|"%r1,l%%%m0(r31)"
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
return|;
comment|/* Code below isn't smart enough to move a doubleword in two parts,      so use output_move_double to do that in the cases that require it.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
return|return
name|store_opcode
argument_list|(
name|mode
argument_list|,
literal|"%r1,l%%%m0(r31)"
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output a load-from-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a reg, and OPERANDS[1] is a mem.     This function returns a template for an insn.    This is in static storage.     It may also output some insns directly.    It may alter the values of operands[0] and operands[1].  */
end_comment

begin_function
name|char
modifier|*
name|output_load
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We don't bother trying to see if we know %hi(address).      This is because we are doing a load, and if we know the      %hi value, we probably also know that value in memory.  */
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|cc_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m1,r0,r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
comment|/* Code below isn't smart enough to move a doubleword in two parts,      so use output_move_double to do that in the cases that require it.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
return|return
name|load_opcode
argument_list|(
name|mode
argument_list|,
literal|"l%%%m1(r31),%0"
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the address specified by OPERANDS[3] into the register    specified by OPERANDS[0].     OPERANDS[3] may be the result of a sum, hence it could either be:     (1) CONST    (2) REG    (2) REG + CONST_INT    (3) REG + REG + CONST_INT    (4) REG + REG  (special case of 3).     Note that (3) is not a legitimate address.    All cases are handled here.  */
end_comment

begin_function
name|void
name|output_load_address
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* Operand is (PLUS (REG) (REG)).  */
name|base
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|operands
index|[
literal|6
index|]
operator|=
name|base
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"adds %7,%6,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov %7,%0\n\tadds %0,%6,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|operands
index|[
literal|6
index|]
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|8
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"adds %6,%7,%0\n\tadds %8,%0,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov %8,%0\n\tadds %0,%6,%0\n\tadds %0,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code to place a size count SIZE in register REG.  */
end_comment

begin_function
specifier|static
name|void
name|output_size_for_block_move
parameter_list|(
name|size
parameter_list|,
name|reg
parameter_list|,
name|align
parameter_list|)
name|rtx
name|size
decl_stmt|,
name|reg
decl_stmt|,
name|align
decl_stmt|;
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|reg
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|size
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|align
expr_stmt|;
if|#
directive|if
literal|1
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
condition|)
name|output_asm_insn
argument_list|(
literal|"sub %2,%1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move.     OPERANDS[0] is the destination.    OPERANDS[1] is the source.    OPERANDS[2] is the size.    OPERANDS[3] is the known safe alignment.    OPERANDS[4..6] are pseudos we can safely clobber as temps.  */
end_comment

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* A vector for our computed operands.  Note that load_output_address      makes use of (and can clobber) up to the 8th element of this vector.  */
name|rtx
name|xoperands
index|[
literal|10
index|]
decl_stmt|;
name|rtx
name|zoperands
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|int
name|movstrsi_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|temp1
init|=
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|alignrtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|alignrtx
argument_list|)
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|temp1
expr_stmt|;
comment|/* We can't move more than four bytes at a time      because we have only one register to move them through.  */
if|if
condition|(
name|align
operator|>
literal|4
condition|)
block|{
name|align
operator|=
literal|4
expr_stmt|;
name|alignrtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Since we clobber untold things, nix the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Recognize special cases of block moves.  These occur      when GNU C++ is forced to treat something as BLKmode      to keep it in memory, when its mode could be represented      with something smaller.       We cannot do this for global variables, since we don't know      what pages they don't cross.  Sigh.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|<=
literal|16
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|xoperands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|op1
init|=
name|xoperands
index|[
literal|1
index|]
decl_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.b %a1,r31\n\tst.b r31,%a0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|align
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|1
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.s %a1,r31\n\tst.s r31,%a0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|2
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.l %a1,r31\n\tst.l r31,%a0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
block|}
comment|/* This is the size of the transfer.      Either use the register which already contains the size,      or use a free register (used by no operands).  */
name|output_size_for_block_move
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|4
index|]
argument_list|,
name|alignrtx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Also emit code to decrement the size value by ALIGN.  */
block|zoperands[0] = operands[0];   zoperands[3] = plus_constant (operands[0], align);   output_load_address (zoperands);
endif|#
directive|endif
comment|/* Generate number for unique label.  */
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
comment|/* Copy the increment (negative) to a register for bla insn.  */
name|xoperands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|align
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|5
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov %4,%5"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Make available a register which is a temporary.  */
name|xoperands
index|[
literal|6
index|]
operator|=
name|operands
index|[
literal|6
index|]
expr_stmt|;
comment|/* Now the actual loop.      In xoperands, elements 1 and 0 are the input and output vectors.      Element 2 is the loop index.  Element 5 is the increment.  */
if|if
condition|(
name|align
operator|==
literal|1
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %0,%2,%6\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %1,%2,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%2,%2\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.b 0(%1),r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%1,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st.b r31,0(%6)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%6,%6"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|==
literal|2
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %0,%2,%6\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %1,%2,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%2,%2\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.s 0(%1),r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%1,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st.s r31,0(%6)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%6,%6"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|==
literal|4
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %0,%2,%6\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %1,%2,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%2,%2\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.l 0(%1),r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%1,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st.l r31,0(%6)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %5,%6,%6"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a delayed branch insn with the delay insn in its    branch slot.  The delayed branch insn template is in TEMPLATE,    with operands OPERANDS.  The insn in its delay slot is INSN.     As a special case, since we know that all memory transfers are via    ld/st insns, if we see a (MEM (SYMBOL_REF ...)) we divide the memory    reference around the branch as  	orh ha%x,r0,r31 	b ... 	ld/st l%x(r31),...     As another special case, we handle loading (SYMBOL_REF ...) and    other large constants around branches as well:  	orh h%x,r0,%0 	b ... 	or l%x,%0,%1     */
end_comment

begin_function
name|char
modifier|*
name|output_delayed_branch
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|,
name|insn
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|extern
name|rtx
name|recog_operand
index|[]
decl_stmt|;
name|rtx
name|src
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
operator|(
name|SMALL_INT
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
comment|/* Output the `orh' insn.  */
name|output_asm_insn
argument_list|(
literal|"orh h%%%1,r0,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Output the branch instruction next.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now output the `or' insn.  */
name|output_asm_insn
argument_list|(
literal|"or l%%%1,%0,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|split_template
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
comment|/* Output the `orh' insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m1,r0,r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|split_template
operator|=
name|load_opcode
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|"l%%%m1(r31),%0"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"orh ha%%%m0,r0,r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|split_template
operator|=
name|store_opcode
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|"%r1,l%%%m0(r31)"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Output the branch instruction next.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now output the load or store. 	 No need to do a CC_STATUS_INIT, because we are branching anyway.  */
name|output_asm_insn
argument_list|(
name|split_template
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|char
modifier|*
name|insn_template
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|insn_outfun
index|[]
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
specifier|extern
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
name|int
name|insn_code_number
decl_stmt|;
name|rtx
name|pat
init|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|rtx
name|delay_insn
init|=
name|gen_rtx
argument_list|(
name|INSN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pat
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Output the branch instruction first.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now recognize the insn which we put in its delay slot. 	 We must do this after outputing the branch insn, 	 since operands may just be a pointer to `recog_operand'.  */
name|insn_code_number
operator|=
name|recog
argument_list|(
name|pat
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the template for what this insn would 	 have been, without the branch.  Its operands are 	 exactly the same as they would be, so we don't 	 need to do an insn_extract.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
block|}
name|CC_STATUS_INIT
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a newly constructed insn DELAY_INSN.  */
end_comment

begin_function
name|char
modifier|*
name|output_delay_insn
parameter_list|(
name|delay_insn
parameter_list|)
name|rtx
name|delay_insn
decl_stmt|;
block|{
name|char
modifier|*
name|template
decl_stmt|;
specifier|extern
name|rtx
name|recog_operand
index|[]
decl_stmt|;
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|insn_template
index|[]
decl_stmt|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|insn_outfun
index|[]
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
name|int
name|insn_code_number
decl_stmt|;
specifier|extern
name|int
name|insn_n_operands
index|[]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Now recognize the insn which we put in its delay slot.      We must do this after outputing the branch insn,      since operands may just be a pointer to `recog_operand'.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Extract the operands of this delay insn.  */
name|INSN_CODE
argument_list|(
name|delay_insn
argument_list|)
operator|=
name|insn_code_number
expr_stmt|;
name|insn_extract
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* It is possible that this insn has not been properly scaned by final      yet.  If this insn's operands don't appear in the peephole's      actual operands, then they won't be fixed up by final, so we      make sure they get fixed up here.  -- This is a kludge.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction.      The instruction's output routine may change it further.      If the output routine for a jump insn needs to depend      on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|delay_insn
argument_list|)
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* Now get the template for what this insn would      have been, without the branch.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

end_unit

