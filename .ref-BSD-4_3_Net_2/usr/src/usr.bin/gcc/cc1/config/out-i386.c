begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)out-i386.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Subroutines for insn-output.c for Intel 80386.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FP_TOP
value|(gen_rtx(REG, DFmode, FIRST_FLOAT_REG))
end_define

begin_define
define|#
directive|define
name|AT_SP
parameter_list|(
name|mode
parameter_list|)
value|(gen_rtx (MEM, (mode), stack_pointer_rtx))
end_define

begin_define
define|#
directive|define
name|AT_BP
parameter_list|(
name|mode
parameter_list|)
value|(gen_rtx (MEM, (mode), frame_pointer_rtx))
end_define

begin_define
define|#
directive|define
name|RET
value|return ""
end_define

begin_comment
comment|/* #define RETCOM(X) fprintf (asm_out_file, "%sX fp_pop_level=%d\n", \ 			   COMMENT_BEGIN, fp_pop_level); RET */
end_comment

begin_define
define|#
directive|define
name|RETCOM
parameter_list|(
name|X
parameter_list|)
value|return ""
end_define

begin_define
define|#
directive|define
name|POP_ONE_FP
define|\
value|{
comment|/* fp_pop_level--; */
value|\     fprintf (asm_out_file, "\tfstp %sst(0)\n", RP); }
end_define

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_movf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_float_constant
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mentions_fp_top
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|call_top_dead_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fp_top_dead_p1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|via_memory
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_asm_insn_double_reg_op
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* All output functions must increment or decrement this to indicate    the net number of pops or pushes which they perform.  Note that it won't    necessarily balance with the optimize running, since we might have    two different calls with the same pop shared by cross jumping.    However on optimize the reg dead heuristic seems to work.  */
end_comment

begin_decl_stmt
name|int
name|fp_pop_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hi_reg_name
index|[]
init|=
name|HI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|qi_reg_name
index|[]
init|=
name|QI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* for fabs, fch, .. where the argument operand[1] must first be moved to   constraints  "=fm" "0" */
end_comment

begin_define
define|#
directive|define
name|FP_CALL1
parameter_list|(
name|op
parameter_list|)
define|\
value|{ if (FP_REG_P (operands[0]))		\       return op;			\     output_movf (FP_TOP, operands[1]);	\     output_asm_insn (op, operands);	\
comment|/* fp_pop_level--; */
value|\     return "fstp%z0 %0"; }
end_define

begin_comment
comment|/* handle case of call where op0/op1 is "=mf" and opn is "mrf"    eg. fadd */
end_comment

begin_define
define|#
directive|define
name|FP_CALL
parameter_list|(
name|op
parameter_list|,
name|rev
parameter_list|,
name|n
parameter_list|)
define|\
value|return fp_call_internal (op, rev, n, operands, insn);
end_define

begin_function
specifier|static
name|char
modifier|*
name|fp_call_internal
parameter_list|(
name|op
parameter_list|,
name|rev
parameter_list|,
name|n
parameter_list|,
name|operands
parameter_list|,
name|insn
parameter_list|)
name|char
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|n
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Here destination is in memory 	 and source is in the fp stack.  */
name|output_movf
argument_list|(
name|FP_TOP
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn_double_reg_op
argument_list|(
name|op
argument_list|,
name|rev
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|"fstp%z0 %0"
return|;
block|}
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|tem1
init|=
name|op
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operands
index|[
name|n
index|]
expr_stmt|;
name|op
operator|=
name|rev
expr_stmt|;
name|operands
index|[
name|n
index|]
operator|=
name|temp
expr_stmt|;
name|rev
operator|=
name|tem1
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|via_memory
argument_list|(
name|operands
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
name|n
index|]
operator|=
name|AT_SP
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
name|n
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|op
argument_list|,
name|operands
operator|+
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
name|op
argument_list|,
name|operands
operator|+
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* It turns out not to work to use top_dead_p because 	 the death notes are not accurate enough. 	 But this ought to work, because the only thing that can 	 live across basic blocks is reg 8, and these insns 	 never involve reg 8 directly.  */
if|if
condition|(
name|fp_top_dead_p1
argument_list|(
name|insn
argument_list|)
condition|)
name|POP_ONE_FP
expr_stmt|;
block|}
name|RET
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform insn OP    with two stack operands, and output on the stack.     REV is the assembler insn that does the same thing but    effectively interchanges the meanings of the two arguments.     Somewhat counterintuitively, the "first" operand was pushed last.     The output replaces either the top-of-stack or both of the arguments,    depending on whether the other argument is wanted after this insn.  */
end_comment

begin_function
specifier|static
name|void
name|output_asm_insn_double_reg_op
parameter_list|(
name|op
parameter_list|,
name|rev
parameter_list|,
name|insn
parameter_list|)
name|char
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_dead_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Here we want the "reversed" insn, fsubr or fdivr. 	 But there is an assembler bug in all 80386 assemblers 	 which exchanges the meanings of fsubr and fsub, and of fdivr and fdiv! 	 So use the "unreversed" opcode (which will assemble into 	 the "reversed" insn).  */
name|rev
operator|=
name|op
expr_stmt|;
while|while
condition|(
operator|*
name|rev
operator|&&
operator|*
name|rev
operator|!=
literal|'%'
condition|)
name|fputc
argument_list|(
operator|*
name|rev
operator|++
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* fp_pop_level--; */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
name|sst
argument_list|,
operator|%
name|sst
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RP
argument_list|,
name|RP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|op
operator|&&
operator|*
name|op
operator|!=
literal|'%'
condition|)
name|fputc
argument_list|(
operator|*
name|op
operator|++
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|AS2
argument_list|( ,
operator|%
name|sst
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|%
name|sst
argument_list|)
argument_list|,
name|RP
argument_list|,
name|RP
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Moves X to memory location 8 below stack pointer    and returns an RTX for that memory location.    X should be a register, in DFmode or SFmode.  */
end_comment

begin_function
specifier|static
name|rtx
name|via_memory
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|rtx
name|xops
index|[
literal|1
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"push%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"push%L0 %0"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an insn to copy the SFmode value in fp0 to OPERAND    without clobbering fp0.  */
end_comment

begin_function
name|void
name|fp_store_sf
parameter_list|(
name|target
parameter_list|)
name|rtx
name|target
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fst%S0 %1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|output_asm_insn
argument_list|(
literal|"fst%S0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an insn to pop an SF value from fp0 into TARGET.    This destroys the value of fp0.  */
end_comment

begin_function
name|void
name|fp_pop_sf
parameter_list|(
name|target
parameter_list|)
name|rtx
name|target
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fstp%S0 %1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
comment|/* fp_pop_level--; */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* fp_pop_level--; */
name|output_asm_insn
argument_list|(
literal|"fstp%S0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the top of the fpu stack into TARGET, without popping.  */
end_comment

begin_function
name|void
name|fp_store_df
parameter_list|(
name|target
parameter_list|)
name|rtx
name|target
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|4
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|target
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fst%Q0 %2"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|output_asm_insn
argument_list|(
literal|"fst%Q0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the top of the fpu stack into TARGET, with popping.  */
end_comment

begin_function
name|void
name|fp_pop_df
parameter_list|(
name|target
parameter_list|)
name|rtx
name|target
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|4
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|target
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* fp_pop_level--; */
name|output_asm_insn
argument_list|(
literal|"fstp%Q0 %2"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* fp_pop_level--; */
name|output_asm_insn
argument_list|(
literal|"fstp%z0 %0"
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Pop the fp stack, convert value to integer and store in TARGET.    TARGET may be memory or register, and may have QI, HI or SImode.  */
end_comment

begin_comment
unit|void fp_pop_int (target)      rtx target; {   if (REG_P (target) || GET_MODE (target) != SImode)     {       rtx xxops[2];       xxops[0] = stack_pointer_rtx;       xxops[1] = gen_rtx (CONST_INT, VOIDmode, 4);       output_asm_insn (AS2 (sub%L0,%1,%0), xxops);       xxops[0] = AT_SP (Pmode);
comment|/* fp_pop_level--; */
end_comment

begin_comment
unit|output_asm_insn ("fistp%L0 %0", xxops);       output_asm_insn ("pop%L0 %0",&target);     }   else if (GET_CODE (target) == MEM)     {
comment|/* fp_pop_level--; */
end_comment

begin_endif
unit|output_asm_insn ("fistp%L0 %0",&target);     }   else abort (); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Push the SFmode value X onto the fpu stack.  */
end_comment

begin_function
name|void
name|fp_push_sf
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* fp_pop_level++; */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|xfops
index|[
literal|3
index|]
decl_stmt|;
name|output_asm_insn
argument_list|(
literal|"push%L0 %0"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|xfops
index|[
literal|0
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xfops
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xfops
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fld%S0 %0\n\tadd%L0 %2,%1"
argument_list|,
name|xfops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"fld%S0 %0"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the DFmode value X onto the fpu stack.  */
end_comment

begin_function
name|void
name|fp_push_df
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* fp_pop_level++; */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|xfops
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"push%L0 %1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"push%L0 %0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|xfops
index|[
literal|0
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xfops
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|xfops
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fld%Q0 %0\n\tadd%L0 %2,%1"
argument_list|,
name|xfops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_asm_insn
argument_list|(
literal|"fld%Q0 %0"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|char
modifier|*
name|output_move_const_single
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|x
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|"push%L0 %1"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
return|return
name|output_move_const_single
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
return|return
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"push%L0 %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|"pop%L0 %0"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an insn to add the constant N to the register X.  */
end_comment

begin_function
specifier|static
name|void
name|asm_add
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If one operand is decrementing and one is incrementing      decrement the former register explicitly      and change that operand into ordinary indexing.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|optype1
operator|==
name|POPOP
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asm_add
argument_list|(
operator|-
literal|8
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
block|}
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|&&
name|optype1
operator|==
name|PUSHOP
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asm_add
argument_list|(
operator|-
literal|8
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
block|}
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If insn is effectively movd N (sp),-(sp) then we will do the      high word first.  We should use the adjusted operand 1 (which is N+4 (sp))      for the low word as well, to compensate for the first decrement of sp.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
comment|/* Likewise,  the first move would clobber the source of the second one,      do them in the other order.  This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|||
name|optype1
operator|==
name|PUSHOP
operator|||
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|standard_80387_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|double
name|d
decl_stmt|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|u
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|d
operator|==
literal|1
condition|)
return|return
literal|2
return|;
comment|/* Note that on the 80387, other constants, such as pi,      are much slower to load as standard constants      than to load from doubles in memory!  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|output_move_const_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|conval
init|=
name|standard_80387_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* fp_pop_level++; */
if|if
condition|(
name|conval
operator|==
literal|1
condition|)
return|return
literal|"fldz"
return|;
if|if
condition|(
name|conval
operator|==
literal|2
condition|)
return|return
literal|"fld1"
return|;
comment|/* fp_pop_level--; */
block|}
name|output_move_double
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|output_move_const_single
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|conval
init|=
name|standard_80387_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* fp_pop_level++; */
if|if
condition|(
name|conval
operator|==
literal|1
condition|)
return|return
literal|"fldz"
return|;
if|if
condition|(
name|conval
operator|==
literal|2
condition|)
return|return
literal|"fld1"
return|;
comment|/* fp_pop_level--; */
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
union|union
block|{
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|u1
union|;
union|union
block|{
name|int
name|i
decl_stmt|;
name|float
name|f
decl_stmt|;
block|}
name|u2
union|;
name|u1
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|u1
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|u2
operator|.
name|f
operator|=
name|u1
operator|.
name|d
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|u2
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an insn to move an SF value from FROM to TO.    The kinds of operands are not restricted    except that they may not both be in memory.  */
end_comment

begin_function
name|void
name|output_movsf
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|to
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|from
argument_list|)
operator|||
name|FP_REG_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|from
operator|=
name|xops
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|FP_REG_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|{ 	  if (REGNO (from) != REGNO (to)) 	    { 	      output_asm_insn ("fld%S0 %1\n\tfstp%S0 %0", xops); 	    } 	}       else
endif|#
directive|endif
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|to
argument_list|)
condition|)
name|fp_pop_sf
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|to
argument_list|)
condition|)
name|fp_push_sf
argument_list|(
name|from
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|xops
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an insn to move a DF value from FROM to TO.    The kinds of operands are not restricted    except that they may not both be in memory.  */
end_comment

begin_function
name|void
name|output_movdf
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|to
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|from
argument_list|)
operator|||
name|FP_REG_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|from
operator|=
name|xops
index|[
literal|1
index|]
expr_stmt|;
name|to
operator|=
name|xops
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|FP_REG_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|{ 	  if (REGNO (from) != REGNO (to)) 	    abort ();
comment|/*	    output_asm_insn ("fld%Q0 %1\n\t fstp%Q0 %0", xops);*/
block|}       else 	{
endif|#
directive|endif
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|to
argument_list|)
condition|)
name|fp_pop_df
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|to
argument_list|)
condition|)
name|fp_push_df
argument_list|(
name|from
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|output_move_double
argument_list|(
name|xops
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* does move of FROM to TO where the mode is the minimum of the two */
end_comment

begin_function
specifier|static
name|void
name|output_movf
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|SFmode
condition|)
name|output_movsf
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|output_movdf
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
name|void
name|function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|,
name|limit
decl_stmt|;
name|rtx
name|xops
index|[
literal|4
index|]
decl_stmt|;
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
comment|/* fp_pop_level = 0; */
name|xops
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"push%L0 %1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Note If use enter it is NOT reversed args.      This one is not reversed from intel!!      I think enter is slower.  Also sdb doesn't like it.      But if you want it the code is:      {      xops[3] = const0_rtx;      output_asm_insn ("enter %2,%3", xops);      }      */
name|nregs
operator|=
literal|0
expr_stmt|;
name|limit
operator|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|limit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tpush%s %se%s\n"
argument_list|,
name|L_SIZE
argument_list|,
name|RP
argument_list|,
name|hi_reg_name
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|nregs
decl_stmt|,
name|limit
decl_stmt|;
name|int
name|assure_sp_pos
decl_stmt|;
name|int
name|return_struct_adjust
decl_stmt|;
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
specifier|extern
name|int
name|current_function_pops_args
decl_stmt|;
specifier|extern
name|int
name|current_function_args_size
decl_stmt|;
specifier|extern
name|int
name|flag_pcc_struct_return
decl_stmt|;
name|limit
operator|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
name|return_struct_adjust
operator|=
operator|(
name|current_function_returns_struct
ifdef|#
directive|ifdef
name|STRUCT_RETURN_CALLER_POP
operator|&&
operator|!
name|flag_pcc_struct_return
endif|#
directive|endif
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
operator|(
name|limit
operator|-
literal|1
operator|)
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|nregs
operator|++
expr_stmt|;
comment|/* sp is often  unreliable so we must go off the frame pointer,    */
if|if
condition|(
name|nregs
operator|&&
name|frame_pointer_needed
condition|)
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|AT_BP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
operator|-
name|size
operator|-
operator|(
name|nregs
operator|*
operator|(
name|UNITS_PER_WORD
operator|)
operator|)
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|lea
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|limit
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tpop%s "
argument_list|,
name|L_SIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%se%s\n"
argument_list|,
name|RP
argument_list|,
name|hi_reg_name
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleave\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tret %s%d\n"
argument_list|,
name|IP
argument_list|,
operator|(
name|current_function_args_size
operator|+
name|return_struct_adjust
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|return_struct_adjust
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tret %s%d\n"
argument_list|,
name|IP
argument_list|,
name|return_struct_adjust
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tret\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hard_regno_mode_ok
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|regno
operator|<
literal|2
condition|?
literal|1
comment|/* Used to reject floating modes here */
else|:
name|regno
operator|<
literal|4
condition|?
literal|1
else|:
name|regno
operator|>=
literal|8
condition|?
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SFmode
else|:
name|mode
operator|!=
name|QImode
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the name of a register based on its machine mode and number.    If CODE is 'w', pretend the mode is HImode.    If CODE is 'b', pretend the mode is QImode.    If CODE is 'k', pretend the mode is SImode.  */
end_comment

begin_define
define|#
directive|define
name|PRINT_REG
parameter_list|(
name|X
parameter_list|,
name|CODE
parameter_list|,
name|FILE
parameter_list|)
define|\
value|do { fprintf (FILE, "%s", RP);			\        switch ((CODE == 'w' ? 2 			\ 		: CODE == 'b' ? 1			\ 		: CODE == 'k' ? 4			\ 		: GET_MODE_SIZE (GET_MODE (X))))	\ 	 {						\ 	 case 4:					\ 	 case 8:					\ 	   if (!FP_REG_P (X)) fputs ("e", FILE);	\ 	 case 2:					\ 	   fputs (hi_reg_name[REGNO (X)], FILE);	\ 	   break;					\ 	 case 1:					\ 	   fputs (qi_reg_name[REGNO (X)], FILE);	\ 	   break;					\ 	 }						\      } while (0)
end_define

begin_comment
comment|/* Meaning of CODE:    f -- float insn (print a CONST_DOUBLE as a float rather than in hex).    L,W,B,Q,S -- print the opcode suffix for specified size of operand.    R -- print the prefix for register names.    z -- print the opcode suffix for the size of the current operand.    * -- print a star (in certain assembler syntax)    w -- print the operand as if it's a "word" (HImode) even if it isn't.    c -- don't print special prefixes before constant operands. */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|USE_STAR
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|RP
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'z'
case|:
comment|/* this is the size of op from size of operand */
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|PUT_OP_SIZE
argument_list|(
literal|'W'
argument_list|,
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|4
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|PUT_OP_SIZE
argument_list|(
literal|'S'
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|PUT_OP_SIZE
argument_list|(
literal|'L'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|PUT_OP_SIZE
argument_list|(
literal|'B'
argument_list|,
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PRINT_REG
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|PRINT_PTR
argument_list|(
name|x
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|u1
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u1
operator|.
name|f
operator|=
name|u
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'f'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%.22e"
argument_list|,
name|u1
operator|.
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|PRINT_IMMED_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
name|u1
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%.22e"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|!=
literal|'c'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|PRINT_IMMED_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|PRINT_OFFSET_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory operand whose address is ADDR.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|ADDR_BEG
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%se"
argument_list|,
name|RP
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|hi_reg_name
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ADDR_END
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|reg1
operator|=
literal|0
expr_stmt|;
name|reg2
operator|=
literal|0
expr_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|reg1
operator|==
literal|0
condition|)
name|reg1
operator|=
name|addr
expr_stmt|;
else|else
name|reg2
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg1
operator|&&
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|reg2
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
argument_list|)
condition|)
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|||
name|breg
operator|!=
literal|0
condition|)
block|{
name|int
name|scale
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* output breg+ireg*scale */
name|PRINT_B_I_S
argument_list|(
name|breg
argument_list|,
name|ireg
argument_list|,
name|scale
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MULT
case|:
block|{
name|int
name|scale
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|PRINT_B_I_S
argument_list|(
operator|(
name|rtx
operator|)
literal|0
argument_list|,
name|ireg
argument_list|,
name|scale
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|<
literal|0x8000
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|>=
operator|-
literal|0x8000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the cc_status for the results of an insn whose pattern is EXP.    On the 80386, we assume that only test and compare insns, as well    as SI, HI,& DI mode ADD, SUB, NEG, AND, IOR, XOR, ASHIFT, LSHIFT,    ASHIFTRT, and LSHIFTRT instructions set the condition codes usefully.    Also, we assume that jumps and moves don't affect the condition codes.    All else, clobbers the condition codes, by assumption.     We assume that ALL add, minus, etc. instructions effect the condition    codes.  This MUST be consistent with i386.md.  */
end_comment

begin_macro
name|notice_update_cc
argument_list|(
argument|exp
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|exp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* Jumps do not alter the cc's.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return;
comment|/* Moving register or memory into a register: 	 it doesn't alter the cc's, but it might invalidate 	 the RTX's which we remember the cc's came from. 	 (Note that moving a constant 0 or 1 MAY set the cc's).  */
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Moving register into memory doesn't alter the cc's. 	 It may invalidate the RTX's which we remember the cc's came from.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|==
name|MEM
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|==
name|MEM
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Function calls clobber the cc's.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return;
block|}
comment|/* Tests and compares set the cc's in predictable ways.  */
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Certain instructions effect the condition codes. */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|QImode
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFT
case|:
comment|/* Shifts on the 386 don't set the condition codes if the 	       shift count is zero. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
break|break;
block|}
comment|/* We assume that the CONST_INT is non-zero (this rtx would 	       have been deleted if it were zero. */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|NEG
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_DEST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CC_STATUS_INIT
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return;
if|if
condition|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|CC_STATUS_INIT
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the top of the fpu stack dies in this insn.  */
end_comment

begin_function
name|int
name|top_dead_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|extern
name|int
name|optimize
decl_stmt|;
if|if
condition|(
name|optimize
condition|)
return|return
operator|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_FLOAT_REG
argument_list|)
operator|||
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_FLOAT_REG
operator|+
literal|1
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
name|call_top_dead_p
argument_list|(
name|insn
argument_list|)
return|;
return|return
name|fp_top_dead_p1
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Following is used after a call_value insn    if obey_regdecls there will not be the REG_DEAD notes    to go by (there won't be any cross jumping to worry about    either), and we depend on seeing if the FP_TOP is used    in the next two insn's.  Otherwise we depend on the    REG_DEAD notes.    */
end_comment

begin_function
specifier|static
name|int
name|call_top_dead_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
return|return
operator|(
operator|!
operator|(
name|mentions_fp_top
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
return|return
operator|(
operator|!
name|FP_REG_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if current val of fpu top-of-stack appears unused    in rest of this basic block.  */
end_comment

begin_function
specifier|static
name|int
name|fp_top_dead_p1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|extern
name|int
name|optimize
decl_stmt|;
name|int
name|past_label
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CALL_INSN
case|:
comment|/* Function calls clobber this value, so it's dead.  */
return|return
literal|1
return|;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
operator|!
name|optimize
condition|)
comment|/* Can't use JUMP_LABEL, but there's no cross-jumping either.  */
return|return
literal|1
return|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
case|case
name|CODE_LABEL
case|:
comment|/* Go past one label or follow one jump in case of cross-jumping, 	     which could insert such a label or jump into one basic block.  */
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|past_label
condition|)
return|return
literal|1
return|;
name|past_label
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|(
name|mentions_fp_top
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|mentions_fp_top
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X involves an FPU register.  */
end_comment

begin_function
specifier|static
name|int
name|mentions_fp_top
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CLOBBER
case|:
case|case
name|MEM
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
return|return
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|mentions_fp_top
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|mentions_fp_top
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Some asm-dependent functions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MASM
end_ifdef

begin_include
include|#
directive|include
file|"masm386.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

end_unit

