begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Motorola 88000.    Copyright (C) 1987 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is where the condition code register lives.  */
end_comment

begin_decl_stmt
name|rtx
name|cc0_reg_rtx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|char * output_compare (operands, opcode, exchange_opcode)      rtx *operands;      char *opcode;      char *exchange_opcode; {   static char buf[40];   rtx op1, op2;    if (GET_CODE (cc_prev_status.value2) == COMPARE)     {       op1 = XEXP (cc_prev_status.value2, 0);       op2 = XEXP (cc_prev_status.value2, 1);     }   else     {       op1 = cc_prev_status.value2;       op2 = const0_rtx;     }   if (GET_CODE (op1) == CONST_INT)     {       operands[2] = op1;       operands[1] = op2;       opcode = exchange_opcode;     }   else     {       operands[1] = op1;       operands[2] = op2;     }   sprintf (buf, "cmp r25,%%1,%%2\n\tbcnd %s,r25,%%l0", opcode);   return buf; }  char * output_fcompare (operands, opcode, exchange_opcode)      rtx *operands;      char *opcode;      char *exchange_opcode; {   static char buf[40];    rtx op1, op2;    if (GET_CODE (cc_prev_status.value2) == COMPARE)     {       op1 = XEXP (cc_prev_status.value2, 0);       op2 = XEXP (cc_prev_status.value2, 1);     }   else     {       op1 = cc_prev_status.value2;       op2 = const0_rtx;     }   if (GET_CODE (op1) == CONST_DOUBLE)     {       operands[2] = op1;       operands[1] = op2;       opcode = exchange_opcode;     }   else     {       operands[1] = op1;       operands[2] = op2;     }   sprintf (buf, "cmp r25,%%1,%%2\n\tbcnd %s,r25,%%l0", opcode);   return buf; }  char * output_store (operands, opcode, exchange_opcode)      rtx *operands;      char *opcode;      char *exchange_opcode; {   static char buf[40];   rtx op1, op2;    if (GET_CODE (cc_prev_status.value2) == COMPARE)     {       op1 = XEXP (cc_prev_status.value2, 0);       op2 = XEXP (cc_prev_status.value2, 1);     }   else     {       op1 = cc_prev_status.value2;       op2 = const0_rtx;     }    if (GET_CODE (op1) == CONST_INT)     {       operands[2] = op1;       operands[1] = op2;       opcode = exchange_opcode;     }   else     {       operands[1] = op1;       operands[2] = op2;     }    sprintf (buf, "cmp r25,%%1,%%2\n\textu %%0,r25,1<%s>", opcode);   return buf; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if OP is a valid second operand for an arithmetic insn.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x10000
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|int5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x20
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"st %r1,%0"
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"ld %0,%1"
return|;
return|return
literal|"or %0,r0,%1"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the first move would clobber the source of the second one,      do them in the other order.  This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %0,%0,4"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %0,%0,4"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subu %0,%0,4"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subu %0,%0,4"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %0,%0,4"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %0,%0,4"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subu %0,%0,4"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subu %0,%0,4"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an ascii string.  */
end_comment

begin_macro
name|output_ascii
argument_list|(
argument|file
argument_list|,
argument|p
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstring \""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* After an octal-escape, if a digit follows, 	     terminate one string constant and start another. 	     The Vax assembler fails to stop reading the escape 	     after three digits, so this is the only way we 	     can get it to parse the data properly.  */
if|if
condition|(
name|i
operator|<
name|size
operator|-
literal|1
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'9'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"\n\tstring \""
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|output_load_address
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lda %0,%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"or %0,r0,%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
name|base
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|base
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|base
argument_list|)
condition|)
if|if
condition|(
name|FITS_16_BITS
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %0,%6,%7"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"subu %0,%6,%7"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"or.h %0,r0,hi16(%7)\n\tor %0,%0,lo16(%7)\n\tadd %0,%6,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MULT
condition|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|==
name|QImode
condition|)
name|output_asm_insn
argument_list|(
literal|"lda.b %0,%6"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|==
name|HImode
condition|)
name|output_asm_insn
argument_list|(
literal|"lda.h %0,%6"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|==
name|SImode
condition|)
name|output_asm_insn
argument_list|(
literal|"lda %0,%6"
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"lda.d %0,%6"
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"lda %0,%6"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FITS_16_BITS
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %0,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"subu %0,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"or.h r25,r0,hi16(%7)\n\tor r25,r0,lo16(%7)\n\taddu %0,%0r25"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|static
name|int
name|movstrsi_label
init|=
literal|0
decl_stmt|;
name|int
name|align
init|=
literal|4
decl_stmt|;
name|rtx
name|xoperands
index|[
literal|9
index|]
decl_stmt|;
name|int
name|available
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Since we clobber untold things, nix the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Get past the MEMs.  */
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|available
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|available
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|available
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Prepare to juggle registers if necessary.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|-
literal|10
argument_list|)
operator|<
literal|3
condition|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|available
index|[
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|-
literal|10
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|-
literal|10
argument_list|)
operator|<
literal|3
condition|)
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|available
index|[
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|-
literal|10
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|-
literal|10
argument_list|)
operator|<
literal|3
condition|)
block|{
name|xoperands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|available
index|[
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|-
literal|10
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xoperands
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|available
index|[
literal|0
index|]
condition|)
block|{
name|xoperands
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|available
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|available
index|[
literal|1
index|]
condition|)
block|{
name|xoperands
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|available
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|xoperands
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|available
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* First, figure out best alignment we may assume.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|xoperands
index|[
literal|5
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"sub %5,%2,1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|align
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|&
literal|3
condition|)
block|{
name|align
operator|=
literal|2
expr_stmt|;
name|i
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|>>=
literal|2
expr_stmt|;
comment|/* predecrement count.  */
name|i
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|xoperands
index|[
literal|5
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
name|i
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"addu %2,r0,%5"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
operator|-
name|i
argument_list|)
condition|)
block|{
name|xoperands
index|[
literal|5
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"subu %2,r0,%5"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"or.u %2,r0,hi16(%5)\n\tor %2,%2,lo16(%5)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
comment|/* Now, set up for pipelined operation: dest must contain      a pre-incremented address, because its index is pre-decremented.  */
name|xoperands
index|[
literal|3
index|]
operator|=
name|plus_constant
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|output_load_address
argument_list|(
name|xoperands
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_load_address
argument_list|(
name|xoperands
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|4
condition|)
name|output_asm_insn
argument_list|(
literal|"\n@Lm%3:\n\tld r25,%1[%2]\n\tsubu %2,%2,1\n\tbcnd.n ge0,%2,@Lm%3\n\tst r25,%0[%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|==
literal|2
condition|)
name|output_asm_insn
argument_list|(
literal|"\n@Lm%3:\n\tld.h r25,%1[%2]\n\tsubu %2,%2,1\n\tbcnd.n ge0,%2,@Lm%3\n\tst.h r25,%0[%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"\n@Lm%3:\n\tld.b r25,%1[%2]\n\tsubu %2,%2,1\n\tbcnd.n ge0,%2,@Lm%3\n\tst.b r25,%0[%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_store_const_int
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|"addu %0,r0,%1"
return|;
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
operator|-
name|i
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
literal|"subu %0,r0,%1"
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|"or.u %0,r0,hi16(%1)"
return|;
comment|/* Could check to see if number is a contiguous field      of 1's.  Then we could use the SET instruction.  */
if|if
condition|(
name|mode
operator|==
name|HImode
condition|)
block|{
name|warning
argument_list|(
literal|"truncating constant `%d' to fit in half-word"
argument_list|,
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"or %0,r0,lo16(%1)"
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
block|{
name|warning
argument_list|(
literal|"truncating constant `%d' to fit in byte"
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
literal|"or %0,r0,%1"
return|;
block|}
return|return
literal|"or.u %0,r0,hi16(%1)\n\tor %0,%0,lo16(%1)"
return|;
block|}
end_function

begin_comment
comment|/* This routine assumes that floating point numbers are represented    in a manner which is consistent between host and target machines.  */
end_comment

begin_function
name|char
modifier|*
name|output_store_const_float
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|"addu %0,r0,%1"
return|;
if|if
condition|(
name|INT_FITS_16_BITS
argument_list|(
operator|-
name|i
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
literal|"subu %0,r0,%1"
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|"or.u %0,r0,hi16(%1)"
return|;
comment|/* Could check to see if number is a contiguous field      of 1's.  Then we could use the SET instruction.  */
return|return
literal|"or.u %0,r0,hi16(%1)\n\tor %0,%0,lo16(%1)"
return|;
block|}
end_function

end_unit

