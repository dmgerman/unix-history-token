begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Tahoe.    Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * File: output-tahoe.c  *  * This port made at the University of Buffalo by Devon Bowen,  * Dale Wiles and Kevin Zachmann.  *  * Mail bugs reports or fixes to:	gcc@cs.buffalo.edu  */
end_comment

begin_comment
comment|/* most of the print_operand_address function was taken from the vax	*/
end_comment

begin_comment
comment|/* since the modes are basically the same. I had to add a special case,	*/
end_comment

begin_comment
comment|/* though, for symbol references with offsets.				*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_macro
name|print_operand_address
argument_list|(
argument|file
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|rtx
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
specifier|static
name|char
modifier|*
name|reg_name
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
name|retry
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_name
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-(%s)"
argument_list|,
name|reg_name
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)+"
argument_list|,
name|reg_name
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|reg1
operator|=
literal|0
expr_stmt|;
name|reg2
operator|=
literal|0
expr_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|reg1
operator|==
literal|0
condition|)
name|reg1
operator|=
name|addr
expr_stmt|;
else|else
name|reg2
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|reg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg2
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg2
operator|!=
literal|0
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
else|else
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
name|output_address
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|breg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_name
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_name
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Do a quick check and find out what the best way to do the */
end_comment

begin_comment
comment|/* mini-move is. Could be a push or a move.....		     */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
return|return
literal|"pushl %1"
return|;
return|return
literal|"movl %1,%0"
return|;
block|}
end_function

begin_comment
comment|/* given the rtx for an address, return true if the given */
end_comment

begin_comment
comment|/* register number is used in the address somewhere.	  */
end_comment

begin_function
name|int
name|regisused
parameter_list|(
name|addr
parameter_list|,
name|regnum
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|regnum
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|regisused
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regnum
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
return|return
operator|(
name|regisused
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regnum
argument_list|)
operator|||
name|regisused
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|regnum
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given some rtx, traverse it and return the register used in a */
end_comment

begin_comment
comment|/* index. If no index is found, return 0.			 */
end_comment

begin_function
name|rtx
name|index_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|index_reg
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|temp
operator|=
name|index_reg
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|temp
return|;
else|else
return|return
name|index_reg
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* simulate the move double by generating two movl's. You have */
end_comment

begin_comment
comment|/* to be careful about mixing modes here. A future improvement */
end_comment

begin_comment
comment|/* would be to allow immediate doubles.			       */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|INDOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|shftreg0
init|=
literal|0
decl_stmt|,
name|shftreg1
init|=
literal|0
decl_stmt|;
name|rtx
name|temp0
init|=
literal|0
decl_stmt|,
name|temp1
init|=
literal|0
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
name|int
name|dohighfirst
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands. */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|shftreg0
operator|=
name|index_reg
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|optype0
operator|=
name|INDOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|optype0
operator|=
name|PUSHOP
expr_stmt|;
name|dohighfirst
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|shftreg1
operator|=
name|index_reg
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|optype1
operator|=
name|INDOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* set up for the high byte move for operand zero */
switch|switch
condition|(
name|optype0
condition|)
block|{
comment|/* if it's a register, just use the next highest in the */
comment|/* high address move.					*/
case|case
name|REGOP
case|:
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* for an offsettable address, use the gcc function to  */
comment|/* modify the operand to get an offset of 4 higher for  */
comment|/* the second move.					*/
case|case
name|OFFSOP
case|:
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
comment|/* if the operand is MEMOP type, it must be a pointer	*/
comment|/* to a pointer. So just remember to increase the mem	*/
comment|/* location and use the same operand.			*/
case|case
name|MEMOP
case|:
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|addreg0
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* if we're dealing with a push instruction, just leave */
comment|/* the operand alone since it auto-increments.		*/
case|case
name|PUSHOP
case|:
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
break|break;
comment|/* YUCK! Indexed addressing!! If the address is considered   */
comment|/* offsettable, go use the offset in the high part. Otherwise */
comment|/* find what exactly is being added to the mutiplication. If */
comment|/* it's a mem reference, increment that with the high part   */
comment|/* being unchanged to cause the shift. If it's a reg, do the */
comment|/* same. If you can't identify it, abort. Remember that the  */
comment|/* shift register was already set during identification.     */
case|case
name|INDOP
case|:
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|temp0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp0
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|temp1
operator|=
name|temp0
expr_stmt|;
name|temp0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|!=
name|MULT
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp0
argument_list|)
operator|==
name|MEM
condition|)
name|addreg0
operator|=
name|temp0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp0
argument_list|)
operator|==
name|REG
condition|)
name|addreg0
operator|=
name|temp0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
comment|/* if we don't know the operand type, print a friendly  */
comment|/* little error message...   8-)			*/
case|case
name|RNDOP
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* do the same setup for operand one */
switch|switch
condition|(
name|optype1
condition|)
block|{
case|case
name|REGOP
case|:
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSOP
case|:
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMOP
case|:
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|addreg1
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POPOP
case|:
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|INDOP
case|:
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|temp0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp0
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|temp1
operator|=
name|temp0
expr_stmt|;
name|temp0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|!=
name|MULT
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp0
argument_list|)
operator|==
name|MEM
condition|)
name|addreg1
operator|=
name|temp0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp0
argument_list|)
operator|==
name|REG
condition|)
name|addreg1
operator|=
name|temp0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|CNSTOP
case|:
comment|/* Since this machine is big-endian, 	 the late half must be the low-order word for an integer, 	 or the latter word for a float.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
block|}
break|break;
case|case
name|RNDOP
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* double the register used for shifting in both of the operands */
comment|/* but make sure the same register isn't doubled twice!	   */
if|if
condition|(
name|shftreg0
operator|&&
name|shftreg1
operator|&&
name|rtx_equal_p
argument_list|(
name|shftreg0
argument_list|,
name|shftreg1
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 %0,%0"
argument_list|,
operator|&
name|shftreg0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|shftreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 %0,%0"
argument_list|,
operator|&
name|shftreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shftreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 %0,%0"
argument_list|,
operator|&
name|shftreg1
argument_list|)
expr_stmt|;
block|}
comment|/* if the destination is a register and that register is needed in  */
comment|/* the source addressing mode, swap the order of the moves since we */
comment|/* don't want this destroyed til last. If both regs are used, not   */
comment|/* much we can do, so abort. If these becomes a problem, maybe we   */
comment|/* can do it on the stack?					      */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|regisused
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|regisused
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|,
name|REGNO
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
literal|8
expr_stmt|;
else|else
name|dohighfirst
operator|++
expr_stmt|;
comment|/* if we're pushing, do the high address part first. */
if|if
condition|(
name|dohighfirst
condition|)
block|{
if|if
condition|(
name|addreg0
operator|&&
name|addreg1
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|addreg0
argument_list|,
name|addreg1
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 $4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
operator|&&
name|addreg1
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|addreg0
argument_list|,
name|addreg1
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"subl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subl2 $4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
block|}
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
operator|&&
name|addreg1
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|addreg0
argument_list|,
name|addreg1
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addl2 $4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
operator|&&
name|addreg1
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|addreg0
argument_list|,
name|addreg1
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"subl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subl2 $4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subl2 $4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shftreg0
operator|&&
name|shftreg1
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|shftreg0
argument_list|,
name|shftreg1
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"shar $1,%0,%0"
argument_list|,
operator|&
name|shftreg0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|shftreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"shar $1,%0,%0"
argument_list|,
operator|&
name|shftreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shftreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"shar $1,%0,%0"
argument_list|,
operator|&
name|shftreg1
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

end_unit

